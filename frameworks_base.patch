diff --git a/api/system-current.txt b/api/system-current.txt
index 0fe164a269c..6b6f7e99e4b 100644
--- a/api/system-current.txt
+++ b/api/system-current.txt
@@ -112,6 +112,7 @@ package android {
     field public static final java.lang.String GRANT_RUNTIME_PERMISSIONS = "android.permission.GRANT_RUNTIME_PERMISSIONS";
     field public static final java.lang.String HARDWARE_TEST = "android.permission.HARDWARE_TEST";
     field public static final java.lang.String HDMI_CEC = "android.permission.HDMI_CEC";
+    field public static final java.lang.String HIDE_NON_SYSTEM_OVERLAY_WINDOWS = "android.permission.HIDE_NON_SYSTEM_OVERLAY_WINDOWS";
     field public static final java.lang.String INJECT_EVENTS = "android.permission.INJECT_EVENTS";
     field public static final java.lang.String INSTALL_GRANT_RUNTIME_PERMISSIONS = "android.permission.INSTALL_GRANT_RUNTIME_PERMISSIONS";
     field public static final java.lang.String INSTALL_LOCATION_PROVIDER = "android.permission.INSTALL_LOCATION_PROVIDER";
diff --git a/core/java/android/accounts/ChooseTypeAndAccountActivity.java b/core/java/android/accounts/ChooseTypeAndAccountActivity.java
index aed7a369371..bf969266257 100644
--- a/core/java/android/accounts/ChooseTypeAndAccountActivity.java
+++ b/core/java/android/accounts/ChooseTypeAndAccountActivity.java
@@ -250,6 +250,10 @@ public class ChooseTypeAndAccountActivity extends Activity
             outState.putParcelableArray(KEY_INSTANCE_STATE_EXISTING_ACCOUNTS, mExistingAccounts);
         }
         if (mSelectedItemIndex != SELECTED_ITEM_NONE) {
+            if (mAccounts == null) {
+                final AccountManager accountManager = AccountManager.get(this);
+                mAccounts = getAcceptableAccountChoices(accountManager);
+            }
             if (mSelectedItemIndex == mAccounts.size()) {
                 outState.putBoolean(KEY_INSTANCE_STATE_SELECTED_ADD_ACCOUNT, true);
             } else {
@@ -291,6 +295,10 @@ public class ChooseTypeAndAccountActivity extends Activity
         mPendingRequest = REQUEST_NULL;
 
         if (resultCode == RESULT_CANCELED) {
+            if (mAccounts == null) {
+                final AccountManager accountManager = AccountManager.get(this);
+                mAccounts = getAcceptableAccountChoices(accountManager);
+            }
             // if canceling out of addAccount and the original state caused us to skip this,
             // finish this activity
             if (mAccounts.isEmpty()) {
diff --git a/core/java/android/app/ActivityThread.java b/core/java/android/app/ActivityThread.java
index 5cfcac33050..010b871c1d4 100644
--- a/core/java/android/app/ActivityThread.java
+++ b/core/java/android/app/ActivityThread.java
@@ -911,7 +911,8 @@ public final class ActivityThread {
         }
 
         public void setHttpProxy(String host, String port, String exclList, Uri pacFileUrl) {
-            final ConnectivityManager cm = ConnectivityManager.from(getSystemContext());
+            final ConnectivityManager cm = ConnectivityManager.from(
+                getApplication() != null ? getApplication() : getSystemContext());
             final Network network = cm.getBoundNetworkForProcess();
             if (network != null) {
                 Proxy.setHttpProxySystemProperty(cm.getDefaultProxy());
diff --git a/core/java/android/app/DownloadManager.java b/core/java/android/app/DownloadManager.java
index 6e38347f7c9..462f66f38de 100644
--- a/core/java/android/app/DownloadManager.java
+++ b/core/java/android/app/DownloadManager.java
@@ -832,6 +832,7 @@ public class DownloadManager {
 
         private long[] mIds = null;
         private Integer mStatusFlags = null;
+        private String mFilterString = null;
         private String mOrderByColumn = Downloads.Impl.COLUMN_LAST_MODIFICATION;
         private int mOrderDirection = ORDER_DESCENDING;
         private boolean mOnlyIncludeVisibleInDownloadsUi = false;
@@ -845,6 +846,17 @@ public class DownloadManager {
             return this;
         }
 
+        /**
+         *
+         * Include only the downloads that contains the given string in its name.
+         * @return this object
+         * @hide
+         */
+        public Query setFilterByString(@Nullable String filter) {
+            mFilterString = filter;
+            return this;
+        }
+
         /**
          * Include only downloads with status matching any the given status flags.
          * @param flags any combination of the STATUS_* bit flags
@@ -904,9 +916,20 @@ public class DownloadManager {
             List<String> selectionParts = new ArrayList<String>();
             String[] selectionArgs = null;
 
-            if (mIds != null) {
-                selectionParts.add(getWhereClauseForIds(mIds));
-                selectionArgs = getWhereArgsForIds(mIds);
+            int whereArgsCount = (mIds == null) ? 0 : mIds.length;
+            whereArgsCount = (mFilterString == null) ? whereArgsCount : whereArgsCount + 1;
+            selectionArgs = new String[whereArgsCount];
+
+            if (whereArgsCount > 0) {
+                if (mIds != null) {
+                    selectionParts.add(getWhereClauseForIds(mIds));
+                    getWhereArgsForIds(mIds, selectionArgs);
+                }
+
+                if (mFilterString != null) {
+                    selectionParts.add(Downloads.Impl.COLUMN_TITLE + " LIKE ?");
+                    selectionArgs[selectionArgs.length - 1] = "%" + mFilterString + "%";
+                }
             }
 
             if (mStatusFlags != null) {
@@ -1450,12 +1473,22 @@ public class DownloadManager {
      */
     static String[] getWhereArgsForIds(long[] ids) {
         String[] whereArgs = new String[ids.length];
+        return getWhereArgsForIds(ids, whereArgs);
+    }
+
+    /**
+     * Get selection args for a clause returned by {@link #getWhereClauseForIds(long[])}
+     * and write it to the supplied args array.
+     */
+    static String[] getWhereArgsForIds(long[] ids, String[] args) {
+        assert(args.length >= ids.length);
         for (int i = 0; i < ids.length; i++) {
-            whereArgs[i] = Long.toString(ids[i]);
+            args[i] = Long.toString(ids[i]);
         }
-        return whereArgs;
+        return args;
     }
 
+
     /**
      * This class wraps a cursor returned by DownloadProvider -- the "underlying cursor" -- and
      * presents a different set of columns, those defined in the DownloadManager.COLUMN_* constants.
diff --git a/core/java/android/app/Notification.java b/core/java/android/app/Notification.java
index 0dd9c63c40c..bcdf3f49251 100644
--- a/core/java/android/app/Notification.java
+++ b/core/java/android/app/Notification.java
@@ -1761,7 +1761,9 @@ public class Notification implements Parcelable
         if (this.actions != null) {
             that.actions = new Action[this.actions.length];
             for(int i=0; i<this.actions.length; i++) {
-                that.actions[i] = this.actions[i].clone();
+                if ( this.actions[i] != null) {
+                    that.actions[i] = this.actions[i].clone();
+                }
             }
         }
 
@@ -3108,7 +3110,9 @@ public class Notification implements Parcelable
          * @param action The action to add.
          */
         public Builder addAction(Action action) {
-            mActions.add(action);
+            if (action != null) {
+                mActions.add(action);
+            }
             return this;
         }
 
@@ -3122,7 +3126,9 @@ public class Notification implements Parcelable
         public Builder setActions(Action... actions) {
             mActions.clear();
             for (int i = 0; i < actions.length; i++) {
-                mActions.add(actions[i]);
+                if (actions[i] != null) {
+                    mActions.add(actions[i]);
+                }
             }
             return this;
         }
diff --git a/core/java/android/app/ResourcesManager.java b/core/java/android/app/ResourcesManager.java
index 5cc064e5d17..4916c1c1f5c 100644
--- a/core/java/android/app/ResourcesManager.java
+++ b/core/java/android/app/ResourcesManager.java
@@ -826,7 +826,8 @@ public class ResourcesManager {
 
             for (int i = mResourceImpls.size() - 1; i >= 0; i--) {
                 ResourcesKey key = mResourceImpls.keyAt(i);
-                ResourcesImpl r = mResourceImpls.valueAt(i).get();
+                WeakReference<ResourcesImpl> weakImplRef = mResourceImpls.valueAt(i);
+                ResourcesImpl r = weakImplRef != null ? weakImplRef.get() : null;
                 if (r != null) {
                     if (DEBUG || DEBUG_CONFIGURATION) Slog.v(TAG, "Changing resources "
                             + r + " config to: " + config);
@@ -890,8 +891,9 @@ public class ResourcesManager {
 
             final int implCount = mResourceImpls.size();
             for (int i = 0; i < implCount; i++) {
-                final ResourcesImpl impl = mResourceImpls.valueAt(i).get();
                 final ResourcesKey key = mResourceImpls.keyAt(i);
+                final WeakReference<ResourcesImpl> weakImplRef = mResourceImpls.valueAt(i);
+                final ResourcesImpl impl = weakImplRef != null ? weakImplRef.get() : null;
                 if (impl != null && key.mResDir.equals(assetPath)) {
                     if (!ArrayUtils.contains(key.mLibDirs, libAsset)) {
                         final int newLibAssetCount = 1 +
diff --git a/core/java/android/bluetooth/BluetoothDevice.java b/core/java/android/bluetooth/BluetoothDevice.java
index cd5eff29237..d329175646e 100644
--- a/core/java/android/bluetooth/BluetoothDevice.java
+++ b/core/java/android/bluetooth/BluetoothDevice.java
@@ -727,7 +727,11 @@ public final class BluetoothDevice implements Parcelable {
             return null;
         }
         try {
-            return sService.getRemoteName(this);
+            String name = sService.getRemoteName(this);
+            if (name != null) {
+                return name.replaceAll("[\\t\\n\\r]+", " ");
+            }
+            return null;
         } catch (RemoteException e) {Log.e(TAG, "", e);}
         return null;
     }
diff --git a/core/java/android/content/ContentProvider.java b/core/java/android/content/ContentProvider.java
index bc2d788bf4c..e61ac70de8d 100644
--- a/core/java/android/content/ContentProvider.java
+++ b/core/java/android/content/ContentProvider.java
@@ -53,6 +53,7 @@ import java.io.IOException;
 import java.io.PrintWriter;
 import java.util.ArrayList;
 import java.util.Arrays;
+import java.util.Objects;
 
 /**
  * Content providers are one of the primary building blocks of Android applications, providing
@@ -207,8 +208,8 @@ public abstract class ContentProvider implements ComponentCallbacks2 {
         public Cursor query(String callingPkg, Uri uri, String[] projection,
                 String selection, String[] selectionArgs, String sortOrder,
                 ICancellationSignal cancellationSignal) {
-            validateIncomingUri(uri);
-            uri = getUriWithoutUserId(uri);
+            uri = validateIncomingUri(uri);
+            uri = maybeGetUriWithoutUserId(uri);
             if (enforceReadPermission(callingPkg, uri, null) != AppOpsManager.MODE_ALLOWED) {
                 // The caller has no access to the data, so return an empty cursor with
                 // the columns in the requested order. The caller may ask for an invalid
@@ -246,16 +247,16 @@ public abstract class ContentProvider implements ComponentCallbacks2 {
 
         @Override
         public String getType(Uri uri) {
-            validateIncomingUri(uri);
-            uri = getUriWithoutUserId(uri);
+            uri = validateIncomingUri(uri);
+            uri = maybeGetUriWithoutUserId(uri);
             return ContentProvider.this.getType(uri);
         }
 
         @Override
         public Uri insert(String callingPkg, Uri uri, ContentValues initialValues) {
-            validateIncomingUri(uri);
+            uri = validateIncomingUri(uri);
             int userId = getUserIdFromUri(uri);
-            uri = getUriWithoutUserId(uri);
+            uri = maybeGetUriWithoutUserId(uri);
             if (enforceWritePermission(callingPkg, uri, null) != AppOpsManager.MODE_ALLOWED) {
                 return rejectInsert(uri, initialValues);
             }
@@ -269,8 +270,8 @@ public abstract class ContentProvider implements ComponentCallbacks2 {
 
         @Override
         public int bulkInsert(String callingPkg, Uri uri, ContentValues[] initialValues) {
-            validateIncomingUri(uri);
-            uri = getUriWithoutUserId(uri);
+            uri = validateIncomingUri(uri);
+            uri = maybeGetUriWithoutUserId(uri);
             if (enforceWritePermission(callingPkg, uri, null) != AppOpsManager.MODE_ALLOWED) {
                 return 0;
             }
@@ -291,11 +292,12 @@ public abstract class ContentProvider implements ComponentCallbacks2 {
             for (int i = 0; i < numOperations; i++) {
                 ContentProviderOperation operation = operations.get(i);
                 Uri uri = operation.getUri();
-                validateIncomingUri(uri);
                 userIds[i] = getUserIdFromUri(uri);
-                if (userIds[i] != UserHandle.USER_CURRENT) {
-                    // Removing the user id from the uri.
-                    operation = new ContentProviderOperation(operation, true);
+                uri = validateIncomingUri(uri);
+                uri = maybeGetUriWithoutUserId(uri);
+                // Rebuild operation if we changed the Uri above
+                if (!Objects.equals(operation.getUri(), uri)) {
+                    operation = new ContentProviderOperation(operation, uri);
                     operations.set(i, operation);
                 }
                 if (operation.isReadOperation()) {
@@ -330,8 +332,8 @@ public abstract class ContentProvider implements ComponentCallbacks2 {
 
         @Override
         public int delete(String callingPkg, Uri uri, String selection, String[] selectionArgs) {
-            validateIncomingUri(uri);
-            uri = getUriWithoutUserId(uri);
+            uri = validateIncomingUri(uri);
+            uri = maybeGetUriWithoutUserId(uri);
             if (enforceWritePermission(callingPkg, uri, null) != AppOpsManager.MODE_ALLOWED) {
                 return 0;
             }
@@ -346,8 +348,8 @@ public abstract class ContentProvider implements ComponentCallbacks2 {
         @Override
         public int update(String callingPkg, Uri uri, ContentValues values, String selection,
                 String[] selectionArgs) {
-            validateIncomingUri(uri);
-            uri = getUriWithoutUserId(uri);
+            uri = validateIncomingUri(uri);
+            uri = maybeGetUriWithoutUserId(uri);
             if (enforceWritePermission(callingPkg, uri, null) != AppOpsManager.MODE_ALLOWED) {
                 return 0;
             }
@@ -363,8 +365,8 @@ public abstract class ContentProvider implements ComponentCallbacks2 {
         public ParcelFileDescriptor openFile(
                 String callingPkg, Uri uri, String mode, ICancellationSignal cancellationSignal,
                 IBinder callerToken) throws FileNotFoundException {
-            validateIncomingUri(uri);
-            uri = getUriWithoutUserId(uri);
+            uri = validateIncomingUri(uri);
+            uri = maybeGetUriWithoutUserId(uri);
             enforceFilePermission(callingPkg, uri, mode, callerToken);
             final String original = setCallingPackage(callingPkg);
             try {
@@ -379,8 +381,8 @@ public abstract class ContentProvider implements ComponentCallbacks2 {
         public AssetFileDescriptor openAssetFile(
                 String callingPkg, Uri uri, String mode, ICancellationSignal cancellationSignal)
                 throws FileNotFoundException {
-            validateIncomingUri(uri);
-            uri = getUriWithoutUserId(uri);
+            uri = validateIncomingUri(uri);
+            uri = maybeGetUriWithoutUserId(uri);
             enforceFilePermission(callingPkg, uri, mode, null);
             final String original = setCallingPackage(callingPkg);
             try {
@@ -405,8 +407,8 @@ public abstract class ContentProvider implements ComponentCallbacks2 {
 
         @Override
         public String[] getStreamTypes(Uri uri, String mimeTypeFilter) {
-            validateIncomingUri(uri);
-            uri = getUriWithoutUserId(uri);
+            uri = validateIncomingUri(uri);
+            uri = maybeGetUriWithoutUserId(uri);
             return ContentProvider.this.getStreamTypes(uri, mimeTypeFilter);
         }
 
@@ -414,8 +416,8 @@ public abstract class ContentProvider implements ComponentCallbacks2 {
         public AssetFileDescriptor openTypedAssetFile(String callingPkg, Uri uri, String mimeType,
                 Bundle opts, ICancellationSignal cancellationSignal) throws FileNotFoundException {
             Bundle.setDefusable(opts, true);
-            validateIncomingUri(uri);
-            uri = getUriWithoutUserId(uri);
+            uri = validateIncomingUri(uri);
+            uri = maybeGetUriWithoutUserId(uri);
             enforceFilePermission(callingPkg, uri, "r", null);
             final String original = setCallingPackage(callingPkg);
             try {
@@ -433,7 +435,7 @@ public abstract class ContentProvider implements ComponentCallbacks2 {
 
         @Override
         public Uri canonicalize(String callingPkg, Uri uri) {
-            validateIncomingUri(uri);
+            uri = validateIncomingUri(uri);
             int userId = getUserIdFromUri(uri);
             uri = getUriWithoutUserId(uri);
             if (enforceReadPermission(callingPkg, uri, null) != AppOpsManager.MODE_ALLOWED) {
@@ -449,7 +451,7 @@ public abstract class ContentProvider implements ComponentCallbacks2 {
 
         @Override
         public Uri uncanonicalize(String callingPkg, Uri uri) {
-            validateIncomingUri(uri);
+            uri = validateIncomingUri(uri);
             int userId = getUserIdFromUri(uri);
             uri = getUriWithoutUserId(uri);
             if (enforceReadPermission(callingPkg, uri, null) != AppOpsManager.MODE_ALLOWED) {
@@ -1735,7 +1737,7 @@ public abstract class ContentProvider implements ComponentCallbacks2 {
          */
         if (mContext == null) {
             mContext = context;
-            if (context != null) {
+            if (context != null && mTransport != null) {
                 mTransport.mAppOpsManager = (AppOpsManager) context.getSystemService(
                         Context.APP_OPS_SERVICE);
             }
@@ -1844,12 +1846,14 @@ public abstract class ContentProvider implements ComponentCallbacks2 {
     }
 
     /** @hide */
-    private void validateIncomingUri(Uri uri) throws SecurityException {
+    public Uri validateIncomingUri(Uri uri) throws SecurityException {
         String auth = uri.getAuthority();
-        int userId = getUserIdFromAuthority(auth, UserHandle.USER_CURRENT);
-        if (userId != UserHandle.USER_CURRENT && userId != mContext.getUserId()) {
-            throw new SecurityException("trying to query a ContentProvider in user "
-                    + mContext.getUserId() + " with a uri belonging to user " + userId);
+        if (!mSingleUser) {
+            int userId = getUserIdFromAuthority(auth, UserHandle.USER_CURRENT);
+            if (userId != UserHandle.USER_CURRENT && userId != mContext.getUserId()) {
+                throw new SecurityException("trying to query a ContentProvider in user "
+                        + mContext.getUserId() + " with a uri belonging to user " + userId);
+            }
         }
         if (!matchesOurAuthorities(getAuthorityWithoutUserId(auth))) {
             String message = "The authority of the uri " + uri + " does not match the one of the "
@@ -1861,6 +1865,27 @@ public abstract class ContentProvider implements ComponentCallbacks2 {
             }
             throw new SecurityException(message);
         }
+
+        // Normalize the path by removing any empty path segments, which can be
+        // a source of security issues.
+        final String encodedPath = uri.getEncodedPath();
+        if (encodedPath != null && encodedPath.indexOf("//") != -1) {
+            final Uri normalized = uri.buildUpon()
+                    .encodedPath(encodedPath.replaceAll("//+", "/")).build();
+            Log.w(TAG, "Normalized " + uri + " to " + normalized
+                    + " to avoid possible security issues");
+            return normalized;
+        } else {
+            return uri;
+        }
+    }
+
+    /** @hide */
+    private Uri maybeGetUriWithoutUserId(Uri uri) {
+        if (mSingleUser) {
+            return uri;
+        }
+        return getUriWithoutUserId(uri);
     }
 
     /** @hide */
diff --git a/core/java/android/content/ContentProviderOperation.java b/core/java/android/content/ContentProviderOperation.java
index fd1e24a48da..1a03bd68cd0 100644
--- a/core/java/android/content/ContentProviderOperation.java
+++ b/core/java/android/content/ContentProviderOperation.java
@@ -94,13 +94,9 @@ public class ContentProviderOperation implements Parcelable {
     }
 
     /** @hide */
-    public ContentProviderOperation(ContentProviderOperation cpo, boolean removeUserIdFromUri) {
+    public ContentProviderOperation(ContentProviderOperation cpo, Uri withUri) {
         mType = cpo.mType;
-        if (removeUserIdFromUri) {
-            mUri = ContentProvider.getUriWithoutUserId(cpo.mUri);
-        } else {
-            mUri = cpo.mUri;
-        }
+        mUri = withUri;
         mValues = cpo.mValues;
         mSelection = cpo.mSelection;
         mSelectionArgs = cpo.mSelectionArgs;
@@ -110,14 +106,6 @@ public class ContentProviderOperation implements Parcelable {
         mYieldAllowed = cpo.mYieldAllowed;
     }
 
-    /** @hide */
-    public ContentProviderOperation getWithoutUserIdInUri() {
-        if (ContentProvider.uriHasUserId(mUri)) {
-            return new ContentProviderOperation(this, true);
-        }
-        return this;
-    }
-
     public void writeToParcel(Parcel dest, int flags) {
         dest.writeInt(mType);
         Uri.writeToParcel(dest, mUri);
diff --git a/core/java/android/content/PermissionChecker.java b/core/java/android/content/PermissionChecker.java
new file mode 100644
index 00000000000..a4b2fe0c10e
--- /dev/null
+++ b/core/java/android/content/PermissionChecker.java
@@ -0,0 +1,157 @@
+/*
+ * Copyright (C) 2018 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package android.content;
+import android.annotation.IntDef;
+import android.annotation.NonNull;
+import android.annotation.Nullable;
+import android.app.AppOpsManager;
+import android.content.pm.PackageManager;
+import android.os.Binder;
+import android.os.Process;
+import java.lang.annotation.Retention;
+import java.lang.annotation.RetentionPolicy;
+/**
+ * This class provides permission check APIs that verify both the
+ * permission and the associated app op for this permission if
+ * such is defined.
+ * <p>
+ * In the new permission model permissions with protection level
+ * dangerous are runtime permissions. For apps targeting {@link android.os.Build.VERSION_CODES#M}
+ * and above the user may not grant such permissions or revoke
+ * them at any time. For apps targeting API lower than {@link android.os.Build.VERSION_CODES#M}
+ * these permissions are always granted as such apps do not expect
+ * permission revocations and would crash. Therefore, when the
+ * user disables a permission for a legacy app in the UI the
+ * platform disables the APIs guarded by this permission making
+ * them a no-op which is doing nothing or returning an empty
+ * result or default error.
+ * </p>
+ * <p>
+ * It is important that when you perform an operation on behalf of
+ * another app you use these APIs to check for permissions as the
+ * app may be a legacy app that does not participate in the new
+ * permission model for which the user had disabled the "permission"
+ * which is achieved by disallowing the corresponding app op.
+ * </p>
+ *
+ * @hide
+ */
+public final class PermissionChecker {
+    /** Permission result: The permission is granted. */
+    public static final int PERMISSION_GRANTED =  PackageManager.PERMISSION_GRANTED;
+    /** Permission result: The permission is denied. */
+    public static final int PERMISSION_DENIED =  PackageManager.PERMISSION_DENIED;
+    /** Permission result: The permission is denied because the app op is not allowed. */
+    public static final int PERMISSION_DENIED_APP_OP =  PackageManager.PERMISSION_DENIED  - 1;
+    /** @hide */
+    @IntDef({PERMISSION_GRANTED,
+            PERMISSION_DENIED,
+            PERMISSION_DENIED_APP_OP})
+    @Retention(RetentionPolicy.SOURCE)
+    public @interface PermissionResult {}
+    private PermissionChecker() {
+        /* do nothing */
+    }
+    /**
+     * Checks whether a given package in a UID and PID has a given permission
+     * and whether the app op that corresponds to this permission is allowed.
+     *
+     * @param context Context for accessing resources.
+     * @param permission The permission to check.
+     * @param pid The process id for which to check.
+     * @param uid The uid for which to check.
+     * @param packageName The package name for which to check. If null the
+     *     the first package for the calling UID will be used.
+     * @return The permission check result which is either {@link #PERMISSION_GRANTED}
+     *     or {@link #PERMISSION_DENIED} or {@link #PERMISSION_DENIED_APP_OP}.
+     */
+    @PermissionResult
+    public static int checkPermission(@NonNull Context context, @NonNull String permission,
+            int pid, int uid, @Nullable String packageName) {
+        if (context.checkPermission(permission, pid, uid) == PackageManager.PERMISSION_DENIED) {
+            return PERMISSION_DENIED;
+        }
+        AppOpsManager appOpsManager = context.getSystemService(AppOpsManager.class);
+        String op = appOpsManager.permissionToOp(permission);
+        if (op == null) {
+            return PERMISSION_GRANTED;
+        }
+        if (packageName == null) {
+            String[] packageNames = context.getPackageManager().getPackagesForUid(uid);
+            if (packageNames == null || packageNames.length <= 0) {
+                return PERMISSION_DENIED;
+            }
+            packageName = packageNames[0];
+        }
+        if (appOpsManager.noteProxyOpNoThrow(op, packageName)
+                != AppOpsManager.MODE_ALLOWED) {
+            return PERMISSION_DENIED_APP_OP;
+        }
+        return PERMISSION_GRANTED;
+    }
+    /**
+     * Checks whether your app has a given permission and whether the app op
+     * that corresponds to this permission is allowed.
+     *
+     * @param context Context for accessing resources.
+     * @param permission The permission to check.
+     * @return The permission check result which is either {@link #PERMISSION_GRANTED}
+     *     or {@link #PERMISSION_DENIED} or {@link #PERMISSION_DENIED_APP_OP}.
+     */
+    @PermissionResult
+    public static int checkSelfPermission(@NonNull Context context,
+            @NonNull String permission) {
+        return checkPermission(context, permission, Process.myPid(),
+                Process.myUid(), context.getPackageName());
+    }
+    /**
+     * Checks whether the IPC you are handling has a given permission and whether
+     * the app op that corresponds to this permission is allowed.
+     *
+     * @param context Context for accessing resources.
+     * @param permission The permission to check.
+     * @param packageName The package name making the IPC. If null the
+     *     the first package for the calling UID will be used.
+     * @return The permission check result which is either {@link #PERMISSION_GRANTED}
+     *     or {@link #PERMISSION_DENIED} or {@link #PERMISSION_DENIED_APP_OP}.
+     */
+    @PermissionResult
+    public static int checkCallingPermission(@NonNull Context context,
+            @NonNull String permission, @Nullable String packageName) {
+        if (Binder.getCallingPid() == Process.myPid()) {
+            return PERMISSION_DENIED;
+        }
+        return checkPermission(context, permission, Binder.getCallingPid(),
+                Binder.getCallingUid(), packageName);
+    }
+    /**
+     * Checks whether the IPC you are handling or your app has a given permission
+     * and whether the app op that corresponds to this permission is allowed.
+     *
+     * @param context Context for accessing resources.
+     * @param permission The permission to check.
+     * @return The permission check result which is either {@link #PERMISSION_GRANTED}
+     *     or {@link #PERMISSION_DENIED} or {@link #PERMISSION_DENIED_APP_OP}.
+     */
+    @PermissionResult
+    public static int checkCallingOrSelfPermission(@NonNull Context context,
+            @NonNull String permission) {
+        String packageName = (Binder.getCallingPid() == Process.myPid())
+                ? context.getPackageName() : null;
+        return checkPermission(context, permission, Binder.getCallingPid(),
+                Binder.getCallingUid(), packageName);
+    }
+}
diff --git a/core/java/android/content/pm/PackageItemInfo.java b/core/java/android/content/pm/PackageItemInfo.java
index bc79f41b1fc..73ae83e32f6 100644
--- a/core/java/android/content/pm/PackageItemInfo.java
+++ b/core/java/android/content/pm/PackageItemInfo.java
@@ -46,6 +46,9 @@ import java.util.Comparator;
  */
 public class PackageItemInfo {
     private static final float MAX_LABEL_SIZE_PX = 500f;
+    /** The maximum length of a safe label, in characters */
+    private static final int MAX_SAFE_LABEL_LENGTH = 50000;
+
     /**
      * Public name of this item. From the "android:name" attribute.
      */
@@ -173,7 +176,8 @@ public class PackageItemInfo {
         // If the label contains new line characters it may push the UI
         // down to hide a part of it. Labels shouldn't have new line
         // characters, so just truncate at the first time one is seen.
-        final int labelLength = labelStr.length();
+        final int labelLength = Math.min(labelStr.length(), MAX_SAFE_LABEL_LENGTH);
+        final StringBuffer sb = new StringBuffer(labelLength);
         int offset = 0;
         while (offset < labelLength) {
             final int codePoint = labelStr.codePointAt(offset);
@@ -185,14 +189,19 @@ public class PackageItemInfo {
                 break;
             }
             // replace all non-break space to " " in order to be trimmed
+            final int charCount = Character.charCount(codePoint);
             if (type == Character.SPACE_SEPARATOR) {
-                labelStr = labelStr.substring(0, offset) + " " + labelStr.substring(offset +
-                        Character.charCount(codePoint));
+                sb.append(' ');
+            } else {
+                sb.append(labelStr.charAt(offset));
+                if (charCount == 2) {
+                    sb.append(labelStr.charAt(offset + 1));
+                }
             }
-            offset += Character.charCount(codePoint);
+            offset += charCount;
         }
 
-        labelStr = labelStr.trim();
+        labelStr = sb.toString().trim();
         if (labelStr.isEmpty()) {
             return packageName;
         }
diff --git a/core/java/android/content/pm/RegisteredServicesCache.java b/core/java/android/content/pm/RegisteredServicesCache.java
index a1103838280..aea843adbd4 100644
--- a/core/java/android/content/pm/RegisteredServicesCache.java
+++ b/core/java/android/content/pm/RegisteredServicesCache.java
@@ -390,15 +390,17 @@ public abstract class RegisteredServicesCache<V> {
     @VisibleForTesting
     protected boolean inSystemImage(int callerUid) {
         String[] packages = mContext.getPackageManager().getPackagesForUid(callerUid);
-        for (String name : packages) {
-            try {
-                PackageInfo packageInfo =
-                        mContext.getPackageManager().getPackageInfo(name, 0 /* flags */);
-                if ((packageInfo.applicationInfo.flags & ApplicationInfo.FLAG_SYSTEM) != 0) {
-                    return true;
+        if (packages != null) {
+            for (String name : packages) {
+                try {
+                    PackageInfo packageInfo =
+                            mContext.getPackageManager().getPackageInfo(name, 0 /* flags */);
+                    if ((packageInfo.applicationInfo.flags & ApplicationInfo.FLAG_SYSTEM) != 0) {
+                        return true;
+                    }
+                } catch (PackageManager.NameNotFoundException e) {
+                    return false;
                 }
-            } catch (PackageManager.NameNotFoundException e) {
-                return false;
             }
         }
         return false;
diff --git a/core/java/android/database/sqlite/SQLiteDatabase.java b/core/java/android/database/sqlite/SQLiteDatabase.java
index 8e178320d66..f300b5be452 100644
--- a/core/java/android/database/sqlite/SQLiteDatabase.java
+++ b/core/java/android/database/sqlite/SQLiteDatabase.java
@@ -1658,7 +1658,8 @@ public final class SQLiteDatabase extends SQLiteClosable {
         executeSql(sql, bindArgs);
     }
 
-    private int executeSql(String sql, Object[] bindArgs) throws SQLException {
+    /** {@hide} */
+    public int executeSql(String sql, Object[] bindArgs) throws SQLException {
         acquireReference();
         try {
             if (DatabaseUtils.getSqlStatementType(sql) == DatabaseUtils.STATEMENT_ATTACH) {
diff --git a/core/java/android/database/sqlite/SQLiteQueryBuilder.java b/core/java/android/database/sqlite/SQLiteQueryBuilder.java
index 56cba795355..13ab6fb0797 100644
--- a/core/java/android/database/sqlite/SQLiteQueryBuilder.java
+++ b/core/java/android/database/sqlite/SQLiteQueryBuilder.java
@@ -16,17 +16,25 @@
 
 package android.database.sqlite;
 
+import android.annotation.NonNull;
+import android.annotation.Nullable;
+import android.content.ContentValues;
 import android.database.Cursor;
 import android.database.DatabaseUtils;
+import android.os.Build;
 import android.os.CancellationSignal;
 import android.os.OperationCanceledException;
 import android.provider.BaseColumns;
 import android.text.TextUtils;
 import android.util.Log;
 
+import libcore.util.EmptyArray;
+
+import java.util.Arrays;
 import java.util.Iterator;
 import java.util.Map;
 import java.util.Map.Entry;
+import java.util.Objects;
 import java.util.Set;
 import java.util.regex.Pattern;
 
@@ -95,9 +103,6 @@ public class SQLiteQueryBuilder
         if (mWhereClause == null) {
             mWhereClause = new StringBuilder(inWhere.length() + 16);
         }
-        if (mWhereClause.length() == 0) {
-            mWhereClause.append('(');
-        }
         mWhereClause.append(inWhere);
     }
 
@@ -115,9 +120,6 @@ public class SQLiteQueryBuilder
         if (mWhereClause == null) {
             mWhereClause = new StringBuilder(inWhere.length() + 16);
         }
-        if (mWhereClause.length() == 0) {
-            mWhereClause.append('(');
-        }
         DatabaseUtils.appendEscapedSQLString(mWhereClause, inWhere);
     }
 
@@ -376,6 +378,11 @@ public class SQLiteQueryBuilder
             return null;
         }
 
+        final String sql;
+        final String unwrappedSql = buildQuery(
+                projectionIn, selection, groupBy, having,
+                sortOrder, limit);
+
         if (mStrict && selection != null && selection.length() > 0) {
             // Validate the user-supplied selection to detect syntactic anomalies
             // in the selection string that could indicate a SQL injection attempt.
@@ -384,24 +391,166 @@ public class SQLiteQueryBuilder
             // originally specified. An attacker cannot create an expression that
             // would escape the SQL expression while maintaining balanced parentheses
             // in both the wrapped and original forms.
-            String sqlForValidation = buildQuery(projectionIn, "(" + selection + ")", groupBy,
+
+            // NOTE: The ordering of the below operations is important; we must
+            // execute the wrapped query to ensure the untrusted clause has been
+            // fully isolated.
+
+            // Validate the unwrapped query
+            db.validateSql(unwrappedSql, cancellationSignal); // will throw if query is invalid
+
+            // Execute wrapped query for extra protection
+            final String wrappedSql = buildQuery(projectionIn, wrap(selection), groupBy,
                     having, sortOrder, limit);
-            db.validateSql(sqlForValidation, cancellationSignal); // will throw if query is invalid
+            sql = wrappedSql;
+        } else {
+            // Execute unwrapped query
+            sql = unwrappedSql;
         }
 
-        String sql = buildQuery(
-                projectionIn, selection, groupBy, having,
-                sortOrder, limit);
-
+        final String[] sqlArgs = selectionArgs;
         if (Log.isLoggable(TAG, Log.DEBUG)) {
-            Log.d(TAG, "Performing query: " + sql);
+            if (Build.IS_DEBUGGABLE) {
+                Log.d(TAG, sql + " with args " + Arrays.toString(sqlArgs));
+            } else {
+                Log.d(TAG, sql);
+            }
         }
         return db.rawQueryWithFactory(
-                mFactory, sql, selectionArgs,
+                mFactory, sql, sqlArgs,
                 SQLiteDatabase.findEditTable(mTables),
                 cancellationSignal); // will throw if query is invalid
     }
 
+    /**
+     * Perform an update by combining all current settings and the
+     * information passed into this method.
+     *
+     * @param db the database to update on
+     * @param selection A filter declaring which rows to return,
+     *   formatted as an SQL WHERE clause (excluding the WHERE
+     *   itself). Passing null will return all rows for the given URL.
+     * @param selectionArgs You may include ?s in selection, which
+     *   will be replaced by the values from selectionArgs, in order
+     *   that they appear in the selection. The values will be bound
+     *   as Strings.
+     * @return the number of rows updated
+     * @hide
+     */
+    public int update(@NonNull SQLiteDatabase db, @NonNull ContentValues values,
+            @Nullable String selection, @Nullable String[] selectionArgs) {
+        Objects.requireNonNull(mTables, "No tables defined");
+        Objects.requireNonNull(db, "No database defined");
+        Objects.requireNonNull(values, "No values defined");
+
+        final String sql;
+        final String unwrappedSql = buildUpdate(values, selection);
+
+        if (mStrict) {
+            // Validate the user-supplied selection to detect syntactic anomalies
+            // in the selection string that could indicate a SQL injection attempt.
+            // The idea is to ensure that the selection clause is a valid SQL expression
+            // by compiling it twice: once wrapped in parentheses and once as
+            // originally specified. An attacker cannot create an expression that
+            // would escape the SQL expression while maintaining balanced parentheses
+            // in both the wrapped and original forms.
+
+            // NOTE: The ordering of the below operations is important; we must
+            // execute the wrapped query to ensure the untrusted clause has been
+            // fully isolated.
+
+            // Validate the unwrapped query
+            db.validateSql(unwrappedSql, null); // will throw if query is invalid
+
+            // Execute wrapped query for extra protection
+            final String wrappedSql = buildUpdate(values, wrap(selection));
+            sql = wrappedSql;
+        } else {
+            // Execute unwrapped query
+            sql = unwrappedSql;
+        }
+
+        if (selectionArgs == null) {
+            selectionArgs = EmptyArray.STRING;
+        }
+        final String[] rawKeys = values.keySet().toArray(EmptyArray.STRING);
+        final int valuesLength = rawKeys.length;
+        final Object[] sqlArgs = new Object[valuesLength + selectionArgs.length];
+        for (int i = 0; i < sqlArgs.length; i++) {
+            if (i < valuesLength) {
+                sqlArgs[i] = values.get(rawKeys[i]);
+            } else {
+                sqlArgs[i] = selectionArgs[i - valuesLength];
+            }
+        }
+        if (Log.isLoggable(TAG, Log.DEBUG)) {
+            if (Build.IS_DEBUGGABLE) {
+                Log.d(TAG, sql + " with args " + Arrays.toString(sqlArgs));
+            } else {
+                Log.d(TAG, sql);
+            }
+        }
+        return db.executeSql(sql, sqlArgs);
+    }
+
+    /**
+     * Perform a delete by combining all current settings and the
+     * information passed into this method.
+     *
+     * @param db the database to delete on
+     * @param selection A filter declaring which rows to return,
+     *   formatted as an SQL WHERE clause (excluding the WHERE
+     *   itself). Passing null will return all rows for the given URL.
+     * @param selectionArgs You may include ?s in selection, which
+     *   will be replaced by the values from selectionArgs, in order
+     *   that they appear in the selection. The values will be bound
+     *   as Strings.
+     * @return the number of rows deleted
+     * @hide
+     */
+    public int delete(@NonNull SQLiteDatabase db, @Nullable String selection,
+            @Nullable String[] selectionArgs) {
+        Objects.requireNonNull(mTables, "No tables defined");
+        Objects.requireNonNull(db, "No database defined");
+
+        final String sql;
+        final String unwrappedSql = buildDelete(selection);
+
+        if (mStrict) {
+            // Validate the user-supplied selection to detect syntactic anomalies
+            // in the selection string that could indicate a SQL injection attempt.
+            // The idea is to ensure that the selection clause is a valid SQL expression
+            // by compiling it twice: once wrapped in parentheses and once as
+            // originally specified. An attacker cannot create an expression that
+            // would escape the SQL expression while maintaining balanced parentheses
+            // in both the wrapped and original forms.
+
+            // NOTE: The ordering of the below operations is important; we must
+            // execute the wrapped query to ensure the untrusted clause has been
+            // fully isolated.
+
+            // Validate the unwrapped query
+            db.validateSql(unwrappedSql, null); // will throw if query is invalid
+
+            // Execute wrapped query for extra protection
+            final String wrappedSql = buildDelete(wrap(selection));
+            sql = wrappedSql;
+        } else {
+            // Execute unwrapped query
+            sql = unwrappedSql;
+        }
+
+        final String[] sqlArgs = selectionArgs;
+        if (Log.isLoggable(TAG, Log.DEBUG)) {
+            if (Build.IS_DEBUGGABLE) {
+                Log.d(TAG, sql + " with args " + Arrays.toString(sqlArgs));
+            } else {
+                Log.d(TAG, sql);
+            }
+        }
+        return db.executeSql(sql, sqlArgs);
+    }
+
     /**
      * Construct a SELECT statement suitable for use in a group of
      * SELECT statements that will be joined through UNION operators
@@ -434,28 +583,10 @@ public class SQLiteQueryBuilder
             String[] projectionIn, String selection, String groupBy,
             String having, String sortOrder, String limit) {
         String[] projection = computeProjection(projectionIn);
-
-        StringBuilder where = new StringBuilder();
-        boolean hasBaseWhereClause = mWhereClause != null && mWhereClause.length() > 0;
-
-        if (hasBaseWhereClause) {
-            where.append(mWhereClause.toString());
-            where.append(')');
-        }
-
-        // Tack on the user's selection, if present.
-        if (selection != null && selection.length() > 0) {
-            if (hasBaseWhereClause) {
-                where.append(" AND ");
-            }
-
-            where.append('(');
-            where.append(selection);
-            where.append(')');
-        }
+        String where = computeWhere(selection);
 
         return buildQueryString(
-                mDistinct, mTables, projection, where.toString(),
+                mDistinct, mTables, projection, where,
                 groupBy, having, sortOrder, limit);
     }
 
@@ -472,6 +603,42 @@ public class SQLiteQueryBuilder
         return buildQuery(projectionIn, selection, groupBy, having, sortOrder, limit);
     }
 
+    /** {@hide} */
+    public String buildUpdate(ContentValues values, String selection) {
+        if (values == null || values.size() == 0) {
+            throw new IllegalArgumentException("Empty values");
+        }
+
+        StringBuilder sql = new StringBuilder(120);
+        sql.append("UPDATE ");
+        sql.append(mTables);
+        sql.append(" SET ");
+
+        final String[] rawKeys = values.keySet().toArray(EmptyArray.STRING);
+        for (int i = 0; i < rawKeys.length; i++) {
+            if (i > 0) {
+                sql.append(',');
+            }
+            sql.append(rawKeys[i]);
+            sql.append("=?");
+        }
+
+        final String where = computeWhere(selection);
+        appendClause(sql, " WHERE ", where);
+        return sql.toString();
+    }
+
+    /** {@hide} */
+    public String buildDelete(String selection) {
+        StringBuilder sql = new StringBuilder(120);
+        sql.append("DELETE FROM ");
+        sql.append(mTables);
+
+        final String where = computeWhere(selection);
+        appendClause(sql, " WHERE ", where);
+        return sql.toString();
+    }
+
     /**
      * Construct a SELECT statement suitable for use in a group of
      * SELECT statements that will be joined through UNION operators
@@ -645,4 +812,37 @@ public class SQLiteQueryBuilder
         }
         return null;
     }
+
+    private @Nullable String computeWhere(@Nullable String selection) {
+        final boolean hasInternal = !TextUtils.isEmpty(mWhereClause);
+        final boolean hasExternal = !TextUtils.isEmpty(selection);
+
+        if (hasInternal || hasExternal) {
+            final StringBuilder where = new StringBuilder();
+            if (hasInternal) {
+                where.append('(').append(mWhereClause).append(')');
+            }
+            if (hasInternal && hasExternal) {
+                where.append(" AND ");
+            }
+            if (hasExternal) {
+                where.append('(').append(selection).append(')');
+            }
+            return where.toString();
+        } else {
+            return null;
+        }
+    }
+
+    /**
+     * Wrap given argument in parenthesis, unless it's {@code null} or
+     * {@code ()}, in which case return it verbatim.
+     */
+    private @Nullable String wrap(@Nullable String arg) {
+        if (TextUtils.isEmpty(arg)) {
+            return arg;
+        } else {
+            return "(" + arg + ")";
+        }
+    }
 }
diff --git a/core/java/android/hardware/location/NanoAppFilter.java b/core/java/android/hardware/location/NanoAppFilter.java
index bf35a3d6fbd..c44094908f3 100644
--- a/core/java/android/hardware/location/NanoAppFilter.java
+++ b/core/java/android/hardware/location/NanoAppFilter.java
@@ -83,7 +83,7 @@ public class NanoAppFilter {
         mAppId = in.readLong();
         mAppVersion = in.readInt();
         mVersionRestrictionMask = in.readInt();
-        mAppIdVendorMask = in.readInt();
+        mAppIdVendorMask = in.readLong();
     }
 
     public int describeContents() {
@@ -91,7 +91,6 @@ public class NanoAppFilter {
     }
 
     public void writeToParcel(Parcel out, int flags) {
-
         out.writeLong(mAppId);
         out.writeInt(mAppVersion);
         out.writeInt(mVersionRestrictionMask);
diff --git a/core/java/android/net/Uri.java b/core/java/android/net/Uri.java
index 09af05c0dfb..6c069be07e3 100644
--- a/core/java/android/net/Uri.java
+++ b/core/java/android/net/Uri.java
@@ -719,6 +719,10 @@ public abstract class Uri implements Parcelable, Comparable<Uri> {
                 LOOP: while (end < length) {
                     switch (uriString.charAt(end)) {
                         case '/': // Start of path
+                        case '\\':// Start of path
+                          // Per http://url.spec.whatwg.org/#host-state, the \ character
+                          // is treated as if it were a / character when encountered in a
+                          // host
                         case '?': // Start of query
                         case '#': // Start of fragment
                             break LOOP;
@@ -757,6 +761,10 @@ public abstract class Uri implements Parcelable, Comparable<Uri> {
                         case '#': // Start of fragment
                             return ""; // Empty path.
                         case '/': // Start of path!
+                        case '\\':// Start of path!
+                          // Per http://url.spec.whatwg.org/#host-state, the \ character
+                          // is treated as if it were a / character when encountered in a
+                          // host
                             break LOOP;
                     }
                     pathStart++;
@@ -1065,7 +1073,7 @@ public abstract class Uri implements Parcelable, Comparable<Uri> {
                 return null;
             }
 
-            int end = authority.indexOf('@');
+            int end = authority.lastIndexOf('@');
             return end == NOT_FOUND ? null : authority.substring(0, end);
         }
 
@@ -1089,7 +1097,7 @@ public abstract class Uri implements Parcelable, Comparable<Uri> {
             }
 
             // Parse out user info and then port.
-            int userInfoSeparator = authority.indexOf('@');
+            int userInfoSeparator = authority.lastIndexOf('@');
             int portSeparator = authority.indexOf(':', userInfoSeparator);
 
             String encodedHost = portSeparator == NOT_FOUND
@@ -1115,7 +1123,7 @@ public abstract class Uri implements Parcelable, Comparable<Uri> {
 
             // Make sure we look for the port separtor *after* the user info
             // separator. We have URLs with a ':' in the user info.
-            int userInfoSeparator = authority.indexOf('@');
+            int userInfoSeparator = authority.lastIndexOf('@');
             int portSeparator = authority.indexOf(':', userInfoSeparator);
 
             if (portSeparator == NOT_FOUND) {
diff --git a/core/java/android/os/Parcel.java b/core/java/android/os/Parcel.java
index f6e6ad6067b..0591fa8883c 100644
--- a/core/java/android/os/Parcel.java
+++ b/core/java/android/os/Parcel.java
@@ -692,11 +692,19 @@ public final class Parcel {
             return;
         }
         Set<Map.Entry<String,Object>> entries = val.entrySet();
-        writeInt(entries.size());
+        int size = entries.size();
+        writeInt(size);
+
         for (Map.Entry<String,Object> e : entries) {
             writeValue(e.getKey());
             writeValue(e.getValue());
+            size--;
         }
+
+        if (size != 0) {
+            throw new BadParcelableException("Map size does not match number of entries!");
+        }
+
     }
 
     /**
diff --git a/core/java/android/provider/MediaStore.java b/core/java/android/provider/MediaStore.java
index de19f819295..b17657b43db 100644
--- a/core/java/android/provider/MediaStore.java
+++ b/core/java/android/provider/MediaStore.java
@@ -678,8 +678,8 @@ public final class MediaStore {
             // Log.v(TAG, "getThumbnail: origId="+origId+", kind="+kind+", isVideo="+isVideo);
             // If the magic is non-zero, we simply return thumbnail if it does exist.
             // querying MediaProvider and simply return thumbnail.
-            MiniThumbFile thumbFile = new MiniThumbFile(isVideo ? Video.Media.EXTERNAL_CONTENT_URI
-                    : Images.Media.EXTERNAL_CONTENT_URI);
+            MiniThumbFile thumbFile = MiniThumbFile.instance(
+                    isVideo ? Video.Media.EXTERNAL_CONTENT_URI : Images.Media.EXTERNAL_CONTENT_URI);
             Cursor c = null;
             try {
                 long magic = thumbFile.getMagic(origId);
diff --git a/core/java/android/provider/Settings.java b/core/java/android/provider/Settings.java
index a8209af6aa2..4766d33846d 100755
--- a/core/java/android/provider/Settings.java
+++ b/core/java/android/provider/Settings.java
@@ -3558,6 +3558,12 @@ public final class Settings {
         /** @hide */
         public static final Validator LOCK_TO_APP_ENABLED_VALIDATOR = sBooleanValidator;
 
+        /**
+         * Whether to wake the screen with the home key, the value is boolean.
+         * @hide
+         */
+        public static final String HOME_WAKE_SCREEN = "home_wake_screen";
+
         /**
          * I am the lolrus.
          * <p>
diff --git a/core/java/android/service/gatekeeper/GateKeeperResponse.java b/core/java/android/service/gatekeeper/GateKeeperResponse.java
index a512957d604..6ca6d8ac710 100644
--- a/core/java/android/service/gatekeeper/GateKeeperResponse.java
+++ b/core/java/android/service/gatekeeper/GateKeeperResponse.java
@@ -85,6 +85,8 @@ public final class GateKeeperResponse implements Parcelable {
             if (mPayload != null) {
                 dest.writeInt(mPayload.length);
                 dest.writeByteArray(mPayload);
+            } else {
+                dest.writeInt(0);
             }
         }
     }
diff --git a/core/java/android/speech/RecognitionService.java b/core/java/android/speech/RecognitionService.java
index 674f809ef0f..70dfef574ca 100644
--- a/core/java/android/speech/RecognitionService.java
+++ b/core/java/android/speech/RecognitionService.java
@@ -20,7 +20,7 @@ import android.annotation.SdkConstant;
 import android.annotation.SdkConstant.SdkConstantType;
 import android.app.Service;
 import android.content.Intent;
-import android.content.pm.PackageManager;
+import android.content.PermissionChecker;
 import android.os.Binder;
 import android.os.Bundle;
 import android.os.Handler;
@@ -174,8 +174,8 @@ public abstract class RecognitionService extends Service {
      */
     private boolean checkPermissions(IRecognitionListener listener) {
         if (DBG) Log.d(TAG, "checkPermissions");
-        if (RecognitionService.this.checkCallingOrSelfPermission(android.Manifest.permission.
-                RECORD_AUDIO) == PackageManager.PERMISSION_GRANTED) {
+        if (PermissionChecker.checkCallingOrSelfPermission(this,
+                android.Manifest.permission.RECORD_AUDIO) == PermissionChecker.PERMISSION_GRANTED) {
             return true;
         }
         try {
diff --git a/core/java/android/text/Layout.java b/core/java/android/text/Layout.java
index 0bd5071b6ea..3bc9390c581 100644
--- a/core/java/android/text/Layout.java
+++ b/core/java/android/text/Layout.java
@@ -824,6 +824,32 @@ public abstract class Layout {
         return TextUtils.packRangeInLong(0, getLineEnd(line));
     }
 
+    /**
+     * Checks if the trailing BiDi level should be used for an offset
+     *
+     * This method is useful when the offset is at the BiDi level transition point and determine
+     * which run need to be used. For example, let's think about following input: (L* denotes
+     * Left-to-Right characters, R* denotes Right-to-Left characters.)
+     * Input (Logical Order): L1 L2 L3 R1 R2 R3 L4 L5 L6
+     * Input (Display Order): L1 L2 L3 R3 R2 R1 L4 L5 L6
+     *
+     * Then, think about selecting the range (3, 6). The offset=3 and offset=6 are ambiguous here
+     * since they are at the BiDi transition point.  In Android, the offset is considered to be
+     * associated with the trailing run if the BiDi level of the trailing run is higher than of the
+     * previous run.  In this case, the BiDi level of the input text is as follows:
+     *
+     * Input (Logical Order): L1 L2 L3 R1 R2 R3 L4 L5 L6
+     *              BiDi Run: [ Run 0 ][ Run 1 ][ Run 2 ]
+     *            BiDi Level:  0  0  0  1  1  1  0  0  0
+     *
+     * Thus, offset = 3 is part of Run 1 and this method returns true for offset = 3, since the BiDi
+     * level of Run 1 is higher than the level of Run 0.  Similarly, the offset = 6 is a part of Run
+     * 1 and this method returns false for the offset = 6 since the BiDi level of Run 1 is higher
+     * than the level of Run 2.
+     *
+     * @returns true if offset is at the BiDi level transition point and trailing BiDi level is
+     *          higher than previous BiDi level. See above for the detail.
+     */
     private boolean primaryIsTrailingPrevious(int offset) {
         int line = getLineForOffset(offset);
         int lineStart = getLineStart(line);
@@ -873,6 +899,41 @@ public abstract class Layout {
         return levelBefore < levelAt;
     }
 
+    /**
+     * Computes in linear time the results of calling
+     * #primaryIsTrailingPrevious for all offsets on a line.
+     * @param line The line giving the offsets we compute the information for
+     * @return The array of results, indexed from 0, where 0 corresponds to the line start offset
+     */
+    private boolean[] primaryIsTrailingPreviousAllLineOffsets(int line) {
+        int lineStart = getLineStart(line);
+        int lineEnd = getLineEnd(line);
+        int[] runs = getLineDirections(line).mDirections;
+
+        boolean[] trailing = new boolean[lineEnd - lineStart + 1];
+
+        byte[] level = new byte[lineEnd - lineStart + 1];
+        for (int i = 0; i < runs.length; i += 2) {
+            int start = lineStart + runs[i];
+            int limit = start + (runs[i + 1] & RUN_LENGTH_MASK);
+            if (limit > lineEnd) {
+                limit = lineEnd;
+            }
+            level[limit - lineStart - 1] =
+                    (byte) ((runs[i + 1] >>> RUN_LEVEL_SHIFT) & RUN_LEVEL_MASK);
+        }
+
+        for (int i = 0; i < runs.length; i += 2) {
+            int start = lineStart + runs[i];
+            byte currentLevel = (byte) ((runs[i + 1] >>> RUN_LEVEL_SHIFT) & RUN_LEVEL_MASK);
+            trailing[start - lineStart] = currentLevel > (start == lineStart
+                    ? (getParagraphDirection(line) == 1 ? 0 : 1)
+                    : level[start - lineStart - 1]);
+        }
+
+        return trailing;
+    }
+
     /**
      * Get the primary horizontal position for the specified text offset.
      * This is the location where a new character would be inserted in
@@ -952,6 +1013,60 @@ public abstract class Layout {
         return getLineStartPos(line, left, right) + wid;
     }
 
+    /**
+     * Computes in linear time the results of calling
+     * #getHorizontal for all offsets on a line.
+     * @param line The line giving the offsets we compute information for
+     * @param clamped Whether to clamp the results to the width of the layout
+     * @param primary Whether the results should be the primary or the secondary horizontal
+     * @return The array of results, indexed from 0, where 0 corresponds to the line start offset
+     */
+    private float[] getLineHorizontals(int line, boolean clamped, boolean primary) {
+        int start = getLineStart(line);
+        int end = getLineEnd(line);
+        int dir = getParagraphDirection(line);
+        boolean hasTab = getLineContainsTab(line);
+        Directions directions = getLineDirections(line);
+
+        TabStops tabStops = null;
+        if (hasTab && mText instanceof Spanned) {
+            // Just checking this line should be good enough, tabs should be
+            // consistent across all lines in a paragraph.
+            TabStopSpan[] tabs = getParagraphSpans((Spanned) mText, start, end, TabStopSpan.class);
+            if (tabs.length > 0) {
+                tabStops = new TabStops(TAB_INCREMENT, tabs); // XXX should reuse
+            }
+        }
+
+        TextLine tl = TextLine.obtain();
+        tl.set(mPaint, mText, start, end, dir, directions, hasTab, tabStops);
+        boolean[] trailings = primaryIsTrailingPreviousAllLineOffsets(line);
+        if (!primary) {
+            for (int offset = 0; offset < trailings.length; ++offset) {
+                trailings[offset] = !trailings[offset];
+            }
+        }
+        float[] wid = tl.measureAllOffsets(trailings, null);
+        TextLine.recycle(tl);
+
+        if (clamped) {
+            for (int offset = 0; offset <= wid.length; ++offset) {
+                if (wid[offset] > mWidth) {
+                    wid[offset] = mWidth;
+                }
+            }
+        }
+        int left = getParagraphLeft(line);
+        int right = getParagraphRight(line);
+
+        int lineStartPos = getLineStartPos(line, left, right);
+        float[] horizontal = new float[end - start + 1];
+        for (int offset = 0; offset < horizontal.length; ++offset) {
+            horizontal[offset] = lineStartPos + wid[offset];
+        }
+        return horizontal;
+    }
+
     /**
      * Get the leftmost position that should be exposed for horizontal
      * scrolling on the specified line.
@@ -1167,6 +1282,8 @@ public abstract class Layout {
         // XXX: we don't care about tabs as we just use TextLine#getOffsetToLeftRightOf here.
         tl.set(mPaint, mText, lineStartOffset, lineEndOffset, getParagraphDirection(line), dirs,
                 false, null);
+        final HorizontalMeasurementProvider horizontal =
+                new HorizontalMeasurementProvider(line, primary);
 
         final int max;
         if (line == getLineCount() - 1) {
@@ -1176,7 +1293,7 @@ public abstract class Layout {
                     !isRtlCharAt(lineEndOffset - 1)) + lineStartOffset;
         }
         int best = lineStartOffset;
-        float bestdist = Math.abs(getHorizontal(best, primary) - horiz);
+        float bestdist = Math.abs(horizontal.get(lineStartOffset) - horiz);
 
         for (int i = 0; i < dirs.mDirections.length; i += 2) {
             int here = lineStartOffset + dirs.mDirections[i];
@@ -1192,7 +1309,7 @@ public abstract class Layout {
                 guess = (high + low) / 2;
                 int adguess = getOffsetAtStartOf(guess);
 
-                if (getHorizontal(adguess, primary) * swap >= horiz * swap)
+                if (horizontal.get(adguess) * swap >= horiz * swap)
                     high = guess;
                 else
                     low = guess;
@@ -1205,9 +1322,9 @@ public abstract class Layout {
                 int aft = tl.getOffsetToLeftRightOf(low - lineStartOffset, isRtl) + lineStartOffset;
                 low = tl.getOffsetToLeftRightOf(aft - lineStartOffset, !isRtl) + lineStartOffset;
                 if (low >= here && low < there) {
-                    float dist = Math.abs(getHorizontal(low, primary) - horiz);
+                    float dist = Math.abs(horizontal.get(low) - horiz);
                     if (aft < there) {
-                        float other = Math.abs(getHorizontal(aft, primary) - horiz);
+                        float other = Math.abs(horizontal.get(aft) - horiz);
 
                         if (other < dist) {
                             dist = other;
@@ -1222,7 +1339,7 @@ public abstract class Layout {
                 }
             }
 
-            float dist = Math.abs(getHorizontal(here, primary) - horiz);
+            float dist = Math.abs(horizontal.get(here) - horiz);
 
             if (dist < bestdist) {
                 bestdist = dist;
@@ -1230,7 +1347,7 @@ public abstract class Layout {
             }
         }
 
-        float dist = Math.abs(getHorizontal(max, primary) - horiz);
+        float dist = Math.abs(horizontal.get(max) - horiz);
 
         if (dist <= bestdist) {
             bestdist = dist;
@@ -1241,6 +1358,47 @@ public abstract class Layout {
         return best;
     }
 
+    /**
+     * Responds to #getHorizontal queries, by selecting the better strategy between:
+     * - calling #getHorizontal explicitly for each query
+     * - precomputing all #getHorizontal measurements, and responding to any query in constant time
+     * The first strategy is used for LTR-only text, while the second is used for all other cases.
+     * The class is currently only used in #getOffsetForHorizontal, so reuse with care in other
+     * contexts.
+     */
+    private class HorizontalMeasurementProvider {
+        private final int mLine;
+        private final boolean mPrimary;
+
+        private float[] mHorizontals;
+        private int mLineStartOffset;
+
+        HorizontalMeasurementProvider(final int line, final boolean primary) {
+            mLine = line;
+            mPrimary = primary;
+            init();
+        }
+
+        private void init() {
+            final Directions dirs = getLineDirections(mLine);
+            if (dirs == DIRS_ALL_LEFT_TO_RIGHT) {
+                return;
+            }
+
+            mHorizontals = getLineHorizontals(mLine, false, mPrimary);
+            mLineStartOffset = getLineStart(mLine);
+        }
+
+        float get(final int offset) {
+            if (mHorizontals == null || offset < mLineStartOffset
+                    || offset >= mLineStartOffset + mHorizontals.length) {
+                return getHorizontal(offset, mPrimary);
+            } else {
+                return mHorizontals[offset - mLineStartOffset];
+            }
+        }
+    }
+
     /**
      * Return the text offset after the last character on the specified line.
      */
diff --git a/core/java/android/text/TextLine.java b/core/java/android/text/TextLine.java
index 2a52961984f..79333563af1 100644
--- a/core/java/android/text/TextLine.java
+++ b/core/java/android/text/TextLine.java
@@ -338,6 +338,98 @@ class TextLine {
         return h;
     }
 
+    /**
+     * @see #measure(int, boolean, FontMetricsInt)
+     * @return The measure results for all possible offsets
+     */
+    float[] measureAllOffsets(boolean[] trailing, FontMetricsInt fmi) {
+        float[] measurement = new float[mLen + 1];
+
+        int[] target = new int[mLen + 1];
+        for (int offset = 0; offset < target.length; ++offset) {
+            target[offset] = trailing[offset] ? offset - 1 : offset;
+        }
+        if (target[0] < 0) {
+            measurement[0] = 0;
+        }
+
+        float h = 0;
+
+        if (!mHasTabs) {
+            if (mDirections == Layout.DIRS_ALL_LEFT_TO_RIGHT) {
+                for (int offset = 0; offset <= mLen; ++offset) {
+                    measurement[offset] = measureRun(0, offset, mLen, false, fmi);
+                }
+                return measurement;
+            }
+            if (mDirections == Layout.DIRS_ALL_RIGHT_TO_LEFT) {
+                for (int offset = 0; offset <= mLen; ++offset) {
+                    measurement[offset] = measureRun(0, offset, mLen, true, fmi);
+                }
+                return measurement;
+            }
+        }
+
+        char[] chars = mChars;
+        int[] runs = mDirections.mDirections;
+        for (int i = 0; i < runs.length; i += 2) {
+            int runStart = runs[i];
+            int runLimit = runStart + (runs[i + 1] & Layout.RUN_LENGTH_MASK);
+            if (runLimit > mLen) {
+                runLimit = mLen;
+            }
+            boolean runIsRtl = (runs[i + 1] & Layout.RUN_RTL_FLAG) != 0;
+
+            int segstart = runStart;
+            for (int j = mHasTabs ? runStart : runLimit; j <= runLimit; ++j) {
+                int codept = 0;
+                if (mHasTabs && j < runLimit) {
+                    codept = chars[j];
+                    if (codept >= 0xD800 && codept < 0xDC00 && j + 1 < runLimit) {
+                        codept = Character.codePointAt(chars, j);
+                        if (codept > 0xFFFF) {
+                            ++j;
+                            continue;
+                        }
+                    }
+                }
+
+                if (j == runLimit || codept == '\t') {
+                    float oldh = h;
+                    boolean advance = (mDir == Layout.DIR_RIGHT_TO_LEFT) == runIsRtl;
+                    float w = measureRun(segstart, j, j, runIsRtl, fmi);
+                    h += advance ? w : -w;
+
+                    float baseh = advance ? oldh : h;
+                    FontMetricsInt crtfmi = advance ? fmi : null;
+                    for (int offset = segstart; offset <= j && offset <= mLen; ++offset) {
+                        if (target[offset] >= segstart && target[offset] < j) {
+                            measurement[offset] =
+                                    baseh + measureRun(segstart, offset, j, runIsRtl, crtfmi);
+                        }
+                    }
+
+                    if (codept == '\t') {
+                        if (target[j] == j) {
+                            measurement[j] = h;
+                        }
+                        h = mDir * nextTab(h * mDir);
+                        if (target[j + 1] == j) {
+                            measurement[j + 1] =  h;
+                        }
+                    }
+
+                    segstart = j + 1;
+                }
+            }
+        }
+        if (target[mLen] == mLen) {
+            measurement[mLen] = h;
+        }
+
+        return measurement;
+    }
+
     /**
      * Draws a unidirectional (but possibly multi-styled) run of text.
      *
diff --git a/core/java/android/text/util/Linkify.java b/core/java/android/text/util/Linkify.java
index ca037a229b0..51ef650c000 100644
--- a/core/java/android/text/util/Linkify.java
+++ b/core/java/android/text/util/Linkify.java
@@ -23,6 +23,7 @@ import android.telephony.PhoneNumberUtils;
 import android.text.method.LinkMovementMethod;
 import android.text.method.MovementMethod;
 import android.text.style.URLSpan;
+import android.util.Log;
 import android.text.Spannable;
 import android.text.SpannableString;
 import android.text.Spanned;
@@ -65,6 +66,9 @@ import libcore.util.EmptyArray;
  */
 
 public class Linkify {
+
+    private static final String LOG_TAG = "Linkify";
+
     /**
      *  Bit field indicating that web URLs should be matched in methods that
      *  take an options mask
@@ -222,6 +226,11 @@ public class Linkify {
      *  @return True if at least one link is found and applied.
      */
     public static final boolean addLinks(@NonNull Spannable text, @LinkifyMask int mask) {
+        if (text != null && containsUnsupportedCharacters(text.toString())) {
+            android.util.EventLog.writeEvent(0x534e4554, "116321860", -1, "");
+            return false;
+        }
+
         if (mask == 0) {
             return false;
         }
@@ -267,6 +276,29 @@ public class Linkify {
         return true;
     }
 
+    /**
+     * Returns true if the specified text contains at least one unsupported character for applying
+     * links. Also logs the error.
+     *
+     * @param text the text to apply links to
+     * @hide
+     */
+    public static boolean containsUnsupportedCharacters(String text) {
+        if (text.contains("\u202C")) {
+            Log.e(LOG_TAG, "Unsupported character for applying links: u202C");
+            return true;
+        }
+        if (text.contains("\u202D")) {
+            Log.e(LOG_TAG, "Unsupported character for applying links: u202D");
+            return true;
+        }
+        if (text.contains("\u202E")) {
+            Log.e(LOG_TAG, "Unsupported character for applying links: u202E");
+            return true;
+        }
+        return false;
+    }
+
     /**
      *  Scans the text of the provided TextView and turns all occurrences of
      *  the link types indicated in the mask into clickable links.  If matches
@@ -437,6 +469,11 @@ public class Linkify {
     public static final boolean addLinks(@NonNull Spannable spannable, @NonNull Pattern pattern,
             @Nullable  String defaultScheme, @Nullable String[] schemes,
             @Nullable MatchFilter matchFilter, @Nullable TransformFilter transformFilter) {
+        if (spannable != null && containsUnsupportedCharacters(spannable.toString())) {
+            android.util.EventLog.writeEvent(0x534e4554, "116321860", -1, "");
+            return false;
+        }
+
         final String[] schemesCopy;
         if (defaultScheme == null) defaultScheme = "";
         if (schemes == null || schemes.length < 1) {
diff --git a/core/java/android/view/WindowManager.java b/core/java/android/view/WindowManager.java
index 395f73844b0..169f7e170dd 100644
--- a/core/java/android/view/WindowManager.java
+++ b/core/java/android/view/WindowManager.java
@@ -655,6 +655,25 @@ public interface WindowManager extends ViewManager {
          */
         public static final int LAST_SYSTEM_WINDOW      = 2999;
 
+        /**
+         * Return true if the window type is an alert window.
+         *
+         * @param type The window type.
+         * @return If the window type is an alert window.
+         * @hide
+         */
+        public static boolean isSystemAlertWindowType(int type) {
+            switch (type) {
+                case TYPE_PHONE:
+                case TYPE_PRIORITY_PHONE:
+                case TYPE_SYSTEM_ALERT:
+                case TYPE_SYSTEM_ERROR:
+                case TYPE_SYSTEM_OVERLAY:
+                    return true;
+            }
+            return false;
+        }
+
         /** @deprecated this is ignored, this value is set automatically when needed. */
         @Deprecated
         public static final int MEMORY_TYPE_NORMAL = 0;
@@ -1262,6 +1281,15 @@ public interface WindowManager extends ViewManager {
          */
         public static final int PRIVATE_FLAG_SUSTAINED_PERFORMANCE_MODE = 0x00040000;
 
+        /**
+         * Flag to indicate that any window added by an application process that is of type
+         * {@link #TYPE_TOAST} or that requires
+         * {@link android.app.AppOpsManager#OP_SYSTEM_ALERT_WINDOW} permission should be hidden when
+         * this window is visible.
+         * @hide
+         */
+        public static final int PRIVATE_FLAG_HIDE_NON_SYSTEM_OVERLAY_WINDOWS = 0x00080000;
+
         /**
          * Control flags that are private to the platform.
          * @hide
diff --git a/core/java/android/view/WindowManagerPolicy.java b/core/java/android/view/WindowManagerPolicy.java
index 46a0194b1b0..ecc9025774a 100644
--- a/core/java/android/view/WindowManagerPolicy.java
+++ b/core/java/android/view/WindowManagerPolicy.java
@@ -1099,6 +1099,13 @@ public interface WindowManagerPolicy {
      */
     public void notifyCameraLensCoverSwitchChanged(long whenNanos, boolean lensCovered);
 
+    /**
+     * Tell the policy that the rotation lock switch has changed state.
+     * @param whenNanos The time when the change occurred in uptime nanoseconds.
+     * @param isLocked True if the rotation is now locked.
+     */
+    public void notifyRotateLockSwitchChanged(long whenNanos, boolean isLocked);
+
     /**
      * Tell the policy if anyone is requesting that keyguard not come on.
      *
diff --git a/core/java/com/android/internal/app/ChooserActivity.java b/core/java/com/android/internal/app/ChooserActivity.java
index a5b2a9194fd..cdf83d3f728 100644
--- a/core/java/com/android/internal/app/ChooserActivity.java
+++ b/core/java/com/android/internal/app/ChooserActivity.java
@@ -83,7 +83,7 @@ public class ChooserActivity extends ResolverActivity {
 
     private static final boolean DEBUG = false;
 
-    private static final int QUERY_TARGET_SERVICE_LIMIT = 5;
+    private static final int QUERY_TARGET_SERVICE_LIMIT = 3;
     private static final int WATCHDOG_TIMEOUT_MILLIS = 5000;
 
     private Bundle mReplacementExtras;
@@ -799,8 +799,8 @@ public class ChooserActivity extends ResolverActivity {
         public static final int TARGET_SERVICE = 1;
         public static final int TARGET_STANDARD = 2;
 
-        private static final int MAX_SERVICE_TARGETS = 8;
-        private static final int MAX_TARGETS_PER_SERVICE = 4;
+        private static final int MAX_SERVICE_TARGETS = 4;
+        private static final int MAX_TARGETS_PER_SERVICE = 2;
 
         private final List<ChooserTargetInfo> mServiceTargets = new ArrayList<>();
         private final List<TargetInfo> mCallerTargets = new ArrayList<>();
diff --git a/core/java/com/android/internal/app/procstats/ProcessState.java b/core/java/com/android/internal/app/procstats/ProcessState.java
index 8c5df08f549..8c2c2362f99 100644
--- a/core/java/com/android/internal/app/procstats/ProcessState.java
+++ b/core/java/com/android/internal/app/procstats/ProcessState.java
@@ -379,7 +379,7 @@ public final class ProcessState {
 
     public void setState(int state, long now) {
         ensureNotDead();
-        if (mCurState != state) {
+        if (!mDead && (mCurState != state)) {
             //Slog.i(TAG, "Setting state in " + mName + "/" + mPackage + ": " + state);
             commitStateTime(now);
             mCurState = state;
diff --git a/core/java/com/android/internal/app/procstats/SparseMappingTable.java b/core/java/com/android/internal/app/procstats/SparseMappingTable.java
index f941836d2c0..6d79d3bd32a 100644
--- a/core/java/com/android/internal/app/procstats/SparseMappingTable.java
+++ b/core/java/com/android/internal/app/procstats/SparseMappingTable.java
@@ -18,6 +18,7 @@ package com.android.internal.app.procstats;
 
 import android.os.Build;
 import android.os.Parcel;
+import android.util.EventLog;
 import android.util.Slog;
 import libcore.util.EmptyArray;
 
@@ -529,6 +530,12 @@ public class SparseMappingTable {
             readCompactedLongArray(in, array, size);
             mLongs.add(array);
         }
+        // Verify that last array's length is consistent with writeToParcel
+        if (N > 0 && mLongs.get(N - 1).length != mNextIndex) {
+            EventLog.writeEvent(0x534e4554, "73252178", -1, "");
+            throw new IllegalStateException("Expected array of length " + mNextIndex + " but was "
+                    + mLongs.get(N - 1).length);
+        }
     }
 
     /**
diff --git a/core/java/com/android/internal/os/ZygoteInit.java b/core/java/com/android/internal/os/ZygoteInit.java
index e4f573b7b8a..0d3f50cb93b 100644
--- a/core/java/com/android/internal/os/ZygoteInit.java
+++ b/core/java/com/android/internal/os/ZygoteInit.java
@@ -245,8 +245,8 @@ public class ZygoteInit {
 
     private static void preloadOpenGL() {
         String driverPackageName = SystemProperties.get(PROPERTY_GFX_DRIVER);
-        if (!SystemProperties.getBoolean(PROPERTY_DISABLE_OPENGL_PRELOADING, false) ||
-                driverPackageName == null || driverPackageName.isEmpty()) {
+        if (!SystemProperties.getBoolean(PROPERTY_DISABLE_OPENGL_PRELOADING, false) &&
+                (driverPackageName == null || driverPackageName.isEmpty())) {
             EGL14.eglGetDisplay(EGL14.EGL_DEFAULT_DISPLAY);
         }
     }
diff --git a/core/java/com/android/internal/widget/VerifyCredentialResponse.java b/core/java/com/android/internal/widget/VerifyCredentialResponse.java
index 48109ca347a..c4d91e021af 100644
--- a/core/java/com/android/internal/widget/VerifyCredentialResponse.java
+++ b/core/java/com/android/internal/widget/VerifyCredentialResponse.java
@@ -95,6 +95,8 @@ public final class VerifyCredentialResponse implements Parcelable {
             if (mPayload != null) {
                 dest.writeInt(mPayload.length);
                 dest.writeByteArray(mPayload);
+            } else {
+                dest.writeInt(0);
             }
         }
     }
diff --git a/core/java/com/android/internal/widget/ViewPager.java b/core/java/com/android/internal/widget/ViewPager.java
index d5b6def9742..df1ed7d392b 100644
--- a/core/java/com/android/internal/widget/ViewPager.java
+++ b/core/java/com/android/internal/widget/ViewPager.java
@@ -31,6 +31,7 @@ import android.os.Parcelable;
 import android.util.AttributeSet;
 import android.util.Log;
 import android.util.MathUtils;
+import android.view.AbsSavedState;
 import android.view.FocusFinder;
 import android.view.Gravity;
 import android.view.KeyEvent;
@@ -1198,15 +1199,11 @@ public class ViewPager extends ViewGroup {
      * state, in which case it should implement a subclass of this which
      * contains that state.
      */
-    public static class SavedState extends BaseSavedState {
+    public static class SavedState extends AbsSavedState {
         int position;
         Parcelable adapterState;
         ClassLoader loader;
 
-        public SavedState(Parcel source) {
-            super(source);
-        }
-
         public SavedState(Parcelable superState) {
             super(superState);
         }
@@ -1225,10 +1222,15 @@ public class ViewPager extends ViewGroup {
                     + " position=" + position + "}";
         }
 
-        public static final Creator<SavedState> CREATOR = new Creator<SavedState>() {
+        public static final Creator<SavedState> CREATOR = new ClassLoaderCreator<SavedState>() {
+            @Override
+            public SavedState createFromParcel(Parcel in, ClassLoader loader) {
+                return new SavedState(in, loader);
+            }
+
             @Override
             public SavedState createFromParcel(Parcel in) {
-                return new SavedState(in);
+                return new SavedState(in, null);
             }
             @Override
             public SavedState[] newArray(int size) {
@@ -1237,7 +1239,7 @@ public class ViewPager extends ViewGroup {
         };
 
         SavedState(Parcel in, ClassLoader loader) {
-            super(in);
+            super(in, loader);
             if (loader == null) {
                 loader = getClass().getClassLoader();
             }
diff --git a/core/jni/android/graphics/Bitmap.cpp b/core/jni/android/graphics/Bitmap.cpp
index 72755ce105c..3e6fe3f38a5 100755
--- a/core/jni/android/graphics/Bitmap.cpp
+++ b/core/jni/android/graphics/Bitmap.cpp
@@ -725,6 +725,8 @@ static jobject Bitmap_creator(JNIEnv* env, jobject, jintArray jColors,
 
     Bitmap* nativeBitmap = GraphicsJNI::allocateJavaPixelRef(env, &bitmap, NULL);
     if (!nativeBitmap) {
+        ALOGE("OOM allocating Bitmap with dimensions %i x %i", width, height);
+        doThrowOOME(env);
         return NULL;
     }
 
diff --git a/core/jni/android/graphics/BitmapFactory.cpp b/core/jni/android/graphics/BitmapFactory.cpp
index 4001283c4c6..0a143610ebd 100644
--- a/core/jni/android/graphics/BitmapFactory.cpp
+++ b/core/jni/android/graphics/BitmapFactory.cpp
@@ -587,8 +587,7 @@ static jobject nativeDecodeFileDescriptor(JNIEnv* env, jobject clazz, jobject fi
         return nullObjectReturn("Could not open file");
     }
 
-    std::unique_ptr<SkFILEStream> fileStream(new SkFILEStream(file,
-            SkFILEStream::kCallerPasses_Ownership));
+    std::unique_ptr<SkFILEStream> fileStream(new SkFILEStream(file));
 
     // If there is no offset for the file descriptor, we use SkFILEStream directly.
     if (::lseek(descriptor, 0, SEEK_CUR) == 0) {
diff --git a/core/jni/android_util_Binder.cpp b/core/jni/android_util_Binder.cpp
index 5559d48a58b..bee11dbe600 100644
--- a/core/jni/android_util_Binder.cpp
+++ b/core/jni/android_util_Binder.cpp
@@ -132,6 +132,14 @@ static struct strict_mode_callback_offsets_t
     jmethodID mCallback;
 } gStrictModeCallbackOffsets;
 
+static struct thread_dispatch_offsets_t
+{
+    // Class state.
+    jclass mClass;
+    jmethodID mDispatchUncaughtException;
+    jmethodID mCurrentThread;
+} gThreadDispatchOffsets;
+
 // ****************************************************************************
 // ****************************************************************************
 // ****************************************************************************
@@ -165,6 +173,23 @@ static JNIEnv* javavm_to_jnienv(JavaVM* vm)
     return vm->GetEnv((void **)&env, JNI_VERSION_1_4) >= 0 ? env : NULL;
 }
 
+// Report a java.lang.Error (or subclass). This may terminate the runtime.
+static void report_java_lang_error(JNIEnv* env, jthrowable error)
+{
+    // Try to run the uncaught exception machinery.
+    jobject thread = env->CallStaticObjectMethod(gThreadDispatchOffsets.mClass,
+            gThreadDispatchOffsets.mCurrentThread);
+    if (thread != nullptr) {
+        env->CallVoidMethod(thread, gThreadDispatchOffsets.mDispatchUncaughtException,
+                error);
+        // Should not return here, unless more errors occured.
+    }
+    // Some error occurred that meant that either dispatchUncaughtException could not be
+    // called or that it had an error itself (as this should be unreachable under normal
+    // conditions). Clear the exception.
+    env->ExceptionClear();
+}
+
 static void report_exception(JNIEnv* env, jthrowable excep, const char* msg)
 {
     env->ExceptionClear();
@@ -191,6 +216,10 @@ static void report_exception(JNIEnv* env, jthrowable excep, const char* msg)
     }
 
     if (env->IsInstanceOf(excep, gErrorOffsets.mClass)) {
+        // Try to report the error. This should not return under normal circumstances.
+        report_java_lang_error(env, excep);
+        // The traditional handling: re-raise and abort.
+
         /*
          * It's an Error: Reraise the exception, detach this thread, and
          * wait for the fireworks. Die even more blatantly after a minute
@@ -1318,5 +1347,12 @@ int register_android_os_Binder(JNIEnv* env)
     gStrictModeCallbackOffsets.mCallback = GetStaticMethodIDOrDie(env, clazz,
             "onBinderStrictModePolicyChange", "(I)V");
 
+    clazz = FindClassOrDie(env, "java/lang/Thread");
+    gThreadDispatchOffsets.mClass = MakeGlobalRefOrDie(env, clazz);
+    gThreadDispatchOffsets.mDispatchUncaughtException = GetMethodIDOrDie(env, clazz,
+            "dispatchUncaughtException", "(Ljava/lang/Throwable;)V");
+    gThreadDispatchOffsets.mCurrentThread = GetStaticMethodIDOrDie(env, clazz, "currentThread",
+            "()Ljava/lang/Thread;");
+
     return 0;
 }
diff --git a/core/res/AndroidManifest.xml b/core/res/AndroidManifest.xml
index 011884cb549..8403e80ae31 100644
--- a/core/res/AndroidManifest.xml
+++ b/core/res/AndroidManifest.xml
@@ -1223,6 +1223,13 @@
     <permission android:name="android.permission.SCORE_NETWORKS"
         android:protectionLevel="signature|privileged" />
 
+    <!-- Allows network stack services (Connectivity and Wifi) to coordinate
+         <p>Not for use by third-party or privileged applications.
+         @hide This should only be used by Connectivity and Wifi Services.
+    -->
+    <permission android:name="android.permission.NETWORK_STACK"
+        android:protectionLevel="signature" />
+
     <!-- ======================================= -->
     <!-- Permissions for short range, peripheral networks -->
     <!-- ======================================= -->
@@ -2154,6 +2161,15 @@
     <permission android:name="android.permission.INTERNAL_SYSTEM_WINDOW"
         android:protectionLevel="signature" />
 
+    <!-- @SystemApi Allows an application to use
+        {@link android.view.WindowManager.LayoutsParams#PRIVATE_FLAG_HIDE_NON_SYSTEM_OVERLAY_WINDOWS}
+        to hide non-system-overlay windows.
+        <p>Not for use by third-party applications.
+        @hide
+    -->
+    <permission android:name="android.permission.HIDE_NON_SYSTEM_OVERLAY_WINDOWS"
+        android:protectionLevel="signature|installer" />
+
     <!-- @SystemApi Allows an application to manage (create, destroy,
          Z-order) application tokens in the window manager.
          <p>Not for use by third-party applications.
diff --git a/core/res/res/drawable-sw600dp-nodpi/default_wallpaper.png b/core/res/res/drawable-sw600dp-nodpi/default_wallpaper.png
index af8e2512385..52af11d8f5a 100644
Binary files a/core/res/res/drawable-sw600dp-nodpi/default_wallpaper.png and b/core/res/res/drawable-sw600dp-nodpi/default_wallpaper.png differ
diff --git a/core/res/res/drawable-sw720dp-nodpi/default_wallpaper.png b/core/res/res/drawable-sw720dp-nodpi/default_wallpaper.png
index cb00d82a826..e3e66721c86 100644
Binary files a/core/res/res/drawable-sw720dp-nodpi/default_wallpaper.png and b/core/res/res/drawable-sw720dp-nodpi/default_wallpaper.png differ
diff --git a/core/res/res/values-mcc302-mnc220/config.xml b/core/res/res/values-mcc302-mnc220/config.xml
index 422f7c92648..e6ddadc37cc 100644
--- a/core/res/res/values-mcc302-mnc220/config.xml
+++ b/core/res/res/values-mcc302-mnc220/config.xml
@@ -50,7 +50,7 @@
         <item>ERR_ESTIMATE=0</item>
         <item>INTERMEDIATE_POS=0</item>
         <item>GPS_LOCK=0</item>
-        <item>SUPL_ES=0</item>
+        <item>SUPL_ES=1</item>
     </string-array>
 
 </resources>
diff --git a/core/res/res/values-mcc302-mnc221/config.xml b/core/res/res/values-mcc302-mnc221/config.xml
index 14442500757..0f01f537902 100644
--- a/core/res/res/values-mcc302-mnc221/config.xml
+++ b/core/res/res/values-mcc302-mnc221/config.xml
@@ -48,7 +48,7 @@
         <item>ERR_ESTIMATE=0</item>
         <item>INTERMEDIATE_POS=0</item>
         <item>GPS_LOCK=0</item>
-        <item>SUPL_ES=0</item>
+        <item>SUPL_ES=1</item>
     </string-array>
 
 </resources>
diff --git a/core/res/res/values-mcc302-mnc370/config.xml b/core/res/res/values-mcc302-mnc370/config.xml
index 05265c7fcd7..9231691db58 100644
--- a/core/res/res/values-mcc302-mnc370/config.xml
+++ b/core/res/res/values-mcc302-mnc370/config.xml
@@ -59,7 +59,7 @@
         <item>ERR_ESTIMATE=0</item>
         <item>INTERMEDIATE_POS=0</item>
         <item>GPS_LOCK=0</item>
-        <item>SUPL_ES=0</item>
+        <item>SUPL_ES=1</item>
     </string-array>
 
 </resources>
diff --git a/core/res/res/values-mcc302-mnc610/config.xml b/core/res/res/values-mcc302-mnc610/config.xml
index 0af2c39e786..b85da2bf047 100644
--- a/core/res/res/values-mcc302-mnc610/config.xml
+++ b/core/res/res/values-mcc302-mnc610/config.xml
@@ -43,6 +43,6 @@
         <item>ERR_ESTIMATE=0</item>
         <item>INTERMEDIATE_POS=0</item>
         <item>GPS_LOCK=0</item>
-        <item>SUPL_ES=0</item>
+        <item>SUPL_ES=1</item>
     </string-array>
 </resources>
diff --git a/core/res/res/values-mcc302-mnc640/config.xml b/core/res/res/values-mcc302-mnc640/config.xml
index e005bc00a27..0454c580442 100644
--- a/core/res/res/values-mcc302-mnc640/config.xml
+++ b/core/res/res/values-mcc302-mnc640/config.xml
@@ -39,6 +39,6 @@
         <item>ERR_ESTIMATE=0</item>
         <item>INTERMEDIATE_POS=0</item>
         <item>GPS_LOCK=0</item>
-        <item>SUPL_ES=0</item>
+        <item>SUPL_ES=1</item>
     </string-array>
 </resources>
diff --git a/core/res/res/values-mcc302-mnc720/config.xml b/core/res/res/values-mcc302-mnc720/config.xml
index 7a3540aa3bd..eef85e18e8d 100644
--- a/core/res/res/values-mcc302-mnc720/config.xml
+++ b/core/res/res/values-mcc302-mnc720/config.xml
@@ -61,7 +61,7 @@
         <item>ERR_ESTIMATE=0</item>
         <item>INTERMEDIATE_POS=0</item>
         <item>GPS_LOCK=0</item>
-        <item>SUPL_ES=0</item>
+        <item>SUPL_ES=1</item>
     </string-array>
 
 </resources>
diff --git a/core/res/res/values-mcc310-mnc490-fr/strings.xml b/core/res/res/values-mcc310-mnc490-fr/strings.xml
deleted file mode 100644
index 33e0c97b2fb..00000000000
--- a/core/res/res/values-mcc310-mnc490-fr/strings.xml
+++ /dev/null
@@ -1,32 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<!-- 
-/*
-** Copyright 2016, The Android Open Source Project
-**
-** Licensed under the Apache License, Version 2.0 (the "License");
-** you may not use this file except in compliance with the License.
-** You my obtain a copy of the License at
-**
-**     http://www.apache.org/licenses/LICENSE-2.0
-**
-** Unless required by applicable law or agreed to in writing, software
-** distributed under the License is distributed on an "AS IS" BASIS,
-** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-** See the License for the specific language governing permissions and
-** limitations under the License.
-*/
- -->
-
-<!--  These resources are around just to allow their values to be customized
-     for different hardware and product builds.  -->
-
-<resources xmlns:android="http://schemas.android.com/apk/res/android"
-    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
-  <string-array name="wfcOperatorErrorAlertMessages">
-    <item msgid="2780619740658228275">"Pour passer des appels et envoyer des messages via le Wi-Fi, demandez d\'abord à votre opérateur de configurer ce service. Ensuite, réactivez les appels Wi-Fi dans les paramètres."</item>
-  </string-array>
-  <string-array name="wfcOperatorErrorNotificationMessages">
-    <item msgid="4633656294483906293">"Inscrivez-vous auprès de votre opérateur."</item>
-  </string-array>
-    <string name="wfcSpnFormat" msgid="1518868466785799436">"Appels Wi-Fi %s"</string>
-</resources>
diff --git a/core/res/res/values/config.xml b/core/res/res/values/config.xml
index 7baed78a51b..bf421043bc2 100644
--- a/core/res/res/values/config.xml
+++ b/core/res/res/values/config.xml
@@ -2325,6 +2325,7 @@
         <item>NTP_SERVER=north-america.pool.ntp.org</item>
         <item>SUPL_VER=0x20000</item>
         <item>SUPL_MODE=1</item>
+        <item>SUPL_ES=1</item>
     </string-array>
 
     <!-- If there is no preload VM number in the sim card, carriers such as
@@ -2710,4 +2711,10 @@
          is installed. -->
     <bool name="config_permissionReviewRequired">false</bool>
 
+    <!-- Older rotation sensors are not setting event.timestamp correctly. Setting to
+         true will use SystemClock.elapsedRealtimeNanos() to set timestamp. -->
+    <bool name="config_useSystemClockforRotationSensor">false</bool>
+
+    <!-- Whether to enable HumanInteractionController by default -->
+    <bool name="config_HICEnabledDefault">true</bool>
 </resources>
diff --git a/core/res/res/values/symbols.xml b/core/res/res/values/symbols.xml
index 08ac0436d63..82a2ff12d5d 100644
--- a/core/res/res/values/symbols.xml
+++ b/core/res/res/values/symbols.xml
@@ -2749,4 +2749,8 @@
   <java-symbol type="bool" name="use_lock_pattern_drawable" />
   <java-symbol type="drawable" name="lockscreen_notselected" />
   <java-symbol type="drawable" name="lockscreen_selected" />
+
+  <java-symbol type="bool" name="config_useSystemClockforRotationSensor" />
+  <!-- Whether to enable HumanInteractionController by default -->
+  <java-symbol type="bool" name="config_HICEnabledDefault" />
 </resources>
diff --git a/core/res/res/xml/config_webview_packages.xml b/core/res/res/xml/config_webview_packages.xml
index f062b59a008..574f7c15fc2 100644
--- a/core/res/res/xml/config_webview_packages.xml
+++ b/core/res/res/xml/config_webview_packages.xml
@@ -15,7 +15,22 @@
 -->
 
 <webviewproviders>
-    <!-- The default WebView implementation -->
-    <webviewprovider description="Android WebView" packageName="com.android.webview" availableByDefault="true">
+
+    <webviewprovider description="Chrome Stable" packageName="com.android.chrome" availableByDefault="true">
+        <signature>MIIEQzCCAyugAwIBAgIJAMLgh0ZkSjCNMA0GCSqGSIb3DQEBBAUAMHQxCzAJBgNVBAYTAlVTMRMwEQYDVQQIEwpDYWxpZm9ybmlhMRYwFAYDVQQHEw1Nb3VudGFpbiBWaWV3MRQwEgYDVQQKEwtHb29nbGUgSW5jLjEQMA4GA1UECxMHQW5kcm9pZDEQMA4GA1UEAxMHQW5kcm9pZDAeFw0wODA4MjEyMzEzMzRaFw0zNjAxMDcyMzEzMzRaMHQxCzAJBgNVBAYTAlVTMRMwEQYDVQQIEwpDYWxpZm9ybmlhMRYwFAYDVQQHEw1Nb3VudGFpbiBWaWV3MRQwEgYDVQQKEwtHb29nbGUgSW5jLjEQMA4GA1UECxMHQW5kcm9pZDEQMA4GA1UEAxMHQW5kcm9pZDCCASAwDQYJKoZIhvcNAQEBBQADggENADCCAQgCggEBAKtWLgDYO6IIrgqWbxJOKdoR8qtW0I9Y4sypEwPpt1TTcvZApxsdyxMJZ2JORland2qSGT2y5b+3JKkedxiLDmpHpDsz2WCbdxgxRczfey5YZnTJ4VZbH0xqWVW/8lGmPav5xVwnIiJS6HXk+BVKZF+JcWjAsb/GEuq/eFdpuzSqeYTcfi6idkyugwfYwXFU1+5fZKUaRKYCwkkFQVfcAs1fXA5V+++FGfvjJ/CxURaSxaBvGdGDhfXE28LWuT9ozCl5xw4Yq5OGazvV24mZVSoOO0yZ31j7kYvtwYK6NeADwbSxDdJEqO4k//0zOHKrUiGYXtqw/A0LFFtqoZKFjnkCAQOjgdkwgdYwHQYDVR0OBBYEFMd9jMIhF1Ylmn/Tgt9r45jk14alMIGmBgNVHSMEgZ4wgZuAFMd9jMIhF1Ylmn/Tgt9r45jk14aloXikdjB0MQswCQYDVQQGEwJVUzETMBEGA1UECBMKQ2FsaWZvcm5pYTEWMBQGA1UEBxMNTW91bnRhaW4gVmlldzEUMBIGA1UEChMLR29vZ2xlIEluYy4xEDAOBgNVBAsTB0FuZHJvaWQxEDAOBgNVBAMTB0FuZHJvaWSCCQDC4IdGZEowjTAMBgNVHRMEBTADAQH/MA0GCSqGSIb3DQEBBAUAA4IBAQBt0lLO74UwLDYKqs6Tm8/yzKkEu116FmH4rkaymUIE0P9KaMftGlMexFlaYjzmB2OxZyl6euNXEsQH8gjwyxCUKRJNexBiGcCEyj6z+a1fuHHvkiaai+KL8W1EyNmgjmyy8AW7P+LLlkR+ho5zEHatRbM/YAnqGcFh5iZBqpknHf1SKMXFh4dd239FJ1jWYfbMDMy3NS5CTMQ2XFI1MvcyUTdZPErjQfTbQe3aDQsQcafEQPD+nqActifKZ0Np0IS9L9kR/wbNvyz6ENwPiTrjV2KRkEjH78ZMcUQXg0L3BYHJ3lc69Vs5Ddf9uUGGMYldX3WfMBEmh/9iFBDAaTCK</signature>
+    </webviewprovider>
+    <webviewprovider description="Chrome Beta" packageName="com.chrome.beta">
+        <signature>MIIDwzCCAqugAwIBAgIJAOoj9MXoVhH6MA0GCSqGSIb3DQEBBQUAMHgxCzAJBgNVBAYTAlVTMRMwEQYDVQQIDApDYWxpZm9ybmlhMRYwFAYDVQQHDA1Nb3VudGFpbiBWaWV3MRQwEgYDVQQKDAtHb29nbGUgSW5jLjEQMA4GA1UECwwHQW5kcm9pZDEUMBIGA1UEAwwLY2hyb21lX2JldGEwHhcNMTYwMjI5MTUxNTIzWhcNNDMwNzE3MTUxNTIzWjB4MQswCQYDVQQGEwJVUzETMBEGA1UECAwKQ2FsaWZvcm5pYTEWMBQGA1UEBwwNTW91bnRhaW4gVmlldzEUMBIGA1UECgwLR29vZ2xlIEluYy4xEDAOBgNVBAsMB0FuZHJvaWQxFDASBgNVBAMMC2Nocm9tZV9iZXRhMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAo/wW27nRxVqGbFOyXr8jtv2pc2Ke8XMr6Sfs+3JK2licVaAljGFpLtWH4wUdb50w/QQSPALNLSSyuK/94rtp5Jjs4RSJI+whuewV/R6El+mFXBO3Ek5/op4UrOsR91IM4emvS67Ji2u8gp5EmttVgJtllFZCbtZLPmKuTaOkOB+EdWIxrYiHVEEaAcQpEHa9UgWUZ0bMfPj8j3F0w+Ak2ttmTjoFGLaZjuBAYwfdctN1b0sdLT9Lif45kMCb8QwPp0F9/ozs0rrTc+I6vnTS8kfFQfk7GIE4Hgm+cYQEHkIA6gLJxUVWvPZGdulAZw7wPt/neOkazHNZPcV4pYuNLQIDAQABo1AwTjAdBgNVHQ4EFgQU5t7dhcZfOSixRsiJ1E46JhzPlwowHwYDVR0jBBgwFoAU5t7dhcZfOSixRsiJ1E46JhzPlwowDAYDVR0TBAUwAwEB/zANBgkqhkiG9w0BAQUFAAOCAQEAZO2jB8P1d8ki3KZILvp27a2VM3DInlp8I8UgG3gh7nBQfTrnZr5M1PL8eFHqX7MEvAiGCMTcrPklEhjtcHK/c7BcdeCWq6oL56UK3JTl33RxJcjmjrz3e3VI6ehRSm1feNAkMD0Nr2RWr2LCYheAEmwTPtluLOJS+i7WhnXJzBtg5UpUFEbdFYenqUbDzya+cUVp0197k7hUTs8/Hxs0wf79o/TZXzTBq9eYQkiITonRN8+5QCBl1XmZKV0IHkzGFES1RP+fTiZpIjZT+W4tasHgs9QTTks4CCpyHBAy+uy7tApe1AxCzihgecCfUN1hWIltKwGZS6EE0bu0OXPzaQ==</signature>
+    </webviewprovider>
+    <webviewprovider description="Chrome Dev" packageName="com.chrome.dev">
+        <signature>MIIDwTCCAqmgAwIBAgIJAOSN+O0cdii5MA0GCSqGSIb3DQEBBQUAMHcxCzAJBgNVBAYTAlVTMRMwEQYDVQQIDApDYWxpZm9ybmlhMRYwFAYDVQQHDA1Nb3VudGFpbiBWaWV3MRQwEgYDVQQKDAtHb29nbGUgSW5jLjEQMA4GA1UECwwHQW5kcm9pZDETMBEGA1UEAwwKY2hyb21lX2RldjAeFw0xNjAyMjkxNzUwMDdaFw00MzA3MTcxNzUwMDdaMHcxCzAJBgNVBAYTAlVTMRMwEQYDVQQIDApDYWxpZm9ybmlhMRYwFAYDVQQHDA1Nb3VudGFpbiBWaWV3MRQwEgYDVQQKDAtHb29nbGUgSW5jLjEQMA4GA1UECwwHQW5kcm9pZDETMBEGA1UEAwwKY2hyb21lX2RldjCCASIwDQYJKoZIhvcNAQEBBQADggEPADCCAQoCggEBANOYPj6Y9rVt8xizSHDYjDEkDfFZAgSiZ9T6tevkQXsFyfaq3Gk3h2qssi29G6cTPJ2VXFKlVB71wSXv5p9/LEcDQPWQiO3Q2cLmgUXxyhJWXI3g96tPAhZQX2q6SC37ZQdiBR/raMO70DAkvCyBGtNplsvutzSE3oZ7LYfzB8vTbe7zCh3fDYSS/7xb3ZVvFqydHS40uVq1qqg1S80Pge7tW3pDGsPMZN7yA4yfmsvA1rbHm9N8t3Rc9hqzh6OxNAAgRB535YcsWL7iF+mpdFILXk3jLYT0nMvMnB83rsdgnRREjlGQYHl2mh8+6CqujsW/eICDq/LR6BYDyqHhk0ECAwEAAaNQME4wHQYDVR0OBBYEFKzsl07JglgpbeYDYGqsgqRDo+01MB8GA1UdIwQYMBaAFKzsl07JglgpbeYDYGqsgqRDo+01MAwGA1UdEwQFMAMBAf8wDQYJKoZIhvcNAQEFBQADggEBACka6SFF6xAcj8L8O6R36++E09DTiGZEjvKT8eIycgcQQ+p1WUmPb6M2EJpN6zvvSE62ussmXdzf8rIyc0JXA8jbViZt62Y39epNENFxPTLN9QzXlT+w8AW73Ka3cnbOuL5EgoDl8fM79WVlARY3X+wB/jGNrkiGIdRm2IZIeAodWgC2mtXMiferyYBKz2/F2bhnU6DwgCbegS8trFjEWviijWdJ+lBdobn7LRc3orZCtHl8UyvRDi7cye3sK9y3BM39k0g20F21wTNHAonnvL6zbuNgpd+UEsVxDpOeWrEdBFN7Md0CI2wnu8eA8ljJD45v0WWMEoxsIi131g5piNM=</signature>
+    </webviewprovider>
+    <webviewprovider description="Chrome Canary" packageName="com.chrome.canary">
+        <signature>MIIDxzCCAq+gAwIBAgIJAML7APITsgV7MA0GCSqGSIb3DQEBBQUAMHoxCzAJBgNVBAYTAlVTMRMwEQYDVQQIDApDYWxpZm9ybmlhMRYwFAYDVQQHDA1Nb3VudGFpbiBWaWV3MRQwEgYDVQQKDAtHb29nbGUgSW5jLjEQMA4GA1UECwwHQW5kcm9pZDEWMBQGA1UEAwwNY2hyb21lX2NhbmFyeTAeFw0xNjAyMjkxOTA5MDdaFw00MzA3MTcxOTA5MDdaMHoxCzAJBgNVBAYTAlVTMRMwEQYDVQQIDApDYWxpZm9ybmlhMRYwFAYDVQQHDA1Nb3VudGFpbiBWaWV3MRQwEgYDVQQKDAtHb29nbGUgSW5jLjEQMA4GA1UECwwHQW5kcm9pZDEWMBQGA1UEAwwNY2hyb21lX2NhbmFyeTCCASIwDQYJKoZIhvcNAQEBBQADggEPADCCAQoCggEBANXfeAoZlr0ya1HBzIfAz/nLLjpPJeAPvuX5dueaxmiQgv2hNG22acriFuiiJI6TU0t8AIVJD5Ifbc4OOuA0zeFhdzWWGnmTRH6x27WI7bzOKnAqOvv21ZBmE9i8Vo++K13xWdTs3qVn1bn9oUONxFu0wKDzXYZhoj1Jom0RZGjXm16xuPlEuOzMcjiNBDoYuxPAXkMcK/G1gP4P4nAV8Rd/GGIjKRS/SUtcShhoAMOQhs4WIEkUrvEVRwhBDIbpM87oFbCVdBH38r0XS6F6CdhPJsKFhoEfq4c01HZqNmDpCPA8AAcCuSWqmXoTIqs7OqkWgduE2bInbWU7WMaTl+kCAwEAAaNQME4wHQYDVR0OBBYEFB/AsC4iPAqaLoNytNSx29qByI7+MB8GA1UdIwQYMBaAFB/AsC4iPAqaLoNytNSx29qByI7+MAwGA1UdEwQFMAMBAf8wDQYJKoZIhvcNAQEFBQADggEBAMb2Td3ro/+MGVnCPAbwBSOZMVLUKGqt6zr8CShW9mtFHnmy29EaWSYYAj1M4+6Vpkq85NsgBEck7rnUjV8A3Q0NKdTys1KRKJqVvQRBN6SwqQenSf/abxQCa8Z+69rh+3BkIU1HLtu5lrMDZwon5H91L5mpORn6vItd20uW132lwSDeUEW2CHslTrodoFuTUcSUlRiq/URfUH3baO1QHXkxpQwrBPKL5deJfcZnxh5MAtAGSQL7gHvayEFlDppETXdDO7vgGTH2dEK2TjKWALbGiKkxSqjRyTNt4/FOj10TqNRdUamj+ydVJgzGQ8bki4Vc6NnKm/r4asusxapkVR4=</signature>
     </webviewprovider>
+    <webviewprovider description="Google WebView" packageName="com.google.android.webview" availableByDefault="true">
+<signature>MIIDuzCCAqOgAwIBAgIJANi6DgBQG4ZTMA0GCSqGSIb3DQEBBQUAMHQxCzAJBgNVBAYTAlVTMRMwEQYDVQQIDApDYWxpZm9ybmlhMRYwFAYDVQQHDA1Nb3VudGFpbiBWaWV3MRQwEgYDVQQKDAtHb29nbGUgSW5jLjEQMA4GA1UECwwHQW5kcm9pZDEQMA4GA1UEAwwHd2VidmlldzAeFw0xNDA4MDgyMzIwMjBaFw00MTEyMjQyMzIwMjBaMHQxCzAJBgNVBAYTAlVTMRMwEQYDVQQIDApDYWxpZm9ybmlhMRYwFAYDVQQHDA1Nb3VudGFpbiBWaWV3MRQwEgYDVQQKDAtHb29nbGUgSW5jLjEQMA4GA1UECwwHQW5kcm9pZDEQMA4GA1UEAwwHd2VidmlldzCCASIwDQYJKoZIhvcNAQEBBQADggEPADCCAQoCggEBAMbtaFX0r5aZJMAbPVMAgK1ZZ29dTn91VsGxXv2hqrQo7IpqEy2JmPvPnoMsSiuTAe+UcQy8oKDQ2aYVSAd1DGIy+nSRyFTt3LSIAdwSBkB1qT4a+OqkpsR6bSNXQXQ18lCQu9gREY3h3QlYBQAyzRxw4hRGlrXAzuSz1Ec4W+6x4nLG5DG61MAMR8ClF9XSqbmGB3kyZ70A0X9OPYYxiMWP1ExaYvpaVqjyZZcrPwr+vtW8oCuGBUtHpBUH3OoG+9s2YMcgLG7vCK9awKDqlPcJSpIAAj6uGs4gORmkqxZRMskLSTWbhP4p+3Ap8jYzTVB6Y1/DMVmYTWRMcPW0macCAwEAAaNQME4wHQYDVR0OBBYEFJ6bAR6/QVm4w9LRSGQiaR5Rhp3TMB8GA1UdIwQYMBaAFJ6bAR6/QVm4w9LRSGQiaR5Rhp3TMAwGA1UdEwQFMAMBAf8wDQYJKoZIhvcNAQEFBQADggEBAEQu8QiVxax7/diEiJrgKE1LwdXsIygJK/KnaKdnYEkAQpeu/QmrLiycm+OFbL1qHJIB7OuI/PQBUtcaNSiJSCVgtwtEbZWWIdsynqG/Nf4aGOndXegSQNRH54M05sRHLoeRycPrY7xQlEwGikNFR76+5UdwFBQI3Gn22g6puJnVukQm/wXQ+ajoiS4QclrNlixoDQsZ4STLH4+Wju2wIWKFFArIhVEIlbamq+p6BghuzH3aIz/Fy0YTQKi7SA+0fuNeCaqlSm5pYSt6p5CH89y1Fr+wFc5r3iLRnUwRcy08ESC7bZJnxV3d/YQ5valTxBbzku/dQbXVj/xg69H8l8M</signature>
+</webviewprovider>
+  <!-- The default WebView implementation -->
+    <webviewprovider description="AOSP WebView" packageName="com.android.webview" availableByDefault="true" isFallback="true" />
 </webviewproviders>
diff --git a/core/tests/coretests/src/android/net/UriTest.java b/core/tests/coretests/src/android/net/UriTest.java
index 6fa28b1ccda..ea0347d67ad 100644
--- a/core/tests/coretests/src/android/net/UriTest.java
+++ b/core/tests/coretests/src/android/net/UriTest.java
@@ -187,6 +187,17 @@ public class UriTest extends TestCase {
         uri = Uri.parse("http://localhost");
         assertEquals("localhost", uri.getHost());
         assertEquals(-1, uri.getPort());
+
+        uri = Uri.parse("http://a:a@example.com:a@example2.com/path");
+        assertEquals("a:a@example.com:a@example2.com", uri.getAuthority());
+        assertEquals("example2.com", uri.getHost());
+        assertEquals(-1, uri.getPort());
+        assertEquals("/path", uri.getPath());
+
+        uri = Uri.parse("http://a.foo.com\\.example.com/path");
+        assertEquals("a.foo.com", uri.getHost());
+        assertEquals(-1, uri.getPort());
+        assertEquals("\\.example.com/path", uri.getPath());
     }
 
     @SmallTest
diff --git a/libs/androidfw/ResourceTypes.cpp b/libs/androidfw/ResourceTypes.cpp
index ceeb12bab20..65588b2fafc 100644
--- a/libs/androidfw/ResourceTypes.cpp
+++ b/libs/androidfw/ResourceTypes.cpp
@@ -457,6 +457,22 @@ status_t ResStringPool::setTo(const void* data, size_t size, bool copyData)
 
     uninit();
 
+    // The chunk must be at least the size of the string pool header.
+    if (size < sizeof(ResStringPool_header)) {
+        ALOGW("Bad string block: data size %zu is too small to be a string block", size);
+        return (mError=BAD_TYPE);
+    }
+
+    // The data is at least as big as a ResChunk_header, so we can safely validate the other
+    // header fields.
+    // `data + size` is safe because the source of `size` comes from the kernel/filesystem.
+    if (validate_chunk(reinterpret_cast<const ResChunk_header*>(data), sizeof(ResStringPool_header),
+                       reinterpret_cast<const uint8_t*>(data) + size,
+                       "ResStringPool_header") != NO_ERROR) {
+        ALOGW("Bad string block: malformed block dimensions");
+        return (mError=BAD_TYPE);
+    }
+
     const bool notDeviceEndian = htods(0xf0) != 0xf0;
 
     if (copyData || notDeviceEndian) {
@@ -468,6 +484,8 @@ status_t ResStringPool::setTo(const void* data, size_t size, bool copyData)
         data = mOwnedData;
     }
 
+    // The size has been checked, so it is safe to read the data in the ResStringPool_header
+    // data structure.
     mHeader = (const ResStringPool_header*)data;
 
     if (notDeviceEndian) {
@@ -807,7 +825,13 @@ const char* ResStringPool::string8At(size_t idx, size_t* outLen) const
             *outLen = decodeLength(&str);
             size_t encLen = decodeLength(&str);
             if ((uint32_t)(str+encLen-strings) < mStringPoolSize) {
-                return (const char*)str;
+                // Reject malformed (non null-terminated) strings
+                if (str[encLen] != 0x00) {
+                    ALOGW("Bad string block: string #%d is not null-terminated",
+                          (int)idx);
+                    return NULL;
+                }
+              return (const char*)str;
             } else {
                 ALOGW("Bad string block: string #%d extends to %d, past end at %d\n",
                         (int)idx, (int)(str+encLen-strings), (int)mStringPoolSize);
@@ -6391,8 +6415,16 @@ status_t ResTable::parsePackage(const ResTable_package* const pkg,
             }
 
         } else if (ctype == RES_TABLE_LIBRARY_TYPE) {
+
             if (group->dynamicRefTable.entries().size() == 0) {
-                status_t err = group->dynamicRefTable.load((const ResTable_lib_header*) chunk);
+                const ResTable_lib_header* lib = (const ResTable_lib_header*) chunk;
+                status_t err = validate_chunk(&lib->header, sizeof(*lib),
+                                              endPos, "ResTable_lib_header");
+                if (err != NO_ERROR) {
+                    return (mError=err);
+                }
+
+                err = group->dynamicRefTable.load(lib);
                 if (err != NO_ERROR) {
                     return (mError=err);
                 }
diff --git a/libs/hwui/Android.mk b/libs/hwui/Android.mk
index cacfce16ab9..0b177b96430 100644
--- a/libs/hwui/Android.mk
+++ b/libs/hwui/Android.mk
@@ -149,7 +149,7 @@ endif
 
 ifdef HWUI_COMPILE_FOR_PERF
     # TODO: Non-arm?
-    hwui_cflags += -fno-omit-frame-pointer -marm -mapcs
+    hwui_cflags += -fno-omit-frame-pointer -marm 
 endif
 
 # This has to be lazy-resolved because it depends on the LOCAL_MODULE_CLASS
diff --git a/libs/hwui/Snapshot.cpp b/libs/hwui/Snapshot.cpp
index 2c9c9d90f68..7c187fbda45 100644
--- a/libs/hwui/Snapshot.cpp
+++ b/libs/hwui/Snapshot.cpp
@@ -38,6 +38,7 @@ Snapshot::Snapshot()
         , mClipArea(&mClipAreaRoot) {
     transform = &mTransformRoot;
     region = nullptr;
+    mRelativeLightCenter.x = mRelativeLightCenter.y = mRelativeLightCenter.z = 0;
 }
 
 /**
diff --git a/media/java/android/media/MediaPlayer.java b/media/java/android/media/MediaPlayer.java
index e5f7527c9db..679a27e9f42 100644
--- a/media/java/android/media/MediaPlayer.java
+++ b/media/java/android/media/MediaPlayer.java
@@ -2025,10 +2025,10 @@ public class MediaPlayer extends PlayerBase
         @Override
         public void writeToParcel(Parcel dest, int flags) {
             dest.writeInt(mTrackType);
+            dest.writeString(mFormat.getString(MediaFormat.KEY_MIME));
             dest.writeString(getLanguage());
 
             if (mTrackType == MEDIA_TRACK_TYPE_SUBTITLE) {
-                dest.writeString(mFormat.getString(MediaFormat.KEY_MIME));
                 dest.writeInt(mFormat.getInteger(MediaFormat.KEY_IS_AUTOSELECT));
                 dest.writeInt(mFormat.getInteger(MediaFormat.KEY_IS_DEFAULT));
                 dest.writeInt(mFormat.getInteger(MediaFormat.KEY_IS_FORCED_SUBTITLE));
diff --git a/media/java/android/media/MediaScanner.java b/media/java/android/media/MediaScanner.java
index 0fafe4b19a4..4c113d946d1 100644
--- a/media/java/android/media/MediaScanner.java
+++ b/media/java/android/media/MediaScanner.java
@@ -323,7 +323,6 @@ public class MediaScanner implements AutoCloseable {
     private final Uri mAudioUri;
     private final Uri mVideoUri;
     private final Uri mImagesUri;
-    private final Uri mThumbsUri;
     private final Uri mPlaylistsUri;
     private final Uri mFilesUri;
     private final Uri mFilesUriNoNotify;
@@ -419,7 +418,6 @@ public class MediaScanner implements AutoCloseable {
         mAudioUri = Audio.Media.getContentUri(volumeName);
         mVideoUri = Video.Media.getContentUri(volumeName);
         mImagesUri = Images.Media.getContentUri(volumeName);
-        mThumbsUri = Images.Thumbnails.getContentUri(volumeName);
         mFilesUri = Files.getContentUri(volumeName);
         mFilesUriNoNotify = mFilesUri.buildUpon().appendQueryParameter("nonotify", "1").build();
 
@@ -1283,53 +1281,6 @@ public class MediaScanner implements AutoCloseable {
         }
     }
 
-    private void pruneDeadThumbnailFiles() {
-        HashSet<String> existingFiles = new HashSet<String>();
-        String directory = "/sdcard/DCIM/.thumbnails";
-        String [] files = (new File(directory)).list();
-        Cursor c = null;
-        if (files == null)
-            files = new String[0];
-
-        for (int i = 0; i < files.length; i++) {
-            String fullPathString = directory + "/" + files[i];
-            existingFiles.add(fullPathString);
-        }
-
-        try {
-            c = mMediaProvider.query(
-                    mThumbsUri,
-                    new String [] { "_data" },
-                    null,
-                    null,
-                    null, null);
-            Log.v(TAG, "pruneDeadThumbnailFiles... " + c);
-            if (c != null && c.moveToFirst()) {
-                do {
-                    String fullPathString = c.getString(0);
-                    existingFiles.remove(fullPathString);
-                } while (c.moveToNext());
-            }
-
-            for (String fileToDelete : existingFiles) {
-                if (false)
-                    Log.v(TAG, "fileToDelete is " + fileToDelete);
-                try {
-                    (new File(fileToDelete)).delete();
-                } catch (SecurityException ex) {
-                }
-            }
-
-            Log.v(TAG, "/pruneDeadThumbnailFiles... " + c);
-        } catch (RemoteException e) {
-            // We will soon be killed...
-        } finally {
-            if (c != null) {
-                c.close();
-            }
-        }
-    }
-
     static class MediaBulkDeleter {
         StringBuilder whereClause = new StringBuilder();
         ArrayList<String> whereArgs = new ArrayList<String>(100);
@@ -1373,9 +1324,6 @@ public class MediaScanner implements AutoCloseable {
             processPlayLists();
         }
 
-        if (mOriginalCount == 0 && mImagesUri.equals(Images.Media.getContentUri("external")))
-            pruneDeadThumbnailFiles();
-
         // allow GC to clean up
         mPlayLists.clear();
     }
diff --git a/media/java/android/media/MiniThumbFile.java b/media/java/android/media/MiniThumbFile.java
index 664308c45bf..4f9dc6817ad 100644
--- a/media/java/android/media/MiniThumbFile.java
+++ b/media/java/android/media/MiniThumbFile.java
@@ -51,6 +51,7 @@ public class MiniThumbFile {
     private RandomAccessFile mMiniThumbFile;
     private FileChannel mChannel;
     private ByteBuffer mBuffer;
+    private ByteBuffer mEmptyBuffer;
     private static final Hashtable<String, MiniThumbFile> sThumbFiles =
         new Hashtable<String, MiniThumbFile>();
 
@@ -127,9 +128,10 @@ public class MiniThumbFile {
         return mMiniThumbFile;
     }
 
-    public MiniThumbFile(Uri uri) {
+    private MiniThumbFile(Uri uri) {
         mUri = uri;
         mBuffer = ByteBuffer.allocateDirect(BYTES_PER_MINTHUMB);
+        mEmptyBuffer = ByteBuffer.allocateDirect(BYTES_PER_MINTHUMB);
     }
 
     public synchronized void deactivate() {
@@ -184,6 +186,54 @@ public class MiniThumbFile {
         return 0;
     }
 
+    public synchronized void eraseMiniThumb(long id) {
+        RandomAccessFile r = miniThumbDataFile();
+        if (r != null) {
+            long pos = id * BYTES_PER_MINTHUMB;
+            FileLock lock = null;
+            try {
+                mBuffer.clear();
+                mBuffer.limit(1 + 8);
+
+                lock = mChannel.lock(pos, BYTES_PER_MINTHUMB, false);
+                // check that we can read the following 9 bytes
+                // (1 for the "status" and 8 for the long)
+                if (mChannel.read(mBuffer, pos) == 9) {
+                    mBuffer.position(0);
+                    if (mBuffer.get() == 1) {
+                        long currentMagic = mBuffer.getLong();
+                        if (currentMagic == 0) {
+                            // there is no thumbnail stored here
+                            Log.i(TAG, "no thumbnail for id " + id);
+                            return;
+                        }
+                        // zero out the thumbnail slot
+                        // Log.v(TAG, "clearing slot " + id + ", magic " + currentMagic
+                        //         + " at offset " + pos);
+                        mChannel.write(mEmptyBuffer, pos);
+                    }
+                } else {
+                    // Log.v(TAG, "No slot");
+                }
+            } catch (IOException ex) {
+                Log.v(TAG, "Got exception checking file magic: ", ex);
+            } catch (RuntimeException ex) {
+                // Other NIO related exception like disk full, read only channel..etc
+                Log.e(TAG, "Got exception when reading magic, id = " + id +
+                        ", disk full or mount read-only? " + ex.getClass());
+            } finally {
+                try {
+                    if (lock != null) lock.release();
+                }
+                catch (IOException ex) {
+                    // ignore it.
+                }
+            }
+        } else {
+            // Log.v(TAG, "No data file");
+        }
+    }
+
     public synchronized void saveMiniThumbToFile(byte[] data, long id, long magic)
             throws IOException {
         RandomAccessFile r = miniThumbDataFile();
diff --git a/media/jni/android_media_ExifInterface.cpp b/media/jni/android_media_ExifInterface.cpp
index 731deae1460..20f9ef6d6a4 100644
--- a/media/jni/android_media_ExifInterface.cpp
+++ b/media/jni/android_media_ExifInterface.cpp
@@ -390,8 +390,7 @@ static jobject ExifInterface_getRawAttributesFromFileDescriptor(
     // Rewind the file descriptor.
     fseek(file, 0L, SEEK_SET);
 
-    std::unique_ptr<SkFILEStream> fileStream(new SkFILEStream(file,
-                SkFILEStream::kCallerPasses_Ownership));
+    std::unique_ptr<SkFILEStream> fileStream(new SkFILEStream(file));
     return getRawAttributes(env, fileStream.get(), false);
 }
 
diff --git a/media/jni/android_mtp_MtpDatabase.cpp b/media/jni/android_mtp_MtpDatabase.cpp
index 7217832bac6..feff102850f 100644
--- a/media/jni/android_mtp_MtpDatabase.cpp
+++ b/media/jni/android_mtp_MtpDatabase.cpp
@@ -948,6 +948,7 @@ void* MyMtpDatabase::getThumbnail(MtpObjectHandle handle, size_t& outThumbSize)
                         outThumbSize = image_data.thumbnail.length;
                     } else {
                         free(result);
+                        result = NULL;
                     }
                 }
                 break;
diff --git a/packages/DocumentsUI/tests/src/com/android/documentsui/SearchViewUiTest.java b/packages/DocumentsUI/tests/src/com/android/documentsui/SearchViewUiTest.java
index a9451a6e379..b6190821c2d 100644
--- a/packages/DocumentsUI/tests/src/com/android/documentsui/SearchViewUiTest.java
+++ b/packages/DocumentsUI/tests/src/com/android/documentsui/SearchViewUiTest.java
@@ -72,6 +72,32 @@ public class SearchViewUiTest extends ActivityTest<FilesActivity> {
         bots.main.assertSearchTextField(false, query);
     }
 
+    public void testSearchDownloads() throws Exception {
+        initTestFiles();
+        bots.roots.openRoot(ROOT_0_ID);
+
+        bots.directory.copyFilesToClipboard(fileName1, fileName2);
+        device.waitForIdle();
+
+        bots.roots.openRoot("Downloads");
+        bots.directory.pasteFilesFromClipboard();
+
+        //TODO: linben Why do we need to click on Downloads again so this will work?
+        bots.roots.openRoot("Downloads");
+        device.waitForIdle();
+
+        String query = "file12";
+        bots.main.openSearchView();
+        bots.main.setSearchQuery(query);
+
+        device.pressEnter();
+
+        bots.directory.assertDocumentsCountOnList(true, 1);
+        bots.directory.assertDocumentsPresent(fileName2);
+
+        device.pressBack();
+    }
+
     @Suppress
     public void testSearchResultsFound_ClearsOnBack() throws Exception {
         initTestFiles();
@@ -151,4 +177,18 @@ public class SearchViewUiTest extends ActivityTest<FilesActivity> {
         bots.main.assertSearchTextFiledAndIcon(false, false);
     }
 
+    @Override
+    public void tearDown() throws Exception {
+        try {
+            // Proper clean up of #testSearchDownloads
+            bots.directory.clickDocument(fileName1 + ".txt");
+            bots.directory.clickDocument(fileName2);
+            device.waitForIdle();
+            bots.main.menuDelete().click();
+            bots.main.findDialogOkButton().click();
+        } catch (Exception e) {
+        } finally {
+            super.tearDown();
+        }
+    }
 }
diff --git a/packages/DocumentsUI/tests/src/com/android/documentsui/bots/DirectoryListBot.java b/packages/DocumentsUI/tests/src/com/android/documentsui/bots/DirectoryListBot.java
index 7c1e2196f6d..e2aabc7c2ba 100644
--- a/packages/DocumentsUI/tests/src/com/android/documentsui/bots/DirectoryListBot.java
+++ b/packages/DocumentsUI/tests/src/com/android/documentsui/bots/DirectoryListBot.java
@@ -30,6 +30,7 @@ import android.support.test.uiautomator.UiObject2;
 import android.support.test.uiautomator.UiObjectNotFoundException;
 import android.support.test.uiautomator.UiSelector;
 import android.support.test.uiautomator.Until;
+import android.view.KeyEvent;
 import android.view.MotionEvent;
 
 import junit.framework.Assert;
@@ -129,6 +130,17 @@ public class DirectoryListBot extends BaseBot {
         return doc;
     }
 
+    public void copyFilesToClipboard(String...labels) throws UiObjectNotFoundException {
+        for (String label: labels) {
+            clickDocument(label);
+        }
+        mDevice.pressKeyCode(KeyEvent.KEYCODE_C, KeyEvent.META_CTRL_ON);
+    }
+
+    public void pasteFilesFromClipboard() {
+        mDevice.pressKeyCode(KeyEvent.KEYCODE_V, KeyEvent.META_CTRL_ON);
+    }
+
     public UiObject2 getSnackbar(String message) {
         return mDevice.wait(Until.findObject(By.text(message)), mTimeout);
     }
diff --git a/packages/SettingsProvider/src/com/android/providers/settings/SettingsProvider.java b/packages/SettingsProvider/src/com/android/providers/settings/SettingsProvider.java
index fec33a27086..d89219f1bdc 100644
--- a/packages/SettingsProvider/src/com/android/providers/settings/SettingsProvider.java
+++ b/packages/SettingsProvider/src/com/android/providers/settings/SettingsProvider.java
@@ -511,6 +511,13 @@ public class SettingsProvider extends ContentProvider {
 
     @Override
     public ParcelFileDescriptor openFile(Uri uri, String mode) throws FileNotFoundException {
+        final int userId = getUserIdFromUri(uri, UserHandle.getCallingUserId());
+        if (userId != UserHandle.getCallingUserId()) {
+            getContext().enforceCallingPermission(Manifest.permission.INTERACT_ACROSS_USERS,
+                    "Access files from the settings of another user");
+        }
+        uri = ContentProvider.getUriWithoutUserId(uri);
+
         final String cacheName;
         if (Settings.System.RINGTONE_CACHE_URI.equals(uri)) {
             cacheName = Settings.System.RINGTONE_CACHE;
@@ -523,8 +530,7 @@ public class SettingsProvider extends ContentProvider {
                     + "ringtone playback is available through android.media.Ringtone");
         }
 
-        final File cacheFile = new File(
-                getRingtoneCacheDir(UserHandle.getCallingUserId()), cacheName);
+        final File cacheFile = new File(getRingtoneCacheDir(userId), cacheName);
         return ParcelFileDescriptor.open(cacheFile, ParcelFileDescriptor.parseMode(mode));
     }
 
diff --git a/packages/SystemUI/AndroidManifest.xml b/packages/SystemUI/AndroidManifest.xml
index 3ee844cd8ef..9e03307fa31 100644
--- a/packages/SystemUI/AndroidManifest.xml
+++ b/packages/SystemUI/AndroidManifest.xml
@@ -165,6 +165,9 @@
     <!-- shortcut manager -->
     <uses-permission android:name="android.permission.RESET_SHORTCUT_MANAGER_THROTTLING" />
 
+    <!-- permission necessary to hide non-system overlay windows from covering up the SystemUI -->
+    <uses-permission android:name="android.permission.HIDE_NON_SYSTEM_OVERLAY_WINDOWS" />
+
     <application
         android:name=".SystemUIApplication"
         android:persistent="true"
diff --git a/packages/SystemUI/res/values/config.xml b/packages/SystemUI/res/values/config.xml
index 0fa9a85f412..925f3681c73 100644
--- a/packages/SystemUI/res/values/config.xml
+++ b/packages/SystemUI/res/values/config.xml
@@ -105,7 +105,7 @@
 
     <!-- Tiles native to System UI. Order should match "quick_settings_tiles_default" -->
     <string name="quick_settings_tiles_stock" translatable="false">
-        wifi,cell,battery,dnd,flashlight,rotation,bt,airplane,location,hotspot,inversion,saver,work,cast,night
+        wifi,cell,battery,dnd,flashlight,rotation,bt,airplane,location,immersive,hotspot,inversion,saver,work,cast,night
     </string>
 
     <!-- The tiles to display in QuickSettings -->
diff --git a/packages/SystemUI/res/values/strings.xml b/packages/SystemUI/res/values/strings.xml
index 4a51329215e..aa6b3e0435c 100644
--- a/packages/SystemUI/res/values/strings.xml
+++ b/packages/SystemUI/res/values/strings.xml
@@ -1700,5 +1700,9 @@
     <string name="high_temp_notif_message">Some features limited while phone cools down</string>
     <!-- Text body for dialog alerting user that their phone has reached a certain temperature and may start to slow down in order to cool down. [CHAR LIMIT=300] -->
     <string name="high_temp_dialog_message">Your phone will automatically try to cool down. You can still use your phone, but it may run slower.\n\nOnce your phone has cooled down, it will run normally.</string>
-
+    <!-- Warning shown when user input has been blocked due to another app overlaying screen
+         content. Since we don't know what the app is showing on top of the input target, we
+         can't verify user consent. [CHAR LIMIT=NONE] -->
+    <string name="touch_filtered_warning">Because an app is obscuring a permission request, Settings
+        can’t verify your response.</string>
 </resources>
diff --git a/packages/SystemUI/src/com/android/systemui/classifier/HumanInteractionClassifier.java b/packages/SystemUI/src/com/android/systemui/classifier/HumanInteractionClassifier.java
index 851ab771882..a384641e16d 100644
--- a/packages/SystemUI/src/com/android/systemui/classifier/HumanInteractionClassifier.java
+++ b/packages/SystemUI/src/com/android/systemui/classifier/HumanInteractionClassifier.java
@@ -36,9 +36,6 @@ public class HumanInteractionClassifier extends Classifier {
     private static final String HIC_ENABLE = "HIC_enable";
     private static final float FINGER_DISTANCE = 0.1f;
 
-    /** Default value for the HIC_ENABLE setting: 1 - enabled, 0 - disabled */
-    private static final int HIC_ENABLE_DEFAULT = 1;
-
     private static HumanInteractionClassifier sInstance = null;
 
     private final Handler mHandler = new Handler();
@@ -105,9 +102,11 @@ public class HumanInteractionClassifier extends Classifier {
     }
 
     private void updateConfiguration() {
+        boolean enabledDefault = mContext.getResources()
+                .getBoolean(com.android.internal.R.bool.config_HICEnabledDefault);
         mEnableClassifier = 0 != Settings.Global.getInt(
                 mContext.getContentResolver(),
-                HIC_ENABLE, HIC_ENABLE_DEFAULT);
+ 		HIC_ENABLE, enabledDefault ? 1 : 0);
     }
 
     public void setType(int type) {
diff --git a/packages/SystemUI/src/com/android/systemui/media/MediaProjectionPermissionActivity.java b/packages/SystemUI/src/com/android/systemui/media/MediaProjectionPermissionActivity.java
index b2a80f4ca52..4a6786832df 100644
--- a/packages/SystemUI/src/com/android/systemui/media/MediaProjectionPermissionActivity.java
+++ b/packages/SystemUI/src/com/android/systemui/media/MediaProjectionPermissionActivity.java
@@ -16,6 +16,8 @@
 
 package com.android.systemui.media;
 
+import static android.view.WindowManager.LayoutParams.PRIVATE_FLAG_HIDE_NON_SYSTEM_OVERLAY_WINDOWS;
+
 import android.app.Activity;
 import android.app.AlertDialog;
 import android.content.DialogInterface;
@@ -36,6 +38,7 @@ import android.text.TextPaint;
 import android.text.TextUtils;
 import android.text.style.StyleSpan;
 import android.util.Log;
+import android.view.Window;
 import android.view.WindowManager;
 import android.widget.CheckBox;
 import android.widget.CompoundButton;
@@ -146,7 +149,9 @@ public class MediaProjectionPermissionActivity extends Activity
         mDialog.getButton(DialogInterface.BUTTON_POSITIVE).setFilterTouchesWhenObscured(true);
 
         ((CheckBox) mDialog.findViewById(R.id.remember)).setOnCheckedChangeListener(this);
-        mDialog.getWindow().setType(WindowManager.LayoutParams.TYPE_SYSTEM_ALERT);
+        final Window w = mDialog.getWindow();
+        w.setType(WindowManager.LayoutParams.TYPE_SYSTEM_ALERT);
+        w.addPrivateFlags(PRIVATE_FLAG_HIDE_NON_SYSTEM_OVERLAY_WINDOWS);
 
         mDialog.show();
     }
diff --git a/packages/SystemUI/src/com/android/systemui/settings/CurrentUserTracker.java b/packages/SystemUI/src/com/android/systemui/settings/CurrentUserTracker.java
index dd8075057e1..005206fcd14 100644
--- a/packages/SystemUI/src/com/android/systemui/settings/CurrentUserTracker.java
+++ b/packages/SystemUI/src/com/android/systemui/settings/CurrentUserTracker.java
@@ -22,39 +22,93 @@ import android.content.Context;
 import android.content.Intent;
 import android.content.IntentFilter;
 
-public abstract class CurrentUserTracker extends BroadcastReceiver {
+import java.util.ArrayList;
+import java.util.List;
+import java.util.function.Consumer;
 
-    private Context mContext;
-    private int mCurrentUserId;
+public abstract class CurrentUserTracker {
+    private final UserReceiver mUserReceiver;
+
+    private Consumer<Integer> mCallback = this::onUserSwitched;
 
     public CurrentUserTracker(Context context) {
-        mContext = context;
+        mUserReceiver = UserReceiver.getInstance(context);
     }
 
     public int getCurrentUserId() {
-        return mCurrentUserId;
-    }
-
-    @Override
-    public void onReceive(Context context, Intent intent) {
-        if (Intent.ACTION_USER_SWITCHED.equals(intent.getAction())) {
-            int oldUserId = mCurrentUserId;
-            mCurrentUserId = intent.getIntExtra(Intent.EXTRA_USER_HANDLE, 0);
-            if (oldUserId != mCurrentUserId) {
-                onUserSwitched(mCurrentUserId);
-            }
-        }
+        return mUserReceiver.getCurrentUserId();
     }
 
     public void startTracking() {
-        mCurrentUserId = ActivityManager.getCurrentUser();
-        IntentFilter filter = new IntentFilter(Intent.ACTION_USER_SWITCHED);
-        mContext.registerReceiver(this, filter);
+        mUserReceiver.addTracker(mCallback);
     }
 
     public void stopTracking() {
-        mContext.unregisterReceiver(this);
+        mUserReceiver.removeTracker(mCallback);
     }
 
     public abstract void onUserSwitched(int newUserId);
+
+    private static class UserReceiver extends BroadcastReceiver {
+        private static UserReceiver sInstance;
+
+        private Context mAppContext;
+        private boolean mReceiverRegistered;
+        private int mCurrentUserId;
+
+        private List<Consumer<Integer>> mCallbacks = new ArrayList<>();
+
+        private UserReceiver(Context context) {
+            mAppContext = context.getApplicationContext();
+        }
+
+        static UserReceiver getInstance(Context context) {
+            if (sInstance == null) {
+                sInstance = new UserReceiver(context);
+            }
+            return sInstance;
+        }
+
+        @Override
+        public void onReceive(Context context, Intent intent) {
+            if (Intent.ACTION_USER_SWITCHED.equals(intent.getAction())) {
+                notifyUserSwitched(intent.getIntExtra(Intent.EXTRA_USER_HANDLE, 0));
+            }
+        }
+
+        public int getCurrentUserId() {
+            return mCurrentUserId;
+        }
+
+        private void addTracker(Consumer<Integer> callback) {
+            if (!mCallbacks.contains(callback)) {
+                mCallbacks.add(callback);
+            }
+            if (!mReceiverRegistered) {
+                mCurrentUserId = ActivityManager.getCurrentUser();
+                IntentFilter filter = new IntentFilter(Intent.ACTION_USER_SWITCHED);
+                mAppContext.registerReceiver(this, filter);
+                mReceiverRegistered = true;
+            }
+        }
+
+        private void removeTracker(Consumer<Integer> callback) {
+            if (mCallbacks.contains(callback)) {
+                mCallbacks.remove(callback);
+                if (mCallbacks.size() == 0 && mReceiverRegistered) {
+                    mAppContext.unregisterReceiver(this);
+                    mReceiverRegistered = false;
+                }
+            }
+        }
+
+        private void notifyUserSwitched(int newUserId) {
+            if (mCurrentUserId != newUserId) {
+                mCurrentUserId = newUserId;
+                for (Consumer<Integer> consumer : mCallbacks) {
+                    consumer.accept(newUserId);
+                }
+            }
+        }
+    }
 }
diff --git a/packages/SystemUI/src/com/android/systemui/statusbar/BaseStatusBar.java b/packages/SystemUI/src/com/android/systemui/statusbar/BaseStatusBar.java
index 9d22b4a9f28..7639b3d32aa 100644
--- a/packages/SystemUI/src/com/android/systemui/statusbar/BaseStatusBar.java
+++ b/packages/SystemUI/src/com/android/systemui/statusbar/BaseStatusBar.java
@@ -2679,4 +2679,23 @@ public abstract class BaseStatusBar extends SystemUI implements
             mAssistManager.startAssist(args);
         }
     }
+
+    public boolean isCameraAllowedByAdmin() {
+       if (mDevicePolicyManager.getCameraDisabled(null, mCurrentUserId)) {
+           return false;
+       } else if (isKeyguardShowing() && isKeyguardSecure()) {
+           // Check if the admin has disabled the camera specifically for the keyguard
+           return (mDevicePolicyManager.getKeyguardDisabledFeatures(null, mCurrentUserId)
+                   & DevicePolicyManager.KEYGUARD_DISABLE_SECURE_CAMERA) == 0;
+       }
+       return true;
+    }
+
+    public boolean isKeyguardShowing() {
+        if (mStatusBarKeyguardViewManager == null) {
+            Slog.i(TAG, "isKeyguardShowing() called before startKeyguard(), returning true");
+            return true;
+        }
+        return mStatusBarKeyguardViewManager.isShowing();
+    }
 }
diff --git a/packages/SystemUI/src/com/android/systemui/statusbar/NotificationGuts.java b/packages/SystemUI/src/com/android/systemui/statusbar/NotificationGuts.java
index 63d28910393..1829e592546 100644
--- a/packages/SystemUI/src/com/android/systemui/statusbar/NotificationGuts.java
+++ b/packages/SystemUI/src/com/android/systemui/statusbar/NotificationGuts.java
@@ -235,7 +235,7 @@ public class NotificationGuts extends LinearLayout implements TunerService.Tunab
     }
 
     private int getSelectedImportance() {
-        if (mSeekBar!= null && mSeekBar.isShown()) {
+        if (mSeekBar != null && mSeekBar.isShown()) {
             if (mSeekBar.isEnabled()) {
                 return mSeekBar.getProgress();
             } else {
diff --git a/packages/SystemUI/src/com/android/systemui/statusbar/phone/KeyguardBottomAreaView.java b/packages/SystemUI/src/com/android/systemui/statusbar/phone/KeyguardBottomAreaView.java
index 4d0e5d34761..c674a82d609 100644
--- a/packages/SystemUI/src/com/android/systemui/statusbar/phone/KeyguardBottomAreaView.java
+++ b/packages/SystemUI/src/com/android/systemui/statusbar/phone/KeyguardBottomAreaView.java
@@ -305,7 +305,10 @@ public class KeyguardBottomAreaView extends FrameLayout implements View.OnClickL
             return;
         }
         ResolveInfo resolved = resolveCameraIntent();
-        boolean visible = !isCameraDisabledByDpm() && resolved != null
+        boolean isCameraDisabled =
+                (mPhoneStatusBar != null) && !mPhoneStatusBar.isCameraAllowedByAdmin();
+        boolean visible = !isCameraDisabled
+                && resolved != null
                 && getResources().getBoolean(R.bool.config_keyguardShowCameraAffordance)
                 && mUserSetupComplete;
         mCameraImageView.setVisibility(visible ? View.VISIBLE : View.GONE);
@@ -339,24 +342,6 @@ public class KeyguardBottomAreaView extends FrameLayout implements View.OnClickL
                 && pm.resolveActivity(PHONE_INTENT, 0) != null;
     }
 
-    private boolean isCameraDisabledByDpm() {
-        final DevicePolicyManager dpm =
-                (DevicePolicyManager) getContext().getSystemService(Context.DEVICE_POLICY_SERVICE);
-        if (dpm != null && mPhoneStatusBar != null) {
-            try {
-                final int userId = ActivityManagerNative.getDefault().getCurrentUser().id;
-                final int disabledFlags = dpm.getKeyguardDisabledFeatures(null, userId);
-                final  boolean disabledBecauseKeyguardSecure =
-                        (disabledFlags & DevicePolicyManager.KEYGUARD_DISABLE_SECURE_CAMERA) != 0
-                                && mPhoneStatusBar.isKeyguardSecure();
-                return dpm.getCameraDisabled(null) || disabledBecauseKeyguardSecure;
-            } catch (RemoteException e) {
-                Log.e(TAG, "Can't get userId", e);
-            }
-        }
-        return false;
-    }
-
     private void watchForCameraPolicyChanges() {
         final IntentFilter filter = new IntentFilter();
         filter.addAction(DevicePolicyManager.ACTION_DEVICE_POLICY_MANAGER_STATE_CHANGED);
diff --git a/packages/SystemUI/src/com/android/systemui/statusbar/phone/NotificationPanelView.java b/packages/SystemUI/src/com/android/systemui/statusbar/phone/NotificationPanelView.java
index 9c700b4280e..ca08ab15e65 100644
--- a/packages/SystemUI/src/com/android/systemui/statusbar/phone/NotificationPanelView.java
+++ b/packages/SystemUI/src/com/android/systemui/statusbar/phone/NotificationPanelView.java
@@ -31,6 +31,7 @@ import android.graphics.Paint;
 import android.graphics.Rect;
 import android.util.AttributeSet;
 import android.util.MathUtils;
+import android.util.EventLog;
 import android.view.MotionEvent;
 import android.view.VelocityTracker;
 import android.view.View;
@@ -2330,6 +2331,10 @@ public class NotificationPanelView extends PanelView implements
      * @param keyguardIsShowing whether keyguard is being shown
      */
     public boolean canCameraGestureBeLaunched(boolean keyguardIsShowing) {
+        if (!mStatusBar.isCameraAllowedByAdmin()) {
+            EventLog.writeEvent(0x534e4554, "63787722", -1, "");
+            return false;
+        }
         ResolveInfo resolveInfo = mKeyguardBottomArea.resolveCameraIntent();
         String packageToLaunch = (resolveInfo == null || resolveInfo.activityInfo == null)
                 ? null : resolveInfo.activityInfo.packageName;
diff --git a/packages/SystemUI/src/com/android/systemui/tuner/TunerFragment.java b/packages/SystemUI/src/com/android/systemui/tuner/TunerFragment.java
index 70f2fdcfa8d..ba50161aae9 100644
--- a/packages/SystemUI/src/com/android/systemui/tuner/TunerFragment.java
+++ b/packages/SystemUI/src/com/android/systemui/tuner/TunerFragment.java
@@ -59,7 +59,10 @@ public class TunerFragment extends PreferenceFragment {
     @Override
     public void onActivityCreated(Bundle savedInstanceState) {
         super.onActivityCreated(savedInstanceState);
-        getActivity().getActionBar().setDisplayHomeAsUpEnabled(true);
+
+        if (getActivity().getActionBar() != null) {
+            getActivity().getActionBar().setDisplayHomeAsUpEnabled(true);
+        }
     }
 
     @Override
diff --git a/packages/SystemUI/src/com/android/systemui/usb/UsbDebuggingActivity.java b/packages/SystemUI/src/com/android/systemui/usb/UsbDebuggingActivity.java
index f5447a29350..329dd9917a7 100644
--- a/packages/SystemUI/src/com/android/systemui/usb/UsbDebuggingActivity.java
+++ b/packages/SystemUI/src/com/android/systemui/usb/UsbDebuggingActivity.java
@@ -31,8 +31,12 @@ import android.os.ServiceManager;
 import android.os.SystemProperties;
 import android.util.Log;
 import android.view.LayoutInflater;
+import android.view.MotionEvent;
 import android.view.View;
+import android.view.Window;
+import android.view.WindowManager;
 import android.widget.CheckBox;
+import android.widget.Toast;
 
 import com.android.internal.app.AlertActivity;
 import com.android.internal.app.AlertController;
@@ -48,6 +52,10 @@ public class UsbDebuggingActivity extends AlertActivity
 
     @Override
     public void onCreate(Bundle icicle) {
+        Window window = getWindow();
+        window.addPrivateFlags(WindowManager.LayoutParams.PRIVATE_FLAG_HIDE_NON_SYSTEM_OVERLAY_WINDOWS);
+        window.setType(WindowManager.LayoutParams.TYPE_SYSTEM_DIALOG);
+
         super.onCreate(icicle);
 
         if (SystemProperties.getInt("service.adb.tcp.port", 0) == 0) {
@@ -79,6 +87,23 @@ public class UsbDebuggingActivity extends AlertActivity
         ap.mView = checkbox;
 
         setupAlert();
+
+        // adding touch listener on affirmative button - checks if window is obscured
+        // if obscured, do not let user give permissions (could be tapjacking involved)
+        final View.OnTouchListener filterTouchListener = (View v, MotionEvent event) -> {
+            // Filter obscured touches by consuming them.
+            if (((event.getFlags() & MotionEvent.FLAG_WINDOW_IS_OBSCURED) != 0)
+                    || ((event.getFlags() & MotionEvent.FLAG_WINDOW_IS_PARTIALLY_OBSCURED) != 0)) {
+                if (event.getAction() == MotionEvent.ACTION_UP) {
+                    Toast.makeText(v.getContext(),
+                            R.string.touch_filtered_warning,
+                            Toast.LENGTH_SHORT).show();
+                }
+                return true;
+            }
+            return false;
+        };
+        mAlert.getButton(BUTTON_POSITIVE).setOnTouchListener(filterTouchListener);
     }
 
     private class UsbDisconnectedReceiver extends BroadcastReceiver {
diff --git a/packages/VpnDialogs/AndroidManifest.xml b/packages/VpnDialogs/AndroidManifest.xml
index a3d27ce8a3d..60ed3245bc2 100644
--- a/packages/VpnDialogs/AndroidManifest.xml
+++ b/packages/VpnDialogs/AndroidManifest.xml
@@ -21,6 +21,7 @@
 
     <uses-permission android:name="android.permission.CONTROL_VPN" />
     <uses-permission android:name="android.permission.CONNECTIVITY_INTERNAL" />
+    <uses-permission android:name="android.permission.HIDE_NON_SYSTEM_OVERLAY_WINDOWS"/>
 
     <application android:label="VpnDialogs"
             android:allowBackup="false" >
diff --git a/packages/VpnDialogs/src/com/android/vpndialogs/ConfirmDialog.java b/packages/VpnDialogs/src/com/android/vpndialogs/ConfirmDialog.java
index 72ce9c4efdc..09339743db5 100644
--- a/packages/VpnDialogs/src/com/android/vpndialogs/ConfirmDialog.java
+++ b/packages/VpnDialogs/src/com/android/vpndialogs/ConfirmDialog.java
@@ -16,6 +16,8 @@
 
 package com.android.vpndialogs;
 
+import static android.view.WindowManager.LayoutParams.PRIVATE_FLAG_HIDE_NON_SYSTEM_OVERLAY_WINDOWS;
+
 import android.content.Context;
 import android.content.DialogInterface;
 import android.content.pm.PackageManager;
@@ -78,6 +80,7 @@ public class ConfirmDialog extends AlertActivity
         setupAlert();
 
         getWindow().setCloseOnTouchOutside(false);
+        getWindow().addPrivateFlags(PRIVATE_FLAG_HIDE_NON_SYSTEM_OVERLAY_WINDOWS);
         Button button = mAlert.getButton(DialogInterface.BUTTON_POSITIVE);
         button.setFilterTouchesWhenObscured(true);
     }
diff --git a/services/core/java/com/android/server/AppOpsService.java b/services/core/java/com/android/server/AppOpsService.java
index 4caeba84b20..c95b9d52ad8 100644
--- a/services/core/java/com/android/server/AppOpsService.java
+++ b/services/core/java/com/android/server/AppOpsService.java
@@ -597,7 +597,6 @@ public class AppOpsService extends IAppOpsService.Stub {
         ArrayList<Callback> repCbs = null;
         code = AppOpsManager.opToSwitch(code);
         synchronized (this) {
-            UidState uidState = getUidStateLocked(uid, false);
             Op op = getOpLocked(code, uid, packageName, true);
             if (op != null) {
                 if (op.mode != mode) {
@@ -973,7 +972,7 @@ public class AppOpsService extends IAppOpsService.Stub {
     public int checkPackage(int uid, String packageName) {
         Preconditions.checkNotNull(packageName);
         synchronized (this) {
-            if (getOpsRawLocked(uid, packageName, true) != null) {
+            if (packageName != null && getOpsRawLocked(uid, packageName, true) != null) {
                 return AppOpsManager.MODE_ALLOWED;
             } else {
                 return AppOpsManager.MODE_ERRORED;
@@ -1533,8 +1532,6 @@ public class AppOpsService extends IAppOpsService.Stub {
 
     void writeState() {
         synchronized (mFile) {
-            List<AppOpsManager.PackageOps> allOps = getPackagesForOps(null);
-
             FileOutputStream stream;
             try {
                 stream = mFile.startWrite();
@@ -1543,15 +1540,33 @@ public class AppOpsService extends IAppOpsService.Stub {
                 return;
             }
 
+            SparseArray<UidState> outUidStates = null;
+            synchronized (this) {
+                final int uidStateCount = mUidStates.size();
+                for (int i = 0; i < uidStateCount; i++) {
+                    UidState uidState = mUidStates.valueAt(i);
+                    SparseIntArray opModes = uidState.opModes;
+                    if (opModes != null && opModes.size() > 0) {
+                        UidState outUidState = new UidState(uidState.uid);
+                        outUidState.opModes = opModes.clone();
+                        if (outUidStates == null) {
+                            outUidStates = new SparseArray<>();
+                        }
+                        outUidStates.put(mUidStates.keyAt(i), outUidState);
+                    }
+                }
+            }
+            List<AppOpsManager.PackageOps> allOps = getPackagesForOps(null);
+
             try {
                 XmlSerializer out = new FastXmlSerializer();
                 out.setOutput(stream, StandardCharsets.UTF_8.name());
                 out.startDocument(null, true);
                 out.startTag(null, "app-ops");
 
-                final int uidStateCount = mUidStates.size();
+                final int uidStateCount = outUidStates != null ? outUidStates.size() : 0;
                 for (int i = 0; i < uidStateCount; i++) {
-                    UidState uidState = mUidStates.valueAt(i);
+                    UidState uidState = outUidStates.valueAt(i);
                     if (uidState.opModes != null && uidState.opModes.size() > 0) {
                         out.startTag(null, "uid");
                         out.attribute(null, "n", Integer.toString(uidState.uid));
diff --git a/services/core/java/com/android/server/BluetoothManagerService.java b/services/core/java/com/android/server/BluetoothManagerService.java
index 2a6f9d2b856..7ba1fe40b4c 100644
--- a/services/core/java/com/android/server/BluetoothManagerService.java
+++ b/services/core/java/com/android/server/BluetoothManagerService.java
@@ -55,6 +55,7 @@ import android.os.UserManager;
 import android.provider.Settings;
 import android.provider.Settings.SettingNotFoundException;
 import android.util.Slog;
+import java.util.concurrent.locks.ReentrantReadWriteLock;
 
 import java.io.FileDescriptor;
 import java.io.PrintWriter;
@@ -122,6 +123,7 @@ class BluetoothManagerService extends IBluetoothManager.Stub {
     private static final int SERVICE_IBLUETOOTHGATT = 2;
 
     private final Context mContext;
+    private static int mBleAppCount = 0;
 
     // Locks are not provided for mName and mAddress.
     // They are accessed in handler or broadcast receiver, same thread context.
@@ -172,6 +174,8 @@ class BluetoothManagerService extends IBluetoothManager.Stub {
     // configuration from external IBinder call which is used to
     // synchronize with broadcast receiver.
     private boolean mQuietEnableExternal;
+    // configuarion from external IBinder call which is used to
+    // synchronize with broadcast receiver.
     private boolean mEnableExternal;
 
     // Map of apps registered to keep BLE scanning on.
@@ -351,6 +355,7 @@ class BluetoothManagerService extends IBluetoothManager.Stub {
 
     /**
      *  Save the Bluetooth on/off state
+     *
      */
     private void persistBluetoothSetting(int value) {
         if (DBG) Slog.d(TAG, "Persisting Bluetooth Setting: " + value);
@@ -644,7 +649,11 @@ class BluetoothManagerService extends IBluetoothManager.Stub {
             if (isBluetoothPersistedStateOnBluetooth() || !isBleAppPresent()) {
                 // This triggers transition to STATE_ON
                 mBluetooth.onLeServiceUp();
+
+                // waive WRITE_SECURE_SETTINGS permission check
+                long callingIdentity = Binder.clearCallingIdentity();
                 persistBluetoothSetting(BLUETOOTH_ON_BLUETOOTH);
+                Binder.restoreCallingIdentity(callingIdentity);
             }
         } catch (RemoteException e) {
             Slog.e(TAG,"Unable to call onServiceUp", e);
@@ -727,6 +736,8 @@ class BluetoothManagerService extends IBluetoothManager.Stub {
             }
         }
 
+        mContext.enforceCallingOrSelfPermission(BLUETOOTH_ADMIN_PERM,
+                                                "Need BLUETOOTH ADMIN permission");
         if (DBG) {
             Slog.d(TAG,"enable(" + packageName + "):  mBluetooth =" + mBluetooth +
                     " mBinding = " + mBinding + " mState = " +
@@ -770,7 +781,10 @@ class BluetoothManagerService extends IBluetoothManager.Stub {
 
         synchronized(mReceiver) {
             if (persist) {
+                // waive WRITE_SECURE_SETTINGS permission check
+                long callingIdentity = Binder.clearCallingIdentity();
                 persistBluetoothSetting(BLUETOOTH_OFF);
+                Binder.restoreCallingIdentity(callingIdentity);
             }
             mEnableExternal = false;
             sendDisableMsg(packageName);
@@ -827,8 +841,11 @@ class BluetoothManagerService extends IBluetoothManager.Stub {
                 } catch (RemoteException re) {
                     Slog.e(TAG, "Unable to unregister BluetoothCallback",re);
                 }
+
+                if (DBG) Slog.d(TAG, "Sending unbind request.");
                 mBluetoothBinder = null;
                 mBluetooth = null;
+                //Unbind
                 mContext.unbindService(mConnection);
                 mUnbinding = false;
                 mBinding = false;
@@ -1103,6 +1120,7 @@ class BluetoothManagerService extends IBluetoothManager.Stub {
      * Inform BluetoothAdapter instances that Adapter service is up
      */
     private void sendBluetoothServiceUpCallback() {
+        if (DBG) Slog.d(TAG,"Calling onBluetoothServiceUp callbacks");
         try {
             int n = mCallbacks.beginBroadcast();
             Slog.d(TAG,"Broadcasting onBluetoothServiceUp() to " + n + " receivers.");
@@ -1121,6 +1139,7 @@ class BluetoothManagerService extends IBluetoothManager.Stub {
      * Inform BluetoothAdapter instances that Adapter service is down
      */
     private void sendBluetoothServiceDownCallback() {
+        if (DBG) Slog.d(TAG,"Calling onBluetoothServiceDown callbacks");
         try {
             int n = mCallbacks.beginBroadcast();
             Slog.d(TAG,"Broadcasting onBluetoothServiceDown() to " + n + " receivers.");
@@ -1236,6 +1255,7 @@ class BluetoothManagerService extends IBluetoothManager.Stub {
 
         @Override
         public void handleMessage(Message msg) {
+            if (DBG) Slog.d (TAG, "Message: " + msg.what);
             switch (msg.what) {
                 case MESSAGE_GET_NAME_AND_ADDRESS:
                     if (DBG) Slog.d(TAG, "MESSAGE_GET_NAME_AND_ADDRESS");
diff --git a/services/core/java/com/android/server/ConnectivityService.java b/services/core/java/com/android/server/ConnectivityService.java
index 269327201d5..903dc400741 100644
--- a/services/core/java/com/android/server/ConnectivityService.java
+++ b/services/core/java/com/android/server/ConnectivityService.java
@@ -3007,6 +3007,12 @@ public class ConnectivityService extends IConnectivityManager.Stub
         ConnectivityManager.enforceTetherChangePermission(mContext);
         if (isTetheringSupported()) {
             final int status = mTethering.tether(iface);
+            if (status == ConnectivityManager.TETHER_ERROR_NO_ERROR) {
+                try {
+                    mPolicyManager.onTetheringChanged(iface, true);
+                } catch (RemoteException e) {
+                }
+            }
             return status;
         } else {
             return ConnectivityManager.TETHER_ERROR_UNSUPPORTED;
@@ -3020,6 +3026,12 @@ public class ConnectivityService extends IConnectivityManager.Stub
 
         if (isTetheringSupported()) {
             final int status = mTethering.untether(iface);
+            if (status == ConnectivityManager.TETHER_ERROR_NO_ERROR) {
+                try {
+                    mPolicyManager.onTetheringChanged(iface, false);
+                } catch (RemoteException e) {
+                }
+            }
             return status;
         } else {
             return ConnectivityManager.TETHER_ERROR_UNSUPPORTED;
@@ -4458,7 +4470,7 @@ public class ConnectivityService extends IConnectivityManager.Stub
     }
 
     private void updateLinkProperties(NetworkAgentInfo networkAgent, LinkProperties oldLp) {
-        LinkProperties newLp = networkAgent.linkProperties;
+        LinkProperties newLp = new LinkProperties(networkAgent.linkProperties);
         int netId = networkAgent.network.netId;
 
         // The NetworkAgentInfo does not know whether clatd is running on its network or not. Before
@@ -4486,6 +4498,9 @@ public class ConnectivityService extends IConnectivityManager.Stub
         }
         // TODO - move this check to cover the whole function
         if (!Objects.equals(newLp, oldLp)) {
+            synchronized (networkAgent) {
+                networkAgent.linkProperties = newLp;
+            }
             notifyIfacesChangedForNetworkStats();
             notifyNetworkCallbacks(networkAgent, ConnectivityManager.CALLBACK_IP_CHANGED);
         }
@@ -4924,6 +4939,13 @@ public class ConnectivityService extends IConnectivityManager.Stub
             // check if it satisfies the NetworkCapabilities
             if (VDBG) log("  checking if request is satisfied: " + nri.request);
             if (satisfies) {
+                if (nri.request.isListen()) {
+                    // This is not a request, it's a callback listener.
+                    // Add it to newNetwork regardless of score.
+                    if (newNetwork.addRequest(nri.request)) addedRequests.add(nri);
+                    continue;
+                }
+
                 // next check if it's better than any current network we're using for
                 // this request
                 if (VDBG) {
diff --git a/services/core/java/com/android/server/NetworkManagementService.java b/services/core/java/com/android/server/NetworkManagementService.java
index bdbd06640e4..aebe77a0849 100644
--- a/services/core/java/com/android/server/NetworkManagementService.java
+++ b/services/core/java/com/android/server/NetworkManagementService.java
@@ -1864,6 +1864,8 @@ public class NetworkManagementService extends INetworkManagementService.Stub
     @Override
     public void setAllowOnlyVpnForUids(boolean add, UidRange[] uidRanges)
             throws ServiceSpecificException {
+        mContext.enforceCallingOrSelfPermission(android.Manifest.permission.NETWORK_STACK, TAG);
+
         try {
             mNetdService.networkRejectNonSecureVpn(add, uidRanges);
         } catch (ServiceSpecificException e) {
diff --git a/services/core/java/com/android/server/accounts/AccountManagerService.java b/services/core/java/com/android/server/accounts/AccountManagerService.java
index a7a79cd5b3e..a085b716bd8 100644
--- a/services/core/java/com/android/server/accounts/AccountManagerService.java
+++ b/services/core/java/com/android/server/accounts/AccountManagerService.java
@@ -4184,6 +4184,10 @@ public class AccountManagerService
         protected void checkKeyIntent(
                 int authUid,
                 Intent intent) throws SecurityException {
+            intent.setFlags(intent.getFlags() & ~(Intent.FLAG_GRANT_READ_URI_PERMISSION
+                    | Intent.FLAG_GRANT_WRITE_URI_PERMISSION
+                    | Intent.FLAG_GRANT_PERSISTABLE_URI_PERMISSION
+                    | Intent.FLAG_GRANT_PREFIX_URI_PERMISSION));
             long bid = Binder.clearCallingIdentity();
             try {
                 PackageManager pm = mContext.getPackageManager();
diff --git a/services/core/java/com/android/server/am/ActivityManagerService.java b/services/core/java/com/android/server/am/ActivityManagerService.java
index 91c4571ee49..7be177a1bc2 100644
--- a/services/core/java/com/android/server/am/ActivityManagerService.java
+++ b/services/core/java/com/android/server/am/ActivityManagerService.java
@@ -8112,13 +8112,26 @@ public final class ActivityManagerService extends ActivityManagerNative
             }
         }
 
+        // Figure out the value returned when access is allowed
+        final int allowedResult;
+        if ((modeFlags & Intent.FLAG_GRANT_PERSISTABLE_URI_PERMISSION) != 0) {
+            // If we're extending a persistable grant, then we need to return
+            // "targetUid" so that we always create a grant data structure to
+            // support take/release APIs
+            allowedResult = targetUid;
+        } else {
+            // Otherwise, we can return "-1" to indicate that no grant data
+            // structures need to be created
+            allowedResult = -1;
+        }
+
         if (targetUid >= 0) {
             // First...  does the target actually need this permission?
             if (checkHoldingPermissionsLocked(pm, pi, grantUri, targetUid, modeFlags)) {
                 // No need to grant the target this permission.
                 if (DEBUG_URI_PERMISSION) Slog.v(TAG_URI_PERMISSION,
                         "Target " + targetPkg + " already has full permission to " + grantUri);
-                return -1;
+                return allowedResult;
             }
         } else {
             // First...  there is no target package, so can anyone access it?
@@ -8134,7 +8147,7 @@ public final class ActivityManagerService extends ActivityManagerNative
                 }
             }
             if (allowed) {
-                return -1;
+                return allowedResult;
             }
         }
 
diff --git a/services/core/java/com/android/server/am/ActivityStackSupervisor.java b/services/core/java/com/android/server/am/ActivityStackSupervisor.java
index c6ab9186456..6115bf3ffd0 100644
--- a/services/core/java/com/android/server/am/ActivityStackSupervisor.java
+++ b/services/core/java/com/android/server/am/ActivityStackSupervisor.java
@@ -2855,10 +2855,10 @@ public final class ActivityStackSupervisor implements DisplayListener {
         }
 
         removeSleepTimeouts();
-
         if (mGoingToSleep.isHeld()) {
             mGoingToSleep.release();
         }
+
         if (mService.mShuttingDown) {
             mService.notifyAll();
         }
@@ -3977,18 +3977,11 @@ public final class ActivityStackSupervisor implements DisplayListener {
                             mLockTaskNotify = new LockTaskNotify(mService.mContext);
                         }
                         mLockTaskNotify.show(false);
-                        try {
-                            boolean shouldLockKeyguard = Settings.Secure.getInt(
-                                    mService.mContext.getContentResolver(),
-                                    Settings.Secure.LOCK_TO_APP_EXIT_LOCKED) != 0;
-                            if (mLockTaskModeState == LOCK_TASK_MODE_PINNED && shouldLockKeyguard) {
-                                mWindowManager.lockNow(null);
-                                mWindowManager.dismissKeyguard();
-                                new LockPatternUtils(mService.mContext)
-                                        .requireCredentialEntry(UserHandle.USER_ALL);
-                            }
-                        } catch (SettingNotFoundException e) {
-                            // No setting, don't lock.
+                        if (mLockTaskModeState == LOCK_TASK_MODE_PINNED && shouldLockKeyguard()) {
+                            mWindowManager.lockNow(null);
+                            mWindowManager.dismissKeyguard();
+                            new LockPatternUtils(mService.mContext)
+                                    .requireCredentialEntry(UserHandle.USER_ALL);
                         }
                     } catch (RemoteException ex) {
                         throw new RuntimeException(ex);
@@ -4025,6 +4018,21 @@ public final class ActivityStackSupervisor implements DisplayListener {
         }
     }
 
+    private boolean shouldLockKeyguard() {
+        // This functionality should be kept consistent with
+        // com.android.settings.security.ScreenPinningSettings (see b/127605586)
+        try {
+            return Settings.Secure.getInt(
+                    mService.mContext.getContentResolver(),
+                    Settings.Secure.LOCK_TO_APP_EXIT_LOCKED) != 0;
+        } catch (Settings.SettingNotFoundException e) {
+            // Log to SafetyNet for b/127605586
+            android.util.EventLog.writeEvent(0x534e4554, "127605586", -1, "");
+            LockPatternUtils lockPatternUtils = new LockPatternUtils(mService.mContext);
+            return lockPatternUtils.isSecure(mCurrentUser);
+        }
+    }
+
     class ActivityContainer extends android.app.IActivityContainer.Stub {
         final static int FORCE_NEW_TASK_FLAGS = FLAG_ACTIVITY_NEW_TASK |
                 FLAG_ACTIVITY_MULTIPLE_TASK | Intent.FLAG_ACTIVITY_NO_ANIMATION;
diff --git a/services/core/java/com/android/server/clipboard/ClipboardService.java b/services/core/java/com/android/server/clipboard/ClipboardService.java
index 66aa40325a4..6f59e845219 100644
--- a/services/core/java/com/android/server/clipboard/ClipboardService.java
+++ b/services/core/java/com/android/server/clipboard/ClipboardService.java
@@ -20,6 +20,7 @@ import android.app.ActivityManagerNative;
 import android.app.AppGlobals;
 import android.app.AppOpsManager;
 import android.app.IActivityManager;
+import android.app.KeyguardManager;
 import android.content.BroadcastReceiver;
 import android.content.ClipData;
 import android.content.ClipDescription;
@@ -255,7 +256,7 @@ public class ClipboardService extends IClipboard.Stub {
     public ClipData getPrimaryClip(String pkg) {
         synchronized (this) {
             if (mAppOps.noteOp(AppOpsManager.OP_READ_CLIPBOARD, Binder.getCallingUid(),
-                    pkg) != AppOpsManager.MODE_ALLOWED) {
+                    pkg) != AppOpsManager.MODE_ALLOWED || isDeviceLocked()) {
                 return null;
             }
             addActiveOwnerLocked(Binder.getCallingUid(), pkg);
@@ -266,7 +267,7 @@ public class ClipboardService extends IClipboard.Stub {
     public ClipDescription getPrimaryClipDescription(String callingPackage) {
         synchronized (this) {
             if (mAppOps.checkOp(AppOpsManager.OP_READ_CLIPBOARD, Binder.getCallingUid(),
-                    callingPackage) != AppOpsManager.MODE_ALLOWED) {
+                    callingPackage) != AppOpsManager.MODE_ALLOWED || isDeviceLocked()) {
                 return null;
             }
             PerUserClipboard clipboard = getClipboard();
@@ -277,7 +278,7 @@ public class ClipboardService extends IClipboard.Stub {
     public boolean hasPrimaryClip(String callingPackage) {
         synchronized (this) {
             if (mAppOps.checkOp(AppOpsManager.OP_READ_CLIPBOARD, Binder.getCallingUid(),
-                    callingPackage) != AppOpsManager.MODE_ALLOWED) {
+                    callingPackage) != AppOpsManager.MODE_ALLOWED || isDeviceLocked()) {
                 return false;
             }
             return getClipboard().primaryClip != null;
@@ -301,7 +302,7 @@ public class ClipboardService extends IClipboard.Stub {
     public boolean hasClipboardText(String callingPackage) {
         synchronized (this) {
             if (mAppOps.checkOp(AppOpsManager.OP_READ_CLIPBOARD, Binder.getCallingUid(),
-                    callingPackage) != AppOpsManager.MODE_ALLOWED) {
+                    callingPackage) != AppOpsManager.MODE_ALLOWED || isDeviceLocked()) {
                 return false;
             }
             PerUserClipboard clipboard = getClipboard();
@@ -313,6 +314,17 @@ public class ClipboardService extends IClipboard.Stub {
         }
     }
 
+    private boolean isDeviceLocked() {
+        final long token = Binder.clearCallingIdentity();
+        try {
+            final KeyguardManager keyguardManager = mContext.getSystemService(
+                    KeyguardManager.class);
+            return keyguardManager != null && keyguardManager.isDeviceLocked();
+        } finally {
+            Binder.restoreCallingIdentity(token);
+        }
+    }
+
     private final void checkUriOwnerLocked(Uri uri, int uid) {
         if (!"content".equals(uri.getScheme())) {
             return;
diff --git a/services/core/java/com/android/server/content/SyncStorageEngine.java b/services/core/java/com/android/server/content/SyncStorageEngine.java
index 069ae739431..f804fa1cff3 100644
--- a/services/core/java/com/android/server/content/SyncStorageEngine.java
+++ b/services/core/java/com/android/server/content/SyncStorageEngine.java
@@ -18,6 +18,7 @@ package com.android.server.content;
 
 import android.accounts.Account;
 import android.accounts.AccountAndUser;
+import android.accounts.AccountManager;
 import android.app.backup.BackupManager;
 import android.content.ComponentName;
 import android.content.ContentResolver;
@@ -27,6 +28,7 @@ import android.content.PeriodicSync;
 import android.content.SyncInfo;
 import android.content.SyncRequest;
 import android.content.SyncStatusInfo;
+import android.content.pm.PackageManager;
 import android.database.Cursor;
 import android.database.sqlite.SQLiteDatabase;
 import android.database.sqlite.SQLiteException;
@@ -350,6 +352,50 @@ public class SyncStorageEngine extends Handler {
         void onAuthorityRemoved(EndPoint removedAuthority);
     }
 
+    /**
+     * Validator that maintains a lazy cache of accounts and providers to tell if an authority or
+     * account is valid.
+     */
+    private static class AccountAuthorityValidator {
+        final private AccountManager mAccountManager;
+        final private PackageManager mPackageManager;
+        final private SparseArray<Account[]> mAccountsCache;
+        final private SparseArray<ArrayMap<String, Boolean>> mProvidersPerUserCache;
+
+        AccountAuthorityValidator(Context context) {
+            mAccountManager = context.getSystemService(AccountManager.class);
+            mPackageManager = context.getPackageManager();
+            mAccountsCache = new SparseArray<>();
+            mProvidersPerUserCache = new SparseArray<>();
+        }
+
+        // An account is valid if an installed authenticator has previously created that account
+        // on the device
+        boolean isAccountValid(Account account, int userId) {
+            Account[] accountsForUser = mAccountsCache.get(userId);
+            if (accountsForUser == null) {
+                accountsForUser = mAccountManager.getAccountsAsUser(userId);
+                mAccountsCache.put(userId, accountsForUser);
+            }
+            return ArrayUtils.contains(accountsForUser, account);
+        }
+
+        // An authority is only valid if it has a content provider installed on the system
+        boolean isAuthorityValid(String authority, int userId) {
+            ArrayMap<String, Boolean> authorityMap = mProvidersPerUserCache.get(userId);
+            if (authorityMap == null) {
+                authorityMap = new ArrayMap<>();
+                mProvidersPerUserCache.put(userId, authorityMap);
+            }
+            if (!authorityMap.containsKey(authority)) {
+                authorityMap.put(authority, mPackageManager.resolveContentProviderAsUser(authority,
+                        PackageManager.MATCH_DIRECT_BOOT_AWARE
+                                | PackageManager.MATCH_DIRECT_BOOT_UNAWARE, userId) != null);
+            }
+            return authorityMap.get(authority);
+        }
+    }
+
     // Primary list of all syncable authorities.  Also our global lock.
     private final SparseArray<AuthorityInfo> mAuthorities =
             new SparseArray<AuthorityInfo>();
@@ -1502,12 +1548,13 @@ public class SyncStorageEngine extends Handler {
                 eventType = parser.next();
                 AuthorityInfo authority = null;
                 PeriodicSync periodicSync = null;
+                AccountAuthorityValidator validator = new AccountAuthorityValidator(mContext);
                 do {
                     if (eventType == XmlPullParser.START_TAG) {
                         tagName = parser.getName();
                         if (parser.getDepth() == 2) {
                             if ("authority".equals(tagName)) {
-                                authority = parseAuthority(parser, version);
+                                authority = parseAuthority(parser, version, validator);
                                 periodicSync = null;
                                 if (authority != null) {
                                     if (authority.ident > highestAuthorityId) {
@@ -1636,7 +1683,8 @@ public class SyncStorageEngine extends Handler {
         mMasterSyncAutomatically.put(userId, listen);
     }
 
-    private AuthorityInfo parseAuthority(XmlPullParser parser, int version) {
+    private AuthorityInfo parseAuthority(XmlPullParser parser, int version,
+            AccountAuthorityValidator validator) {
         AuthorityInfo authority = null;
         int id = -1;
         try {
@@ -1676,21 +1724,26 @@ public class SyncStorageEngine extends Handler {
                 if (Log.isLoggable(TAG_FILE, Log.VERBOSE)) {
                     Slog.v(TAG_FILE, "Creating authority entry");
                 }
-                EndPoint info = null;
                 if (accountName != null && authorityName != null) {
-                    info = new EndPoint(
+                    EndPoint info = new EndPoint(
                             new Account(accountName, accountType),
                             authorityName, userId);
-                }
-                if (info != null) {
-                    authority = getOrCreateAuthorityLocked(info, id, false);
-                    // If the version is 0 then we are upgrading from a file format that did not
-                    // know about periodic syncs. In that case don't clear the list since we
-                    // want the default, which is a daily periodic sync.
-                    // Otherwise clear out this default list since we will populate it later with
-                    // the periodic sync descriptions that are read from the configuration file.
-                    if (version > 0) {
-                        authority.periodicSyncs.clear();
+                    if (validator.isAccountValid(info.account, userId)
+                            && validator.isAuthorityValid(authorityName, userId)) {
+                        authority = getOrCreateAuthorityLocked(info, id, false);
+                        // If the version is 0 then we are upgrading from a file format that did not
+                        // know about periodic syncs. In that case don't clear the list since we
+                        // want the default, which is a daily periodic sync.
+                        // Otherwise clear out this default list since we will populate it later
+                        // with
+                        // the periodic sync descriptions that are read from the configuration file.
+                        if (version > 0) {
+                            authority.periodicSyncs.clear();
+                        }
+                    } else {
+                        EventLog.writeEvent(0x534e4554, "35028827", -1,
+                                "account:" + info.account + " provider:" + authorityName + " user:"
+                                        + userId);
                     }
                 }
             }
diff --git a/services/core/java/com/android/server/display/ColorFade.java b/services/core/java/com/android/server/display/ColorFade.java
index a16fcd2fa11..7a5f5231869 100644
--- a/services/core/java/com/android/server/display/ColorFade.java
+++ b/services/core/java/com/android/server/display/ColorFade.java
@@ -36,6 +36,7 @@ import android.opengl.EGLDisplay;
 import android.opengl.EGLSurface;
 import android.opengl.GLES20;
 import android.opengl.GLES11Ext;
+import android.os.SystemProperties;
 import android.util.Slog;
 import android.view.DisplayInfo;
 import android.view.Surface.OutOfResourcesException;
@@ -70,6 +71,9 @@ final class ColorFade {
     // See code for details.
     private static final int DEJANK_FRAMES = 3;
 
+    private static final boolean DESTROY_SURFACE_AFTER_DETACH =
+            SystemProperties.getBoolean("ro.egl.destroy_after_detach", false);
+
     private final int mDisplayId;
 
     // Set to true when the animation context has been fully prepared.
@@ -331,10 +335,15 @@ final class ColorFade {
                 destroyScreenshotTexture();
                 destroyGLShaders();
                 destroyGLBuffers();
-                destroyEglSurface();
+                if (!DESTROY_SURFACE_AFTER_DETACH) {
+                    destroyEglSurface();
+                }
             } finally {
                 detachEglContext();
             }
+            if (DESTROY_SURFACE_AFTER_DETACH) {
+                destroyEglSurface();
+            }
             // This is being called with no active context so shouldn't be
             // needed but is safer to not change for now.
             GLES20.glFlush();
diff --git a/services/core/java/com/android/server/input/InputManagerService.java b/services/core/java/com/android/server/input/InputManagerService.java
index 719ce7618fd..df2c00be83d 100644
--- a/services/core/java/com/android/server/input/InputManagerService.java
+++ b/services/core/java/com/android/server/input/InputManagerService.java
@@ -286,6 +286,9 @@ public class InputManagerService extends IInputManager.Stub
     /** Switch code: Camera lens cover. When set the lens is covered. */
     public static final int SW_CAMERA_LENS_COVER = 0x09;
 
+    /** Switch code: Rotation Lock.  When set, rotation is locked. */
+    public static final int SW_ROTATE_LOCK = 0x0c;
+
     public static final int SW_LID_BIT = 1 << SW_LID;
     public static final int SW_TABLET_MODE_BIT = 1 << SW_TABLET_MODE;
     public static final int SW_KEYPAD_SLIDE_BIT = 1 << SW_KEYPAD_SLIDE;
@@ -296,6 +299,7 @@ public class InputManagerService extends IInputManager.Stub
     public static final int SW_JACK_BITS =
             SW_HEADPHONE_INSERT_BIT | SW_MICROPHONE_INSERT_BIT | SW_JACK_PHYSICAL_INSERT_BIT | SW_LINEOUT_INSERT_BIT;
     public static final int SW_CAMERA_LENS_COVER_BIT = 1 << SW_CAMERA_LENS_COVER;
+    public static final int SW_ROTATE_LOCK_BIT = 1 << SW_ROTATE_LOCK;
 
     /** Whether to use the dev/input/event or uevent subsystem for the audio jack. */
     final boolean mUseDevInputEventForAudioJack;
@@ -1831,6 +1835,11 @@ public class InputManagerService extends IInputManager.Stub
                     switchMask);
         }
 
+        if ((switchMask & SW_ROTATE_LOCK_BIT) != 0) {
+            final boolean isLocked = ((switchValues & SW_ROTATE_LOCK_BIT) != 0);
+            mWindowManagerCallbacks.notifyRotateLockSwitchChanged(whenNanos, isLocked);
+        }
+
         if ((switchMask & SW_TABLET_MODE_BIT) != 0) {
             SomeArgs args = SomeArgs.obtain();
             args.argi1 = (int) (whenNanos & 0xFFFFFFFF);
@@ -2032,6 +2041,8 @@ public class InputManagerService extends IInputManager.Stub
 
         public void notifyCameraLensCoverSwitchChanged(long whenNanos, boolean lensCovered);
 
+        public void notifyRotateLockSwitchChanged(long whenNanos, boolean isLocked);
+
         public void notifyInputChannelBroken(InputWindowHandle inputWindowHandle);
 
         public long notifyANR(InputApplicationHandle inputApplicationHandle,
diff --git a/services/core/java/com/android/server/pm/PackageManagerService.java b/services/core/java/com/android/server/pm/PackageManagerService.java
index b6a99408122..6ccc128fff7 100644
--- a/services/core/java/com/android/server/pm/PackageManagerService.java
+++ b/services/core/java/com/android/server/pm/PackageManagerService.java
@@ -423,7 +423,7 @@ public class PackageManagerService extends IPackageManager.Stub {
      * one gets run at the next available charging+idle time.  This final mandatory
      * no-fstrim check kicks in only of the other scheduling criteria is never met.
      */
-    private static final long DEFAULT_MANDATORY_FSTRIM_INTERVAL = 3 * DateUtils.DAY_IN_MILLIS;
+    private static final long DEFAULT_MANDATORY_FSTRIM_INTERVAL = 1 * DateUtils.DAY_IN_MILLIS;
 
     /**
      * Whether verification is enabled by default.
@@ -15686,6 +15686,13 @@ public class PackageManagerService extends IPackageManager.Stub {
 
     @Override
     public boolean isPackageDeviceAdminOnAnyUser(String packageName) {
+	final int callingUid = Binder.getCallingUid();
+        if (checkUidPermission(android.Manifest.permission.MANAGE_USERS, callingUid)
+                != PERMISSION_GRANTED) {
+            EventLog.writeEvent(0x534e4554, "128599183", -1, "");
+            throw new SecurityException(android.Manifest.permission.MANAGE_USERS
+                    + " permission is required to call this API");
+        }
         return isPackageDeviceAdmin(packageName, UserHandle.USER_ALL);
     }
 
diff --git a/services/core/java/com/android/server/pm/ShortcutService.java b/services/core/java/com/android/server/pm/ShortcutService.java
index 6e8799e8132..b33cbfd6b0c 100644
--- a/services/core/java/com/android/server/pm/ShortcutService.java
+++ b/services/core/java/com/android/server/pm/ShortcutService.java
@@ -124,6 +124,7 @@ import java.nio.charset.StandardCharsets;
 import java.util.ArrayList;
 import java.util.Collections;
 import java.util.List;
+import java.util.Objects;
 import java.util.concurrent.atomic.AtomicBoolean;
 import java.util.function.Consumer;
 import java.util.function.Predicate;
@@ -1523,6 +1524,24 @@ public class ShortcutService extends IShortcutService.Stub {
         throw new SecurityException("Calling package name mismatch");
     }
 
+    private void verifyShortcutInfoPackage(String callerPackage, ShortcutInfo si) {
+        if (si == null) {
+            return;
+        }
+        if (!Objects.equals(callerPackage, si.getPackage())) {
+            android.util.EventLog.writeEvent(0x534e4554, "109824443", -1, "");
+            throw new SecurityException("Shortcut package name mismatch");
+        }
+    }
+
+    private void verifyShortcutInfoPackages(
+            String callerPackage, List<ShortcutInfo> list) {
+        final int size = list.size();
+        for (int i = 0; i < size; i++) {
+            verifyShortcutInfoPackage(callerPackage, list.get(i));
+        }
+    }
+
     // Overridden in unit tests to execute r synchronously.
     void injectPostToHandler(Runnable r) {
         mHandler.post(r);
@@ -1651,6 +1670,7 @@ public class ShortcutService extends IShortcutService.Stub {
         verifyCaller(packageName, userId);
 
         final List<ShortcutInfo> newShortcuts = (List<ShortcutInfo>) shortcutInfoList.getList();
+        verifyShortcutInfoPackages(packageName, newShortcuts);
         final int size = newShortcuts.size();
 
         synchronized (mLock) {
@@ -1702,6 +1722,7 @@ public class ShortcutService extends IShortcutService.Stub {
         verifyCaller(packageName, userId);
 
         final List<ShortcutInfo> newShortcuts = (List<ShortcutInfo>) shortcutInfoList.getList();
+        verifyShortcutInfoPackages(packageName, newShortcuts);
         final int size = newShortcuts.size();
 
         synchronized (mLock) {
@@ -1782,6 +1803,7 @@ public class ShortcutService extends IShortcutService.Stub {
         verifyCaller(packageName, userId);
 
         final List<ShortcutInfo> newShortcuts = (List<ShortcutInfo>) shortcutInfoList.getList();
+        verifyShortcutInfoPackages(packageName, newShortcuts);
         final int size = newShortcuts.size();
 
         synchronized (mLock) {
diff --git a/services/core/java/com/android/server/policy/PhoneWindowManager.java b/services/core/java/com/android/server/policy/PhoneWindowManager.java
index 889c52afa37..872b03d2f09 100644
--- a/services/core/java/com/android/server/policy/PhoneWindowManager.java
+++ b/services/core/java/com/android/server/policy/PhoneWindowManager.java
@@ -491,6 +491,9 @@ public class PhoneWindowManager implements WindowManagerPolicy {
     boolean mTranslucentDecorEnabled = true;
     boolean mUseTvRouting;
 
+    // Behavior of home wake
+    boolean mHomeWakeScreen;
+
     int mPointerLocationMode = 0; // guarded by mLock
 
     // The last window we were told about in focusChanged.
@@ -877,6 +880,10 @@ public class PhoneWindowManager implements WindowManagerPolicy {
             resolver.registerContentObserver(Settings.Global.getUriFor(
                     Settings.Global.POLICY_CONTROL), false, this,
                     UserHandle.USER_ALL);
+            resolver.registerContentObserver(Settings.System.getUriFor(
+                    Settings.System.HOME_WAKE_SCREEN), false, this,
+                    UserHandle.USER_ALL);
+
             updateSettings();
         }
 
@@ -2067,6 +2074,8 @@ public class PhoneWindowManager implements WindowManagerPolicy {
                     Settings.Secure.INCALL_BACK_BUTTON_BEHAVIOR,
                     Settings.Secure.INCALL_BACK_BUTTON_BEHAVIOR_DEFAULT,
                     UserHandle.USER_CURRENT);
+            mHomeWakeScreen = (Settings.System.getIntForUser(resolver,
+                    Settings.System.HOME_WAKE_SCREEN, 1, UserHandle.USER_CURRENT) == 1);
 
             // Configure wake gesture.
             boolean wakeGestureEnabledSetting = Settings.Secure.getIntForUser(resolver,
@@ -3881,8 +3890,9 @@ public class PhoneWindowManager implements WindowManagerPolicy {
                 awakenDreams();
             }
             hideRecentApps(false, true);
-        } else {
-            // Otherwise, just launch Home
+        } else if (mScreenOnFully) {
+            // check if screen is fully on before going home
+            // to avoid hardware home button wake going home
             sendCloseSystemWindows(SYSTEM_DIALOG_REASON_HOME_KEY);
             startDockOrHome(true /*fromHomeKey*/, awakenFromDreams);
         }
@@ -5567,6 +5577,18 @@ public class PhoneWindowManager implements WindowManagerPolicy {
         mCameraLensCoverState = lensCoverState;
     }
 
+    /** {@inheritDoc} */
+    public void notifyRotateLockSwitchChanged(long whenNanos, boolean isLocked) {
+        try {
+            if (isLocked)
+                mWindowManager.freezeRotation(-1);
+            else
+                mWindowManager.thawRotation();
+        } catch (RemoteException e) {
+            // Ignore
+        }
+    }
+
     void setHdmiPlugged(boolean plugged) {
         if (mHdmiPlugged != plugged) {
             mHdmiPlugged = plugged;
@@ -5884,6 +5906,12 @@ public class PhoneWindowManager implements WindowManagerPolicy {
                 break;
             }
 
+            case KeyEvent.KEYCODE_HOME:
+                if (down && !interactive && mHomeWakeScreen) {
+                    isWakeKey = true;
+                }
+                break;
+
             case KeyEvent.KEYCODE_ENDCALL: {
                 result &= ~ACTION_PASS_TO_USER;
                 if (down) {
diff --git a/services/core/java/com/android/server/policy/WindowOrientationListener.java b/services/core/java/com/android/server/policy/WindowOrientationListener.java
index 8ef0acbd380..a884851d242 100644
--- a/services/core/java/com/android/server/policy/WindowOrientationListener.java
+++ b/services/core/java/com/android/server/policy/WindowOrientationListener.java
@@ -56,6 +56,7 @@ public abstract class WindowOrientationListener {
     private boolean mEnabled;
     private int mRate;
     private String mSensorType;
+    private boolean mUseSystemClockforRotationSensor;
     private Sensor mSensor;
     private OrientationJudge mOrientationJudge;
     private int mCurrentRotation = -1;
@@ -90,6 +91,9 @@ public abstract class WindowOrientationListener {
         mRate = rate;
         mSensor = mSensorManager.getDefaultSensor(Sensor.TYPE_DEVICE_ORIENTATION);
 
+        mUseSystemClockforRotationSensor = context.getResources().getBoolean(
+                com.android.internal.R.bool.config_useSystemClockforRotationSensor);
+
         if (mSensor != null) {
             mOrientationJudge = new OrientationSensorJudge();
         }
@@ -592,7 +596,8 @@ public abstract class WindowOrientationListener {
                 // Reset the orientation listener state if the samples are too far apart in time
                 // or when we see values of (0, 0, 0) which indicates that we polled the
                 // accelerometer too soon after turning it on and we don't have any data yet.
-                final long now = event.timestamp;
+                final long now = mUseSystemClockforRotationSensor
+                        ? SystemClock.elapsedRealtimeNanos() : event.timestamp;
                 final long then = mLastFilteredTimestampNanos;
                 final float timeDeltaMS = (now - then) * 0.000001f;
                 final boolean skipSample;
diff --git a/services/core/java/com/android/server/wm/InputMonitor.java b/services/core/java/com/android/server/wm/InputMonitor.java
index be9fb26bb28..d835e884615 100644
--- a/services/core/java/com/android/server/wm/InputMonitor.java
+++ b/services/core/java/com/android/server/wm/InputMonitor.java
@@ -392,6 +392,12 @@ final class InputMonitor implements InputManagerService.WindowManagerCallbacks {
         mService.mPolicy.notifyCameraLensCoverSwitchChanged(whenNanos, lensCovered);
     }
 
+    /* Notifies that the rotation lock switch changed state. */
+    @Override
+    public void notifyRotateLockSwitchChanged(long whenNanos, boolean isLocked) {
+        mService.mPolicy.notifyRotateLockSwitchChanged(whenNanos, isLocked);
+    }
+
     /* Provides an opportunity for the window manager policy to intercept early key
      * processing as soon as the key has been read from the device. */
     @Override
diff --git a/services/core/java/com/android/server/wm/Session.java b/services/core/java/com/android/server/wm/Session.java
index 08c0a4b0135..b5c4202dc10 100644
--- a/services/core/java/com/android/server/wm/Session.java
+++ b/services/core/java/com/android/server/wm/Session.java
@@ -16,6 +16,9 @@
 
 package com.android.server.wm;
 
+import static android.Manifest.permission.HIDE_NON_SYSTEM_OVERLAY_WINDOWS;
+import static android.Manifest.permission.INTERNAL_SYSTEM_WINDOW;
+import static android.content.pm.PackageManager.PERMISSION_GRANTED;
 import static com.android.server.wm.WindowManagerDebugConfig.DEBUG_DRAG;
 import static com.android.server.wm.WindowManagerDebugConfig.DEBUG_TASK_POSITIONING;
 import static com.android.server.wm.WindowManagerDebugConfig.SHOW_LIGHT_TRANSACTIONS;
@@ -67,6 +70,8 @@ final class Session extends IWindowSession.Stub
     final int mUid;
     final int mPid;
     final String mStringName;
+    final boolean mCanAddInternalSystemWindow;
+    final boolean mCanHideNonSystemOverlayWindows;
     SurfaceSession mSurfaceSession;
     int mNumWindow = 0;
     boolean mClientDead = false;
@@ -80,6 +85,10 @@ final class Session extends IWindowSession.Stub
         mInputContext = inputContext;
         mUid = Binder.getCallingUid();
         mPid = Binder.getCallingPid();
+        mCanAddInternalSystemWindow = service.mContext.checkCallingOrSelfPermission(
+                INTERNAL_SYSTEM_WINDOW) == PERMISSION_GRANTED;
+        mCanHideNonSystemOverlayWindows = service.mContext.checkCallingOrSelfPermission(
+                HIDE_NON_SYSTEM_OVERLAY_WINDOWS) == PERMISSION_GRANTED;
         mLastReportedAnimatorScale = service.getCurrentAnimatorScale();
         StringBuilder sb = new StringBuilder();
         sb.append("Session{");
diff --git a/services/core/java/com/android/server/wm/WindowManagerService.java b/services/core/java/com/android/server/wm/WindowManagerService.java
index ca2610af3f6..be1d84f11ee 100644
--- a/services/core/java/com/android/server/wm/WindowManagerService.java
+++ b/services/core/java/com/android/server/wm/WindowManagerService.java
@@ -16,6 +16,7 @@
 
 package com.android.server.wm;
 
+import static android.view.WindowManager.LayoutParams.PRIVATE_FLAG_HIDE_NON_SYSTEM_OVERLAY_WINDOWS;
 import android.Manifest;
 import android.animation.ValueAnimator;
 import android.annotation.IntDef;
@@ -189,6 +190,7 @@ import static android.view.WindowManager.LayoutParams.INPUT_FEATURE_NO_INPUT_CHA
 import static android.view.WindowManager.LayoutParams.LAST_APPLICATION_WINDOW;
 import static android.view.WindowManager.LayoutParams.LAST_SUB_WINDOW;
 import static android.view.WindowManager.LayoutParams.PRIVATE_FLAG_COMPATIBLE_WINDOW;
+import static android.view.WindowManager.LayoutParams.PRIVATE_FLAG_HIDE_NON_SYSTEM_OVERLAY_WINDOWS;
 import static android.view.WindowManager.LayoutParams.TYPE_ACCESSIBILITY_OVERLAY;
 import static android.view.WindowManager.LayoutParams.TYPE_APPLICATION;
 import static android.view.WindowManager.LayoutParams.TYPE_APPLICATION_STARTING;
@@ -490,6 +492,9 @@ public class WindowManagerService extends IWindowManager.Stub
      */
     final ArrayList<WindowState> mForceRemoves = new ArrayList<>();
 
+    /** List of window currently causing non-system overlay windows to be hidden. */
+    private ArrayList<WindowState> mHidingNonSystemOverlayWindows = new ArrayList<WindowState>();
+
     /**
      * Windows that clients are waiting to have drawn.
      */
@@ -2129,6 +2134,9 @@ public class WindowManagerService extends IWindowManager.Stub
                 }
             }
 
+            final boolean hideSystemAlertWindows = !mHidingNonSystemOverlayWindows.isEmpty();
+            win.setForceHideNonSystemOverlayWindowIfNeeded(hideSystemAlertWindows);
+
             if (type == TYPE_APPLICATION_STARTING && token.appWindowToken != null) {
                 token.appWindowToken.startingWindow = win;
                 if (DEBUG_STARTING_WINDOW) Slog.v (TAG_WM, "addWindow: " + token.appWindowToken
@@ -2576,6 +2584,7 @@ public class WindowManagerService extends IWindowManager.Stub
 
         mPendingRemove.remove(win);
         mResizingWindows.remove(win);
+        updateNonSystemOverlayWindowsVisibilityIfNeeded(win, false /* surfaceShown */);
         mWindowsChanged = true;
         if (DEBUG_WINDOW_MOVEMENT) Slog.v(TAG_WM, "Final remove of window: " + win);
 
@@ -2893,6 +2902,11 @@ public class WindowManagerService extends IWindowManager.Stub
                         | WindowManager.LayoutParams.SYSTEM_UI_VISIBILITY_CHANGED)) != 0) {
                     win.mLayoutNeeded = true;
                 }
+
+                if ((flagChanges & PRIVATE_FLAG_HIDE_NON_SYSTEM_OVERLAY_WINDOWS) != 0) {
+                    updateNonSystemOverlayWindowsVisibilityIfNeeded(
+                            win, win.mWinAnimator.getShown());
+                }
             }
 
             if (DEBUG_LAYOUT) Slog.v(TAG_WM, "Relayout " + win + ": viewVisibility=" + viewVisibility
@@ -11771,4 +11785,35 @@ public class WindowManagerService extends IWindowManager.Stub
             }
         }
     }
+
+    void updateNonSystemOverlayWindowsVisibilityIfNeeded(WindowState win, boolean surfaceShown) {
+        if (!win.hideNonSystemOverlayWindowsWhenVisible()
+                && !mHidingNonSystemOverlayWindows.contains(win)) {
+            return;
+        }
+        final boolean systemAlertWindowsHidden = !mHidingNonSystemOverlayWindows.isEmpty();
+        if (surfaceShown) {
+            if (!mHidingNonSystemOverlayWindows.contains(win)) {
+                mHidingNonSystemOverlayWindows.add(win);
+            }
+        } else {
+            mHidingNonSystemOverlayWindows.remove(win);
+        }
+
+        final boolean hideSystemAlertWindows = !mHidingNonSystemOverlayWindows.isEmpty();
+
+        if (systemAlertWindowsHidden == hideSystemAlertWindows) {
+            return;
+        }
+
+        final int numDisplays = mDisplayContents.size();
+        for (int displayNdx = 0; displayNdx < numDisplays; ++displayNdx) {
+            final WindowList windows = mDisplayContents.valueAt(displayNdx).getWindowList();
+            final int numWindows = windows.size();
+            for (int winNdx = 0; winNdx < numWindows; ++winNdx) {
+                final WindowState w = windows.get(winNdx);
+                w.setForceHideNonSystemOverlayWindowIfNeeded(hideSystemAlertWindows);
+            }
+        }
+    }
 }
diff --git a/services/core/java/com/android/server/wm/WindowState.java b/services/core/java/com/android/server/wm/WindowState.java
index fbef2c626a9..228ef1afb2a 100644
--- a/services/core/java/com/android/server/wm/WindowState.java
+++ b/services/core/java/com/android/server/wm/WindowState.java
@@ -79,6 +79,7 @@ import static android.view.WindowManager.LayoutParams.FLAG_TURN_SCREEN_ON;
 import static android.view.WindowManager.LayoutParams.LAST_SUB_WINDOW;
 import static android.view.WindowManager.LayoutParams.MATCH_PARENT;
 import static android.view.WindowManager.LayoutParams.PRIVATE_FLAG_COMPATIBLE_WINDOW;
+import static android.view.WindowManager.LayoutParams.PRIVATE_FLAG_HIDE_NON_SYSTEM_OVERLAY_WINDOWS;
 import static android.view.WindowManager.LayoutParams.PRIVATE_FLAG_KEYGUARD;
 import static android.view.WindowManager.LayoutParams.PRIVATE_FLAG_LAYOUT_CHILD_WINDOW_IN_PARENT_FRAME;
 import static android.view.WindowManager.LayoutParams.PRIVATE_FLAG_WILL_NOT_REPLACE_ON_RELAUNCH;
@@ -91,7 +92,9 @@ import static android.view.WindowManager.LayoutParams.TYPE_DRAWN_APPLICATION;
 import static android.view.WindowManager.LayoutParams.TYPE_DOCK_DIVIDER;
 import static android.view.WindowManager.LayoutParams.TYPE_INPUT_METHOD;
 import static android.view.WindowManager.LayoutParams.TYPE_INPUT_METHOD_DIALOG;
+import static android.view.WindowManager.LayoutParams.TYPE_TOAST;
 import static android.view.WindowManager.LayoutParams.TYPE_WALLPAPER;
+import static android.view.WindowManager.LayoutParams.isSystemAlertWindowType;
 import static android.view.WindowManagerPolicy.FINISH_LAYOUT_REDO_WALLPAPER;
 import static com.android.server.wm.DragResizeMode.DRAG_RESIZE_MODE_DOCKED_DIVIDER;
 import static com.android.server.wm.DragResizeMode.DRAG_RESIZE_MODE_FREEFORM;
@@ -141,6 +144,7 @@ final class WindowState implements WindowManagerPolicy.WindowState {
     final int mAppOp;
     // UserId and appId of the owner. Don't display windows of non-current user.
     final int mOwnerUid;
+    final boolean mOwnerCanAddInternalSystemWindow;
     final IWindowId mWindowId;
     WindowToken mToken;
     WindowToken mRootToken;
@@ -167,6 +171,8 @@ final class WindowState implements WindowManagerPolicy.WindowState {
     boolean mPolicyVisibilityAfterAnim = true;
     boolean mAppOpVisibility = true;
     boolean mPermanentlyHidden; // the window should never be shown again
+    // This is a non-system overlay window that is currently force hidden.
+    private boolean mForceHideNonSystemOverlayWindow;
     boolean mAppFreezing;
     boolean mAttachedHidden;    // is our parent window hidden?
     boolean mWallpaperVisible;  // for wallpaper, what was last vis report?
@@ -522,6 +528,7 @@ final class WindowState implements WindowManagerPolicy.WindowState {
         mAppOp = appOp;
         mToken = token;
         mOwnerUid = s.mUid;
+        mOwnerCanAddInternalSystemWindow = s.mCanAddInternalSystemWindow;
         mWindowId = new IWindowId.Stub() {
             @Override
             public void registerFocusObserver(IWindowFocusObserver observer) {
@@ -1882,6 +1889,10 @@ final class WindowState implements WindowManagerPolicy.WindowState {
             // to handle their windows being removed from under them.
             return false;
         }
+        if (mForceHideNonSystemOverlayWindow) {
+            // This is an alert window that is currently force hidden.
+            return false;
+        }
         if (mPolicyVisibility && mPolicyVisibilityAfterAnim) {
             // Already showing.
             return false;
@@ -1955,6 +1966,22 @@ final class WindowState implements WindowManagerPolicy.WindowState {
         return true;
     }
 
+    void setForceHideNonSystemOverlayWindowIfNeeded(boolean forceHide) {
+        if (mOwnerCanAddInternalSystemWindow
+                || (!isSystemAlertWindowType(mAttrs.type) && mAttrs.type != TYPE_TOAST)) {
+            return;
+        }
+        if (mForceHideNonSystemOverlayWindow == forceHide) {
+            return;
+        }
+        mForceHideNonSystemOverlayWindow = forceHide;
+        if (forceHide) {
+            hideLw(true /* doAnimation */, true /* requestAnim */);
+        } else {
+            showLw(true /* doAnimation */, true /* requestAnim */);
+        }
+    }
+
     public void setAppOpVisibilityLw(boolean state) {
         if (mAppOpVisibility != state) {
             mAppOpVisibility = state;
@@ -2755,6 +2782,17 @@ final class WindowState implements WindowManagerPolicy.WindowState {
         }
     }
 
+    /**
+     * Returns true if any window added by an application process that if of type
+     * {@link android.view.WindowManager.LayoutParams#TYPE_TOAST} or that requires that requires
+     * {@link android.app.AppOpsManager#OP_SYSTEM_ALERT_WINDOW} permission should be hidden when
+     * this window is visible.
+     */
+    boolean hideNonSystemOverlayWindowsWhenVisible() {
+        return (mAttrs.privateFlags & PRIVATE_FLAG_HIDE_NON_SYSTEM_OVERLAY_WINDOWS) != 0
+                && mSession.mCanHideNonSystemOverlayWindows;
+    }
+
     String makeInputChannelName() {
         return Integer.toHexString(System.identityHashCode(this))
             + " " + getWindowTag();
diff --git a/services/core/java/com/android/server/wm/WindowStateAnimator.java b/services/core/java/com/android/server/wm/WindowStateAnimator.java
index aa8e781b1c0..ec3208b3cc6 100644
--- a/services/core/java/com/android/server/wm/WindowStateAnimator.java
+++ b/services/core/java/com/android/server/wm/WindowStateAnimator.java
@@ -582,6 +582,7 @@ class WindowStateAnimator {
             //dump();
             mLastHidden = true;
             if (mSurfaceController != null) {
+                mService.updateNonSystemOverlayWindowsVisibilityIfNeeded(mWin, false);
                 mSurfaceController.hideInTransaction(reason);
             }
         }
@@ -1814,6 +1815,7 @@ class WindowStateAnimator {
         if (!shown)
             return false;
 
+        mService.updateNonSystemOverlayWindowsVisibilityIfNeeded(mWin, true);
         if (mWin.mTurnOnScreen) {
             if (DEBUG_VISIBILITY) Slog.v(TAG, "Show surface turning screen on: " + mWin);
             mWin.mTurnOnScreen = false;
diff --git a/services/devicepolicy/java/com/android/server/devicepolicy/DevicePolicyManagerService.java b/services/devicepolicy/java/com/android/server/devicepolicy/DevicePolicyManagerService.java
index e3b6ecc749c..e7f01282268 100644
--- a/services/devicepolicy/java/com/android/server/devicepolicy/DevicePolicyManagerService.java
+++ b/services/devicepolicy/java/com/android/server/devicepolicy/DevicePolicyManagerService.java
@@ -71,6 +71,7 @@ import android.content.pm.PackageManager;
 import android.content.pm.PackageManager.NameNotFoundException;
 import android.content.pm.PackageManagerInternal;
 import android.content.pm.ParceledListSlice;
+import android.content.pm.PermissionInfo;
 import android.content.pm.ResolveInfo;
 import android.content.pm.ServiceInfo;
 import android.content.pm.UserInfo;
@@ -123,6 +124,7 @@ import android.telephony.TelephonyManager;
 import android.text.TextUtils;
 import android.util.ArrayMap;
 import android.util.ArraySet;
+import android.util.EventLog;
 import android.util.Log;
 import android.util.Pair;
 import android.util.Slog;
@@ -3153,6 +3155,9 @@ public class DevicePolicyManagerService extends IDevicePolicyManager.Stub {
 
     @Override
     public boolean isSeparateProfileChallengeAllowed(int userHandle) {
+        if (!isCallerWithSystemUid()) {
+            throw new SecurityException("Caller must be system");
+        }
         ComponentName profileOwner = getProfileOwner(userHandle);
         // Profile challenge is supported on N or newer release.
         return profileOwner != null &&
@@ -7115,6 +7120,7 @@ public class DevicePolicyManagerService extends IDevicePolicyManager.Stub {
         if (!mHasFeature) {
             return null;
         }
+        enforceManageUsers();
         synchronized (this) {
             List<String> result = null;
             // If we have multiple profiles we return the intersection of the
@@ -8621,6 +8627,10 @@ public class DevicePolicyManagerService extends IDevicePolicyManager.Stub {
                         < android.os.Build.VERSION_CODES.M) {
                     return false;
                 }
+                if (!isRuntimePermission(permission)) {
+                    EventLog.writeEvent(0x534e4554, "62623498", user.getIdentifier(), "");
+                    return false;
+                }
                 final PackageManager packageManager = mContext.getPackageManager();
                 switch (grantState) {
                     case DevicePolicyManager.PERMISSION_GRANT_STATE_GRANTED: {
@@ -8646,6 +8656,8 @@ public class DevicePolicyManagerService extends IDevicePolicyManager.Stub {
                 return true;
             } catch (SecurityException se) {
                 return false;
+            } catch (NameNotFoundException e) {
+                return false;
             } finally {
                 mInjector.binderRestoreCallingIdentity(ident);
             }
@@ -8691,6 +8703,13 @@ public class DevicePolicyManagerService extends IDevicePolicyManager.Stub {
         }
     }
 
+    public boolean isRuntimePermission(String permissionName) throws NameNotFoundException {
+        PackageManager packageManager = mContext.getPackageManager();
+        PermissionInfo permissionInfo = packageManager.getPermissionInfo(permissionName, 0);
+        return (permissionInfo.protectionLevel & PermissionInfo.PROTECTION_MASK_BASE)
+                == PermissionInfo.PROTECTION_DANGEROUS;
+    }
+
     @Override
     public boolean isProvisioningAllowed(String action) {
         if (!mHasFeature) {
diff --git a/services/net/java/android/net/dhcp/DhcpClient.java b/services/net/java/android/net/dhcp/DhcpClient.java
index ffbea9fce27..8dd05b19ea7 100644
--- a/services/net/java/android/net/dhcp/DhcpClient.java
+++ b/services/net/java/android/net/dhcp/DhcpClient.java
@@ -40,6 +40,7 @@ import android.os.SystemClock;
 import android.system.ErrnoException;
 import android.system.Os;
 import android.system.PacketSocketAddress;
+import android.util.EventLog;
 import android.util.Log;
 import android.util.SparseArray;
 import android.util.TimeUtils;
@@ -369,6 +370,13 @@ public class DhcpClient extends StateMachine {
                     if (PACKET_DBG) {
                         Log.d(TAG, HexDump.dumpHexString(mPacket, 0, length));
                     }
+                    if (e.errorCode == DhcpErrorEvent.DHCP_NO_COOKIE) {
+                        int snetTagId = 0x534e4554;
+                        String bugId = "31850211";
+                        int uid = -1;
+                        String data = DhcpPacket.ParseException.class.getName();
+                        EventLog.writeEvent(snetTagId, bugId, uid, data);
+                    }
                     logError(e.errorCode);
                 }
             }
diff --git a/services/tests/Android.mk b/services/tests/Android.mk
deleted file mode 100644
index 40369ee2ec5..00000000000
--- a/services/tests/Android.mk
+++ /dev/null
@@ -1,3 +0,0 @@
-LOCAL_PATH:= $(call my-dir)
-
-include $(call all-makefiles-under, $(LOCAL_PATH))
diff --git a/services/tests/servicestests/Android.mk b/services/tests/servicestests/Android.mk
deleted file mode 100644
index 7886b5e9e39..00000000000
--- a/services/tests/servicestests/Android.mk
+++ /dev/null
@@ -1,87 +0,0 @@
-#########################################################################
-# Build FrameworksServicesTests package
-#########################################################################
-
-LOCAL_PATH:= $(call my-dir)
-include $(CLEAR_VARS)
-
-# We only want this apk build for tests.
-LOCAL_MODULE_TAGS := tests
-
-# Include all test java files.
-LOCAL_SRC_FILES := $(call all-java-files-under, src)
-
-LOCAL_STATIC_JAVA_LIBRARIES := \
-    frameworks-base-testutils \
-    services.core \
-    services.devicepolicy \
-    services.net \
-    services.usage \
-    easymocklib \
-    guava \
-    android-support-test \
-    mockito-target \
-    ShortcutManagerTestUtils \
-    truth-prebuilt
-
-LOCAL_JAVA_LIBRARIES := android.test.runner
-
-LOCAL_PACKAGE_NAME := FrameworksServicesTests
-
-LOCAL_CERTIFICATE := platform
-
-# These are not normally accessible from apps so they must be explicitly included.
-LOCAL_JNI_SHARED_LIBRARIES := libservicestestsjni \
-    libbacktrace \
-    libbase \
-    libbinder \
-    libc++ \
-    libcutils \
-    liblog \
-    liblzma \
-    libnativehelper \
-    libnetdaidl \
-    libui \
-    libunwind \
-    libutils
-
-LOCAL_ADDITIONAL_DEPENDENCIES := $(LOCAL_PATH)/Android.mk
-
-# Code coverage puts us over the dex limit, so enable multi-dex for coverage-enabled builds
-ifeq (true,$(EMMA_INSTRUMENT))
-LOCAL_JACK_FLAGS := --multi-dex native
-endif # EMMA_INSTRUMENT_STATIC
-
-include $(BUILD_PACKAGE)
-
-#########################################################################
-# Build JNI Shared Library
-#########################################################################
-
-LOCAL_PATH:= $(LOCAL_PATH)/jni
-
-include $(CLEAR_VARS)
-
-LOCAL_MODULE_TAGS := tests
-
-LOCAL_CFLAGS := -Wall -Wextra -Werror
-
-LOCAL_C_INCLUDES := \
-  libpcap \
-  hardware/google/apf
-
-LOCAL_SRC_FILES := $(call all-cpp-files-under)
-
-LOCAL_SHARED_LIBRARIES := \
-  libbinder \
-  libcutils \
-  libnativehelper \
-  libnetdaidl
-
-LOCAL_STATIC_LIBRARIES := \
-  libpcap \
-  libapf
-
-LOCAL_MODULE := libservicestestsjni
-
-include $(BUILD_SHARED_LIBRARY)
diff --git a/services/tests/servicestests/AndroidManifest.xml b/services/tests/servicestests/AndroidManifest.xml
deleted file mode 100644
index b8ace28fc09..00000000000
--- a/services/tests/servicestests/AndroidManifest.xml
+++ /dev/null
@@ -1,164 +0,0 @@
-<?xml version="1.0" encoding="utf-8"?>
-<!-- Copyright (C) 2008 The Android Open Source Project
-
-     Licensed under the Apache License, Version 2.0 (the "License");
-     you may not use this file except in compliance with the License.
-     You may obtain a copy of the License at
-  
-          http://www.apache.org/licenses/LICENSE-2.0
-  
-     Unless required by applicable law or agreed to in writing, software
-     distributed under the License is distributed on an "AS IS" BASIS,
-     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-     See the License for the specific language governing permissions and
-     limitations under the License.
--->
-
-<manifest xmlns:android="http://schemas.android.com/apk/res/android"
-        package="com.android.frameworks.servicestests">
-
-    <uses-permission android:name="android.permission.READ_LOGS" />
-    <uses-permission android:name="android.permission.WRITE_SETTINGS" />
-    <uses-permission android:name="android.permission.WRITE_SECURE_SETTINGS" />
-    <uses-permission android:name="android.permission.READ_PHONE_STATE" />
-    <uses-permission android:name="android.permission.ACCESS_NETWORK_STATE" />
-    <uses-permission android:name="android.permission.BROADCAST_STICKY" />
-    <uses-permission android:name="android.permission.WRITE_SECURE_SETTINGS" />
-    <uses-permission android:name="android.permission.UPDATE_DEVICE_STATS" />
-    <uses-permission android:name="android.permission.MANAGE_APP_TOKENS" />
-    <uses-permission android:name="android.permission.WAKE_LOCK" />
-    <uses-permission android:name="android.permission.INTERACT_ACROSS_USERS" />
-    <uses-permission android:name="android.permission.REAL_GET_TASKS" />
-    <uses-permission android:name="android.permission.GET_DETAILED_TASKS" />
-    <uses-permission android:name="android.permission.MANAGE_NETWORK_POLICY" />
-    <uses-permission android:name="android.permission.READ_NETWORK_USAGE_HISTORY" />
-    <uses-permission android:name="android.permission.MODIFY_NETWORK_ACCOUNTING" />
-    <uses-permission android:name="android.permission.CONNECTIVITY_INTERNAL" />
-    <uses-permission android:name="android.permission.ACCESS_WIFI_STATE" />
-    <uses-permission android:name="android.permission.MANAGE_USERS" />
-    <uses-permission android:name="android.permission.INTERACT_ACROSS_USERS_FULL" />
-    <uses-permission android:name="android.permission.MANAGE_DEVICE_ADMINS" />
-    <uses-permission android:name="android.permission.MODIFY_PHONE_STATE" />
-    <uses-permission android:name="android.permission.INTERNET" />
-    <uses-permission android:name="android.permission.CHANGE_NETWORK_STATE" />
-    <uses-permission android:name="android.permission.PACKET_KEEPALIVE_OFFLOAD" />
-    <uses-permission android:name="android.permission.GET_INTENT_SENDER_INTENT" />
-
-    <application>
-        <uses-library android:name="android.test.runner" />
-
-        <service android:name="com.android.server.AccessibilityManagerServiceTest$MyFirstMockAccessibilityService"
-            android:permission="android.permission.BIND_ACCESSIBILITY_SERVICE">
-          <intent-filter>
-            <action android:name="android.accessibilityservice.AccessibilityService"/>
-          </intent-filter>
-        </service>
-
-        <service android:name="com.android.server.AccessibilityManagerServiceTest$MySecondMockAccessibilityService"
-            android:permission="android.permission.BIND_ACCESSIBILITY_SERVICE">
-          <intent-filter>
-            <action android:name="android.accessibilityservice.AccessibilityService"/>
-          </intent-filter>
-        </service>
-
-        <receiver android:name="com.android.server.devicepolicy.ApplicationRestrictionsTest$AdminReceiver"
-                android:permission="android.permission.BIND_DEVICE_ADMIN">
-            <meta-data android:name="android.app.device_admin"
-                       android:resource="@xml/device_admin_sample" />
-            <intent-filter>
-                <action android:name="android.app.action.DEVICE_ADMIN_ENABLED" />
-            </intent-filter>
-        </receiver>
-
-        <receiver android:name="com.android.server.devicepolicy.DummyDeviceAdmins$Admin1"
-            android:permission="android.permission.BIND_DEVICE_ADMIN">
-            <meta-data android:name="android.app.device_admin"
-                android:resource="@xml/device_admin_sample" />
-            <intent-filter>
-                <action android:name="android.app.action.DEVICE_ADMIN_ENABLED" />
-            </intent-filter>
-        </receiver>
-
-        <receiver android:name="com.android.server.devicepolicy.DummyDeviceAdmins$Admin2"
-            android:permission="android.permission.BIND_DEVICE_ADMIN">
-            <meta-data android:name="android.app.device_admin"
-                android:resource="@xml/device_admin_sample" />
-            <intent-filter>
-                <action android:name="android.app.action.DEVICE_ADMIN_ENABLED" />
-            </intent-filter>
-        </receiver>
-
-        <receiver android:name="com.android.server.devicepolicy.DummyDeviceAdmins$Admin3"
-            android:permission="android.permission.BIND_DEVICE_ADMIN">
-            <meta-data android:name="android.app.device_admin"
-                android:resource="@xml/device_admin_sample" />
-            <intent-filter>
-                <action android:name="android.app.action.DEVICE_ADMIN_ENABLED" />
-            </intent-filter>
-        </receiver>
-
-        <receiver android:name="com.android.server.devicepolicy.DummyDeviceAdmins$AdminNoPerm">
-            <meta-data android:name="android.app.device_admin"
-                android:resource="@xml/device_admin_sample" />
-            <intent-filter>
-                <action android:name="android.app.action.DEVICE_ADMIN_ENABLED" />
-            </intent-filter>
-        </receiver>
-
-        <service android:name="com.android.server.job.MockPriorityJobService"
-                 android:permission="android.permission.BIND_JOB_SERVICE" />
-
-        <activity android:name="com.android.server.pm.BaseShortcutManagerTest$ShortcutActivity" />
-        <activity android:name="com.android.server.pm.BaseShortcutManagerTest$ShortcutActivity2" />
-        <activity android:name="com.android.server.pm.BaseShortcutManagerTest$ShortcutActivity3" />
-
-        <activity android:name="com.android.server.pm.ShortcutTestActivity"
-            android:enabled="true" android:exported="true" />
-
-        <activity-alias android:name="a.ShortcutEnabled"
-            android:targetActivity="com.android.server.pm.ShortcutTestActivity"
-            android:enabled="true" android:exported="true">
-        </activity-alias>
-        <activity-alias android:name="a.ShortcutDisabled"
-            android:targetActivity="com.android.server.pm.ShortcutTestActivity"
-            android:enabled="false" android:exported="true">
-            <meta-data android:name="android.app.shortcuts" android:resource="@xml/shortcut_5"/>
-        </activity-alias>
-        <activity-alias android:name="a.ShortcutUnexported"
-            android:targetActivity="com.android.server.pm.ShortcutTestActivity"
-            android:enabled="true" android:exported="false">
-            <meta-data android:name="android.app.shortcuts" android:resource="@xml/shortcut_5"/>
-        </activity-alias>
-        <activity-alias android:name="a.Shortcut1"
-            android:targetActivity="com.android.server.pm.ShortcutTestActivity"
-            android:enabled="true" android:exported="true">
-            <meta-data android:name="android.app.shortcuts" android:resource="@xml/shortcut_1"/>
-        </activity-alias>
-
-        <activity-alias android:name="a.DisabledMain"
-            android:targetActivity="com.android.server.pm.ShortcutTestActivity"
-            android:enabled="false" android:exported="true">
-            <intent-filter>
-                <action android:name="android.intent.action.MAIN" />
-                <category android:name="android.intent.category.DEFAULT" />
-                <category android:name="android.intent.category.LAUNCHER" />
-            </intent-filter>
-        </activity-alias>
-
-        <activity-alias android:name="a.UnexportedMain"
-            android:targetActivity="com.android.server.pm.ShortcutTestActivity"
-            android:enabled="true" android:exported="false">
-            <intent-filter>
-                <action android:name="android.intent.action.MAIN" />
-                <category android:name="android.intent.category.DEFAULT" />
-                <category android:name="android.intent.category.LAUNCHER" />
-            </intent-filter>
-        </activity-alias>
-
-    </application>
-
-    <instrumentation
-    	android:name="android.support.test.runner.AndroidJUnitRunner"
-    	android:targetPackage="com.android.frameworks.servicestests"
-    	android:label="Frameworks Services Tests" />
-</manifest>
diff --git a/services/tests/servicestests/assets/DevicePolicyManagerServiceMigrationTest/legacy_device_owner.xml b/services/tests/servicestests/assets/DevicePolicyManagerServiceMigrationTest/legacy_device_owner.xml
deleted file mode 100644
index 9564969ab57..00000000000
--- a/services/tests/servicestests/assets/DevicePolicyManagerServiceMigrationTest/legacy_device_owner.xml
+++ /dev/null
@@ -1,4 +0,0 @@
-<?xml version='1.0' encoding='utf-8' standalone='yes' ?>
-<device-owner package="com.android.frameworks.servicestests" />
-<profile-owner package="com.android.frameworks.servicestests" name="0" userId="10" component="com.android.frameworks.servicestests/com.android.server.devicepolicy.DummyDeviceAdmins$Admin2" />
-<profile-owner package="com.android.frameworks.servicestests" name="0" userId="11" component="com.android.frameworks.servicestests/com.android.server.devicepolicy.DummyDeviceAdmins$Admin3" />
diff --git a/services/tests/servicestests/assets/DevicePolicyManagerServiceMigrationTest/legacy_device_policies.xml b/services/tests/servicestests/assets/DevicePolicyManagerServiceMigrationTest/legacy_device_policies.xml
deleted file mode 100644
index 48cb814fa90..00000000000
--- a/services/tests/servicestests/assets/DevicePolicyManagerServiceMigrationTest/legacy_device_policies.xml
+++ /dev/null
@@ -1,7 +0,0 @@
-<?xml version='1.0' encoding='utf-8' standalone='yes' ?>
-<policies setup-complete="true">
-    <admin name="com.google.android.gms/com.google.android.gms.mdm.receivers.MdmDeviceAdminReceiver">
-    </admin>
-    <admin name="com.android.frameworks.servicestests/com.android.server.devicepolicy.DummyDeviceAdmins$Admin1">
-    </admin>
-</policies>
diff --git a/services/tests/servicestests/assets/DevicePolicyManagerServiceMigrationTest/legacy_device_policies_10.xml b/services/tests/servicestests/assets/DevicePolicyManagerServiceMigrationTest/legacy_device_policies_10.xml
deleted file mode 100644
index 6b53840434c..00000000000
--- a/services/tests/servicestests/assets/DevicePolicyManagerServiceMigrationTest/legacy_device_policies_10.xml
+++ /dev/null
@@ -1,5 +0,0 @@
-<?xml version='1.0' encoding='utf-8' standalone='yes' ?>
-<policies setup-complete="true">
-    <admin name="com.android.frameworks.servicestests/com.android.server.devicepolicy.DummyDeviceAdmins$Admin2">
-    </admin>
-</policies>
diff --git a/services/tests/servicestests/assets/DevicePolicyManagerServiceMigrationTest/legacy_device_policies_11.xml b/services/tests/servicestests/assets/DevicePolicyManagerServiceMigrationTest/legacy_device_policies_11.xml
deleted file mode 100644
index 2bcc5d41a7c..00000000000
--- a/services/tests/servicestests/assets/DevicePolicyManagerServiceMigrationTest/legacy_device_policies_11.xml
+++ /dev/null
@@ -1,5 +0,0 @@
-<?xml version='1.0' encoding='utf-8' standalone='yes' ?>
-<policies setup-complete="true">
-    <admin name="com.android.frameworks.servicestests/com.android.server.devicepolicy.DummyDeviceAdmins$Admin3">
-    </admin>
-</policies>
diff --git a/services/tests/servicestests/assets/DevicePolicyManagerServiceMigrationTest2/legacy_device_owner.xml b/services/tests/servicestests/assets/DevicePolicyManagerServiceMigrationTest2/legacy_device_owner.xml
deleted file mode 100644
index c0977f79127..00000000000
--- a/services/tests/servicestests/assets/DevicePolicyManagerServiceMigrationTest2/legacy_device_owner.xml
+++ /dev/null
@@ -1,2 +0,0 @@
-<?xml version='1.0' encoding='utf-8' standalone='yes' ?>
-<profile-owner package="com.android.frameworks.servicestests" name="0" userId="0" component="com.android.frameworks.servicestests/com.android.server.devicepolicy.DummyDeviceAdmins$Admin2" />
diff --git a/services/tests/servicestests/assets/DevicePolicyManagerServiceMigrationTest2/legacy_device_policies.xml b/services/tests/servicestests/assets/DevicePolicyManagerServiceMigrationTest2/legacy_device_policies.xml
deleted file mode 100644
index 6b53840434c..00000000000
--- a/services/tests/servicestests/assets/DevicePolicyManagerServiceMigrationTest2/legacy_device_policies.xml
+++ /dev/null
@@ -1,5 +0,0 @@
-<?xml version='1.0' encoding='utf-8' standalone='yes' ?>
-<policies setup-complete="true">
-    <admin name="com.android.frameworks.servicestests/com.android.server.devicepolicy.DummyDeviceAdmins$Admin2">
-    </admin>
-</policies>
diff --git a/services/tests/servicestests/assets/OwnersTest/test01/input.xml b/services/tests/servicestests/assets/OwnersTest/test01/input.xml
deleted file mode 100644
index db3e974f5d0..00000000000
--- a/services/tests/servicestests/assets/OwnersTest/test01/input.xml
+++ /dev/null
@@ -1 +0,0 @@
-<?xml version='1.0' encoding='utf-8' standalone='yes' ?>
diff --git a/services/tests/servicestests/assets/OwnersTest/test02/input.xml b/services/tests/servicestests/assets/OwnersTest/test02/input.xml
deleted file mode 100644
index 321842b2745..00000000000
--- a/services/tests/servicestests/assets/OwnersTest/test02/input.xml
+++ /dev/null
@@ -1,2 +0,0 @@
-<?xml version='1.0' encoding='utf-8' standalone='yes' ?>
-<device-owner package="com.google.android.testdpc" />
diff --git a/services/tests/servicestests/assets/OwnersTest/test03/input.xml b/services/tests/servicestests/assets/OwnersTest/test03/input.xml
deleted file mode 100644
index 1bbfdadf6eb..00000000000
--- a/services/tests/servicestests/assets/OwnersTest/test03/input.xml
+++ /dev/null
@@ -1,3 +0,0 @@
-<?xml version='1.0' encoding='utf-8' standalone='yes' ?>
-<profile-owner package="com.google.android.testdpc0" name="0" userId="10" component="com.google.android.testdpc/com.google.android.testdpc.DeviceAdminReceiver0" />
-<profile-owner package="com.google.android.testdpc1" name="1" userId="11" />
diff --git a/services/tests/servicestests/assets/OwnersTest/test04/input.xml b/services/tests/servicestests/assets/OwnersTest/test04/input.xml
deleted file mode 100644
index 8be51d9a45e..00000000000
--- a/services/tests/servicestests/assets/OwnersTest/test04/input.xml
+++ /dev/null
@@ -1,6 +0,0 @@
-<?xml version='1.0' encoding='utf-8' standalone='yes' ?>
-<device-owner package="com.google.android.testdpc" />
-<profile-owner package="com.google.android.testdpc0" name="0" userId="10" component="com.google.android.testdpc/com.google.android.testdpc.DeviceAdminReceiver0" />
-<profile-owner package="com.google.android.testdpc1" name="1" userId="11" />
-<device-initializer package="com.google.android.testdpcx" name="di" component="com.google.android.testdpcx/receiver" />
-<system-update-policy policy_type="5" />
diff --git a/services/tests/servicestests/assets/OwnersTest/test05/input.xml b/services/tests/servicestests/assets/OwnersTest/test05/input.xml
deleted file mode 100644
index dbcb8588654..00000000000
--- a/services/tests/servicestests/assets/OwnersTest/test05/input.xml
+++ /dev/null
@@ -1,3 +0,0 @@
-<?xml version='1.0' encoding='utf-8' standalone='yes' ?>
-<device-initializer package="com.google.android.testdpcx" name="di" component="com.google.android.testdpcx/receiver" />
-
diff --git a/services/tests/servicestests/assets/OwnersTest/test06/input.xml b/services/tests/servicestests/assets/OwnersTest/test06/input.xml
deleted file mode 100644
index 794622b0b99..00000000000
--- a/services/tests/servicestests/assets/OwnersTest/test06/input.xml
+++ /dev/null
@@ -1,2 +0,0 @@
-<?xml version='1.0' encoding='utf-8' standalone='yes' ?>
-<system-update-policy policy_type="5" />
diff --git a/services/tests/servicestests/assets/shortcut/dumpsys_expected.txt b/services/tests/servicestests/assets/shortcut/dumpsys_expected.txt
deleted file mode 100644
index eed2087f80e..00000000000
--- a/services/tests/servicestests/assets/shortcut/dumpsys_expected.txt
+++ /dev/null
@@ -1,105 +0,0 @@
-{
- "shortcut": [
-  {
-   "userId": 0,
-   "launchers": [
-    {
-     "name": "com.android.launcher.1"
-    },
-    {
-     "name": "com.android.launcher.2"
-    },
-    {
-     "name": "com.android.launcher.3"
-    },
-    {
-     "name": "com.android.launcher.4"
-    },
-    {
-     "name": "com.android.launcher.1"
-    }
-   ],
-   "packages": [
-    {
-     "name": "com.android.test.1",
-     "dynamic": 3,
-     "manifest": 0,
-     "pinned": 4,
-     "bitmaps": 0,
-     "bitmapBytes": 0
-    },
-    {
-     "name": "com.android.test.2",
-     "dynamic": 4,
-     "manifest": 0,
-     "pinned": 5,
-     "bitmaps": 2,
-     "bitmapBytes": ***BITMAP_SIZE***
-    },
-    {
-     "name": "com.android.test.3",
-     "dynamic": 3,
-     "manifest": 0,
-     "pinned": 6,
-     "bitmaps": 0,
-     "bitmapBytes": 0
-    },
-    {
-     "name": "com.android.test.4",
-     "dynamic": 0,
-     "manifest": 0,
-     "pinned": 0,
-     "bitmaps": 0,
-     "bitmapBytes": 0
-    }
-   ]
-  },
-  {
-   "userId": 10,
-   "launchers": [
-    {
-     "name": "com.android.launcher.1"
-    }
-   ],
-   "packages": [
-    {
-     "name": "com.android.test.1",
-     "dynamic": 3,
-     "manifest": 0,
-     "pinned": 2,
-     "bitmaps": 0,
-     "bitmapBytes": 0
-    }
-   ]
-  },
-  {
-   "userId": 20,
-   "launchers": [
-    {
-     "name": "com.android.launcher.1"
-    },
-    {
-     "name": "com.android.launcher.2"
-    },
-    {
-     "name": "com.android.launcher.3"
-    },
-    {
-     "name": "com.android.launcher.1"
-    }
-   ],
-   "packages": [
-    {
-     "name": "com.android.test.1",
-     "dynamic": 3,
-     "manifest": 0,
-     "pinned": 6,
-     "bitmaps": 0,
-     "bitmapBytes": 0
-    }
-   ]
-  }
- ],
- "lowRam": false,
- "iconSize": 128
-}
diff --git a/services/tests/servicestests/assets/shortcut/shortcut_legacy_file.xml b/services/tests/servicestests/assets/shortcut/shortcut_legacy_file.xml
deleted file mode 100644
index f7eee9155da..00000000000
--- a/services/tests/servicestests/assets/shortcut/shortcut_legacy_file.xml
+++ /dev/null
@@ -1,25 +0,0 @@
-<?xml version='1.0' encoding='utf-8' standalone='yes' ?>
-<!-- Copyright (C) 2016 The Android Open Source Project
-
-     Licensed under the Apache License, Version 2.0 (the "License");
-     you may not use this file except in compliance with the License.
-     You may obtain a copy of the License at
-
-          http://www.apache.org/licenses/LICENSE-2.0
-
-     Unless required by applicable law or agreed to in writing, software
-     distributed under the License is distributed on an "AS IS" BASIS,
-     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-     See the License for the specific language governing permissions and
-     limitations under the License.
--->
-<user locales="en-US" last-app-scan-time="3113976673">
-    <package name="com.android.test.1" call-count="0" last-reset="1468976368772">
-        <package-info version="25" last_udpate_time="1230796800000" />
-        <shortcut id="manifest-shortcut-storage" activity="com.android.test.1/com.android.test.1.Settings" title="Storage" intent="#Intent;action=android.settings.INTERNAL_STORAGE_SETTINGS;end" timestamp="1469050672334" flags="1" >
-            <intent-extras>
-                <int name="key" value="12345" />
-            </intent-extras>
-        </shortcut>
-    </package>
-</user>
diff --git a/services/tests/servicestests/jni/UidRangeTest.cpp b/services/tests/servicestests/jni/UidRangeTest.cpp
deleted file mode 100644
index 7941731a07f..00000000000
--- a/services/tests/servicestests/jni/UidRangeTest.cpp
+++ /dev/null
@@ -1,79 +0,0 @@
-/*
- * Copyright (C) 2016 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#include <memory>
-
-#include <binder/Parcel.h>
-
-#include "UidRangeTest.h"
-
-using android::net::UidRange;
-
-extern "C"
-JNIEXPORT jbyteArray Java_android_net_UidRangeTest_readAndWriteNative(JNIEnv* env, jclass,
-        jbyteArray inParcel) {
-    const UidRange range = unmarshall(env, inParcel);
-    return marshall(env, range);
-}
-
-extern "C"
-JNIEXPORT jint Java_android_net_UidRangeTest_getStart(JNIEnv* env, jclass, jbyteArray inParcel) {
-    const UidRange range = unmarshall(env, inParcel);
-    return range.getStart();
-}
-
-extern "C"
-JNIEXPORT jint Java_android_net_UidRangeTest_getStop(JNIEnv* env, jclass, jbyteArray inParcel) {
-    const UidRange range = unmarshall(env, inParcel);
-    return range.getStop();
-}
-
-
-/**
- * Reads exactly one UidRange from 'parcelData' assuming that it is a Parcel. Any bytes afterward
- * are ignored.
- */
-UidRange unmarshall(JNIEnv* env, jbyteArray parcelData) {
-    const int length = env->GetArrayLength(parcelData);
-
-    std::unique_ptr<uint8_t> bytes(new uint8_t[length]);
-    env->GetByteArrayRegion(parcelData, 0, length, reinterpret_cast<jbyte*>(bytes.get()));
-
-    android::Parcel p;
-    p.setData(bytes.get(), length);
-
-    UidRange range;
-    range.readFromParcel(&p);
-    return range;
-}
-
-/**
- * Creates a Java byte[] array and writes the contents of 'range' to it as a Parcel containing
- * exactly one object.
- *
- * Every UidRange maps to a unique parcel object, so both 'marshall(e, unmarshall(e, x))' and
- * 'unmarshall(e, marshall(e, x))' should be fixed points.
- */
-jbyteArray marshall(JNIEnv* env, const UidRange& range) {
-    android::Parcel p;
-    range.writeToParcel(&p);
-    const int length = p.dataSize();
-
-    jbyteArray parcelData = env->NewByteArray(length);
-    env->SetByteArrayRegion(parcelData, 0, length, reinterpret_cast<const jbyte*>(p.data()));
-
-    return parcelData;
-}
diff --git a/services/tests/servicestests/jni/UidRangeTest.h b/services/tests/servicestests/jni/UidRangeTest.h
deleted file mode 100644
index b7e74537880..00000000000
--- a/services/tests/servicestests/jni/UidRangeTest.h
+++ /dev/null
@@ -1,38 +0,0 @@
-/*
- * Copyright (C) 2016 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#ifndef _ANDROID_NET_UIDRANGETEST_H_
-#define _ANDROID_NET_UIDRANGETEST_H_
-
-#include <jni.h>
-
-#include "android/net/UidRange.h"
-
-android::net::UidRange unmarshall(JNIEnv* env, jbyteArray parcelData);
-
-jbyteArray marshall(JNIEnv* env, const android::net::UidRange& range);
-
-extern "C"
-JNIEXPORT jbyteArray Java_android_net_UidRangeTest_readAndWriteNative(JNIEnv* env, jclass,
-        jbyteArray inParcel);
-
-extern "C"
-JNIEXPORT jint Java_android_net_UidRangeTest_getStart(JNIEnv* env, jclass, jbyteArray inParcel);
-
-extern "C"
-JNIEXPORT jint Java_android_net_UidRangeTest_getStop(JNIEnv* env, jclass, jbyteArray inParcel);
-
-#endif  //  _ANDROID_NET_UIDRANGETEST_H_
diff --git a/services/tests/servicestests/jni/apf_jni.cpp b/services/tests/servicestests/jni/apf_jni.cpp
deleted file mode 100644
index ee43dd48836..00000000000
--- a/services/tests/servicestests/jni/apf_jni.cpp
+++ /dev/null
@@ -1,182 +0,0 @@
-/*
- * Copyright 2016, The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#include <JNIHelp.h>
-#include <ScopedUtfChars.h>
-#include <jni.h>
-#include <pcap.h>
-#include <stdlib.h>
-#include <string>
-#include <utils/Log.h>
-
-#include "apf_interpreter.h"
-
-#define ARRAY_SIZE(x) (sizeof(x) / sizeof((x)[0]))
-
-// JNI function acting as simply call-through to native APF interpreter.
-static jint com_android_server_ApfTest_apfSimulate(
-        JNIEnv* env, jclass, jbyteArray program, jbyteArray packet, jint filter_age) {
-    return accept_packet(
-            (uint8_t*)env->GetByteArrayElements(program, NULL),
-            env->GetArrayLength(program),
-            (uint8_t*)env->GetByteArrayElements(packet, NULL),
-            env->GetArrayLength(packet),
-            filter_age);
-}
-
-class ScopedPcap {
-  public:
-    ScopedPcap(pcap_t* pcap) : pcap_ptr(pcap) {}
-    ~ScopedPcap() {
-        pcap_close(pcap_ptr);
-    }
-
-    pcap_t* get() const { return pcap_ptr; };
-  private:
-    pcap_t* const pcap_ptr;
-};
-
-class ScopedFILE {
-  public:
-    ScopedFILE(FILE* fp) : file(fp) {}
-    ~ScopedFILE() {
-        fclose(file);
-    }
-
-    FILE* get() const { return file; };
-  private:
-    FILE* const file;
-};
-
-static void throwException(JNIEnv* env, const std::string& error) {
-    jclass newExcCls = env->FindClass("java/lang/IllegalStateException");
-    if (newExcCls == 0) {
-      abort();
-      return;
-    }
-    env->ThrowNew(newExcCls, error.c_str());
-}
-
-static jstring com_android_server_ApfTest_compileToBpf(JNIEnv* env, jclass, jstring jfilter) {
-    ScopedUtfChars filter(env, jfilter);
-    std::string bpf_string;
-    ScopedPcap pcap(pcap_open_dead(DLT_EN10MB, 65535));
-    if (pcap.get() == NULL) {
-        throwException(env, "pcap_open_dead failed");
-        return NULL;
-    }
-
-    // Compile "filter" to a BPF program
-    bpf_program bpf;
-    if (pcap_compile(pcap.get(), &bpf, filter.c_str(), 0, PCAP_NETMASK_UNKNOWN)) {
-        throwException(env, "pcap_compile failed");
-        return NULL;
-    }
-
-    // Translate BPF program to human-readable format
-    const struct bpf_insn* insn = bpf.bf_insns;
-    for (uint32_t i = 0; i < bpf.bf_len; i++) {
-        bpf_string += bpf_image(insn++, i);
-        bpf_string += "\n";
-    }
-
-    return env->NewStringUTF(bpf_string.c_str());
-}
-
-static jboolean com_android_server_ApfTest_compareBpfApf(JNIEnv* env, jclass, jstring jfilter,
-        jstring jpcap_filename, jbyteArray japf_program) {
-    ScopedUtfChars filter(env, jfilter);
-    ScopedUtfChars pcap_filename(env, jpcap_filename);
-    const uint8_t* apf_program = (uint8_t*)env->GetByteArrayElements(japf_program, NULL);
-    const uint32_t apf_program_len = env->GetArrayLength(japf_program);
-
-    // Open pcap file for BPF filtering
-    ScopedFILE bpf_fp(fopen(pcap_filename.c_str(), "rb"));
-    char pcap_error[PCAP_ERRBUF_SIZE];
-    ScopedPcap bpf_pcap(pcap_fopen_offline(bpf_fp.get(), pcap_error));
-    if (bpf_pcap.get() == NULL) {
-        throwException(env, "pcap_fopen_offline failed: " + std::string(pcap_error));
-        return false;
-    }
-
-    // Open pcap file for APF filtering
-    ScopedFILE apf_fp(fopen(pcap_filename.c_str(), "rb"));
-    ScopedPcap apf_pcap(pcap_fopen_offline(apf_fp.get(), pcap_error));
-    if (apf_pcap.get() == NULL) {
-        throwException(env, "pcap_fopen_offline failed: " + std::string(pcap_error));
-        return false;
-    }
-
-    // Compile "filter" to a BPF program
-    bpf_program bpf;
-    if (pcap_compile(bpf_pcap.get(), &bpf, filter.c_str(), 0, PCAP_NETMASK_UNKNOWN)) {
-        throwException(env, "pcap_compile failed");
-        return false;
-    }
-
-    // Install BPF filter on bpf_pcap
-    if (pcap_setfilter(bpf_pcap.get(), &bpf)) {
-        throwException(env, "pcap_setfilter failed");
-        return false;
-    }
-
-    while (1) {
-        pcap_pkthdr bpf_header, apf_header;
-        // Run BPF filter to the next matching packet.
-        const uint8_t* bpf_packet = pcap_next(bpf_pcap.get(), &bpf_header);
-
-        // Run APF filter to the next matching packet.
-        const uint8_t* apf_packet;
-        do {
-            apf_packet = pcap_next(apf_pcap.get(), &apf_header);
-        } while (apf_packet != NULL && !accept_packet(
-                apf_program, apf_program_len, apf_packet, apf_header.len, 0));
-
-        // Make sure both filters matched the same packet.
-        if (apf_packet == NULL && bpf_packet == NULL)
-             break;
-        if (apf_packet == NULL || bpf_packet == NULL)
-             return false;
-        if (apf_header.len != bpf_header.len ||
-                apf_header.ts.tv_sec != bpf_header.ts.tv_sec ||
-                apf_header.ts.tv_usec != bpf_header.ts.tv_usec ||
-                memcmp(apf_packet, bpf_packet, apf_header.len))
-            return false;
-    }
-    return true;
-}
-
-extern "C" jint JNI_OnLoad(JavaVM* vm, void*) {
-    JNIEnv *env;
-    if (vm->GetEnv(reinterpret_cast<void**>(&env), JNI_VERSION_1_6) != JNI_OK) {
-        ALOGE("ERROR: GetEnv failed");
-        return -1;
-    }
-
-    static JNINativeMethod gMethods[] = {
-            { "apfSimulate", "([B[BI)I",
-                    (void*)com_android_server_ApfTest_apfSimulate },
-            { "compileToBpf", "(Ljava/lang/String;)Ljava/lang/String;",
-                    (void*)com_android_server_ApfTest_compileToBpf },
-            { "compareBpfApf", "(Ljava/lang/String;Ljava/lang/String;[B)Z",
-                    (void*)com_android_server_ApfTest_compareBpfApf },
-    };
-
-    jniRegisterNativeMethods(env, "android/net/apf/ApfTest",
-            gMethods, ARRAY_SIZE(gMethods));
-
-    return JNI_VERSION_1_6;
-}
diff --git a/services/tests/servicestests/res/drawable-nodpi/black_1024x4096.png b/services/tests/servicestests/res/drawable-nodpi/black_1024x4096.png
deleted file mode 100644
index f7003269889..00000000000
Binary files a/services/tests/servicestests/res/drawable-nodpi/black_1024x4096.png and /dev/null differ
diff --git a/services/tests/servicestests/res/drawable-nodpi/black_16x64.png b/services/tests/servicestests/res/drawable-nodpi/black_16x64.png
deleted file mode 100644
index 315763e4560..00000000000
Binary files a/services/tests/servicestests/res/drawable-nodpi/black_16x64.png and /dev/null differ
diff --git a/services/tests/servicestests/res/drawable-nodpi/black_32x32.png b/services/tests/servicestests/res/drawable-nodpi/black_32x32.png
deleted file mode 100644
index 8958f6b1eab..00000000000
Binary files a/services/tests/servicestests/res/drawable-nodpi/black_32x32.png and /dev/null differ
diff --git a/services/tests/servicestests/res/drawable-nodpi/black_4096x1024.png b/services/tests/servicestests/res/drawable-nodpi/black_4096x1024.png
deleted file mode 100644
index f6750301773..00000000000
Binary files a/services/tests/servicestests/res/drawable-nodpi/black_4096x1024.png and /dev/null differ
diff --git a/services/tests/servicestests/res/drawable-nodpi/black_4096x4096.png b/services/tests/servicestests/res/drawable-nodpi/black_4096x4096.png
deleted file mode 100644
index 999d8585fc6..00000000000
Binary files a/services/tests/servicestests/res/drawable-nodpi/black_4096x4096.png and /dev/null differ
diff --git a/services/tests/servicestests/res/drawable-nodpi/black_512x512.png b/services/tests/servicestests/res/drawable-nodpi/black_512x512.png
deleted file mode 100644
index 40d1c2c41f1..00000000000
Binary files a/services/tests/servicestests/res/drawable-nodpi/black_512x512.png and /dev/null differ
diff --git a/services/tests/servicestests/res/drawable-nodpi/black_64x16.png b/services/tests/servicestests/res/drawable-nodpi/black_64x16.png
deleted file mode 100644
index 58830151997..00000000000
Binary files a/services/tests/servicestests/res/drawable-nodpi/black_64x16.png and /dev/null differ
diff --git a/services/tests/servicestests/res/drawable-nodpi/black_64x64.png b/services/tests/servicestests/res/drawable-nodpi/black_64x64.png
deleted file mode 100644
index 71cfafc2ad3..00000000000
Binary files a/services/tests/servicestests/res/drawable-nodpi/black_64x64.png and /dev/null differ
diff --git a/services/tests/servicestests/res/drawable-nodpi/icon1.png b/services/tests/servicestests/res/drawable-nodpi/icon1.png
deleted file mode 100644
index 64eb294363d..00000000000
Binary files a/services/tests/servicestests/res/drawable-nodpi/icon1.png and /dev/null differ
diff --git a/services/tests/servicestests/res/drawable-nodpi/icon2.png b/services/tests/servicestests/res/drawable-nodpi/icon2.png
deleted file mode 100644
index 75024841d32..00000000000
Binary files a/services/tests/servicestests/res/drawable-nodpi/icon2.png and /dev/null differ
diff --git a/services/tests/servicestests/res/drawable/icon1.png b/services/tests/servicestests/res/drawable/icon1.png
deleted file mode 100644
index 64eb294363d..00000000000
Binary files a/services/tests/servicestests/res/drawable/icon1.png and /dev/null differ
diff --git a/services/tests/servicestests/res/drawable/icon2.png b/services/tests/servicestests/res/drawable/icon2.png
deleted file mode 100644
index 75024841d32..00000000000
Binary files a/services/tests/servicestests/res/drawable/icon2.png and /dev/null differ
diff --git a/services/tests/servicestests/res/drawable/icon3.png b/services/tests/servicestests/res/drawable/icon3.png
deleted file mode 100644
index 64eb294363d..00000000000
Binary files a/services/tests/servicestests/res/drawable/icon3.png and /dev/null differ
diff --git a/services/tests/servicestests/res/raw/apf.pcap b/services/tests/servicestests/res/raw/apf.pcap
deleted file mode 100644
index 963165f19f7..00000000000
Binary files a/services/tests/servicestests/res/raw/apf.pcap and /dev/null differ
diff --git a/services/tests/servicestests/res/raw/netstats_uid_v4 b/services/tests/servicestests/res/raw/netstats_uid_v4
deleted file mode 100644
index e75fc1ca5c2..00000000000
Binary files a/services/tests/servicestests/res/raw/netstats_uid_v4 and /dev/null differ
diff --git a/services/tests/servicestests/res/raw/netstats_v1 b/services/tests/servicestests/res/raw/netstats_v1
deleted file mode 100644
index e80860a6b95..00000000000
Binary files a/services/tests/servicestests/res/raw/netstats_v1 and /dev/null differ
diff --git a/services/tests/servicestests/res/raw/test1.obb b/services/tests/servicestests/res/raw/test1.obb
deleted file mode 100644
index 7d2b4f6e6fb..00000000000
Binary files a/services/tests/servicestests/res/raw/test1.obb and /dev/null differ
diff --git a/services/tests/servicestests/res/raw/test1_nosig.obb b/services/tests/servicestests/res/raw/test1_nosig.obb
deleted file mode 100644
index 5c3573f72a1..00000000000
Binary files a/services/tests/servicestests/res/raw/test1_nosig.obb and /dev/null differ
diff --git a/services/tests/servicestests/res/raw/test1_wrongpackage.obb b/services/tests/servicestests/res/raw/test1_wrongpackage.obb
deleted file mode 100644
index d0aafe16e1a..00000000000
Binary files a/services/tests/servicestests/res/raw/test1_wrongpackage.obb and /dev/null differ
diff --git a/services/tests/servicestests/res/values/strings.xml b/services/tests/servicestests/res/values/strings.xml
deleted file mode 100644
index 2f9d06c318c..00000000000
--- a/services/tests/servicestests/res/values/strings.xml
+++ /dev/null
@@ -1,24 +0,0 @@
-<?xml version="1.0" encoding="utf-8"?>
-<!-- Copyright (C) 2016 The Android Open Source Project
-
-     Licensed under the Apache License, Version 2.0 (the "License");
-     you may not use this file except in compliance with the License.
-     You may obtain a copy of the License at
-
-          http://www.apache.org/licenses/LICENSE-2.0
-
-     Unless required by applicable law or agreed to in writing, software
-     distributed under the License is distributed on an "AS IS" BASIS,
-     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-     See the License for the specific language governing permissions and
-     limitations under the License.
--->
-
-<resources xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
-    <string name="shortcut_title1"></string>
-    <string name="shortcut_text1"></string>
-    <string name="shortcut_disabled_message1"></string>
-    <string name="shortcut_title2"></string>
-    <string name="shortcut_text2"></string>
-    <string name="shortcut_disabled_message2"></string>
-</resources>
diff --git a/services/tests/servicestests/res/xml/device_admin_sample.xml b/services/tests/servicestests/res/xml/device_admin_sample.xml
deleted file mode 100644
index 032debbb92b..00000000000
--- a/services/tests/servicestests/res/xml/device_admin_sample.xml
+++ /dev/null
@@ -1,29 +0,0 @@
-<?xml version="1.0" encoding="utf-8"?>
-<!-- Copyright (C) 2014 The Android Open Source Project
-
-     Licensed under the Apache License, Version 2.0 (the "License");
-     you may not use this file except in compliance with the License.
-     You may obtain a copy of the License at
-
-          http://www.apache.org/licenses/LICENSE-2.0
-
-     Unless required by applicable law or agreed to in writing, software
-     distributed under the License is distributed on an "AS IS" BASIS,
-     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-     See the License for the specific language governing permissions and
-     limitations under the License.
--->
-
-<device-admin xmlns:android="http://schemas.android.com/apk/res/android">
-    <uses-policies>
-        <limit-password />
-        <watch-login />
-        <reset-password />
-        <force-lock />
-        <wipe-data />
-        <expire-password />
-        <encrypted-storage />
-        <disable-camera />
-        <disable-keyguard-features />
-    </uses-policies>
-</device-admin>
diff --git a/services/tests/servicestests/res/xml/shortcut_0.xml b/services/tests/servicestests/res/xml/shortcut_0.xml
deleted file mode 100644
index fda001ec0aa..00000000000
--- a/services/tests/servicestests/res/xml/shortcut_0.xml
+++ /dev/null
@@ -1,2 +0,0 @@
-<shortcuts xmlns:android="http://schemas.android.com/apk/res/android" >
-</shortcuts>
diff --git a/services/tests/servicestests/res/xml/shortcut_1.xml b/services/tests/servicestests/res/xml/shortcut_1.xml
deleted file mode 100644
index e3f9172cc23..00000000000
--- a/services/tests/servicestests/res/xml/shortcut_1.xml
+++ /dev/null
@@ -1,18 +0,0 @@
-<shortcuts xmlns:android="http://schemas.android.com/apk/res/android" >
-    <shortcut
-        android:shortcutId="ms1"
-        android:enabled="true"
-        android:icon="@drawable/icon1"
-        android:shortcutShortLabel="@string/shortcut_title1"
-        android:shortcutLongLabel="@string/shortcut_text1"
-        android:shortcutDisabledMessage="@string/shortcut_disabled_message1"
-        >
-        <intent
-            android:action="action1"
-            android:data="data1"
-            >
-        </intent>
-        <categories android:name="android.shortcut.conversation" />
-        <categories android:name="android.shortcut.media" />
-    </shortcut>
-</shortcuts>
diff --git a/services/tests/servicestests/res/xml/shortcut_1_alt.xml b/services/tests/servicestests/res/xml/shortcut_1_alt.xml
deleted file mode 100644
index 2d5e8e7cbd7..00000000000
--- a/services/tests/servicestests/res/xml/shortcut_1_alt.xml
+++ /dev/null
@@ -1,33 +0,0 @@
-<?xml version="1.0" encoding="utf-8"?>
-<!-- Copyright (C) 2016 The Android Open Source Project
-
-     Licensed under the Apache License, Version 2.0 (the "License");
-     you may not use this file except in compliance with the License.
-     You may obtain a copy of the License at
-
-          http://www.apache.org/licenses/LICENSE-2.0
-
-     Unless required by applicable law or agreed to in writing, software
-     distributed under the License is distributed on an "AS IS" BASIS,
-     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-     See the License for the specific language governing permissions and
-     limitations under the License.
--->
-<shortcuts xmlns:android="http://schemas.android.com/apk/res/android" >
-    <shortcut
-        android:shortcutId="ms1-alt"
-        android:enabled="true"
-        android:icon="@drawable/icon1"
-        android:shortcutShortLabel="@string/shortcut_title1"
-        android:shortcutLongLabel="@string/shortcut_text1"
-        android:shortcutDisabledMessage="@string/shortcut_disabled_message1"
-        >
-        <intent
-            android:action="action1"
-            android:data="data1"
-        >
-        </intent>
-        <categories android:name="android.shortcut.conversation" />
-        <categories android:name="android.shortcut.media" />
-    </shortcut>
-</shortcuts>
diff --git a/services/tests/servicestests/res/xml/shortcut_1_disable.xml b/services/tests/servicestests/res/xml/shortcut_1_disable.xml
deleted file mode 100644
index e3ee3a0786e..00000000000
--- a/services/tests/servicestests/res/xml/shortcut_1_disable.xml
+++ /dev/null
@@ -1,25 +0,0 @@
-<?xml version="1.0" encoding="utf-8"?>
-<!-- Copyright (C) 2016 The Android Open Source Project
-
-     Licensed under the Apache License, Version 2.0 (the "License");
-     you may not use this file except in compliance with the License.
-     You may obtain a copy of the License at
-
-          http://www.apache.org/licenses/LICENSE-2.0
-
-     Unless required by applicable law or agreed to in writing, software
-     distributed under the License is distributed on an "AS IS" BASIS,
-     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-     See the License for the specific language governing permissions and
-     limitations under the License.
--->
-<shortcuts xmlns:android="http://schemas.android.com/apk/res/android" >
-    <shortcut
-        android:shortcutId="ms1"
-        android:enabled="false"
-        android:icon="@drawable/icon2"
-        android:shortcutShortLabel="@string/shortcut_title2"
-        android:shortcutLongLabel="@string/shortcut_text2"
-        android:shortcutDisabledMessage="@string/shortcut_disabled_message2"
-    />
-</shortcuts>
diff --git a/services/tests/servicestests/res/xml/shortcut_2.xml b/services/tests/servicestests/res/xml/shortcut_2.xml
deleted file mode 100644
index f7ea803d340..00000000000
--- a/services/tests/servicestests/res/xml/shortcut_2.xml
+++ /dev/null
@@ -1,48 +0,0 @@
-<?xml version="1.0" encoding="utf-8"?>
-<!-- Copyright (C) 2016 The Android Open Source Project
-
-     Licensed under the Apache License, Version 2.0 (the "License");
-     you may not use this file except in compliance with the License.
-     You may obtain a copy of the License at
-
-          http://www.apache.org/licenses/LICENSE-2.0
-
-     Unless required by applicable law or agreed to in writing, software
-     distributed under the License is distributed on an "AS IS" BASIS,
-     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-     See the License for the specific language governing permissions and
-     limitations under the License.
--->
-<shortcuts xmlns:android="http://schemas.android.com/apk/res/android" >
-    <shortcut
-        android:shortcutId="ms1"
-        android:enabled="true"
-        android:icon="@drawable/icon1"
-        android:shortcutShortLabel="@string/shortcut_title1"
-        android:shortcutLongLabel="@string/shortcut_text1"
-        android:shortcutDisabledMessage="@string/shortcut_disabled_message1"
-        >
-        <intent
-            android:action="action1"
-            android:data="http://a.b.c/"
-            >
-        </intent>
-        <categories android:name="android.shortcut.conversation" />
-        <categories android:name="android.shortcut.media" />
-    </shortcut>
-    <shortcut
-        android:shortcutId="ms2"
-        android:enabled="true"
-        android:icon="@drawable/icon2"
-        android:shortcutShortLabel="@string/shortcut_title2"
-        android:shortcutLongLabel="@string/shortcut_text2"
-        android:shortcutDisabledMessage="@string/shortcut_disabled_message2"
-        >
-        <intent
-            android:action="action2"
-            android:data="http://a.b.c/2"
-            >
-        </intent>
-        <categories android:name="android.shortcut.conversation" />
-    </shortcut>
-</shortcuts>
diff --git a/services/tests/servicestests/res/xml/shortcut_2_duplicate.xml b/services/tests/servicestests/res/xml/shortcut_2_duplicate.xml
deleted file mode 100644
index b00ec60e0ff..00000000000
--- a/services/tests/servicestests/res/xml/shortcut_2_duplicate.xml
+++ /dev/null
@@ -1,35 +0,0 @@
-<?xml version="1.0" encoding="utf-8"?>
-<!-- Copyright (C) 2016 The Android Open Source Project
-
-     Licensed under the Apache License, Version 2.0 (the "License");
-     you may not use this file except in compliance with the License.
-     You may obtain a copy of the License at
-
-          http://www.apache.org/licenses/LICENSE-2.0
-
-     Unless required by applicable law or agreed to in writing, software
-     distributed under the License is distributed on an "AS IS" BASIS,
-     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-     See the License for the specific language governing permissions and
-     limitations under the License.
--->
-<shortcuts xmlns:android="http://schemas.android.com/apk/res/android" >
-    <shortcut
-        android:shortcutId="ms1"
-        android:shortcutShortLabel="@string/shortcut_title1"
-        >
-        <intent
-            android:action="action1"
-            >
-        </intent>
-    </shortcut>
-    <shortcut
-        android:shortcutId="ms1"
-        android:shortcutShortLabel="@string/shortcut_title2"
-        >
-        <intent
-            android:action="action2"
-            >
-        </intent>
-    </shortcut>
-</shortcuts>
diff --git a/services/tests/servicestests/res/xml/shortcut_3.xml b/services/tests/servicestests/res/xml/shortcut_3.xml
deleted file mode 100644
index 432ca4935ec..00000000000
--- a/services/tests/servicestests/res/xml/shortcut_3.xml
+++ /dev/null
@@ -1,56 +0,0 @@
-<?xml version="1.0" encoding="utf-8"?>
-<!-- Copyright (C) 2016 The Android Open Source Project
-
-     Licensed under the Apache License, Version 2.0 (the "License");
-     you may not use this file except in compliance with the License.
-     You may obtain a copy of the License at
-
-          http://www.apache.org/licenses/LICENSE-2.0
-
-     Unless required by applicable law or agreed to in writing, software
-     distributed under the License is distributed on an "AS IS" BASIS,
-     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-     See the License for the specific language governing permissions and
-     limitations under the License.
--->
-<shortcuts xmlns:android="http://schemas.android.com/apk/res/android" >
-    <shortcut
-        android:shortcutId="ms1"
-        android:enabled="true"
-        android:icon="@drawable/icon1"
-        android:shortcutShortLabel="@string/shortcut_title1"
-        android:shortcutLongLabel="@string/shortcut_text1"
-        android:shortcutDisabledMessage="@string/shortcut_disabled_message1"
-        >
-        <intent
-            android:action="action1"
-            android:data="http://a.b.c/"
-            >
-        </intent>
-        <categories android:name="android.shortcut.conversation" />
-        <categories android:name="android.shortcut.media" />
-    </shortcut>
-    <shortcut
-        android:shortcutId="ms2"
-        android:enabled="true"
-        android:icon="@drawable/icon2"
-        android:shortcutShortLabel="@string/shortcut_title2"
-        android:shortcutLongLabel="@string/shortcut_text2"
-        android:shortcutDisabledMessage="@string/shortcut_disabled_message2"
-        >
-        <intent
-            android:action="action2"
-            android:data="http://a.b.c/2"
-            >
-        </intent>
-        <categories android:name="android.shortcut.conversation" />
-    </shortcut>
-    <shortcut
-        android:shortcutId="ms3"
-        android:enabled="true"
-        android:icon="@drawable/icon3"
-        android:shortcutShortLabel="@string/shortcut_title2"
-        >
-        <intent android:action="action3" />
-    </shortcut>
-</shortcuts>
diff --git a/services/tests/servicestests/res/xml/shortcut_5.xml b/services/tests/servicestests/res/xml/shortcut_5.xml
deleted file mode 100644
index 9551100cefe..00000000000
--- a/services/tests/servicestests/res/xml/shortcut_5.xml
+++ /dev/null
@@ -1,85 +0,0 @@
-<?xml version="1.0" encoding="utf-8"?>
-<!-- Copyright (C) 2016 The Android Open Source Project
-
-     Licensed under the Apache License, Version 2.0 (the "License");
-     you may not use this file except in compliance with the License.
-     You may obtain a copy of the License at
-
-          http://www.apache.org/licenses/LICENSE-2.0
-
-     Unless required by applicable law or agreed to in writing, software
-     distributed under the License is distributed on an "AS IS" BASIS,
-     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-     See the License for the specific language governing permissions and
-     limitations under the License.
--->
-<shortcuts xmlns:android="http://schemas.android.com/apk/res/android" >
-    <shortcut
-        android:shortcutId="ms1"
-        android:enabled="true"
-        android:icon="@drawable/icon1"
-        android:shortcutShortLabel="@string/shortcut_title1"
-        android:shortcutLongLabel="@string/shortcut_text1"
-        android:shortcutDisabledMessage="@string/shortcut_disabled_message1"
-        >
-        <intent
-            android:action="action1"
-            android:data="http://a.b.c/1"
-            >
-        </intent>
-        <categories android:name="android.shortcut.conversation" />
-        <categories android:name="android.shortcut.media" />
-    </shortcut>
-    <shortcut
-        android:shortcutId="ms2"
-        android:enabled="true"
-        android:icon="@drawable/icon2"
-        android:shortcutShortLabel="@string/shortcut_title2"
-        android:shortcutLongLabel="@string/shortcut_text2"
-        android:shortcutDisabledMessage="@string/shortcut_disabled_message2"
-        >
-        <intent
-            android:action="action2"
-            >
-        </intent>
-        <categories android:name="android.shortcut.conversation" />
-    </shortcut>
-    <shortcut
-        android:shortcutId="ms3"
-        android:shortcutShortLabel="@string/shortcut_title1"
-        >
-        <intent
-            android:action="android.intent.action.VIEW"
-            >
-        </intent>
-    </shortcut>
-    <shortcut
-        android:shortcutId="ms4"
-        android:shortcutShortLabel="@string/shortcut_title2"
-        >
-        <intent
-            android:action="android.intent.action.VIEW2"
-            >
-        </intent>
-        <categories />
-        <categories android:name="" />
-        <categories android:name="cat" />
-    </shortcut>
-    <shortcut
-        android:shortcutId="ms5"
-        android:shortcutShortLabel="@string/shortcut_title1"
-        >
-        <intent
-            android:action="action"
-            android:data="http://www/"
-            android:targetPackage="abc"
-            android:targetClass=".xyz"
-            android:mimeType="foo/bar"
-            >
-            <categories android:name="cat1" />
-            <categories android:name="cat2" />
-            <extra android:name="key1" android:value="value1" />
-            <extra android:name="key2" android:value="value2" />
-        </intent>
-    </shortcut>
-</shortcuts>
diff --git a/services/tests/servicestests/res/xml/shortcut_5_alt.xml b/services/tests/servicestests/res/xml/shortcut_5_alt.xml
deleted file mode 100644
index f79cd6f1573..00000000000
--- a/services/tests/servicestests/res/xml/shortcut_5_alt.xml
+++ /dev/null
@@ -1,74 +0,0 @@
-<?xml version="1.0" encoding="utf-8"?>
-<!-- Copyright (C) 2016 The Android Open Source Project
-
-     Licensed under the Apache License, Version 2.0 (the "License");
-     you may not use this file except in compliance with the License.
-     You may obtain a copy of the License at
-
-          http://www.apache.org/licenses/LICENSE-2.0
-
-     Unless required by applicable law or agreed to in writing, software
-     distributed under the License is distributed on an "AS IS" BASIS,
-     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-     See the License for the specific language governing permissions and
-     limitations under the License.
--->
-<shortcuts xmlns:android="http://schemas.android.com/apk/res/android" >
-    <shortcut
-        android:shortcutId="ms1_alt"
-        android:enabled="true"
-        android:icon="@drawable/icon1"
-        android:shortcutShortLabel="@string/shortcut_title1"
-        android:shortcutLongLabel="@string/shortcut_text1"
-        android:shortcutDisabledMessage="@string/shortcut_disabled_message1"
-        >
-        <intent
-            android:action="action1"
-            android:data="http://a.b.c/1"
-            >
-        </intent>
-        <categories android:name="android.shortcut.conversation" />
-        <categories android:name="android.shortcut.media" />
-    </shortcut>
-    <shortcut
-        android:shortcutId="ms2_alt"
-        android:enabled="true"
-        android:icon="@drawable/icon2"
-        android:shortcutShortLabel="@string/shortcut_title2"
-        android:shortcutLongLabel="@string/shortcut_text2"
-        android:shortcutDisabledMessage="@string/shortcut_disabled_message2"
-        >
-        <intent
-            android:action="action2"
-            >
-        </intent>
-        <categories android:name="android.shortcut.conversation" />
-    </shortcut>
-    <shortcut
-        android:shortcutId="ms3_alt"
-        android:shortcutShortLabel="@string/shortcut_title1"
-        >
-        <intent
-            android:action="android.intent.action.VIEW"
-            >
-        </intent>
-    </shortcut>
-    <shortcut
-        android:shortcutId="ms4_alt"
-        android:shortcutShortLabel="@string/shortcut_title1"
-        >
-        <intent
-            android:action="android.intent.action.VIEW"
-            >
-        </intent>
-    </shortcut>
-    <shortcut
-        android:shortcutId="ms5_alt"
-        android:shortcutShortLabel="@string/shortcut_title1"
-        >
-        <intent
-            android:action="android.intent.action.VIEW"
-            >
-        </intent>
-    </shortcut>
-</shortcuts>
diff --git a/services/tests/servicestests/res/xml/shortcut_5_reverse.xml b/services/tests/servicestests/res/xml/shortcut_5_reverse.xml
deleted file mode 100644
index d5b7c8fde0b..00000000000
--- a/services/tests/servicestests/res/xml/shortcut_5_reverse.xml
+++ /dev/null
@@ -1,78 +0,0 @@
-<?xml version="1.0" encoding="utf-8"?>
-<!-- Copyright (C) 2016 The Android Open Source Project
-
-     Licensed under the Apache License, Version 2.0 (the "License");
-     you may not use this file except in compliance with the License.
-     You may obtain a copy of the License at
-
-          http://www.apache.org/licenses/LICENSE-2.0
-
-     Unless required by applicable law or agreed to in writing, software
-     distributed under the License is distributed on an "AS IS" BASIS,
-     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-     See the License for the specific language governing permissions and
-     limitations under the License.
--->
-<shortcuts xmlns:android="http://schemas.android.com/apk/res/android" >
-    <shortcut
-        android:shortcutId="ms5"
-        android:enabled="true"
-        android:icon="@drawable/icon1"
-        android:shortcutShortLabel="@string/shortcut_title1"
-        android:shortcutLongLabel="@string/shortcut_text1"
-        android:shortcutDisabledMessage="@string/shortcut_disabled_message1"
-        >
-        <intent
-            android:action="action1"
-            android:data="http://a.b.c/1"
-            >
-        </intent>
-        <categories android:name="android.shortcut.conversation" />
-        <categories android:name="android.shortcut.media" />
-    </shortcut>
-    <shortcut
-        android:shortcutId="ms4"
-        android:enabled="true"
-        android:icon="@drawable/icon2"
-        android:shortcutShortLabel="@string/shortcut_title2"
-        android:shortcutLongLabel="@string/shortcut_text2"
-        android:shortcutDisabledMessage="@string/shortcut_disabled_message2"
-        >
-        <intent
-            android:action="action2"
-            >
-        </intent>
-        <categories android:name="android.shortcut.conversation" />
-    </shortcut>
-    <shortcut
-        android:shortcutId="ms3"
-        android:shortcutShortLabel="@string/shortcut_title1"
-        >
-        <intent
-            android:action="android.intent.action.VIEW"
-            >
-        </intent>
-    </shortcut>
-    <shortcut
-        android:shortcutId="ms2"
-        android:shortcutShortLabel="@string/shortcut_title1"
-        >
-        <intent
-            android:action="android.intent.action.VIEW"
-            >
-        </intent>
-    </shortcut>
-    <shortcut
-        android:shortcutId="ms1"
-        android:shortcutShortLabel="@string/shortcut_title1"
-        >
-        <intent
-            android:action="action"
-            >
-            <categories android:name="cat1" />
-            <categories android:name="cat2" />
-            <extra android:name="key1" android:value="value1" />
-            <extra android:name="key2" android:value="value2" />
-        </intent>
-    </shortcut>
-</shortcuts>
diff --git a/services/tests/servicestests/res/xml/shortcut_error_1.xml b/services/tests/servicestests/res/xml/shortcut_error_1.xml
deleted file mode 100644
index 3990d027050..00000000000
--- a/services/tests/servicestests/res/xml/shortcut_error_1.xml
+++ /dev/null
@@ -1,34 +0,0 @@
-<?xml version="1.0" encoding="utf-8"?>
-<!-- Copyright (C) 2016 The Android Open Source Project
-
-     Licensed under the Apache License, Version 2.0 (the "License");
-     you may not use this file except in compliance with the License.
-     You may obtain a copy of the License at
-
-          http://www.apache.org/licenses/LICENSE-2.0
-
-     Unless required by applicable law or agreed to in writing, software
-     distributed under the License is distributed on an "AS IS" BASIS,
-     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-     See the License for the specific language governing permissions and
-     limitations under the License.
--->
-<shortcuts xmlns:android="http://schemas.android.com/apk/res/android" >
-    <shortcut
-        android:shortcutShortLabel="@string/shortcut_title1"
-        >
-        <intent
-            android:action="android.intent.action.VIEW"
-            >
-        </intent>
-    </shortcut>
-    <shortcut
-        android:shortcutId="x1"
-        android:shortcutShortLabel="@string/shortcut_title1"
-        >
-        <intent
-            android:action="android.intent.action.VIEW"
-            >
-        </intent>
-    </shortcut>
-</shortcuts>
diff --git a/services/tests/servicestests/res/xml/shortcut_error_2.xml b/services/tests/servicestests/res/xml/shortcut_error_2.xml
deleted file mode 100644
index a6f715025cc..00000000000
--- a/services/tests/servicestests/res/xml/shortcut_error_2.xml
+++ /dev/null
@@ -1,34 +0,0 @@
-<?xml version="1.0" encoding="utf-8"?>
-<!-- Copyright (C) 2016 The Android Open Source Project
-
-     Licensed under the Apache License, Version 2.0 (the "License");
-     you may not use this file except in compliance with the License.
-     You may obtain a copy of the License at
-
-          http://www.apache.org/licenses/LICENSE-2.0
-
-     Unless required by applicable law or agreed to in writing, software
-     distributed under the License is distributed on an "AS IS" BASIS,
-     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-     See the License for the specific language governing permissions and
-     limitations under the License.
--->
-<shortcuts xmlns:android="http://schemas.android.com/apk/res/android" >
-    <shortcut
-        android:shortcutId="manifest-shortcut-3"
-        >
-        <intent
-            android:action="android.intent.action.VIEW"
-            >
-        </intent>
-    </shortcut>
-    <shortcut
-        android:shortcutId="x2"
-        android:shortcutShortLabel="@string/shortcut_title1"
-        >
-        <intent
-            android:action="android.intent.action.VIEW"
-            >
-        </intent>
-    </shortcut>
-</shortcuts>
diff --git a/services/tests/servicestests/res/xml/shortcut_error_3.xml b/services/tests/servicestests/res/xml/shortcut_error_3.xml
deleted file mode 100644
index 24ee024f64a..00000000000
--- a/services/tests/servicestests/res/xml/shortcut_error_3.xml
+++ /dev/null
@@ -1,36 +0,0 @@
-<?xml version="1.0" encoding="utf-8"?>
-<!-- Copyright (C) 2016 The Android Open Source Project
-
-     Licensed under the Apache License, Version 2.0 (the "License");
-     you may not use this file except in compliance with the License.
-     You may obtain a copy of the License at
-
-          http://www.apache.org/licenses/LICENSE-2.0
-
-     Unless required by applicable law or agreed to in writing, software
-     distributed under the License is distributed on an "AS IS" BASIS,
-     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-     See the License for the specific language governing permissions and
-     limitations under the License.
--->
-<shortcuts xmlns:android="http://schemas.android.com/apk/res/android" >
-    <shortcut
-        android:shortcutId="manifest-shortcut-3"
-        android:shortcutShortLabel="@string/shortcut_title1"
-    />
-    <shortcut
-        android:shortcutId="@string/shortcut_title1"
-        android:shortcutShortLabel="@string/shortcut_title1"
-    />
-    <shortcut
-        android:shortcutId="x3"
-        android:shortcutShortLabel="@string/shortcut_title1"
-        >
-        <intent
-            android:action="android.intent.action.VIEW"
-            >
-        </intent>
-        <categories android:name="@string/shortcut_title1" />
-        <categories android:name="cat2" />
-    </shortcut>
-</shortcuts>
diff --git a/services/tests/servicestests/res/xml/shortcut_error_4.xml b/services/tests/servicestests/res/xml/shortcut_error_4.xml
deleted file mode 100644
index f680e99f98c..00000000000
--- a/services/tests/servicestests/res/xml/shortcut_error_4.xml
+++ /dev/null
@@ -1,70 +0,0 @@
-<?xml version="1.0" encoding="utf-8"?>
-<!-- Copyright (C) 2016 The Android Open Source Project
-
-     Licensed under the Apache License, Version 2.0 (the "License");
-     you may not use this file except in compliance with the License.
-     You may obtain a copy of the License at
-
-          http://www.apache.org/licenses/LICENSE-2.0
-
-     Unless required by applicable law or agreed to in writing, software
-     distributed under the License is distributed on an "AS IS" BASIS,
-     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-     See the License for the specific language governing permissions and
-     limitations under the License.
--->
-<shortcuts xmlns:android="http://schemas.android.com/apk/res/android" >
-    <!-- This is valid -->
-    <shortcut
-        android:shortcutId="ms1"
-        android:shortcutShortLabel="@string/shortcut_title1"
-        >
-        <intent android:action="action1" >
-            <extra android:name="key1" android:value="value1" />
-        </intent>
-    </shortcut>
-
-    <!-- Invalid: no intent -->
-    <shortcut
-        android:shortcutId="ms_ignored1"
-        android:shortcutShortLabel="@string/shortcut_title1"
-        />
-
-    <!-- Valid: more than one intent -->
-    <shortcut
-        android:shortcutId="ms2"
-        android:shortcutShortLabel="@string/shortcut_title1"
-        >
-        <intent android:action="action2_1" >
-            <extra android:name="key1" android:value="value1" />
-        </intent>
-        <intent android:action="action2_2">
-            <extra android:name="key2" android:value="value2" />
-        </intent>
-    </shortcut>
-
-    <!-- Valid: disabled shortcut doesn't need an intent -->
-    <shortcut
-        android:shortcutId="ms3"
-        android:enabled="false"
-        android:shortcutShortLabel="@string/shortcut_title1"
-        />
-
-    <!-- Valid, but disabled shortcut's intent will be ignored. -->
-    <shortcut
-        android:shortcutId="ms4"
-        android:enabled="false"
-        android:shortcutShortLabel="@string/shortcut_title1"
-        >
-        <intent android:action="action4" />
-    </shortcut>
-
-    <!-- Invalid, no intent action (if any of the intents is invalid, the entire shortcut will be invalid.) -->
-    <shortcut
-        android:shortcutId="ms_ignored2"
-        android:shortcutShortLabel="@string/shortcut_title1"
-        >
-        <intent android:data="x"/>
-        <intent android:action="actionx"/>
-    </shortcut>
-</shortcuts>
diff --git a/services/tests/servicestests/src/android/net/ConnectivityMetricsLoggerTest.java b/services/tests/servicestests/src/android/net/ConnectivityMetricsLoggerTest.java
deleted file mode 100644
index 6d42cce2e50..00000000000
--- a/services/tests/servicestests/src/android/net/ConnectivityMetricsLoggerTest.java
+++ /dev/null
@@ -1,130 +0,0 @@
-/*
- * Copyright (C) 2016, The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package android.net;
-
-import android.os.Bundle;
-import android.os.Parcel;
-import java.util.List;
-import junit.framework.TestCase;
-import org.mockito.ArgumentCaptor;
-import org.mockito.Mock;
-import org.mockito.MockitoAnnotations;
-
-import static org.mockito.Mockito.any;
-import static org.mockito.Mockito.times;
-import static org.mockito.Mockito.verify;
-import static org.mockito.Mockito.when;
-
-public class ConnectivityMetricsLoggerTest extends TestCase {
-
-    // use same Parcel object everywhere for pointer equality
-    static final Bundle FAKE_EV = new Bundle();
-    static final int FAKE_COMPONENT = 1;
-    static final int FAKE_EVENT = 2;
-
-    @Mock IConnectivityMetricsLogger mService;
-    ArgumentCaptor<ConnectivityMetricsEvent> evCaptor;
-    ArgumentCaptor<ConnectivityMetricsEvent[]> evArrayCaptor;
-
-    ConnectivityMetricsLogger mLog;
-
-    public void setUp() {
-        MockitoAnnotations.initMocks(this);
-        evCaptor = ArgumentCaptor.forClass(ConnectivityMetricsEvent.class);
-        evArrayCaptor = ArgumentCaptor.forClass(ConnectivityMetricsEvent[].class);
-        mLog = new ConnectivityMetricsLogger(mService);
-    }
-
-    public void testLogEvents() throws Exception {
-        mLog.logEvent(1, FAKE_COMPONENT, FAKE_EVENT, FAKE_EV);
-        mLog.logEvent(2, FAKE_COMPONENT, FAKE_EVENT, FAKE_EV);
-        mLog.logEvent(3, FAKE_COMPONENT, FAKE_EVENT, FAKE_EV);
-
-        List<ConnectivityMetricsEvent> gotEvents = verifyEvents(3);
-        assertEventsEqual(expectedEvent(1), gotEvents.get(0));
-        assertEventsEqual(expectedEvent(2), gotEvents.get(1));
-        assertEventsEqual(expectedEvent(3), gotEvents.get(2));
-    }
-
-    public void testLogEventTriggerThrottling() throws Exception {
-        when(mService.logEvent(any())).thenReturn(1234L);
-
-        mLog.logEvent(1, FAKE_COMPONENT, FAKE_EVENT, FAKE_EV);
-        mLog.logEvent(2, FAKE_COMPONENT, FAKE_EVENT, FAKE_EV);
-
-        List<ConnectivityMetricsEvent> gotEvents = verifyEvents(1);
-        assertEventsEqual(expectedEvent(1), gotEvents.get(0));
-    }
-
-    public void testLogEventFails() throws Exception {
-        when(mService.logEvent(any())).thenReturn(-1L); // Error.
-
-        mLog.logEvent(1, FAKE_COMPONENT, FAKE_EVENT, FAKE_EV);
-        mLog.logEvent(2, FAKE_COMPONENT, FAKE_EVENT, FAKE_EV);
-
-        List<ConnectivityMetricsEvent> gotEvents = verifyEvents(1);
-        assertEventsEqual(expectedEvent(1), gotEvents.get(0));
-    }
-
-    public void testLogEventWhenThrottling() throws Exception {
-        when(mService.logEvent(any())).thenReturn(Long.MAX_VALUE); // Throttled
-
-        // No events are logged. The service is only called once
-        // After that, throttling state is maintained locally.
-        mLog.logEvent(1, FAKE_COMPONENT, FAKE_EVENT, FAKE_EV);
-        mLog.logEvent(2, FAKE_COMPONENT, FAKE_EVENT, FAKE_EV);
-
-        List<ConnectivityMetricsEvent> gotEvents = verifyEvents(1);
-        assertEventsEqual(expectedEvent(1), gotEvents.get(0));
-    }
-
-    public void testLogEventRecoverFromThrottling() throws Exception {
-        final long throttleTimeout = System.currentTimeMillis() + 10;
-        when(mService.logEvent(any())).thenReturn(throttleTimeout, 0L);
-
-        mLog.logEvent(1, FAKE_COMPONENT, FAKE_EVENT, FAKE_EV);
-        mLog.logEvent(2, FAKE_COMPONENT, FAKE_EVENT, FAKE_EV);
-        mLog.logEvent(3, FAKE_COMPONENT, FAKE_EVENT, FAKE_EV);
-        Thread.sleep(100);
-        mLog.logEvent(53, FAKE_COMPONENT, FAKE_EVENT, FAKE_EV);
-
-        List<ConnectivityMetricsEvent> gotEvents = verifyEvents(1);
-        assertEventsEqual(expectedEvent(1), gotEvents.get(0));
-
-        verify(mService, times(1)).logEvents(evArrayCaptor.capture());
-        ConnectivityMetricsEvent[] gotOtherEvents = evArrayCaptor.getAllValues().get(0);
-        assertEquals(ConnectivityMetricsLogger.TAG_SKIPPED_EVENTS, gotOtherEvents[0].eventTag);
-        assertEventsEqual(expectedEvent(53), gotOtherEvents[1]);
-    }
-
-    List<ConnectivityMetricsEvent> verifyEvents(int n) throws Exception {
-        verify(mService, times(n)).logEvent(evCaptor.capture());
-        return evCaptor.getAllValues();
-    }
-
-    static ConnectivityMetricsEvent expectedEvent(int timestamp) {
-        return new ConnectivityMetricsEvent((long)timestamp, FAKE_COMPONENT, FAKE_EVENT, FAKE_EV);
-    }
-
-    /** Outer equality for ConnectivityMetricsEvent to avoid overriding equals() and hashCode(). */
-    static void assertEventsEqual(ConnectivityMetricsEvent expected, ConnectivityMetricsEvent got) {
-        assertEquals(expected.timestamp, got.timestamp);
-        assertEquals(expected.componentTag, got.componentTag);
-        assertEquals(expected.eventTag, got.eventTag);
-        assertEquals(expected.data, got.data);
-    }
-}
diff --git a/services/tests/servicestests/src/android/net/IpUtilsTest.java b/services/tests/servicestests/src/android/net/IpUtilsTest.java
deleted file mode 100644
index c2d1608c461..00000000000
--- a/services/tests/servicestests/src/android/net/IpUtilsTest.java
+++ /dev/null
@@ -1,162 +0,0 @@
-/*
- * Copyright (C) 2015 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package android.net.util;
-
-import android.net.util.IpUtils;
-import android.test.suitebuilder.annotation.SmallTest;
-
-import java.nio.ByteBuffer;
-
-import junit.framework.TestCase;
-
-
-public class IpUtilsTest extends TestCase {
-
-    private static final int IPV4_HEADER_LENGTH = 20;
-    private static final int IPV6_HEADER_LENGTH = 40;
-    private static final int TCP_HEADER_LENGTH = 20;
-    private static final int UDP_HEADER_LENGTH = 8;
-    private static final int IP_CHECKSUM_OFFSET = 10;
-    private static final int TCP_CHECKSUM_OFFSET = 16;
-    private static final int UDP_CHECKSUM_OFFSET = 6;
-
-    private int getUnsignedByte(ByteBuffer buf, int offset) {
-        return buf.get(offset) & 0xff;
-    }
-
-    private int getChecksum(ByteBuffer buf, int offset) {
-        return getUnsignedByte(buf, offset) * 256 + getUnsignedByte(buf, offset + 1);
-    }
-
-    private void assertChecksumEquals(int expected, short actual) {
-        assertEquals(Integer.toHexString(expected), Integer.toHexString(actual & 0xffff));
-    }
-
-    // Generate test packets using Python code like this::
-    //
-    // from scapy import all as scapy
-    //
-    // def JavaPacketDefinition(bytes):
-    //   out = "        ByteBuffer packet = ByteBuffer.wrap(new byte[] {\n            "
-    //   for i in xrange(len(bytes)):
-    //     out += "(byte) 0x%02x" % ord(bytes[i])
-    //     if i < len(bytes) - 1:
-    //       if i % 4 == 3:
-    //         out += ",\n            "
-    //       else:
-    //         out += ", "
-    //   out += "\n        });"
-    //   return out
-    //
-    // packet = (scapy.IPv6(src="2001:db8::1", dst="2001:db8::2") /
-    //           scapy.UDP(sport=12345, dport=7) /
-    //           "hello")
-    // print JavaPacketDefinition(str(packet))
-
-    @SmallTest
-    public void testIpv6TcpChecksum() throws Exception {
-        // packet = (scapy.IPv6(src="2001:db8::1", dst="2001:db8::2", tc=0x80) /
-        //           scapy.TCP(sport=12345, dport=7,
-        //                     seq=1692871236, ack=128376451, flags=16,
-        //                     window=32768) /
-        //           "hello, world")
-        ByteBuffer packet = ByteBuffer.wrap(new byte[] {
-            (byte) 0x68, (byte) 0x00, (byte) 0x00, (byte) 0x00,
-            (byte) 0x00, (byte) 0x20, (byte) 0x06, (byte) 0x40,
-            (byte) 0x20, (byte) 0x01, (byte) 0x0d, (byte) 0xb8,
-            (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
-            (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
-            (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x01,
-            (byte) 0x20, (byte) 0x01, (byte) 0x0d, (byte) 0xb8,
-            (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
-            (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
-            (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x02,
-            (byte) 0x30, (byte) 0x39, (byte) 0x00, (byte) 0x07,
-            (byte) 0x64, (byte) 0xe7, (byte) 0x2a, (byte) 0x44,
-            (byte) 0x07, (byte) 0xa6, (byte) 0xde, (byte) 0x83,
-            (byte) 0x50, (byte) 0x10, (byte) 0x80, (byte) 0x00,
-            (byte) 0xee, (byte) 0x71, (byte) 0x00, (byte) 0x00,
-            (byte) 0x68, (byte) 0x65, (byte) 0x6c, (byte) 0x6c,
-            (byte) 0x6f, (byte) 0x2c, (byte) 0x20, (byte) 0x77,
-            (byte) 0x6f, (byte) 0x72, (byte) 0x6c, (byte) 0x64
-        });
-
-        // Check that a valid packet has checksum 0.
-        int transportLen = packet.limit() - IPV6_HEADER_LENGTH;
-        assertEquals(0, IpUtils.tcpChecksum(packet, 0, IPV6_HEADER_LENGTH, transportLen));
-
-        // Check that we can calculate the checksum from scratch.
-        int sumOffset = IPV6_HEADER_LENGTH + TCP_CHECKSUM_OFFSET;
-        int sum = getUnsignedByte(packet, sumOffset) * 256 + getUnsignedByte(packet, sumOffset + 1);
-        assertEquals(0xee71, sum);
-
-        packet.put(sumOffset, (byte) 0);
-        packet.put(sumOffset + 1, (byte) 0);
-        assertChecksumEquals(sum, IpUtils.tcpChecksum(packet, 0, IPV6_HEADER_LENGTH, transportLen));
-
-        // Check that writing the checksum back into the packet results in a valid packet.
-        packet.putShort(
-            sumOffset,
-            IpUtils.tcpChecksum(packet, 0, IPV6_HEADER_LENGTH, transportLen));
-        assertEquals(0, IpUtils.tcpChecksum(packet, 0, IPV6_HEADER_LENGTH, transportLen));
-    }
-
-    @SmallTest
-    public void testIpv4UdpChecksum() {
-        // packet = (scapy.IP(src="192.0.2.1", dst="192.0.2.2", tos=0x40) /
-        //           scapy.UDP(sport=32012, dport=4500) /
-        //           "\xff")
-        ByteBuffer packet = ByteBuffer.wrap(new byte[] {
-            (byte) 0x45, (byte) 0x40, (byte) 0x00, (byte) 0x1d,
-            (byte) 0x00, (byte) 0x01, (byte) 0x00, (byte) 0x00,
-            (byte) 0x40, (byte) 0x11, (byte) 0xf6, (byte) 0x8b,
-            (byte) 0xc0, (byte) 0x00, (byte) 0x02, (byte) 0x01,
-            (byte) 0xc0, (byte) 0x00, (byte) 0x02, (byte) 0x02,
-            (byte) 0x7d, (byte) 0x0c, (byte) 0x11, (byte) 0x94,
-            (byte) 0x00, (byte) 0x09, (byte) 0xee, (byte) 0x36,
-            (byte) 0xff
-        });
-
-        // Check that a valid packet has IP checksum 0 and UDP checksum 0xffff (0 is not a valid
-        // UDP checksum, so the udpChecksum rewrites 0 to 0xffff).
-        assertEquals(0, IpUtils.ipChecksum(packet, 0));
-        assertEquals((short) 0xffff, IpUtils.udpChecksum(packet, 0, IPV4_HEADER_LENGTH));
-
-        // Check that we can calculate the checksums from scratch.
-        final int ipSumOffset = IP_CHECKSUM_OFFSET;
-        final int ipSum = getChecksum(packet, ipSumOffset);
-        assertEquals(0xf68b, ipSum);
-
-        packet.put(ipSumOffset, (byte) 0);
-        packet.put(ipSumOffset + 1, (byte) 0);
-        assertChecksumEquals(ipSum, IpUtils.ipChecksum(packet, 0));
-
-        final int udpSumOffset = IPV4_HEADER_LENGTH + UDP_CHECKSUM_OFFSET;
-        final int udpSum = getChecksum(packet, udpSumOffset);
-        assertEquals(0xee36, udpSum);
-
-        packet.put(udpSumOffset, (byte) 0);
-        packet.put(udpSumOffset + 1, (byte) 0);
-        assertChecksumEquals(udpSum, IpUtils.udpChecksum(packet, 0, IPV4_HEADER_LENGTH));
-
-        // Check that writing the checksums back into the packet results in a valid packet.
-        packet.putShort(ipSumOffset, IpUtils.ipChecksum(packet, 0));
-        packet.putShort(udpSumOffset, IpUtils.udpChecksum(packet, 0, IPV4_HEADER_LENGTH));
-        assertEquals(0, IpUtils.ipChecksum(packet, 0));
-        assertEquals((short) 0xffff, IpUtils.udpChecksum(packet, 0, IPV4_HEADER_LENGTH));
-    }
-}
diff --git a/services/tests/servicestests/src/android/net/UidRangeTest.java b/services/tests/servicestests/src/android/net/UidRangeTest.java
deleted file mode 100644
index 221fe0f99f0..00000000000
--- a/services/tests/servicestests/src/android/net/UidRangeTest.java
+++ /dev/null
@@ -1,112 +0,0 @@
-/*
- * Copyright (C) 2016 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package android.net;
-
-import android.os.Parcel;
-import android.test.suitebuilder.annotation.SmallTest;
-
-import junit.framework.TestCase;
-
-import static org.junit.Assert.assertArrayEquals;
-
-public class UidRangeTest extends TestCase {
-
-    static {
-        System.loadLibrary("servicestestsjni");
-    }
-
-    private static native byte[] readAndWriteNative(byte[] inParcel);
-    private static native int getStart(byte[] inParcel);
-    private static native int getStop(byte[] inParcel);
-
-    @SmallTest
-    public void testNativeParcelUnparcel() {
-        UidRange original = new UidRange(1234, Integer.MAX_VALUE);
-
-        byte[] inParcel = marshall(original);
-        byte[] outParcel = readAndWriteNative(inParcel);
-        UidRange roundTrip = unmarshall(outParcel);
-
-        assertEquals(original, roundTrip);
-        assertArrayEquals(inParcel, outParcel);
-    }
-
-    @SmallTest
-    public void testIndividualNativeFields() {
-        UidRange original = new UidRange(0x11115678, 0x22224321);
-        byte[] originalBytes = marshall(original);
-
-        assertEquals(original.start, getStart(originalBytes));
-        assertEquals(original.stop, getStop(originalBytes));
-    }
-
-    @SmallTest
-    public void testSingleItemUidRangeAllowed() {
-        new UidRange(123, 123);
-        new UidRange(0, 0);
-        new UidRange(Integer.MAX_VALUE, Integer.MAX_VALUE);
-    }
-
-    @SmallTest
-    public void testNegativeUidsDisallowed() {
-        try {
-            new UidRange(-2, 100);
-            fail("Exception not thrown for negative start UID");
-        } catch (IllegalArgumentException expected) {
-        }
-
-        try {
-            new UidRange(-200, -100);
-            fail("Exception not thrown for negative stop UID");
-        } catch (IllegalArgumentException expected) {
-        }
-    }
-
-    @SmallTest
-    public void testStopLessThanStartDisallowed() {
-        final int x = 4195000;
-        try {
-            new UidRange(x, x - 1);
-            fail("Exception not thrown for negative-length UID range");
-        } catch (IllegalArgumentException expected) {
-        }
-    }
-
-    /**
-     * Write a {@link UidRange} into an empty parcel and return the underlying data.
-     *
-     * @see unmarshall(byte[])
-     */
-    private static byte[] marshall(UidRange range) {
-        Parcel p = Parcel.obtain();
-        range.writeToParcel(p, /* flags */ 0);
-        p.setDataPosition(0);
-        return p.marshall();
-    }
-
-    /**
-     * Read raw bytes into a parcel, and read a {@link UidRange} back out of them.
-     *
-     * @see marshall(UidRange)
-     */
-    private static UidRange unmarshall(byte[] data) {
-        Parcel p = Parcel.obtain();
-        p.unmarshall(data, 0, data.length);
-        p.setDataPosition(0);
-        return UidRange.CREATOR.createFromParcel(p);
-    }
-}
diff --git a/services/tests/servicestests/src/android/net/apf/ApfTest.java b/services/tests/servicestests/src/android/net/apf/ApfTest.java
deleted file mode 100644
index 6092fddc6be..00000000000
--- a/services/tests/servicestests/src/android/net/apf/ApfTest.java
+++ /dev/null
@@ -1,1205 +0,0 @@
-/*
- * Copyright (C) 2012 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package android.net.apf;
-
-import static android.system.OsConstants.*;
-
-import com.android.frameworks.servicestests.R;
-
-import android.net.LinkAddress;
-import android.net.LinkProperties;
-import android.net.NetworkUtils;
-import android.net.apf.ApfCapabilities;
-import android.net.apf.ApfFilter;
-import android.net.apf.ApfGenerator;
-import android.net.apf.ApfGenerator.IllegalInstructionException;
-import android.net.apf.ApfGenerator.Register;
-import android.net.ip.IpManager;
-import android.net.metrics.IpConnectivityLog;
-import android.net.metrics.RaEvent;
-import android.os.ConditionVariable;
-import android.os.Parcelable;
-import android.system.ErrnoException;
-import android.system.Os;
-import android.test.AndroidTestCase;
-import android.test.suitebuilder.annotation.LargeTest;
-
-import org.mockito.ArgumentCaptor;
-import org.mockito.Mock;
-import org.mockito.MockitoAnnotations;
-import static org.mockito.Mockito.atLeastOnce;
-import static org.mockito.Mockito.verify;
-
-import java.io.File;
-import java.io.FileDescriptor;
-import java.io.FileOutputStream;
-import java.io.IOException;
-import java.io.InputStream;
-import java.io.OutputStream;
-import java.net.InetAddress;
-import java.net.NetworkInterface;
-import java.nio.ByteBuffer;
-import java.util.List;
-
-import libcore.io.IoUtils;
-import libcore.io.Streams;
-
-/**
- * Tests for APF program generator and interpreter.
- *
- * Build, install and run with:
- *  runtest frameworks-services -c android.net.apf.ApfTest
- */
-public class ApfTest extends AndroidTestCase {
-    private static final int TIMEOUT_MS = 500;
-
-    @Mock IpConnectivityLog mLog;
-
-    @Override
-    public void setUp() throws Exception {
-        super.setUp();
-        MockitoAnnotations.initMocks(this);
-        // Load up native shared library containing APF interpreter exposed via JNI.
-        System.loadLibrary("servicestestsjni");
-    }
-
-    // Expected return codes from APF interpreter.
-    private final static int PASS = 1;
-    private final static int DROP = 0;
-    // Interpreter will just accept packets without link layer headers, so pad fake packet to at
-    // least the minimum packet size.
-    private final static int MIN_PKT_SIZE = 15;
-
-    private final static boolean DROP_MULTICAST = true;
-    private final static boolean ALLOW_MULTICAST = false;
-
-    private static String label(int code) {
-        switch (code) {
-            case PASS: return "PASS";
-            case DROP: return "DROP";
-            default:   return "UNKNOWN";
-        }
-    }
-
-    private static void assertReturnCodesEqual(int expected, int got) {
-        assertEquals(label(expected), label(got));
-    }
-
-    private void assertVerdict(int expected, byte[] program, byte[] packet, int filterAge) {
-        assertReturnCodesEqual(expected, apfSimulate(program, packet, filterAge));
-    }
-
-    private void assertVerdict(int expected, byte[] program, byte[] packet) {
-        assertReturnCodesEqual(expected, apfSimulate(program, packet, 0));
-    }
-
-    private void assertPass(byte[] program, byte[] packet, int filterAge) {
-        assertVerdict(PASS, program, packet, filterAge);
-    }
-
-    private void assertPass(byte[] program, byte[] packet) {
-        assertVerdict(PASS, program, packet);
-    }
-
-    private void assertDrop(byte[] program, byte[] packet, int filterAge) {
-        assertVerdict(DROP, program, packet, filterAge);
-    }
-
-    private void assertDrop(byte[] program, byte[] packet) {
-        assertVerdict(DROP, program, packet);
-    }
-
-    private void assertVerdict(int expected, ApfGenerator gen, byte[] packet, int filterAge)
-            throws IllegalInstructionException {
-        assertReturnCodesEqual(expected, apfSimulate(gen.generate(), packet, filterAge));
-    }
-
-    private void assertPass(ApfGenerator gen, byte[] packet, int filterAge)
-            throws IllegalInstructionException {
-        assertVerdict(PASS, gen, packet, filterAge);
-    }
-
-    private void assertDrop(ApfGenerator gen, byte[] packet, int filterAge)
-            throws IllegalInstructionException {
-        assertVerdict(DROP, gen, packet, filterAge);
-    }
-
-    private void assertPass(ApfGenerator gen)
-            throws IllegalInstructionException {
-        assertVerdict(PASS, gen, new byte[MIN_PKT_SIZE], 0);
-    }
-
-    private void assertDrop(ApfGenerator gen)
-            throws IllegalInstructionException {
-        assertVerdict(DROP, gen, new byte[MIN_PKT_SIZE], 0);
-    }
-
-    /**
-     * Test each instruction by generating a program containing the instruction,
-     * generating bytecode for that program and running it through the
-     * interpreter to verify it functions correctly.
-     */
-    @LargeTest
-    public void testApfInstructions() throws IllegalInstructionException {
-        // Empty program should pass because having the program counter reach the
-        // location immediately after the program indicates the packet should be
-        // passed to the AP.
-        ApfGenerator gen = new ApfGenerator();
-        assertPass(gen);
-
-        // Test jumping to pass label.
-        gen = new ApfGenerator();
-        gen.addJump(gen.PASS_LABEL);
-        byte[] program = gen.generate();
-        assertEquals(1, program.length);
-        assertEquals((14 << 3) | (0 << 1) | 0, program[0]);
-        assertPass(program, new byte[MIN_PKT_SIZE], 0);
-
-        // Test jumping to drop label.
-        gen = new ApfGenerator();
-        gen.addJump(gen.DROP_LABEL);
-        program = gen.generate();
-        assertEquals(2, program.length);
-        assertEquals((14 << 3) | (1 << 1) | 0, program[0]);
-        assertEquals(1, program[1]);
-        assertDrop(program, new byte[15], 15);
-
-        // Test jumping if equal to 0.
-        gen = new ApfGenerator();
-        gen.addJumpIfR0Equals(0, gen.DROP_LABEL);
-        assertDrop(gen);
-
-        // Test jumping if not equal to 0.
-        gen = new ApfGenerator();
-        gen.addJumpIfR0NotEquals(0, gen.DROP_LABEL);
-        assertPass(gen);
-        gen = new ApfGenerator();
-        gen.addLoadImmediate(Register.R0, 1);
-        gen.addJumpIfR0NotEquals(0, gen.DROP_LABEL);
-        assertDrop(gen);
-
-        // Test jumping if registers equal.
-        gen = new ApfGenerator();
-        gen.addJumpIfR0EqualsR1(gen.DROP_LABEL);
-        assertDrop(gen);
-
-        // Test jumping if registers not equal.
-        gen = new ApfGenerator();
-        gen.addJumpIfR0NotEqualsR1(gen.DROP_LABEL);
-        assertPass(gen);
-        gen = new ApfGenerator();
-        gen.addLoadImmediate(Register.R0, 1);
-        gen.addJumpIfR0NotEqualsR1(gen.DROP_LABEL);
-        assertDrop(gen);
-
-        // Test load immediate.
-        gen = new ApfGenerator();
-        gen.addLoadImmediate(Register.R0, 1234567890);
-        gen.addJumpIfR0Equals(1234567890, gen.DROP_LABEL);
-        assertDrop(gen);
-
-        // Test add.
-        gen = new ApfGenerator();
-        gen.addAdd(1234567890);
-        gen.addJumpIfR0Equals(1234567890, gen.DROP_LABEL);
-        assertDrop(gen);
-
-        // Test subtract.
-        gen = new ApfGenerator();
-        gen.addAdd(-1234567890);
-        gen.addJumpIfR0Equals(-1234567890, gen.DROP_LABEL);
-        assertDrop(gen);
-
-        // Test or.
-        gen = new ApfGenerator();
-        gen.addOr(1234567890);
-        gen.addJumpIfR0Equals(1234567890, gen.DROP_LABEL);
-        assertDrop(gen);
-
-        // Test and.
-        gen = new ApfGenerator();
-        gen.addLoadImmediate(Register.R0, 1234567890);
-        gen.addAnd(123456789);
-        gen.addJumpIfR0Equals(1234567890 & 123456789, gen.DROP_LABEL);
-        assertDrop(gen);
-
-        // Test left shift.
-        gen = new ApfGenerator();
-        gen.addLoadImmediate(Register.R0, 1234567890);
-        gen.addLeftShift(1);
-        gen.addJumpIfR0Equals(1234567890 << 1, gen.DROP_LABEL);
-        assertDrop(gen);
-
-        // Test right shift.
-        gen = new ApfGenerator();
-        gen.addLoadImmediate(Register.R0, 1234567890);
-        gen.addRightShift(1);
-        gen.addJumpIfR0Equals(1234567890 >> 1, gen.DROP_LABEL);
-        assertDrop(gen);
-
-        // Test multiply.
-        gen = new ApfGenerator();
-        gen.addLoadImmediate(Register.R0, 1234567890);
-        gen.addMul(2);
-        gen.addJumpIfR0Equals(1234567890 * 2, gen.DROP_LABEL);
-        assertDrop(gen);
-
-        // Test divide.
-        gen = new ApfGenerator();
-        gen.addLoadImmediate(Register.R0, 1234567890);
-        gen.addDiv(2);
-        gen.addJumpIfR0Equals(1234567890 / 2, gen.DROP_LABEL);
-        assertDrop(gen);
-
-        // Test divide by zero.
-        gen = new ApfGenerator();
-        gen.addDiv(0);
-        gen.addJump(gen.DROP_LABEL);
-        assertPass(gen);
-
-        // Test add.
-        gen = new ApfGenerator();
-        gen.addLoadImmediate(Register.R1, 1234567890);
-        gen.addAddR1();
-        gen.addJumpIfR0Equals(1234567890, gen.DROP_LABEL);
-        assertDrop(gen);
-
-        // Test subtract.
-        gen = new ApfGenerator();
-        gen.addLoadImmediate(Register.R1, -1234567890);
-        gen.addAddR1();
-        gen.addJumpIfR0Equals(-1234567890, gen.DROP_LABEL);
-        assertDrop(gen);
-
-        // Test or.
-        gen = new ApfGenerator();
-        gen.addLoadImmediate(Register.R1, 1234567890);
-        gen.addOrR1();
-        gen.addJumpIfR0Equals(1234567890, gen.DROP_LABEL);
-        assertDrop(gen);
-
-        // Test and.
-        gen = new ApfGenerator();
-        gen.addLoadImmediate(Register.R0, 1234567890);
-        gen.addLoadImmediate(Register.R1, 123456789);
-        gen.addAndR1();
-        gen.addJumpIfR0Equals(1234567890 & 123456789, gen.DROP_LABEL);
-        assertDrop(gen);
-
-        // Test left shift.
-        gen = new ApfGenerator();
-        gen.addLoadImmediate(Register.R0, 1234567890);
-        gen.addLoadImmediate(Register.R1, 1);
-        gen.addLeftShiftR1();
-        gen.addJumpIfR0Equals(1234567890 << 1, gen.DROP_LABEL);
-        assertDrop(gen);
-
-        // Test right shift.
-        gen = new ApfGenerator();
-        gen.addLoadImmediate(Register.R0, 1234567890);
-        gen.addLoadImmediate(Register.R1, -1);
-        gen.addLeftShiftR1();
-        gen.addJumpIfR0Equals(1234567890 >> 1, gen.DROP_LABEL);
-        assertDrop(gen);
-
-        // Test multiply.
-        gen = new ApfGenerator();
-        gen.addLoadImmediate(Register.R0, 1234567890);
-        gen.addLoadImmediate(Register.R1, 2);
-        gen.addMulR1();
-        gen.addJumpIfR0Equals(1234567890 * 2, gen.DROP_LABEL);
-        assertDrop(gen);
-
-        // Test divide.
-        gen = new ApfGenerator();
-        gen.addLoadImmediate(Register.R0, 1234567890);
-        gen.addLoadImmediate(Register.R1, 2);
-        gen.addDivR1();
-        gen.addJumpIfR0Equals(1234567890 / 2, gen.DROP_LABEL);
-        assertDrop(gen);
-
-        // Test divide by zero.
-        gen = new ApfGenerator();
-        gen.addDivR1();
-        gen.addJump(gen.DROP_LABEL);
-        assertPass(gen);
-
-        // Test byte load.
-        gen = new ApfGenerator();
-        gen.addLoad8(Register.R0, 1);
-        gen.addJumpIfR0Equals(45, gen.DROP_LABEL);
-        assertDrop(gen, new byte[]{123,45,0,0,0,0,0,0,0,0,0,0,0,0,0}, 0);
-
-        // Test out of bounds load.
-        gen = new ApfGenerator();
-        gen.addLoad8(Register.R0, 16);
-        gen.addJumpIfR0Equals(0, gen.DROP_LABEL);
-        assertPass(gen, new byte[]{123,45,0,0,0,0,0,0,0,0,0,0,0,0,0}, 0);
-
-        // Test half-word load.
-        gen = new ApfGenerator();
-        gen.addLoad16(Register.R0, 1);
-        gen.addJumpIfR0Equals((45 << 8) | 67, gen.DROP_LABEL);
-        assertDrop(gen, new byte[]{123,45,67,0,0,0,0,0,0,0,0,0,0,0,0}, 0);
-
-        // Test word load.
-        gen = new ApfGenerator();
-        gen.addLoad32(Register.R0, 1);
-        gen.addJumpIfR0Equals((45 << 24) | (67 << 16) | (89 << 8) | 12, gen.DROP_LABEL);
-        assertDrop(gen, new byte[]{123,45,67,89,12,0,0,0,0,0,0,0,0,0,0}, 0);
-
-        // Test byte indexed load.
-        gen = new ApfGenerator();
-        gen.addLoadImmediate(Register.R1, 1);
-        gen.addLoad8Indexed(Register.R0, 0);
-        gen.addJumpIfR0Equals(45, gen.DROP_LABEL);
-        assertDrop(gen, new byte[]{123,45,0,0,0,0,0,0,0,0,0,0,0,0,0}, 0);
-
-        // Test out of bounds indexed load.
-        gen = new ApfGenerator();
-        gen.addLoadImmediate(Register.R1, 8);
-        gen.addLoad8Indexed(Register.R0, 8);
-        gen.addJumpIfR0Equals(0, gen.DROP_LABEL);
-        assertPass(gen, new byte[]{123,45,0,0,0,0,0,0,0,0,0,0,0,0,0}, 0);
-
-        // Test half-word indexed load.
-        gen = new ApfGenerator();
-        gen.addLoadImmediate(Register.R1, 1);
-        gen.addLoad16Indexed(Register.R0, 0);
-        gen.addJumpIfR0Equals((45 << 8) | 67, gen.DROP_LABEL);
-        assertDrop(gen, new byte[]{123,45,67,0,0,0,0,0,0,0,0,0,0,0,0}, 0);
-
-        // Test word indexed load.
-        gen = new ApfGenerator();
-        gen.addLoadImmediate(Register.R1, 1);
-        gen.addLoad32Indexed(Register.R0, 0);
-        gen.addJumpIfR0Equals((45 << 24) | (67 << 16) | (89 << 8) | 12, gen.DROP_LABEL);
-        assertDrop(gen, new byte[]{123,45,67,89,12,0,0,0,0,0,0,0,0,0,0}, 0);
-
-        // Test jumping if greater than.
-        gen = new ApfGenerator();
-        gen.addJumpIfR0GreaterThan(0, gen.DROP_LABEL);
-        assertPass(gen);
-        gen = new ApfGenerator();
-        gen.addLoadImmediate(Register.R0, 1);
-        gen.addJumpIfR0GreaterThan(0, gen.DROP_LABEL);
-        assertDrop(gen);
-
-        // Test jumping if less than.
-        gen = new ApfGenerator();
-        gen.addJumpIfR0LessThan(0, gen.DROP_LABEL);
-        assertPass(gen);
-        gen = new ApfGenerator();
-        gen.addJumpIfR0LessThan(1, gen.DROP_LABEL);
-        assertDrop(gen);
-
-        // Test jumping if any bits set.
-        gen = new ApfGenerator();
-        gen.addJumpIfR0AnyBitsSet(3, gen.DROP_LABEL);
-        assertPass(gen);
-        gen = new ApfGenerator();
-        gen.addLoadImmediate(Register.R0, 1);
-        gen.addJumpIfR0AnyBitsSet(3, gen.DROP_LABEL);
-        assertDrop(gen);
-        gen = new ApfGenerator();
-        gen.addLoadImmediate(Register.R0, 3);
-        gen.addJumpIfR0AnyBitsSet(3, gen.DROP_LABEL);
-        assertDrop(gen);
-
-        // Test jumping if register greater than.
-        gen = new ApfGenerator();
-        gen.addJumpIfR0GreaterThanR1(gen.DROP_LABEL);
-        assertPass(gen);
-        gen = new ApfGenerator();
-        gen.addLoadImmediate(Register.R0, 2);
-        gen.addLoadImmediate(Register.R1, 1);
-        gen.addJumpIfR0GreaterThanR1(gen.DROP_LABEL);
-        assertDrop(gen);
-
-        // Test jumping if register less than.
-        gen = new ApfGenerator();
-        gen.addJumpIfR0LessThanR1(gen.DROP_LABEL);
-        assertPass(gen);
-        gen = new ApfGenerator();
-        gen.addLoadImmediate(Register.R1, 1);
-        gen.addJumpIfR0LessThanR1(gen.DROP_LABEL);
-        assertDrop(gen);
-
-        // Test jumping if any bits set in register.
-        gen = new ApfGenerator();
-        gen.addLoadImmediate(Register.R1, 3);
-        gen.addJumpIfR0AnyBitsSetR1(gen.DROP_LABEL);
-        assertPass(gen);
-        gen = new ApfGenerator();
-        gen.addLoadImmediate(Register.R1, 3);
-        gen.addLoadImmediate(Register.R0, 1);
-        gen.addJumpIfR0AnyBitsSetR1(gen.DROP_LABEL);
-        assertDrop(gen);
-        gen = new ApfGenerator();
-        gen.addLoadImmediate(Register.R1, 3);
-        gen.addLoadImmediate(Register.R0, 3);
-        gen.addJumpIfR0AnyBitsSetR1(gen.DROP_LABEL);
-        assertDrop(gen);
-
-        // Test load from memory.
-        gen = new ApfGenerator();
-        gen.addLoadFromMemory(Register.R0, 0);
-        gen.addJumpIfR0Equals(0, gen.DROP_LABEL);
-        assertDrop(gen);
-
-        // Test store to memory.
-        gen = new ApfGenerator();
-        gen.addLoadImmediate(Register.R1, 1234567890);
-        gen.addStoreToMemory(Register.R1, 12);
-        gen.addLoadFromMemory(Register.R0, 12);
-        gen.addJumpIfR0Equals(1234567890, gen.DROP_LABEL);
-        assertDrop(gen);
-
-        // Test filter age pre-filled memory.
-        gen = new ApfGenerator();
-        gen.addLoadFromMemory(Register.R0, gen.FILTER_AGE_MEMORY_SLOT);
-        gen.addJumpIfR0Equals(1234567890, gen.DROP_LABEL);
-        assertDrop(gen, new byte[MIN_PKT_SIZE], 1234567890);
-
-        // Test packet size pre-filled memory.
-        gen = new ApfGenerator();
-        gen.addLoadFromMemory(Register.R0, gen.PACKET_SIZE_MEMORY_SLOT);
-        gen.addJumpIfR0Equals(MIN_PKT_SIZE, gen.DROP_LABEL);
-        assertDrop(gen);
-
-        // Test IPv4 header size pre-filled memory.
-        gen = new ApfGenerator();
-        gen.addLoadFromMemory(Register.R0, gen.IPV4_HEADER_SIZE_MEMORY_SLOT);
-        gen.addJumpIfR0Equals(20, gen.DROP_LABEL);
-        assertDrop(gen, new byte[]{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0x45}, 0);
-
-        // Test not.
-        gen = new ApfGenerator();
-        gen.addLoadImmediate(Register.R0, 1234567890);
-        gen.addNot(Register.R0);
-        gen.addJumpIfR0Equals(~1234567890, gen.DROP_LABEL);
-        assertDrop(gen);
-
-        // Test negate.
-        gen = new ApfGenerator();
-        gen.addLoadImmediate(Register.R0, 1234567890);
-        gen.addNeg(Register.R0);
-        gen.addJumpIfR0Equals(-1234567890, gen.DROP_LABEL);
-        assertDrop(gen);
-
-        // Test move.
-        gen = new ApfGenerator();
-        gen.addLoadImmediate(Register.R1, 1234567890);
-        gen.addMove(Register.R0);
-        gen.addJumpIfR0Equals(1234567890, gen.DROP_LABEL);
-        assertDrop(gen);
-        gen = new ApfGenerator();
-        gen.addLoadImmediate(Register.R0, 1234567890);
-        gen.addMove(Register.R1);
-        gen.addJumpIfR0Equals(1234567890, gen.DROP_LABEL);
-        assertDrop(gen);
-
-        // Test swap.
-        gen = new ApfGenerator();
-        gen.addLoadImmediate(Register.R1, 1234567890);
-        gen.addSwap();
-        gen.addJumpIfR0Equals(1234567890, gen.DROP_LABEL);
-        assertDrop(gen);
-        gen = new ApfGenerator();
-        gen.addLoadImmediate(Register.R0, 1234567890);
-        gen.addSwap();
-        gen.addJumpIfR0Equals(0, gen.DROP_LABEL);
-        assertDrop(gen);
-
-        // Test jump if bytes not equal.
-        gen = new ApfGenerator();
-        gen.addLoadImmediate(Register.R0, 1);
-        gen.addJumpIfBytesNotEqual(Register.R0, new byte[]{123}, gen.DROP_LABEL);
-        program = gen.generate();
-        assertEquals(6, program.length);
-        assertEquals((13 << 3) | (1 << 1) | 0, program[0]);
-        assertEquals(1, program[1]);
-        assertEquals(((20 << 3) | (1 << 1) | 0) - 256, program[2]);
-        assertEquals(1, program[3]);
-        assertEquals(1, program[4]);
-        assertEquals(123, program[5]);
-        assertDrop(program, new byte[MIN_PKT_SIZE], 0);
-        gen = new ApfGenerator();
-        gen.addLoadImmediate(Register.R0, 1);
-        gen.addJumpIfBytesNotEqual(Register.R0, new byte[]{123}, gen.DROP_LABEL);
-        byte[] packet123 = {0,123,0,0,0,0,0,0,0,0,0,0,0,0,0};
-        assertPass(gen, packet123, 0);
-        gen = new ApfGenerator();
-        gen.addJumpIfBytesNotEqual(Register.R0, new byte[]{123}, gen.DROP_LABEL);
-        assertDrop(gen, packet123, 0);
-        gen = new ApfGenerator();
-        gen.addLoadImmediate(Register.R0, 1);
-        gen.addJumpIfBytesNotEqual(Register.R0, new byte[]{1,2,30,4,5}, gen.DROP_LABEL);
-        byte[] packet12345 = {0,1,2,3,4,5,0,0,0,0,0,0,0,0,0};
-        assertDrop(gen, packet12345, 0);
-        gen = new ApfGenerator();
-        gen.addLoadImmediate(Register.R0, 1);
-        gen.addJumpIfBytesNotEqual(Register.R0, new byte[]{1,2,3,4,5}, gen.DROP_LABEL);
-        assertPass(gen, packet12345, 0);
-    }
-
-    /**
-     * Generate some BPF programs, translate them to APF, then run APF and BPF programs
-     * over packet traces and verify both programs filter out the same packets.
-     */
-    @LargeTest
-    public void testApfAgainstBpf() throws Exception {
-        String[] tcpdump_filters = new String[]{ "udp", "tcp", "icmp", "icmp6", "udp port 53",
-                "arp", "dst 239.255.255.250", "arp or tcp or udp port 53", "net 192.168.1.0/24",
-                "arp or icmp6 or portrange 53-54", "portrange 53-54 or portrange 100-50000",
-                "tcp[tcpflags] & (tcp-ack|tcp-fin) != 0 and (ip[2:2] > 57 or icmp)" };
-        String pcap_filename = stageFile(R.raw.apf);
-        for (String tcpdump_filter : tcpdump_filters) {
-            byte[] apf_program = Bpf2Apf.convert(compileToBpf(tcpdump_filter));
-            assertTrue("Failed to match for filter: " + tcpdump_filter,
-                    compareBpfApf(tcpdump_filter, pcap_filename, apf_program));
-        }
-    }
-
-    private class MockIpManagerCallback extends IpManager.Callback {
-        private final ConditionVariable mGotApfProgram = new ConditionVariable();
-        private byte[] mLastApfProgram;
-
-        @Override
-        public void installPacketFilter(byte[] filter) {
-            mLastApfProgram = filter;
-            mGotApfProgram.open();
-        }
-
-        public void resetApfProgramWait() {
-            mGotApfProgram.close();
-        }
-
-        public byte[] getApfProgram() {
-            assertTrue(mGotApfProgram.block(TIMEOUT_MS));
-            return mLastApfProgram;
-        }
-
-        public void assertNoProgramUpdate() {
-            assertFalse(mGotApfProgram.block(TIMEOUT_MS));
-        }
-    }
-
-    private static class TestApfFilter extends ApfFilter {
-        public final static byte[] MOCK_MAC_ADDR = {1,2,3,4,5,6};
-        private FileDescriptor mWriteSocket;
-
-        public TestApfFilter(IpManager.Callback ipManagerCallback, boolean multicastFilter,
-                IpConnectivityLog log) throws Exception {
-            super(new ApfCapabilities(2, 1700, ARPHRD_ETHER), NetworkInterface.getByName("lo"),
-                    ipManagerCallback, multicastFilter, log);
-        }
-
-        // Pretend an RA packet has been received and show it to ApfFilter.
-        public void pretendPacketReceived(byte[] packet) throws IOException, ErrnoException {
-            // ApfFilter's ReceiveThread will be waiting to read this.
-            Os.write(mWriteSocket, packet, 0, packet.length);
-        }
-
-        @Override
-        void maybeStartFilter() {
-            mHardwareAddress = MOCK_MAC_ADDR;
-            installNewProgramLocked();
-
-            // Create two sockets, "readSocket" and "mWriteSocket" and connect them together.
-            FileDescriptor readSocket = new FileDescriptor();
-            mWriteSocket = new FileDescriptor();
-            try {
-                Os.socketpair(AF_UNIX, SOCK_STREAM, 0, mWriteSocket, readSocket);
-            } catch (ErrnoException e) {
-                fail();
-                return;
-            }
-            // Now pass readSocket to ReceiveThread as if it was setup to read raw RAs.
-            // This allows us to pretend RA packets have been recieved via pretendPacketReceived().
-            mReceiveThread = new ReceiveThread(readSocket);
-            mReceiveThread.start();
-        }
-
-        @Override
-        public void shutdown() {
-            super.shutdown();
-            IoUtils.closeQuietly(mWriteSocket);
-        }
-    }
-
-    private static final int ETH_HEADER_LEN = 14;
-    private static final int ETH_DEST_ADDR_OFFSET = 0;
-    private static final int ETH_ETHERTYPE_OFFSET = 12;
-    private static final byte[] ETH_BROADCAST_MAC_ADDRESS =
-            {(byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff };
-
-    private static final int IPV4_VERSION_IHL_OFFSET = ETH_HEADER_LEN + 0;
-    private static final int IPV4_PROTOCOL_OFFSET = ETH_HEADER_LEN + 9;
-    private static final int IPV4_DEST_ADDR_OFFSET = ETH_HEADER_LEN + 16;
-    private static final byte[] IPV4_BROADCAST_ADDRESS =
-            {(byte) 255, (byte) 255, (byte) 255, (byte) 255};
-
-    private static final int IPV6_NEXT_HEADER_OFFSET = ETH_HEADER_LEN + 6;
-    private static final int IPV6_HEADER_LEN = 40;
-    private static final int IPV6_DEST_ADDR_OFFSET = ETH_HEADER_LEN + 24;
-    // The IPv6 all nodes address ff02::1
-    private static final byte[] IPV6_ALL_NODES_ADDRESS =
-            { (byte) 0xff, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1 };
-    private static final byte[] IPV6_ALL_ROUTERS_ADDRESS =
-            { (byte) 0xff, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2 };
-
-    private static final int ICMP6_TYPE_OFFSET = ETH_HEADER_LEN + IPV6_HEADER_LEN;
-    private static final int ICMP6_ROUTER_SOLICITATION = 133;
-    private static final int ICMP6_ROUTER_ADVERTISEMENT = 134;
-    private static final int ICMP6_NEIGHBOR_SOLICITATION = 135;
-    private static final int ICMP6_NEIGHBOR_ANNOUNCEMENT = 136;
-
-    private static final int ICMP6_RA_HEADER_LEN = 16;
-    private static final int ICMP6_RA_ROUTER_LIFETIME_OFFSET =
-            ETH_HEADER_LEN + IPV6_HEADER_LEN + 6;
-    private static final int ICMP6_RA_CHECKSUM_OFFSET =
-            ETH_HEADER_LEN + IPV6_HEADER_LEN + 2;
-    private static final int ICMP6_RA_OPTION_OFFSET =
-            ETH_HEADER_LEN + IPV6_HEADER_LEN + ICMP6_RA_HEADER_LEN;
-
-    private static final int ICMP6_PREFIX_OPTION_TYPE = 3;
-    private static final int ICMP6_PREFIX_OPTION_LEN = 32;
-    private static final int ICMP6_PREFIX_OPTION_VALID_LIFETIME_OFFSET = 4;
-    private static final int ICMP6_PREFIX_OPTION_PREFERRED_LIFETIME_OFFSET = 8;
-
-    // From RFC6106: Recursive DNS Server option
-    private static final int ICMP6_RDNSS_OPTION_TYPE = 25;
-    // From RFC6106: DNS Search List option
-    private static final int ICMP6_DNSSL_OPTION_TYPE = 31;
-
-    // From RFC4191: Route Information option
-    private static final int ICMP6_ROUTE_INFO_OPTION_TYPE = 24;
-    // Above three options all have the same format:
-    private static final int ICMP6_4_BYTE_OPTION_LEN = 8;
-    private static final int ICMP6_4_BYTE_LIFETIME_OFFSET = 4;
-    private static final int ICMP6_4_BYTE_LIFETIME_LEN = 4;
-
-    private static final int UDP_HEADER_LEN = 8;
-    private static final int UDP_DESTINATION_PORT_OFFSET = ETH_HEADER_LEN + 22;
-
-    private static final int DHCP_CLIENT_PORT = 68;
-    private static final int DHCP_CLIENT_MAC_OFFSET = ETH_HEADER_LEN + UDP_HEADER_LEN + 48;
-
-    private static final int ARP_HEADER_OFFSET = ETH_HEADER_LEN;
-    private static final byte[] ARP_IPV4_REQUEST_HEADER = {
-            0, 1, // Hardware type: Ethernet (1)
-            8, 0, // Protocol type: IP (0x0800)
-            6,    // Hardware size: 6
-            4,    // Protocol size: 4
-            0, 1  // Opcode: request (1)
-    };
-    private static final byte[] ARP_IPV4_REPLY_HEADER = {
-            0, 1, // Hardware type: Ethernet (1)
-            8, 0, // Protocol type: IP (0x0800)
-            6,    // Hardware size: 6
-            4,    // Protocol size: 4
-            0, 2  // Opcode: reply (2)
-    };
-    private static final int ARP_TARGET_IP_ADDRESS_OFFSET = ETH_HEADER_LEN + 24;
-
-    private static final byte[] MOCK_IPV4_ADDR           = {10, 0, 0, 1};
-    private static final byte[] MOCK_BROADCAST_IPV4_ADDR = {10, 0, 31, (byte) 255}; // prefix = 19
-    private static final byte[] MOCK_MULTICAST_IPV4_ADDR = {(byte) 224, 0, 0, 1};
-    private static final byte[] ANOTHER_IPV4_ADDR        = {10, 0, 0, 2};
-    private static final byte[] IPV4_ANY_HOST_ADDR       = {0, 0, 0, 0};
-
-    @LargeTest
-    public void testApfFilterIPv4() throws Exception {
-        MockIpManagerCallback ipManagerCallback = new MockIpManagerCallback();
-        LinkAddress link = new LinkAddress(InetAddress.getByAddress(MOCK_IPV4_ADDR), 19);
-        LinkProperties lp = new LinkProperties();
-        lp.addLinkAddress(link);
-
-        ApfFilter apfFilter = new TestApfFilter(ipManagerCallback, DROP_MULTICAST, mLog);
-        apfFilter.setLinkProperties(lp);
-
-        byte[] program = ipManagerCallback.getApfProgram();
-
-        // Verify empty packet of 100 zero bytes is passed
-        ByteBuffer packet = ByteBuffer.wrap(new byte[100]);
-        assertPass(program, packet.array());
-
-        // Verify unicast IPv4 packet is passed
-        put(packet, ETH_DEST_ADDR_OFFSET, TestApfFilter.MOCK_MAC_ADDR);
-        packet.putShort(ETH_ETHERTYPE_OFFSET, (short)ETH_P_IP);
-        put(packet, IPV4_DEST_ADDR_OFFSET, MOCK_IPV4_ADDR);
-        assertPass(program, packet.array());
-
-        // Verify L2 unicast to IPv4 broadcast addresses is dropped (b/30231088)
-        put(packet, IPV4_DEST_ADDR_OFFSET, IPV4_BROADCAST_ADDRESS);
-        assertDrop(program, packet.array());
-        put(packet, IPV4_DEST_ADDR_OFFSET, MOCK_BROADCAST_IPV4_ADDR);
-        assertDrop(program, packet.array());
-
-        // Verify multicast/broadcast IPv4, not DHCP to us, is dropped
-        put(packet, ETH_DEST_ADDR_OFFSET, ETH_BROADCAST_MAC_ADDRESS);
-        assertDrop(program, packet.array());
-        packet.put(IPV4_VERSION_IHL_OFFSET, (byte)0x45);
-        assertDrop(program, packet.array());
-        packet.put(IPV4_PROTOCOL_OFFSET, (byte)IPPROTO_UDP);
-        assertDrop(program, packet.array());
-        packet.putShort(UDP_DESTINATION_PORT_OFFSET, (short)DHCP_CLIENT_PORT);
-        assertDrop(program, packet.array());
-        put(packet, IPV4_DEST_ADDR_OFFSET, MOCK_MULTICAST_IPV4_ADDR);
-        assertDrop(program, packet.array());
-        put(packet, IPV4_DEST_ADDR_OFFSET, MOCK_BROADCAST_IPV4_ADDR);
-        assertDrop(program, packet.array());
-        put(packet, IPV4_DEST_ADDR_OFFSET, IPV4_BROADCAST_ADDRESS);
-        assertDrop(program, packet.array());
-
-        // Verify broadcast IPv4 DHCP to us is passed
-        put(packet, DHCP_CLIENT_MAC_OFFSET, TestApfFilter.MOCK_MAC_ADDR);
-        assertPass(program, packet.array());
-
-        // Verify unicast IPv4 DHCP to us is passed
-        put(packet, ETH_DEST_ADDR_OFFSET, TestApfFilter.MOCK_MAC_ADDR);
-        assertPass(program, packet.array());
-
-        apfFilter.shutdown();
-    }
-
-    @LargeTest
-    public void testApfFilterIPv6() throws Exception {
-        MockIpManagerCallback ipManagerCallback = new MockIpManagerCallback();
-        ApfFilter apfFilter = new TestApfFilter(ipManagerCallback, ALLOW_MULTICAST, mLog);
-        byte[] program = ipManagerCallback.getApfProgram();
-
-        // Verify empty IPv6 packet is passed
-        ByteBuffer packet = ByteBuffer.wrap(new byte[100]);
-        packet.putShort(ETH_ETHERTYPE_OFFSET, (short)ETH_P_IPV6);
-        assertPass(program, packet.array());
-
-        // Verify empty ICMPv6 packet is passed
-        packet.put(IPV6_NEXT_HEADER_OFFSET, (byte)IPPROTO_ICMPV6);
-        assertPass(program, packet.array());
-
-        // Verify empty ICMPv6 NA packet is passed
-        packet.put(ICMP6_TYPE_OFFSET, (byte)ICMP6_NEIGHBOR_ANNOUNCEMENT);
-        assertPass(program, packet.array());
-
-        // Verify ICMPv6 NA to ff02::1 is dropped
-        put(packet, IPV6_DEST_ADDR_OFFSET, IPV6_ALL_NODES_ADDRESS);
-        assertDrop(program, packet.array());
-
-        // Verify ICMPv6 RS to any is dropped
-        packet.put(ICMP6_TYPE_OFFSET, (byte)ICMP6_ROUTER_SOLICITATION);
-        assertDrop(program, packet.array());
-        put(packet, IPV6_DEST_ADDR_OFFSET, IPV6_ALL_ROUTERS_ADDRESS);
-        assertDrop(program, packet.array());
-
-        apfFilter.shutdown();
-    }
-
-    @LargeTest
-    public void testApfFilterMulticast() throws Exception {
-        final byte[] unicastIpv4Addr   = {(byte)192,0,2,63};
-        final byte[] broadcastIpv4Addr = {(byte)192,0,2,(byte)255};
-        final byte[] multicastIpv4Addr = {(byte)224,0,0,1};
-        final byte[] multicastIpv6Addr = {(byte)0xff,2,0,0,0,0,0,0,0,0,0,0,0,0,0,(byte)0xfb};
-
-        MockIpManagerCallback ipManagerCallback = new MockIpManagerCallback();
-        LinkAddress link = new LinkAddress(InetAddress.getByAddress(unicastIpv4Addr), 24);
-        LinkProperties lp = new LinkProperties();
-        lp.addLinkAddress(link);
-
-        ApfFilter apfFilter = new TestApfFilter(ipManagerCallback, ALLOW_MULTICAST, mLog);
-        apfFilter.setLinkProperties(lp);
-
-        byte[] program = ipManagerCallback.getApfProgram();
-
-        // Construct IPv4 and IPv6 multicast packets.
-        ByteBuffer mcastv4packet = ByteBuffer.wrap(new byte[100]);
-        mcastv4packet.putShort(ETH_ETHERTYPE_OFFSET, (short)ETH_P_IP);
-        put(mcastv4packet, IPV4_DEST_ADDR_OFFSET, multicastIpv4Addr);
-
-        ByteBuffer mcastv6packet = ByteBuffer.wrap(new byte[100]);
-        mcastv6packet.putShort(ETH_ETHERTYPE_OFFSET, (short)ETH_P_IPV6);
-        mcastv6packet.put(IPV6_NEXT_HEADER_OFFSET, (byte)IPPROTO_UDP);
-        put(mcastv6packet, IPV6_DEST_ADDR_OFFSET, multicastIpv6Addr);
-
-        // Construct IPv4 broadcast packet.
-        ByteBuffer bcastv4packet1 = ByteBuffer.wrap(new byte[100]);
-        bcastv4packet1.put(ETH_BROADCAST_MAC_ADDRESS);
-        bcastv4packet1.putShort(ETH_ETHERTYPE_OFFSET, (short)ETH_P_IP);
-        put(bcastv4packet1, IPV4_DEST_ADDR_OFFSET, multicastIpv4Addr);
-
-        ByteBuffer bcastv4packet2 = ByteBuffer.wrap(new byte[100]);
-        bcastv4packet2.put(ETH_BROADCAST_MAC_ADDRESS);
-        bcastv4packet2.putShort(ETH_ETHERTYPE_OFFSET, (short)ETH_P_IP);
-        put(bcastv4packet2, IPV4_DEST_ADDR_OFFSET, IPV4_BROADCAST_ADDRESS);
-
-        // Construct IPv4 broadcast with L2 unicast address packet (b/30231088).
-        ByteBuffer bcastv4unicastl2packet = ByteBuffer.wrap(new byte[100]);
-        bcastv4unicastl2packet.put(TestApfFilter.MOCK_MAC_ADDR);
-        bcastv4unicastl2packet.putShort(ETH_ETHERTYPE_OFFSET, (short)ETH_P_IP);
-        put(bcastv4unicastl2packet, IPV4_DEST_ADDR_OFFSET, broadcastIpv4Addr);
-
-        // Verify initially disabled multicast filter is off
-        assertPass(program, mcastv4packet.array());
-        assertPass(program, mcastv6packet.array());
-        assertPass(program, bcastv4packet1.array());
-        assertPass(program, bcastv4packet2.array());
-        assertPass(program, bcastv4unicastl2packet.array());
-
-        // Turn on multicast filter and verify it works
-        ipManagerCallback.resetApfProgramWait();
-        apfFilter.setMulticastFilter(true);
-        program = ipManagerCallback.getApfProgram();
-        assertDrop(program, mcastv4packet.array());
-        assertDrop(program, mcastv6packet.array());
-        assertDrop(program, bcastv4packet1.array());
-        assertDrop(program, bcastv4packet2.array());
-        assertDrop(program, bcastv4unicastl2packet.array());
-
-        // Turn off multicast filter and verify it's off
-        ipManagerCallback.resetApfProgramWait();
-        apfFilter.setMulticastFilter(false);
-        program = ipManagerCallback.getApfProgram();
-        assertPass(program, mcastv4packet.array());
-        assertPass(program, mcastv6packet.array());
-        assertPass(program, bcastv4packet1.array());
-        assertPass(program, bcastv4packet2.array());
-        assertPass(program, bcastv4unicastl2packet.array());
-
-        // Verify it can be initialized to on
-        ipManagerCallback.resetApfProgramWait();
-        apfFilter.shutdown();
-        apfFilter = new TestApfFilter(ipManagerCallback, DROP_MULTICAST, mLog);
-        apfFilter.setLinkProperties(lp);
-        program = ipManagerCallback.getApfProgram();
-        assertDrop(program, mcastv4packet.array());
-        assertDrop(program, mcastv6packet.array());
-        assertDrop(program, bcastv4packet1.array());
-        assertDrop(program, bcastv4unicastl2packet.array());
-
-        // Verify that ICMPv6 multicast is not dropped.
-        mcastv6packet.put(IPV6_NEXT_HEADER_OFFSET, (byte)IPPROTO_ICMPV6);
-        assertPass(program, mcastv6packet.array());
-
-        apfFilter.shutdown();
-    }
-
-    private byte[] getProgram(MockIpManagerCallback cb, ApfFilter filter, LinkProperties lp) {
-        cb.resetApfProgramWait();
-        filter.setLinkProperties(lp);
-        return cb.getApfProgram();
-    }
-
-    private void verifyArpFilter(byte[] program, int filterResult) {
-        // Verify ARP request packet
-        assertPass(program, arpRequestBroadcast(MOCK_IPV4_ADDR));
-        assertVerdict(filterResult, program, arpRequestBroadcast(ANOTHER_IPV4_ADDR));
-        assertDrop(program, arpRequestBroadcast(IPV4_ANY_HOST_ADDR));
-
-        // Verify unicast ARP reply packet is always accepted.
-        assertPass(program, arpReplyUnicast(MOCK_IPV4_ADDR));
-        assertPass(program, arpReplyUnicast(ANOTHER_IPV4_ADDR));
-        assertPass(program, arpReplyUnicast(IPV4_ANY_HOST_ADDR));
-
-        // Verify GARP reply packets are always filtered
-        assertDrop(program, garpReply());
-    }
-
-    @LargeTest
-    public void testApfFilterArp() throws Exception {
-        MockIpManagerCallback ipManagerCallback = new MockIpManagerCallback();
-        ApfFilter apfFilter = new TestApfFilter(ipManagerCallback, ALLOW_MULTICAST, mLog);
-
-        // Verify initially ARP request filter is off, and GARP filter is on.
-        verifyArpFilter(ipManagerCallback.getApfProgram(), PASS);
-
-        // Inform ApfFilter of our address and verify ARP filtering is on
-        LinkAddress linkAddress = new LinkAddress(InetAddress.getByAddress(MOCK_IPV4_ADDR), 24);
-        LinkProperties lp = new LinkProperties();
-        assertTrue(lp.addLinkAddress(linkAddress));
-        verifyArpFilter(getProgram(ipManagerCallback, apfFilter, lp), DROP);
-
-        // Inform ApfFilter of loss of IP and verify ARP filtering is off
-        verifyArpFilter(getProgram(ipManagerCallback, apfFilter, new LinkProperties()), PASS);
-
-        apfFilter.shutdown();
-    }
-
-    private static byte[] arpRequestBroadcast(byte[] tip) {
-        ByteBuffer packet = ByteBuffer.wrap(new byte[100]);
-        packet.putShort(ETH_ETHERTYPE_OFFSET, (short)ETH_P_ARP);
-        put(packet, ETH_DEST_ADDR_OFFSET, ETH_BROADCAST_MAC_ADDRESS);
-        put(packet, ARP_HEADER_OFFSET, ARP_IPV4_REPLY_HEADER);
-        put(packet, ARP_TARGET_IP_ADDRESS_OFFSET, tip);
-        return packet.array();
-    }
-
-    private static byte[] arpReplyUnicast(byte[] tip) {
-        ByteBuffer packet = ByteBuffer.wrap(new byte[100]);
-        packet.putShort(ETH_ETHERTYPE_OFFSET, (short)ETH_P_ARP);
-        put(packet, ARP_HEADER_OFFSET, ARP_IPV4_REPLY_HEADER);
-        put(packet, ARP_TARGET_IP_ADDRESS_OFFSET, tip);
-        return packet.array();
-    }
-
-    private static byte[] garpReply() {
-        ByteBuffer packet = ByteBuffer.wrap(new byte[100]);
-        packet.putShort(ETH_ETHERTYPE_OFFSET, (short)ETH_P_ARP);
-        put(packet, ETH_DEST_ADDR_OFFSET, ETH_BROADCAST_MAC_ADDRESS);
-        put(packet, ARP_HEADER_OFFSET, ARP_IPV4_REPLY_HEADER);
-        put(packet, ARP_TARGET_IP_ADDRESS_OFFSET, IPV4_ANY_HOST_ADDR);
-        return packet.array();
-    }
-
-    // Verify that the last program pushed to the IpManager.Callback properly filters the
-    // given packet for the given lifetime.
-    private void verifyRaLifetime(MockIpManagerCallback ipManagerCallback, ByteBuffer packet,
-            int lifetime) {
-        byte[] program = ipManagerCallback.getApfProgram();
-
-        // Verify new program should drop RA for 1/6th its lifetime
-        assertDrop(program, packet.array());
-        assertDrop(program, packet.array(), lifetime/6);
-        assertPass(program, packet.array(), lifetime/6 + 1);
-        assertPass(program, packet.array(), lifetime);
-
-        // Verify RA checksum is ignored
-        packet.putShort(ICMP6_RA_CHECKSUM_OFFSET, (short)12345);
-        assertDrop(program, packet.array());
-        packet.putShort(ICMP6_RA_CHECKSUM_OFFSET, (short)-12345);
-        assertDrop(program, packet.array());
-
-        // Verify other changes to RA make it not match filter
-        packet.put(0, (byte)-1);
-        assertPass(program, packet.array());
-        packet.put(0, (byte)0);
-        assertDrop(program, packet.array());
-    }
-
-    // Test that when ApfFilter is shown the given packet, it generates a program to filter it
-    // for the given lifetime.
-    private void testRaLifetime(TestApfFilter apfFilter, MockIpManagerCallback ipManagerCallback,
-            ByteBuffer packet, int lifetime) throws IOException, ErrnoException {
-        // Verify new program generated if ApfFilter witnesses RA
-        ipManagerCallback.resetApfProgramWait();
-        apfFilter.pretendPacketReceived(packet.array());
-        ipManagerCallback.getApfProgram();
-
-        verifyRaLifetime(ipManagerCallback, packet, lifetime);
-    }
-
-    private void verifyRaEvent(RaEvent expected) {
-        ArgumentCaptor<Parcelable> captor = ArgumentCaptor.forClass(Parcelable.class);
-        verify(mLog, atLeastOnce()).log(captor.capture());
-        RaEvent got = lastRaEvent(captor.getAllValues());
-        if (!raEventEquals(expected, got)) {
-            assertEquals(expected, got);  // fail for printing an assertion error message.
-        }
-    }
-
-    private RaEvent lastRaEvent(List<Parcelable> events) {
-        RaEvent got = null;
-        for (Parcelable ev : events) {
-            if (ev instanceof RaEvent) {
-                got = (RaEvent) ev;
-            }
-        }
-        return got;
-    }
-
-    private boolean raEventEquals(RaEvent ev1, RaEvent ev2) {
-        return (ev1 != null) && (ev2 != null)
-                && (ev1.routerLifetime == ev2.routerLifetime)
-                && (ev1.prefixValidLifetime == ev2.prefixValidLifetime)
-                && (ev1.prefixPreferredLifetime == ev2.prefixPreferredLifetime)
-                && (ev1.routeInfoLifetime == ev2.routeInfoLifetime)
-                && (ev1.rdnssLifetime == ev2.rdnssLifetime)
-                && (ev1.dnsslLifetime == ev2.dnsslLifetime);
-    }
-
-    private void assertInvalidRa(TestApfFilter apfFilter, MockIpManagerCallback ipManagerCallback,
-            ByteBuffer packet) throws IOException, ErrnoException {
-        ipManagerCallback.resetApfProgramWait();
-        apfFilter.pretendPacketReceived(packet.array());
-        ipManagerCallback.assertNoProgramUpdate();
-    }
-
-    @LargeTest
-    public void testApfFilterRa() throws Exception {
-        MockIpManagerCallback ipManagerCallback = new MockIpManagerCallback();
-        TestApfFilter apfFilter = new TestApfFilter(ipManagerCallback, DROP_MULTICAST, mLog);
-        byte[] program = ipManagerCallback.getApfProgram();
-
-        // Verify RA is passed the first time
-        ByteBuffer basePacket = ByteBuffer.wrap(new byte[ICMP6_RA_OPTION_OFFSET]);
-        basePacket.putShort(ETH_ETHERTYPE_OFFSET, (short)ETH_P_IPV6);
-        basePacket.put(IPV6_NEXT_HEADER_OFFSET, (byte)IPPROTO_ICMPV6);
-        basePacket.put(ICMP6_TYPE_OFFSET, (byte)ICMP6_ROUTER_ADVERTISEMENT);
-        basePacket.putShort(ICMP6_RA_ROUTER_LIFETIME_OFFSET, (short)1000);
-        basePacket.position(IPV6_DEST_ADDR_OFFSET);
-        basePacket.put(IPV6_ALL_NODES_ADDRESS);
-        assertPass(program, basePacket.array());
-
-        testRaLifetime(apfFilter, ipManagerCallback, basePacket, 1000);
-        verifyRaEvent(new RaEvent(1000, -1, -1, -1, -1, -1));
-
-        // Ensure zero-length options cause the packet to be silently skipped.
-        // Do this before we test other packets. http://b/29586253
-        ByteBuffer zeroLengthOptionPacket = ByteBuffer.wrap(
-                new byte[ICMP6_RA_OPTION_OFFSET + ICMP6_4_BYTE_OPTION_LEN]);
-        basePacket.clear();
-        zeroLengthOptionPacket.put(basePacket);
-        zeroLengthOptionPacket.put((byte)ICMP6_PREFIX_OPTION_TYPE);
-        zeroLengthOptionPacket.put((byte)0);
-        assertInvalidRa(apfFilter, ipManagerCallback, zeroLengthOptionPacket);
-
-        // Generate several RAs with different options and lifetimes, and verify when
-        // ApfFilter is shown these packets, it generates programs to filter them for the
-        // appropriate lifetime.
-        ByteBuffer prefixOptionPacket = ByteBuffer.wrap(
-                new byte[ICMP6_RA_OPTION_OFFSET + ICMP6_PREFIX_OPTION_LEN]);
-        basePacket.clear();
-        prefixOptionPacket.put(basePacket);
-        prefixOptionPacket.put((byte)ICMP6_PREFIX_OPTION_TYPE);
-        prefixOptionPacket.put((byte)(ICMP6_PREFIX_OPTION_LEN / 8));
-        prefixOptionPacket.putInt(
-                ICMP6_RA_OPTION_OFFSET + ICMP6_PREFIX_OPTION_PREFERRED_LIFETIME_OFFSET, 100);
-        prefixOptionPacket.putInt(
-                ICMP6_RA_OPTION_OFFSET + ICMP6_PREFIX_OPTION_VALID_LIFETIME_OFFSET, 200);
-        testRaLifetime(apfFilter, ipManagerCallback, prefixOptionPacket, 100);
-        verifyRaEvent(new RaEvent(1000, 200, 100, -1, -1, -1));
-
-        ByteBuffer rdnssOptionPacket = ByteBuffer.wrap(
-                new byte[ICMP6_RA_OPTION_OFFSET + ICMP6_4_BYTE_OPTION_LEN]);
-        basePacket.clear();
-        rdnssOptionPacket.put(basePacket);
-        rdnssOptionPacket.put((byte)ICMP6_RDNSS_OPTION_TYPE);
-        rdnssOptionPacket.put((byte)(ICMP6_4_BYTE_OPTION_LEN / 8));
-        rdnssOptionPacket.putInt(
-                ICMP6_RA_OPTION_OFFSET + ICMP6_4_BYTE_LIFETIME_OFFSET, 300);
-        testRaLifetime(apfFilter, ipManagerCallback, rdnssOptionPacket, 300);
-        verifyRaEvent(new RaEvent(1000, -1, -1, -1, 300, -1));
-
-        ByteBuffer routeInfoOptionPacket = ByteBuffer.wrap(
-                new byte[ICMP6_RA_OPTION_OFFSET + ICMP6_4_BYTE_OPTION_LEN]);
-        basePacket.clear();
-        routeInfoOptionPacket.put(basePacket);
-        routeInfoOptionPacket.put((byte)ICMP6_ROUTE_INFO_OPTION_TYPE);
-        routeInfoOptionPacket.put((byte)(ICMP6_4_BYTE_OPTION_LEN / 8));
-        routeInfoOptionPacket.putInt(
-                ICMP6_RA_OPTION_OFFSET + ICMP6_4_BYTE_LIFETIME_OFFSET, 400);
-        testRaLifetime(apfFilter, ipManagerCallback, routeInfoOptionPacket, 400);
-        verifyRaEvent(new RaEvent(1000, -1, -1, 400, -1, -1));
-
-        ByteBuffer dnsslOptionPacket = ByteBuffer.wrap(
-                new byte[ICMP6_RA_OPTION_OFFSET + ICMP6_4_BYTE_OPTION_LEN]);
-        basePacket.clear();
-        dnsslOptionPacket.put(basePacket);
-        dnsslOptionPacket.put((byte)ICMP6_DNSSL_OPTION_TYPE);
-        dnsslOptionPacket.put((byte)(ICMP6_4_BYTE_OPTION_LEN / 8));
-        dnsslOptionPacket.putInt(
-                ICMP6_RA_OPTION_OFFSET + ICMP6_4_BYTE_LIFETIME_OFFSET, 2000);
-        // Note that lifetime of 2000 will be ignored in favor of shorter
-        // route lifetime of 1000.
-        testRaLifetime(apfFilter, ipManagerCallback, dnsslOptionPacket, 1000);
-        verifyRaEvent(new RaEvent(1000, -1, -1, -1, -1, 2000));
-
-        // Verify that current program filters all five RAs:
-        verifyRaLifetime(ipManagerCallback, basePacket, 1000);
-        verifyRaLifetime(ipManagerCallback, prefixOptionPacket, 100);
-        verifyRaLifetime(ipManagerCallback, rdnssOptionPacket, 300);
-        verifyRaLifetime(ipManagerCallback, routeInfoOptionPacket, 400);
-        verifyRaLifetime(ipManagerCallback, dnsslOptionPacket, 1000);
-
-        apfFilter.shutdown();
-    }
-
-    /**
-     * Stage a file for testing, i.e. make it native accessible. Given a resource ID,
-     * copy that resource into the app's data directory and return the path to it.
-     */
-    private String stageFile(int rawId) throws Exception {
-        File file = new File(getContext().getFilesDir(), "staged_file");
-        new File(file.getParent()).mkdirs();
-        InputStream in = null;
-        OutputStream out = null;
-        try {
-            in = getContext().getResources().openRawResource(rawId);
-            out = new FileOutputStream(file);
-            Streams.copy(in, out);
-        } finally {
-            if (in != null) in.close();
-            if (out != null) out.close();
-        }
-        return file.getAbsolutePath();
-    }
-
-    private static void put(ByteBuffer buffer, int position, byte[] bytes) {
-        final int original = buffer.position();
-        buffer.position(position);
-        buffer.put(bytes);
-        buffer.position(original);
-    }
-
-    /**
-     * Call the APF interpreter the run {@code program} on {@code packet} pretending the
-     * filter was installed {@code filter_age} seconds ago.
-     */
-    private native static int apfSimulate(byte[] program, byte[] packet, int filter_age);
-
-    /**
-     * Compile a tcpdump human-readable filter (e.g. "icmp" or "tcp port 54") into a BPF
-     * prorgam and return a human-readable dump of the BPF program identical to "tcpdump -d".
-     */
-    private native static String compileToBpf(String filter);
-
-    /**
-     * Open packet capture file {@code pcap_filename} and filter the packets using tcpdump
-     * human-readable filter (e.g. "icmp" or "tcp port 54") compiled to a BPF program and
-     * at the same time using APF program {@code apf_program}.  Return {@code true} if
-     * both APF and BPF programs filter out exactly the same packets.
-     */
-    private native static boolean compareBpfApf(String filter, String pcap_filename,
-            byte[] apf_program);
-
-    public void testBytesToInt() {
-        assertEquals(0x00000000, ApfFilter.bytesToInt(IPV4_ANY_HOST_ADDR));
-        assertEquals(0xffffffff, ApfFilter.bytesToInt(IPV4_BROADCAST_ADDRESS));
-        assertEquals(0x0a000001, ApfFilter.bytesToInt(MOCK_IPV4_ADDR));
-        assertEquals(0x0a000002, ApfFilter.bytesToInt(ANOTHER_IPV4_ADDR));
-        assertEquals(0x0a001fff, ApfFilter.bytesToInt(MOCK_BROADCAST_IPV4_ADDR));
-        assertEquals(0xe0000001, ApfFilter.bytesToInt(MOCK_MULTICAST_IPV4_ADDR));
-    }
-
-    public void testBroadcastAddress() throws Exception {
-        assertEqualsIp("255.255.255.255", ApfFilter.ipv4BroadcastAddress(IPV4_ANY_HOST_ADDR, 0));
-        assertEqualsIp("0.0.0.0", ApfFilter.ipv4BroadcastAddress(IPV4_ANY_HOST_ADDR, 32));
-        assertEqualsIp("0.0.3.255", ApfFilter.ipv4BroadcastAddress(IPV4_ANY_HOST_ADDR, 22));
-        assertEqualsIp("0.255.255.255", ApfFilter.ipv4BroadcastAddress(IPV4_ANY_HOST_ADDR, 8));
-
-        assertEqualsIp("255.255.255.255", ApfFilter.ipv4BroadcastAddress(MOCK_IPV4_ADDR, 0));
-        assertEqualsIp("10.0.0.1", ApfFilter.ipv4BroadcastAddress(MOCK_IPV4_ADDR, 32));
-        assertEqualsIp("10.0.0.255", ApfFilter.ipv4BroadcastAddress(MOCK_IPV4_ADDR, 24));
-        assertEqualsIp("10.0.255.255", ApfFilter.ipv4BroadcastAddress(MOCK_IPV4_ADDR, 16));
-    }
-
-    public void assertEqualsIp(String expected, int got) throws Exception {
-        int want = ApfFilter.bytesToInt(InetAddress.getByName(expected).getAddress());
-        assertEquals(want, got);
-    }
-}
diff --git a/services/tests/servicestests/src/android/net/apf/Bpf2Apf.java b/services/tests/servicestests/src/android/net/apf/Bpf2Apf.java
deleted file mode 100644
index 220e54ddef5..00000000000
--- a/services/tests/servicestests/src/android/net/apf/Bpf2Apf.java
+++ /dev/null
@@ -1,327 +0,0 @@
-/*
- * Copyright (C) 2015 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package android.net.apf;
-
-import android.net.apf.ApfGenerator;
-import android.net.apf.ApfGenerator.IllegalInstructionException;
-import android.net.apf.ApfGenerator.Register;
-
-import java.io.BufferedReader;
-import java.io.InputStreamReader;
-
-/**
- * BPF to APF translator.
- *
- * Note: This is for testing purposes only and is not guaranteed to support
- *       translation of all BPF programs.
- *
- * Example usage:
- *   javac net/java/android/net/apf/ApfGenerator.java \
- *         tests/servicestests/src/android/net/apf/Bpf2Apf.java
- *   sudo tcpdump -i em1 -d icmp | java -classpath tests/servicestests/src:net/java \
- *                                      android.net.apf.Bpf2Apf
- */
-public class Bpf2Apf {
-    private static int parseImm(String line, String arg) {
-        if (!arg.startsWith("#0x")) {
-            throw new IllegalArgumentException("Unhandled instruction: " + line);
-        }
-        final long val_long = Long.parseLong(arg.substring(3), 16);
-        if (val_long < 0 || val_long > Long.parseLong("ffffffff", 16)) {
-            throw new IllegalArgumentException("Unhandled instruction: " + line);
-        }
-        return new Long((val_long << 32) >> 32).intValue();
-    }
-
-    /**
-     * Convert a single line of "tcpdump -d" (human readable BPF program dump) {@code line} into
-     * APF instruction(s) and append them to {@code gen}. Here's an example line:
-     * (001) jeq      #0x86dd          jt 2    jf 7
-     */
-    private static void convertLine(String line, ApfGenerator gen)
-            throws IllegalInstructionException {
-        if (line.indexOf("(") != 0 || line.indexOf(")") != 4 || line.indexOf(" ") != 5) {
-            throw new IllegalArgumentException("Unhandled instruction: " + line);
-        }
-        int label = Integer.parseInt(line.substring(1, 4));
-        gen.defineLabel(Integer.toString(label));
-        String opcode = line.substring(6, 10).trim();
-        String arg = line.substring(15, Math.min(32, line.length())).trim();
-        switch (opcode) {
-            case "ld":
-            case "ldh":
-            case "ldb":
-            case "ldx":
-            case "ldxb":
-            case "ldxh":
-                Register dest = opcode.contains("x") ? Register.R1 : Register.R0;
-                if (arg.equals("4*([14]&0xf)")) {
-                    if (!opcode.equals("ldxb")) {
-                        throw new IllegalArgumentException("Unhandled instruction: " + line);
-                    }
-                    gen.addLoadFromMemory(dest, gen.IPV4_HEADER_SIZE_MEMORY_SLOT);
-                    break;
-                }
-                if (arg.equals("#pktlen")) {
-                    if (!opcode.equals("ld")) {
-                        throw new IllegalArgumentException("Unhandled instruction: " + line);
-                    }
-                    gen.addLoadFromMemory(dest, gen.PACKET_SIZE_MEMORY_SLOT);
-                    break;
-                }
-                if (arg.startsWith("#0x")) {
-                    if (!opcode.equals("ld")) {
-                        throw new IllegalArgumentException("Unhandled instruction: " + line);
-                    }
-                    gen.addLoadImmediate(dest, parseImm(line, arg));
-                    break;
-                }
-                if (arg.startsWith("M[")) {
-                    if (!opcode.startsWith("ld")) {
-                        throw new IllegalArgumentException("Unhandled instruction: " + line);
-                    }
-                    int memory_slot = Integer.parseInt(arg.substring(2, arg.length() - 1));
-                    if (memory_slot < 0 || memory_slot >= gen.MEMORY_SLOTS ||
-                            // Disallow use of pre-filled slots as BPF programs might
-                            // wrongfully assume they're initialized to 0.
-                            (memory_slot >= gen.FIRST_PREFILLED_MEMORY_SLOT &&
-                                    memory_slot <= gen.LAST_PREFILLED_MEMORY_SLOT)) {
-                        throw new IllegalArgumentException("Unhandled instruction: " + line);
-                    }
-                    gen.addLoadFromMemory(dest, memory_slot);
-                    break;
-                }
-                if (arg.startsWith("[x + ")) {
-                    int offset = Integer.parseInt(arg.substring(5, arg.length() - 1));
-                    switch (opcode) {
-                        case "ld":
-                        case "ldx":
-                            gen.addLoad32Indexed(dest, offset);
-                            break;
-                        case "ldh":
-                        case "ldxh":
-                            gen.addLoad16Indexed(dest, offset);
-                            break;
-                        case "ldb":
-                        case "ldxb":
-                            gen.addLoad8Indexed(dest, offset);
-                            break;
-                    }
-                } else {
-                    int offset = Integer.parseInt(arg.substring(1, arg.length() - 1));
-                    switch (opcode) {
-                        case "ld":
-                        case "ldx":
-                            gen.addLoad32(dest, offset);
-                            break;
-                        case "ldh":
-                        case "ldxh":
-                            gen.addLoad16(dest, offset);
-                            break;
-                        case "ldb":
-                        case "ldxb":
-                            gen.addLoad8(dest, offset);
-                            break;
-                    }
-                }
-                break;
-            case "st":
-            case "stx":
-                Register src = opcode.contains("x") ? Register.R1 : Register.R0;
-                if (!arg.startsWith("M[")) {
-                    throw new IllegalArgumentException("Unhandled instruction: " + line);
-                }
-                int memory_slot = Integer.parseInt(arg.substring(2, arg.length() - 1));
-                if (memory_slot < 0 || memory_slot >= gen.MEMORY_SLOTS ||
-                        // Disallow overwriting pre-filled slots
-                        (memory_slot >= gen.FIRST_PREFILLED_MEMORY_SLOT &&
-                                memory_slot <= gen.LAST_PREFILLED_MEMORY_SLOT)) {
-                    throw new IllegalArgumentException("Unhandled instruction: " + line);
-                }
-                gen.addStoreToMemory(src, memory_slot);
-                break;
-            case "add":
-            case "and":
-            case "or":
-            case "sub":
-                if (arg.equals("x")) {
-                    switch(opcode) {
-                        case "add":
-                            gen.addAddR1();
-                            break;
-                        case "and":
-                            gen.addAndR1();
-                            break;
-                        case "or":
-                            gen.addOrR1();
-                            break;
-                        case "sub":
-                            gen.addNeg(Register.R1);
-                            gen.addAddR1();
-                            gen.addNeg(Register.R1);
-                            break;
-                    }
-                } else {
-                    int imm = parseImm(line, arg);
-                    switch(opcode) {
-                        case "add":
-                            gen.addAdd(imm);
-                            break;
-                        case "and":
-                            gen.addAnd(imm);
-                            break;
-                        case "or":
-                            gen.addOr(imm);
-                            break;
-                        case "sub":
-                            gen.addAdd(-imm);
-                            break;
-                    }
-                }
-                break;
-            case "jeq":
-            case "jset":
-            case "jgt":
-            case "jge":
-                int val = 0;
-                boolean reg_compare;
-                if (arg.startsWith("x")) {
-                    reg_compare = true;
-                } else {
-                    reg_compare = false;
-                    val = parseImm(line, arg);
-                }
-                int jt_offset = line.indexOf("jt");
-                int jf_offset = line.indexOf("jf");
-                String true_label = line.substring(jt_offset + 2, jf_offset).trim();
-                String false_label = line.substring(jf_offset + 2).trim();
-                boolean true_label_is_fallthrough = Integer.parseInt(true_label) == label + 1;
-                boolean false_label_is_fallthrough = Integer.parseInt(false_label) == label + 1;
-                if (true_label_is_fallthrough && false_label_is_fallthrough)
-                    break;
-                switch (opcode) {
-                    case "jeq":
-                        if (!true_label_is_fallthrough) {
-                            if (reg_compare) {
-                                gen.addJumpIfR0EqualsR1(true_label);
-                            } else {
-                                gen.addJumpIfR0Equals(val, true_label);
-                            }
-                        }
-                        if (!false_label_is_fallthrough) {
-                            if (!true_label_is_fallthrough) {
-                                gen.addJump(false_label);
-                            } else if (reg_compare) {
-                                gen.addJumpIfR0NotEqualsR1(false_label);
-                            } else {
-                                gen.addJumpIfR0NotEquals(val, false_label);
-                            }
-                        }
-                        break;
-                    case "jset":
-                        if (reg_compare) {
-                            gen.addJumpIfR0AnyBitsSetR1(true_label);
-                        } else {
-                            gen.addJumpIfR0AnyBitsSet(val, true_label);
-                        }
-                        if (!false_label_is_fallthrough) {
-                            gen.addJump(false_label);
-                        }
-                        break;
-                    case "jgt":
-                        if (!true_label_is_fallthrough ||
-                                // We have no less-than-or-equal-to register to register
-                                // comparison instruction, so in this case we'll jump
-                                // around an unconditional jump.
-                                (!false_label_is_fallthrough && reg_compare)) {
-                            if (reg_compare) {
-                                gen.addJumpIfR0GreaterThanR1(true_label);
-                            } else {
-                                gen.addJumpIfR0GreaterThan(val, true_label);
-                            }
-                        }
-                        if (!false_label_is_fallthrough) {
-                            if (!true_label_is_fallthrough || reg_compare) {
-                                gen.addJump(false_label);
-                            } else {
-                                gen.addJumpIfR0LessThan(val + 1, false_label);
-                            }
-                        }
-                        break;
-                    case "jge":
-                        if (!false_label_is_fallthrough ||
-                                // We have no greater-than-or-equal-to register to register
-                                // comparison instruction, so in this case we'll jump
-                                // around an unconditional jump.
-                                (!true_label_is_fallthrough && reg_compare)) {
-                            if (reg_compare) {
-                                gen.addJumpIfR0LessThanR1(false_label);
-                            } else {
-                                gen.addJumpIfR0LessThan(val, false_label);
-                            }
-                        }
-                        if (!true_label_is_fallthrough) {
-                            if (!false_label_is_fallthrough || reg_compare) {
-                                gen.addJump(true_label);
-                            } else {
-                                gen.addJumpIfR0GreaterThan(val - 1, true_label);
-                            }
-                        }
-                        break;
-                }
-                break;
-            case "ret":
-                if (arg.equals("#0")) {
-                    gen.addJump(gen.DROP_LABEL);
-                } else {
-                    gen.addJump(gen.PASS_LABEL);
-                }
-                break;
-            case "tax":
-                gen.addMove(Register.R1);
-                break;
-            case "txa":
-                gen.addMove(Register.R0);
-                break;
-            default:
-                throw new IllegalArgumentException("Unhandled instruction: " + line);
-        }
-    }
-
-    /**
-     * Convert the output of "tcpdump -d" (human readable BPF program dump) {@code bpf} into an APF
-     * program and return it.
-     */
-    public static byte[] convert(String bpf) throws IllegalInstructionException {
-        ApfGenerator gen = new ApfGenerator();
-        for (String line : bpf.split("\\n")) convertLine(line, gen);
-        return gen.generate();
-    }
-
-    /**
-     * Convert the output of "tcpdump -d" (human readable BPF program dump) piped in stdin into an
-     * APF program and output it via stdout.
-     */
-    public static void main(String[] args) throws Exception {
-        BufferedReader in = new BufferedReader(new InputStreamReader(System.in));
-        String line = null;
-        StringBuilder responseData = new StringBuilder();
-        ApfGenerator gen = new ApfGenerator();
-        while ((line = in.readLine()) != null) convertLine(line, gen);
-        System.out.write(gen.generate());
-    }
-}
diff --git a/services/tests/servicestests/src/android/net/dhcp/DhcpPacketTest.java b/services/tests/servicestests/src/android/net/dhcp/DhcpPacketTest.java
deleted file mode 100644
index bc8baa12a45..00000000000
--- a/services/tests/servicestests/src/android/net/dhcp/DhcpPacketTest.java
+++ /dev/null
@@ -1,939 +0,0 @@
-/*
- * Copyright (C) 2015 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package android.net.dhcp;
-
-import android.net.DhcpResults;
-import android.net.LinkAddress;
-import android.net.NetworkUtils;
-import android.net.metrics.DhcpErrorEvent;
-import android.system.OsConstants;
-import android.test.suitebuilder.annotation.SmallTest;
-import com.android.internal.util.HexDump;
-import java.net.Inet4Address;
-import java.nio.ByteBuffer;
-import java.util.ArrayList;
-import java.util.Arrays;
-import java.util.Random;
-import junit.framework.TestCase;
-
-import static android.net.dhcp.DhcpPacket.*;
-
-public class DhcpPacketTest extends TestCase {
-
-    private static Inet4Address SERVER_ADDR = v4Address("192.0.2.1");
-    private static Inet4Address CLIENT_ADDR = v4Address("192.0.2.234");
-    // Use our own empty address instead of Inet4Address.ANY or INADDR_ANY to ensure that the code
-    // doesn't use == instead of equals when comparing addresses.
-    private static Inet4Address ANY = (Inet4Address) v4Address("0.0.0.0");
-
-    private static byte[] CLIENT_MAC = new byte[] { 0x00, 0x01, 0x02, 0x03, 0x04, 0x05 };
-
-    private static final Inet4Address v4Address(String addrString) throws IllegalArgumentException {
-        return (Inet4Address) NetworkUtils.numericToInetAddress(addrString);
-    }
-
-    public void setUp() {
-        DhcpPacket.testOverrideVendorId = "android-dhcp-???";
-        DhcpPacket.testOverrideHostname = "android-01234567890abcde";
-    }
-
-    class TestDhcpPacket extends DhcpPacket {
-        private byte mType;
-        // TODO: Make this a map of option numbers to bytes instead.
-        private byte[] mDomainBytes, mVendorInfoBytes, mLeaseTimeBytes, mNetmaskBytes;
-
-        public TestDhcpPacket(byte type, Inet4Address clientIp, Inet4Address yourIp) {
-            super(0xdeadbeef, (short) 0, clientIp, yourIp, INADDR_ANY, INADDR_ANY,
-                  CLIENT_MAC, true);
-            mType = type;
-        }
-
-        public TestDhcpPacket(byte type) {
-            this(type, INADDR_ANY, CLIENT_ADDR);
-        }
-
-        public TestDhcpPacket setDomainBytes(byte[] domainBytes) {
-            mDomainBytes = domainBytes;
-            return this;
-        }
-
-        public TestDhcpPacket setVendorInfoBytes(byte[] vendorInfoBytes) {
-            mVendorInfoBytes = vendorInfoBytes;
-            return this;
-        }
-
-        public TestDhcpPacket setLeaseTimeBytes(byte[] leaseTimeBytes) {
-            mLeaseTimeBytes = leaseTimeBytes;
-            return this;
-        }
-
-        public TestDhcpPacket setNetmaskBytes(byte[] netmaskBytes) {
-            mNetmaskBytes = netmaskBytes;
-            return this;
-        }
-
-        public ByteBuffer buildPacket(int encap, short unusedDestUdp, short unusedSrcUdp) {
-            ByteBuffer result = ByteBuffer.allocate(MAX_LENGTH);
-            fillInPacket(encap, CLIENT_ADDR, SERVER_ADDR,
-                         DHCP_CLIENT, DHCP_SERVER, result, DHCP_BOOTREPLY, false);
-            return result;
-        }
-
-        public void finishPacket(ByteBuffer buffer) {
-            addTlv(buffer, DHCP_MESSAGE_TYPE, mType);
-            if (mDomainBytes != null) {
-                addTlv(buffer, DHCP_DOMAIN_NAME, mDomainBytes);
-            }
-            if (mVendorInfoBytes != null) {
-                addTlv(buffer, DHCP_VENDOR_INFO, mVendorInfoBytes);
-            }
-            if (mLeaseTimeBytes != null) {
-                addTlv(buffer, DHCP_LEASE_TIME, mLeaseTimeBytes);
-            }
-            if (mNetmaskBytes != null) {
-                addTlv(buffer, DHCP_SUBNET_MASK, mNetmaskBytes);
-            }
-            addTlvEnd(buffer);
-        }
-
-        // Convenience method.
-        public ByteBuffer build() {
-            // ENCAP_BOOTP packets don't contain ports, so just pass in 0.
-            ByteBuffer pkt = buildPacket(ENCAP_BOOTP, (short) 0, (short) 0);
-            pkt.flip();
-            return pkt;
-        }
-    }
-
-    private void assertDomainAndVendorInfoParses(
-            String expectedDomain, byte[] domainBytes,
-            String expectedVendorInfo, byte[] vendorInfoBytes) throws Exception {
-        ByteBuffer packet = new TestDhcpPacket(DHCP_MESSAGE_TYPE_OFFER)
-                .setDomainBytes(domainBytes)
-                .setVendorInfoBytes(vendorInfoBytes)
-                .build();
-        DhcpPacket offerPacket = DhcpPacket.decodeFullPacket(packet, ENCAP_BOOTP);
-        assertEquals(expectedDomain, offerPacket.mDomainName);
-        assertEquals(expectedVendorInfo, offerPacket.mVendorInfo);
-    }
-
-    @SmallTest
-    public void testDomainName() throws Exception {
-        byte[] nullByte = new byte[] { 0x00 };
-        byte[] twoNullBytes = new byte[] { 0x00, 0x00 };
-        byte[] nonNullDomain = new byte[] {
-            (byte) 'g', (byte) 'o', (byte) 'o', (byte) '.', (byte) 'g', (byte) 'l'
-        };
-        byte[] trailingNullDomain = new byte[] {
-            (byte) 'g', (byte) 'o', (byte) 'o', (byte) '.', (byte) 'g', (byte) 'l', 0x00
-        };
-        byte[] embeddedNullsDomain = new byte[] {
-            (byte) 'g', (byte) 'o', (byte) 'o', 0x00, 0x00, (byte) 'g', (byte) 'l'
-        };
-        byte[] metered = "ANDROID_METERED".getBytes("US-ASCII");
-
-        byte[] meteredEmbeddedNull = metered.clone();
-        meteredEmbeddedNull[7] = (char) 0;
-
-        byte[] meteredTrailingNull = metered.clone();
-        meteredTrailingNull[meteredTrailingNull.length - 1] = (char) 0;
-
-        assertDomainAndVendorInfoParses("", nullByte, "\u0000", nullByte);
-        assertDomainAndVendorInfoParses("", twoNullBytes, "\u0000\u0000", twoNullBytes);
-        assertDomainAndVendorInfoParses("goo.gl", nonNullDomain, "ANDROID_METERED", metered);
-        assertDomainAndVendorInfoParses("goo", embeddedNullsDomain,
-                                        "ANDROID\u0000METERED", meteredEmbeddedNull);
-        assertDomainAndVendorInfoParses("goo.gl", trailingNullDomain,
-                                        "ANDROID_METERE\u0000", meteredTrailingNull);
-    }
-
-    private void assertLeaseTimeParses(boolean expectValid, Integer rawLeaseTime,
-            long leaseTimeMillis, byte[] leaseTimeBytes) throws Exception {
-        TestDhcpPacket testPacket = new TestDhcpPacket(DHCP_MESSAGE_TYPE_OFFER);
-        if (leaseTimeBytes != null) {
-            testPacket.setLeaseTimeBytes(leaseTimeBytes);
-        }
-        ByteBuffer packet = testPacket.build();
-        DhcpPacket offerPacket = null;
-
-        if (!expectValid) {
-            try {
-                offerPacket = DhcpPacket.decodeFullPacket(packet, ENCAP_BOOTP);
-                fail("Invalid packet parsed successfully: " + offerPacket);
-            } catch (ParseException expected) {
-            }
-            return;
-        }
-
-        offerPacket = DhcpPacket.decodeFullPacket(packet, ENCAP_BOOTP);
-        assertNotNull(offerPacket);
-        assertEquals(rawLeaseTime, offerPacket.mLeaseTime);
-        DhcpResults dhcpResults = offerPacket.toDhcpResults();  // Just check this doesn't crash.
-        assertEquals(leaseTimeMillis, offerPacket.getLeaseTimeMillis());
-    }
-
-    @SmallTest
-    public void testLeaseTime() throws Exception {
-        byte[] noLease = null;
-        byte[] tooShortLease = new byte[] { 0x00, 0x00 };
-        byte[] tooLongLease = new byte[] { 0x00, 0x00, 0x00, 60, 0x01 };
-        byte[] zeroLease = new byte[] { 0x00, 0x00, 0x00, 0x00 };
-        byte[] tenSecondLease = new byte[] { 0x00, 0x00, 0x00, 10 };
-        byte[] oneMinuteLease = new byte[] { 0x00, 0x00, 0x00, 60 };
-        byte[] fiveMinuteLease = new byte[] { 0x00, 0x00, 0x01, 0x2c };
-        byte[] oneDayLease = new byte[] { 0x00, 0x01, 0x51, (byte) 0x80 };
-        byte[] maxIntPlusOneLease = new byte[] { (byte) 0x80, 0x00, 0x00, 0x01 };
-        byte[] infiniteLease = new byte[] { (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff };
-
-        assertLeaseTimeParses(true, null, 0, noLease);
-        assertLeaseTimeParses(false, null, 0, tooShortLease);
-        assertLeaseTimeParses(false, null, 0, tooLongLease);
-        assertLeaseTimeParses(true, 0, 60 * 1000, zeroLease);
-        assertLeaseTimeParses(true, 10, 60 * 1000, tenSecondLease);
-        assertLeaseTimeParses(true, 60, 60 * 1000, oneMinuteLease);
-        assertLeaseTimeParses(true, 300, 300 * 1000, fiveMinuteLease);
-        assertLeaseTimeParses(true, 86400, 86400 * 1000, oneDayLease);
-        assertLeaseTimeParses(true, -2147483647, 2147483649L * 1000, maxIntPlusOneLease);
-        assertLeaseTimeParses(true, DhcpPacket.INFINITE_LEASE, 0, infiniteLease);
-    }
-
-    private void checkIpAddress(String expected, Inet4Address clientIp, Inet4Address yourIp,
-                                byte[] netmaskBytes) throws Exception {
-        checkIpAddress(expected, DHCP_MESSAGE_TYPE_OFFER, clientIp, yourIp, netmaskBytes);
-        checkIpAddress(expected, DHCP_MESSAGE_TYPE_ACK, clientIp, yourIp, netmaskBytes);
-    }
-
-    private void checkIpAddress(String expected, byte type,
-                                Inet4Address clientIp, Inet4Address yourIp,
-                                byte[] netmaskBytes) throws Exception {
-        ByteBuffer packet = new TestDhcpPacket(type, clientIp, yourIp)
-                .setNetmaskBytes(netmaskBytes)
-                .build();
-        DhcpPacket offerPacket = DhcpPacket.decodeFullPacket(packet, ENCAP_BOOTP);
-        DhcpResults results = offerPacket.toDhcpResults();
-
-        if (expected != null) {
-            LinkAddress expectedAddress = new LinkAddress(expected);
-            assertEquals(expectedAddress, results.ipAddress);
-        } else {
-            assertNull(results);
-        }
-    }
-
-    @SmallTest
-    public void testIpAddress() throws Exception {
-        byte[] slash11Netmask = new byte[] { (byte) 0xff, (byte) 0xe0, 0x00, 0x00 };
-        byte[] slash24Netmask = new byte[] { (byte) 0xff, (byte) 0xff, (byte) 0xff, 0x00 };
-        byte[] invalidNetmask = new byte[] { (byte) 0xff, (byte) 0xfb, (byte) 0xff, 0x00 };
-        Inet4Address example1 = v4Address("192.0.2.1");
-        Inet4Address example2 = v4Address("192.0.2.43");
-
-        // A packet without any addresses is not valid.
-        checkIpAddress(null, ANY, ANY, slash24Netmask);
-
-        // ClientIP is used iff YourIP is not present.
-        checkIpAddress("192.0.2.1/24", example2, example1, slash24Netmask);
-        checkIpAddress("192.0.2.43/11", example2, ANY, slash11Netmask);
-        checkIpAddress("192.0.2.43/11", ANY, example2, slash11Netmask);
-
-        // Invalid netmasks are ignored.
-        checkIpAddress(null, example2, ANY, invalidNetmask);
-
-        // If there is no netmask, implicit netmasks are used.
-        checkIpAddress("192.0.2.43/24", ANY, example2, null);
-    }
-
-    private void assertDhcpResults(String ipAddress, String gateway, String dnsServersString,
-            String domains, String serverAddress, String vendorInfo, int leaseDuration,
-            boolean hasMeteredHint, int mtu, DhcpResults dhcpResults) throws Exception {
-        assertEquals(new LinkAddress(ipAddress), dhcpResults.ipAddress);
-        assertEquals(v4Address(gateway), dhcpResults.gateway);
-
-        String[] dnsServerStrings = dnsServersString.split(",");
-        ArrayList dnsServers = new ArrayList();
-        for (String dnsServerString : dnsServerStrings) {
-            dnsServers.add(v4Address(dnsServerString));
-        }
-        assertEquals(dnsServers, dhcpResults.dnsServers);
-
-        assertEquals(domains, dhcpResults.domains);
-        assertEquals(v4Address(serverAddress), dhcpResults.serverAddress);
-        assertEquals(vendorInfo, dhcpResults.vendorInfo);
-        assertEquals(leaseDuration, dhcpResults.leaseDuration);
-        assertEquals(hasMeteredHint, dhcpResults.hasMeteredHint());
-        assertEquals(mtu, dhcpResults.mtu);
-    }
-
-    @SmallTest
-    public void testOffer1() throws Exception {
-        // TODO: Turn all of these into golden files. This will probably require modifying
-        // Android.mk appropriately, making this into an AndroidTestCase, and adding code to read
-        // the golden files from the test APK's assets via mContext.getAssets().
-        final ByteBuffer packet = ByteBuffer.wrap(HexDump.hexStringToByteArray(
-            // IP header.
-            "451001480000000080118849c0a89003c0a89ff7" +
-            // UDP header.
-            "004300440134dcfa" +
-            // BOOTP header.
-            "02010600c997a63b0000000000000000c0a89ff70000000000000000" +
-            // MAC address.
-            "30766ff2a90c00000000000000000000" +
-            // Server name.
-            "0000000000000000000000000000000000000000000000000000000000000000" +
-            "0000000000000000000000000000000000000000000000000000000000000000" +
-            // File.
-            "0000000000000000000000000000000000000000000000000000000000000000" +
-            "0000000000000000000000000000000000000000000000000000000000000000" +
-            "0000000000000000000000000000000000000000000000000000000000000000" +
-            "0000000000000000000000000000000000000000000000000000000000000000" +
-            // Options
-            "638253633501023604c0a89003330400001c200104fffff0000304c0a89ffe06080808080808080404" +
-            "3a0400000e103b040000189cff00000000000000000000"));
-
-        DhcpPacket offerPacket = DhcpPacket.decodeFullPacket(packet, ENCAP_L3);
-        assertTrue(offerPacket instanceof DhcpOfferPacket);  // Implicitly checks it's non-null.
-        DhcpResults dhcpResults = offerPacket.toDhcpResults();
-        assertDhcpResults("192.168.159.247/20", "192.168.159.254", "8.8.8.8,8.8.4.4",
-                null, "192.168.144.3", null, 7200, false, 0, dhcpResults);
-    }
-
-    @SmallTest
-    public void testOffer2() throws Exception {
-        final ByteBuffer packet = ByteBuffer.wrap(HexDump.hexStringToByteArray(
-            // IP header.
-            "450001518d0600004011144dc0a82b01c0a82bf7" +
-            // UDP header.
-            "00430044013d9ac7" +
-            // BOOTP header.
-            "02010600dfc23d1f0002000000000000c0a82bf7c0a82b0100000000" +
-            // MAC address.
-            "30766ff2a90c00000000000000000000" +
-            // Server name.
-            "0000000000000000000000000000000000000000000000000000000000000000" +
-            "0000000000000000000000000000000000000000000000000000000000000000" +
-            // File.
-            "0000000000000000000000000000000000000000000000000000000000000000" +
-            "0000000000000000000000000000000000000000000000000000000000000000" +
-            "0000000000000000000000000000000000000000000000000000000000000000" +
-            "0000000000000000000000000000000000000000000000000000000000000000" +
-            // Options
-            "638253633501023604c0a82b01330400000e103a04000007083b0400000c4e0104ffffff00" +
-            "1c04c0a82bff0304c0a82b010604c0a82b012b0f414e44524f49445f4d455445524544ff"));
-
-        assertEquals(337, packet.limit());
-        DhcpPacket offerPacket = DhcpPacket.decodeFullPacket(packet, ENCAP_L3);
-        assertTrue(offerPacket instanceof DhcpOfferPacket);  // Implicitly checks it's non-null.
-        DhcpResults dhcpResults = offerPacket.toDhcpResults();
-        assertDhcpResults("192.168.43.247/24", "192.168.43.1", "192.168.43.1",
-                null, "192.168.43.1", "ANDROID_METERED", 3600, true, 0, dhcpResults);
-        assertTrue(dhcpResults.hasMeteredHint());
-    }
-
-    @SmallTest
-    public void testBadIpPacket() throws Exception {
-        final byte[] packet = HexDump.hexStringToByteArray(
-            // IP header.
-            "450001518d0600004011144dc0a82b01c0a82bf7");
-
-        try {
-            DhcpPacket offerPacket = DhcpPacket.decodeFullPacket(packet, packet.length, ENCAP_L3);
-        } catch (DhcpPacket.ParseException expected) {
-            assertDhcpErrorCodes(DhcpErrorEvent.L3_TOO_SHORT, expected.errorCode);
-            return;
-        }
-        fail("Dhcp packet parsing should have failed");
-    }
-
-    @SmallTest
-    public void testBadDhcpPacket() throws Exception {
-        final byte[] packet = HexDump.hexStringToByteArray(
-            // IP header.
-            "450001518d0600004011144dc0a82b01c0a82bf7" +
-            // UDP header.
-            "00430044013d9ac7" +
-            // BOOTP header.
-            "02010600dfc23d1f0002000000000000c0a82bf7c0a82b0100000000");
-
-        try {
-            DhcpPacket offerPacket = DhcpPacket.decodeFullPacket(packet, packet.length, ENCAP_L3);
-        } catch (DhcpPacket.ParseException expected) {
-            assertDhcpErrorCodes(DhcpErrorEvent.L3_TOO_SHORT, expected.errorCode);
-            return;
-        }
-        fail("Dhcp packet parsing should have failed");
-    }
-
-    @SmallTest
-    public void testBadTruncatedOffer() throws Exception {
-        final byte[] packet = HexDump.hexStringToByteArray(
-            // IP header.
-            "450001518d0600004011144dc0a82b01c0a82bf7" +
-            // UDP header.
-            "00430044013d9ac7" +
-            // BOOTP header.
-            "02010600dfc23d1f0002000000000000c0a82bf7c0a82b0100000000" +
-            // MAC address.
-            "30766ff2a90c00000000000000000000" +
-            // Server name.
-            "0000000000000000000000000000000000000000000000000000000000000000" +
-            "0000000000000000000000000000000000000000000000000000000000000000" +
-            // File, missing one byte
-            "0000000000000000000000000000000000000000000000000000000000000000" +
-            "0000000000000000000000000000000000000000000000000000000000000000" +
-            "0000000000000000000000000000000000000000000000000000000000000000" +
-            "00000000000000000000000000000000000000000000000000000000000000");
-
-        try {
-            DhcpPacket offerPacket = DhcpPacket.decodeFullPacket(packet, packet.length, ENCAP_L3);
-        } catch (DhcpPacket.ParseException expected) {
-            assertDhcpErrorCodes(DhcpErrorEvent.L3_TOO_SHORT, expected.errorCode);
-            return;
-        }
-        fail("Dhcp packet parsing should have failed");
-    }
-
-    @SmallTest
-    public void testBadOfferWithoutACookie() throws Exception {
-        final byte[] packet = HexDump.hexStringToByteArray(
-            // IP header.
-            "450001518d0600004011144dc0a82b01c0a82bf7" +
-            // UDP header.
-            "00430044013d9ac7" +
-            // BOOTP header.
-            "02010600dfc23d1f0002000000000000c0a82bf7c0a82b0100000000" +
-            // MAC address.
-            "30766ff2a90c00000000000000000000" +
-            // Server name.
-            "0000000000000000000000000000000000000000000000000000000000000000" +
-            "0000000000000000000000000000000000000000000000000000000000000000" +
-            // File.
-            "0000000000000000000000000000000000000000000000000000000000000000" +
-            "0000000000000000000000000000000000000000000000000000000000000000" +
-            "0000000000000000000000000000000000000000000000000000000000000000" +
-            "0000000000000000000000000000000000000000000000000000000000000000"
-            // No options
-            );
-
-        try {
-            DhcpPacket offerPacket = DhcpPacket.decodeFullPacket(packet, packet.length, ENCAP_L3);
-        } catch (DhcpPacket.ParseException expected) {
-            assertDhcpErrorCodes(DhcpErrorEvent.DHCP_NO_COOKIE, expected.errorCode);
-            return;
-        }
-        fail("Dhcp packet parsing should have failed");
-    }
-
-    @SmallTest
-    public void testOfferWithBadCookie() throws Exception {
-        final byte[] packet = HexDump.hexStringToByteArray(
-            // IP header.
-            "450001518d0600004011144dc0a82b01c0a82bf7" +
-            // UDP header.
-            "00430044013d9ac7" +
-            // BOOTP header.
-            "02010600dfc23d1f0002000000000000c0a82bf7c0a82b0100000000" +
-            // MAC address.
-            "30766ff2a90c00000000000000000000" +
-            // Server name.
-            "0000000000000000000000000000000000000000000000000000000000000000" +
-            "0000000000000000000000000000000000000000000000000000000000000000" +
-            // File.
-            "0000000000000000000000000000000000000000000000000000000000000000" +
-            "0000000000000000000000000000000000000000000000000000000000000000" +
-            "0000000000000000000000000000000000000000000000000000000000000000" +
-            "0000000000000000000000000000000000000000000000000000000000000000" +
-            // Bad cookie
-            "DEADBEEF3501023604c0a82b01330400000e103a04000007083b0400000c4e0104ffffff00" +
-            "1c04c0a82bff0304c0a82b010604c0a82b012b0f414e44524f49445f4d455445524544ff");
-
-        try {
-            DhcpPacket offerPacket = DhcpPacket.decodeFullPacket(packet, packet.length, ENCAP_L3);
-        } catch (DhcpPacket.ParseException expected) {
-            assertDhcpErrorCodes(DhcpErrorEvent.DHCP_BAD_MAGIC_COOKIE, expected.errorCode);
-            return;
-        }
-        fail("Dhcp packet parsing should have failed");
-    }
-
-    private void assertDhcpErrorCodes(int expected, int got) {
-        assertEquals(Integer.toHexString(expected), Integer.toHexString(got));
-    }
-
-    public void testTruncatedOfferPackets() throws Exception {
-        final byte[] packet = HexDump.hexStringToByteArray(
-            // IP header.
-            "450001518d0600004011144dc0a82b01c0a82bf7" +
-            // UDP header.
-            "00430044013d9ac7" +
-            // BOOTP header.
-            "02010600dfc23d1f0002000000000000c0a82bf7c0a82b0100000000" +
-            // MAC address.
-            "30766ff2a90c00000000000000000000" +
-            // Server name.
-            "0000000000000000000000000000000000000000000000000000000000000000" +
-            "0000000000000000000000000000000000000000000000000000000000000000" +
-            // File.
-            "0000000000000000000000000000000000000000000000000000000000000000" +
-            "0000000000000000000000000000000000000000000000000000000000000000" +
-            "0000000000000000000000000000000000000000000000000000000000000000" +
-            "0000000000000000000000000000000000000000000000000000000000000000" +
-            // Options
-            "638253633501023604c0a82b01330400000e103a04000007083b0400000c4e0104ffffff00" +
-            "1c04c0a82bff0304c0a82b010604c0a82b012b0f414e44524f49445f4d455445524544ff");
-
-        for (int len = 0; len < packet.length; len++) {
-            try {
-                DhcpPacket.decodeFullPacket(packet, len, ENCAP_L3);
-            } catch (ParseException e) {
-                if (e.errorCode == DhcpErrorEvent.PARSING_ERROR) {
-                    fail(String.format("bad truncated packet of length %d", len));
-                }
-            }
-        }
-    }
-
-    public void testRandomPackets() throws Exception {
-        final int maxRandomPacketSize = 512;
-        final Random r = new Random();
-        for (int i = 0; i < 10000; i++) {
-            byte[] packet = new byte[r.nextInt(maxRandomPacketSize + 1)];
-            r.nextBytes(packet);
-            try {
-                DhcpPacket.decodeFullPacket(packet, packet.length, ENCAP_L3);
-            } catch (ParseException e) {
-                if (e.errorCode == DhcpErrorEvent.PARSING_ERROR) {
-                    fail("bad packet: " + HexDump.toHexString(packet));
-                }
-            }
-        }
-    }
-
-    private byte[] mtuBytes(int mtu) {
-        // 0x1a02: option 26, length 2. 0xff: no more options.
-        if (mtu > Short.MAX_VALUE - Short.MIN_VALUE) {
-            throw new IllegalArgumentException(
-                String.format("Invalid MTU %d, must be 16-bit unsigned", mtu));
-        }
-        String hexString = String.format("1a02%04xff", mtu);
-        return HexDump.hexStringToByteArray(hexString);
-    }
-
-    private void checkMtu(ByteBuffer packet, int expectedMtu, byte[] mtuBytes) throws Exception {
-        if (mtuBytes != null) {
-            packet.position(packet.capacity() - mtuBytes.length);
-            packet.put(mtuBytes);
-            packet.clear();
-        }
-        DhcpPacket offerPacket = DhcpPacket.decodeFullPacket(packet, ENCAP_L3);
-        assertTrue(offerPacket instanceof DhcpOfferPacket);  // Implicitly checks it's non-null.
-        DhcpResults dhcpResults = offerPacket.toDhcpResults();
-        assertDhcpResults("192.168.159.247/20", "192.168.159.254", "8.8.8.8,8.8.4.4",
-                null, "192.168.144.3", null, 7200, false, expectedMtu, dhcpResults);
-    }
-
-    @SmallTest
-    public void testMtu() throws Exception {
-        final ByteBuffer packet = ByteBuffer.wrap(HexDump.hexStringToByteArray(
-            // IP header.
-            "451001480000000080118849c0a89003c0a89ff7" +
-            // UDP header.
-            "004300440134dcfa" +
-            // BOOTP header.
-            "02010600c997a63b0000000000000000c0a89ff70000000000000000" +
-            // MAC address.
-            "30766ff2a90c00000000000000000000" +
-            // Server name.
-            "0000000000000000000000000000000000000000000000000000000000000000" +
-            "0000000000000000000000000000000000000000000000000000000000000000" +
-            // File.
-            "0000000000000000000000000000000000000000000000000000000000000000" +
-            "0000000000000000000000000000000000000000000000000000000000000000" +
-            "0000000000000000000000000000000000000000000000000000000000000000" +
-            "0000000000000000000000000000000000000000000000000000000000000000" +
-            // Options
-            "638253633501023604c0a89003330400001c200104fffff0000304c0a89ffe06080808080808080404" +
-            "3a0400000e103b040000189cff00000000"));
-
-        checkMtu(packet, 0, null);
-        checkMtu(packet, 0, mtuBytes(1501));
-        checkMtu(packet, 1500, mtuBytes(1500));
-        checkMtu(packet, 1499, mtuBytes(1499));
-        checkMtu(packet, 1280, mtuBytes(1280));
-        checkMtu(packet, 0, mtuBytes(1279));
-        checkMtu(packet, 0, mtuBytes(576));
-        checkMtu(packet, 0, mtuBytes(68));
-        checkMtu(packet, 0, mtuBytes(Short.MIN_VALUE));
-        checkMtu(packet, 0, mtuBytes(Short.MAX_VALUE + 3));
-        checkMtu(packet, 0, mtuBytes(-1));
-    }
-
-    @SmallTest
-    public void testBadHwaddrLength() throws Exception {
-        final ByteBuffer packet = ByteBuffer.wrap(HexDump.hexStringToByteArray(
-            // IP header.
-            "450001518d0600004011144dc0a82b01c0a82bf7" +
-            // UDP header.
-            "00430044013d9ac7" +
-            // BOOTP header.
-            "02010600dfc23d1f0002000000000000c0a82bf7c0a82b0100000000" +
-            // MAC address.
-            "30766ff2a90c00000000000000000000" +
-            // Server name.
-            "0000000000000000000000000000000000000000000000000000000000000000" +
-            "0000000000000000000000000000000000000000000000000000000000000000" +
-            // File.
-            "0000000000000000000000000000000000000000000000000000000000000000" +
-            "0000000000000000000000000000000000000000000000000000000000000000" +
-            "0000000000000000000000000000000000000000000000000000000000000000" +
-            "0000000000000000000000000000000000000000000000000000000000000000" +
-            // Options
-            "638253633501023604c0a82b01330400000e103a04000007083b0400000c4e0104ffffff00" +
-            "1c04c0a82bff0304c0a82b010604c0a82b012b0f414e44524f49445f4d455445524544ff"));
-        String expectedClientMac = "30766FF2A90C";
-
-        final int hwAddrLenOffset = 20 + 8 + 2;
-        assertEquals(6, packet.get(hwAddrLenOffset));
-
-        // Expect the expected.
-        DhcpPacket offerPacket = DhcpPacket.decodeFullPacket(packet, ENCAP_L3);
-        assertNotNull(offerPacket);
-        assertEquals(6, offerPacket.getClientMac().length);
-        assertEquals(expectedClientMac, HexDump.toHexString(offerPacket.getClientMac()));
-
-        // Reduce the hardware address length and verify that it shortens the client MAC.
-        packet.flip();
-        packet.put(hwAddrLenOffset, (byte) 5);
-        offerPacket = DhcpPacket.decodeFullPacket(packet, ENCAP_L3);
-        assertNotNull(offerPacket);
-        assertEquals(5, offerPacket.getClientMac().length);
-        assertEquals(expectedClientMac.substring(0, 10),
-                HexDump.toHexString(offerPacket.getClientMac()));
-
-        packet.flip();
-        packet.put(hwAddrLenOffset, (byte) 3);
-        offerPacket = DhcpPacket.decodeFullPacket(packet, ENCAP_L3);
-        assertNotNull(offerPacket);
-        assertEquals(3, offerPacket.getClientMac().length);
-        assertEquals(expectedClientMac.substring(0, 6),
-                HexDump.toHexString(offerPacket.getClientMac()));
-
-        // Set the the hardware address length to 0xff and verify that we a) don't treat it as -1
-        // and crash, and b) hardcode it to 6.
-        packet.flip();
-        packet.put(hwAddrLenOffset, (byte) -1);
-        offerPacket = DhcpPacket.decodeFullPacket(packet, ENCAP_L3);
-        assertNotNull(offerPacket);
-        assertEquals(6, offerPacket.getClientMac().length);
-        assertEquals(expectedClientMac, HexDump.toHexString(offerPacket.getClientMac()));
-
-        // Set the the hardware address length to a positive invalid value (> 16) and verify that we
-        // hardcode it to 6.
-        packet.flip();
-        packet.put(hwAddrLenOffset, (byte) 17);
-        offerPacket = DhcpPacket.decodeFullPacket(packet, ENCAP_L3);
-        assertNotNull(offerPacket);
-        assertEquals(6, offerPacket.getClientMac().length);
-        assertEquals(expectedClientMac, HexDump.toHexString(offerPacket.getClientMac()));
-    }
-
-    @SmallTest
-    public void testPadAndOverloadedOptionsOffer() throws Exception {
-        // A packet observed in the real world that is interesting for two reasons:
-        //
-        // 1. It uses pad bytes, which we previously didn't support correctly.
-        // 2. It uses DHCP option overloading, which we don't currently support (but it doesn't
-        //    store any information in the overloaded fields).
-        //
-        // For now, we just check that it parses correctly.
-        final ByteBuffer packet = ByteBuffer.wrap(HexDump.hexStringToByteArray(
-            // Ethernet header.
-            "b4cef6000000e80462236e300800" +
-            // IP header.
-            "4500014c00000000ff11741701010101ac119876" +
-            // UDP header. TODO: fix invalid checksum (due to MAC address obfuscation).
-            "004300440138ae5a" +
-            // BOOTP header.
-            "020106000fa0059f0000000000000000ac1198760000000000000000" +
-            // MAC address.
-            "b4cef600000000000000000000000000" +
-            // Server name.
-            "ff00000000000000000000000000000000000000000000000000000000000000" +
-            "0000000000000000000000000000000000000000000000000000000000000000" +
-            // File.
-            "ff00000000000000000000000000000000000000000000000000000000000000" +
-            "0000000000000000000000000000000000000000000000000000000000000000" +
-            "0000000000000000000000000000000000000000000000000000000000000000" +
-            "0000000000000000000000000000000000000000000000000000000000000000" +
-            // Options
-            "638253633501023604010101010104ffff000033040000a8c03401030304ac1101010604ac110101" +
-            "0000000000000000000000000000000000000000000000ff000000"));
-
-        DhcpPacket offerPacket = DhcpPacket.decodeFullPacket(packet, ENCAP_L2);
-        assertTrue(offerPacket instanceof DhcpOfferPacket);
-        DhcpResults dhcpResults = offerPacket.toDhcpResults();
-        assertDhcpResults("172.17.152.118/16", "172.17.1.1", "172.17.1.1",
-                null, "1.1.1.1", null, 43200, false, 0, dhcpResults);
-    }
-
-    @SmallTest
-    public void testBug2111() throws Exception {
-        final ByteBuffer packet = ByteBuffer.wrap(HexDump.hexStringToByteArray(
-            // IP header.
-            "4500014c00000000ff119beac3eaf3880a3f5d04" +
-            // UDP header. TODO: fix invalid checksum (due to MAC address obfuscation).
-            "0043004401387464" +
-            // BOOTP header.
-            "0201060002554812000a0000000000000a3f5d040000000000000000" +
-            // MAC address.
-            "00904c00000000000000000000000000" +
-            // Server name.
-            "0000000000000000000000000000000000000000000000000000000000000000" +
-            "0000000000000000000000000000000000000000000000000000000000000000" +
-            // File.
-            "0000000000000000000000000000000000000000000000000000000000000000" +
-            "0000000000000000000000000000000000000000000000000000000000000000" +
-            "0000000000000000000000000000000000000000000000000000000000000000" +
-            "0000000000000000000000000000000000000000000000000000000000000000" +
-            // Options.
-            "638253633501023604c00002fe33040000bfc60104fffff00003040a3f50010608c0000201c0000202" +
-            "0f0f646f6d61696e3132332e636f2e756b0000000000ff00000000"));
-
-        DhcpPacket offerPacket = DhcpPacket.decodeFullPacket(packet, ENCAP_L3);
-        assertTrue(offerPacket instanceof DhcpOfferPacket);
-        DhcpResults dhcpResults = offerPacket.toDhcpResults();
-        assertDhcpResults("10.63.93.4/20", "10.63.80.1", "192.0.2.1,192.0.2.2",
-                "domain123.co.uk", "192.0.2.254", null, 49094, false, 0, dhcpResults);
-    }
-
-    @SmallTest
-    public void testBug2136() throws Exception {
-        final ByteBuffer packet = ByteBuffer.wrap(HexDump.hexStringToByteArray(
-            // Ethernet header.
-            "bcf5ac000000d0c7890000000800" +
-            // IP header.
-            "4500014c00000000ff119beac3eaf3880a3f5d04" +
-            // UDP header. TODO: fix invalid checksum (due to MAC address obfuscation).
-            "0043004401387574" +
-            // BOOTP header.
-            "0201060163339a3000050000000000000a209ecd0000000000000000" +
-            // MAC address.
-            "bcf5ac00000000000000000000000000" +
-            // Server name.
-            "0000000000000000000000000000000000000000000000000000000000000000" +
-            "0000000000000000000000000000000000000000000000000000000000000000" +
-            // File.
-            "0000000000000000000000000000000000000000000000000000000000000000" +
-            "0000000000000000000000000000000000000000000000000000000000000000" +
-            "0000000000000000000000000000000000000000000000000000000000000000" +
-            "0000000000000000000000000000000000000000000000000000000000000000" +
-            // Options.
-            "6382536335010236040a20ff80330400001c200104fffff00003040a20900106089458413494584135" +
-            "0f0b6c616e63732e61632e756b000000000000000000ff00000000"));
-
-        DhcpPacket offerPacket = DhcpPacket.decodeFullPacket(packet, ENCAP_L2);
-        assertTrue(offerPacket instanceof DhcpOfferPacket);
-        assertEquals("BCF5AC000000", HexDump.toHexString(offerPacket.getClientMac()));
-        DhcpResults dhcpResults = offerPacket.toDhcpResults();
-        assertDhcpResults("10.32.158.205/20", "10.32.144.1", "148.88.65.52,148.88.65.53",
-                "lancs.ac.uk", "10.32.255.128", null, 7200, false, 0, dhcpResults);
-    }
-
-    @SmallTest
-    public void testUdpServerAnySourcePort() throws Exception {
-        final ByteBuffer packet = ByteBuffer.wrap(HexDump.hexStringToByteArray(
-            // Ethernet header.
-            "9cd917000000001c2e0000000800" +
-            // IP header.
-            "45a00148000040003d115087d18194fb0a0f7af2" +
-            // UDP header. TODO: fix invalid checksum (due to MAC address obfuscation).
-            // NOTE: The server source port is not the canonical port 67.
-            "C29F004401341268" +
-            // BOOTP header.
-            "02010600d628ba8200000000000000000a0f7af2000000000a0fc818" +
-            // MAC address.
-            "9cd91700000000000000000000000000" +
-            // Server name.
-            "0000000000000000000000000000000000000000000000000000000000000000" +
-            "0000000000000000000000000000000000000000000000000000000000000000" +
-            // File.
-            "0000000000000000000000000000000000000000000000000000000000000000" +
-            "0000000000000000000000000000000000000000000000000000000000000000" +
-            "0000000000000000000000000000000000000000000000000000000000000000" +
-            "0000000000000000000000000000000000000000000000000000000000000000" +
-            // Options.
-            "6382536335010236040a0169fc3304000151800104ffff000003040a0fc817060cd1818003d1819403" +
-            "d18180060f0777766d2e6564751c040a0fffffff000000"));
-
-        DhcpPacket offerPacket = DhcpPacket.decodeFullPacket(packet, ENCAP_L2);
-        assertTrue(offerPacket instanceof DhcpOfferPacket);
-        assertEquals("9CD917000000", HexDump.toHexString(offerPacket.getClientMac()));
-        DhcpResults dhcpResults = offerPacket.toDhcpResults();
-        assertDhcpResults("10.15.122.242/16", "10.15.200.23",
-                "209.129.128.3,209.129.148.3,209.129.128.6",
-                "wvm.edu", "10.1.105.252", null, 86400, false, 0, dhcpResults);
-    }
-
-    @SmallTest
-    public void testUdpInvalidDstPort() throws Exception {
-        final ByteBuffer packet = ByteBuffer.wrap(HexDump.hexStringToByteArray(
-            // Ethernet header.
-            "9cd917000000001c2e0000000800" +
-            // IP header.
-            "45a00148000040003d115087d18194fb0a0f7af2" +
-            // UDP header. TODO: fix invalid checksum (due to MAC address obfuscation).
-            // NOTE: The destination port is a non-DHCP port.
-            "0043aaaa01341268" +
-            // BOOTP header.
-            "02010600d628ba8200000000000000000a0f7af2000000000a0fc818" +
-            // MAC address.
-            "9cd91700000000000000000000000000" +
-            // Server name.
-            "0000000000000000000000000000000000000000000000000000000000000000" +
-            "0000000000000000000000000000000000000000000000000000000000000000" +
-            // File.
-            "0000000000000000000000000000000000000000000000000000000000000000" +
-            "0000000000000000000000000000000000000000000000000000000000000000" +
-            "0000000000000000000000000000000000000000000000000000000000000000" +
-            "0000000000000000000000000000000000000000000000000000000000000000" +
-            // Options.
-            "6382536335010236040a0169fc3304000151800104ffff000003040a0fc817060cd1818003d1819403" +
-            "d18180060f0777766d2e6564751c040a0fffffff000000"));
-
-        try {
-            DhcpPacket.decodeFullPacket(packet, ENCAP_L2);
-            fail("Packet with invalid dst port did not throw ParseException");
-        } catch (ParseException expected) {}
-    }
-
-    @SmallTest
-    public void testMultipleRouters() throws Exception {
-        final ByteBuffer packet = ByteBuffer.wrap(HexDump.hexStringToByteArray(
-            // Ethernet header.
-            "fc3d93000000" + "081735000000" + "0800" +
-            // IP header.
-            "45000148c2370000ff117ac2c0a8bd02ffffffff" +
-            // UDP header. TODO: fix invalid checksum (due to MAC address obfuscation).
-            "0043004401343beb" +
-            // BOOTP header.
-            "0201060027f518e20000800000000000c0a8bd310000000000000000" +
-            // MAC address.
-            "fc3d9300000000000000000000000000" +
-            // Server name.
-            "0000000000000000000000000000000000000000000000000000000000000000" +
-            "0000000000000000000000000000000000000000000000000000000000000000" +
-            // File.
-            "0000000000000000000000000000000000000000000000000000000000000000" +
-            "0000000000000000000000000000000000000000000000000000000000000000" +
-            "0000000000000000000000000000000000000000000000000000000000000000" +
-            "0000000000000000000000000000000000000000000000000000000000000000" +
-            // Options.
-            "638253633501023604c0abbd023304000070803a04000038403b04000062700104ffffff00" +
-            "0308c0a8bd01ffffff0006080808080808080404ff000000000000"));
-
-        DhcpPacket offerPacket = DhcpPacket.decodeFullPacket(packet, ENCAP_L2);
-        assertTrue(offerPacket instanceof DhcpOfferPacket);
-        assertEquals("FC3D93000000", HexDump.toHexString(offerPacket.getClientMac()));
-        DhcpResults dhcpResults = offerPacket.toDhcpResults();
-        assertDhcpResults("192.168.189.49/24", "192.168.189.1", "8.8.8.8,8.8.4.4",
-                null, "192.171.189.2", null, 28800, false, 0, dhcpResults);
-    }
-
-    @SmallTest
-    public void testDiscoverPacket() throws Exception {
-        short secs = 7;
-        int transactionId = 0xdeadbeef;
-        byte[] hwaddr = {
-                (byte) 0xda, (byte) 0x01, (byte) 0x19, (byte) 0x5b, (byte) 0xb1, (byte) 0x7a
-        };
-
-        ByteBuffer packet = DhcpPacket.buildDiscoverPacket(
-                DhcpPacket.ENCAP_L2, transactionId, secs, hwaddr,
-                false /* do unicast */, DhcpClient.REQUESTED_PARAMS);
-
-        byte[] headers = new byte[] {
-            // Ethernet header.
-            (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff,
-            (byte) 0xda, (byte) 0x01, (byte) 0x19, (byte) 0x5b, (byte) 0xb1, (byte) 0x7a,
-            (byte) 0x08, (byte) 0x00,
-            // IP header.
-            (byte) 0x45, (byte) 0x10, (byte) 0x01, (byte) 0x56,
-            (byte) 0x00, (byte) 0x00, (byte) 0x40, (byte) 0x00,
-            (byte) 0x40, (byte) 0x11, (byte) 0x39, (byte) 0x88,
-            (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
-            (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff,
-            // UDP header.
-            (byte) 0x00, (byte) 0x44, (byte) 0x00, (byte) 0x43,
-            (byte) 0x01, (byte) 0x42, (byte) 0x6a, (byte) 0x4a,
-            // BOOTP.
-            (byte) 0x01, (byte) 0x01, (byte) 0x06, (byte) 0x00,
-            (byte) 0xde, (byte) 0xad, (byte) 0xbe, (byte) 0xef,
-            (byte) 0x00, (byte) 0x07, (byte) 0x00, (byte) 0x00,
-            (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
-            (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
-            (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
-            (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
-            (byte) 0xda, (byte) 0x01, (byte) 0x19, (byte) 0x5b,
-            (byte) 0xb1, (byte) 0x7a
-        };
-        byte[] options = new byte[] {
-            // Magic cookie 0x63825363.
-            (byte) 0x63, (byte) 0x82, (byte) 0x53, (byte) 0x63,
-            // Message type DISCOVER.
-            (byte) 0x35, (byte) 0x01, (byte) 0x01,
-            // Client identifier Ethernet, da:01:19:5b:b1:7a.
-            (byte) 0x3d, (byte) 0x07,
-                    (byte) 0x01,
-                    (byte) 0xda, (byte) 0x01, (byte) 0x19, (byte) 0x5b, (byte) 0xb1, (byte) 0x7a,
-            // Max message size 1500.
-            (byte) 0x39, (byte) 0x02, (byte) 0x05, (byte) 0xdc,
-            // Version "android-dhcp-???".
-            (byte) 0x3c, (byte) 0x10,
-                    'a', 'n', 'd', 'r', 'o', 'i', 'd', '-', 'd', 'h', 'c', 'p', '-', '?', '?', '?',
-            // Hostname "android-01234567890abcde"
-            (byte) 0x0c, (byte) 0x18,
-                    'a', 'n', 'd', 'r', 'o', 'i', 'd', '-',
-                    '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '0', 'a', 'b', 'c', 'd', 'e',
-            // Requested parameter list.
-            (byte) 0x37, (byte) 0x0a,
-                DHCP_SUBNET_MASK,
-                DHCP_ROUTER,
-                DHCP_DNS_SERVER,
-                DHCP_DOMAIN_NAME,
-                DHCP_MTU,
-                DHCP_BROADCAST_ADDRESS,
-                DHCP_LEASE_TIME,
-                DHCP_RENEWAL_TIME,
-                DHCP_REBINDING_TIME,
-                DHCP_VENDOR_INFO,
-            // End options.
-            (byte) 0xff,
-            // Our packets are always of even length. TODO: find out why and possibly fix it.
-            (byte) 0x00
-        };
-        byte[] expected = new byte[DhcpPacket.MIN_PACKET_LENGTH_L2 + options.length];
-        assertTrue((expected.length & 1) == 0);
-        System.arraycopy(headers, 0, expected, 0, headers.length);
-        System.arraycopy(options, 0, expected, DhcpPacket.MIN_PACKET_LENGTH_L2, options.length);
-
-        byte[] actual = new byte[packet.limit()];
-        packet.get(actual);
-        String msg =
-                "Expected:\n  " + Arrays.toString(expected) +
-                "\nActual:\n  " + Arrays.toString(actual);
-        assertTrue(msg, Arrays.equals(expected, actual));
-    }
-}
diff --git a/services/tests/servicestests/src/android/net/netlink/NetlinkErrorMessageTest.java b/services/tests/servicestests/src/android/net/netlink/NetlinkErrorMessageTest.java
deleted file mode 100644
index e677475f590..00000000000
--- a/services/tests/servicestests/src/android/net/netlink/NetlinkErrorMessageTest.java
+++ /dev/null
@@ -1,82 +0,0 @@
-/*
- * Copyright (C) 2015 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package android.net.netlink;
-
-import static android.net.netlink.StructNlMsgHdr.NLM_F_REQUEST;
-import static android.net.netlink.StructNlMsgHdr.NLM_F_ACK;
-import static android.net.netlink.StructNlMsgHdr.NLM_F_REPLACE;
-
-import android.net.netlink.NetlinkConstants;
-import android.net.netlink.NetlinkErrorMessage;
-import android.net.netlink.NetlinkMessage;
-import android.net.netlink.StructNlMsgErr;
-import android.util.Log;
-import java.nio.ByteBuffer;
-import java.nio.ByteOrder;
-import junit.framework.TestCase;
-import libcore.util.HexEncoding;
-
-
-public class NetlinkErrorMessageTest extends TestCase {
-    private final String TAG = "NetlinkErrorMessageTest";
-
-    // Hexadecimal representation of packet capture.
-    public static final String NLM_ERROR_OK_HEX =
-            // struct nlmsghdr
-            "24000000" +     // length = 36
-            "0200"     +     // type = 2 (NLMSG_ERROR)
-            "0000"     +     // flags
-            "26350000" +     // seqno
-            "64100000" +     // pid = userspace process
-            // error integer
-            "00000000" +     // "errno" (0 == OK)
-            // struct nlmsghdr
-            "30000000" +     // length (48) of original request
-            "1C00"     +     // type = 28 (RTM_NEWNEIGH)
-            "0501"     +     // flags (NLM_F_REQUEST | NLM_F_ACK | NLM_F_REPLACE)
-            "26350000" +     // seqno
-            "00000000";      // pid = kernel
-    public static final byte[] NLM_ERROR_OK =
-            HexEncoding.decode(NLM_ERROR_OK_HEX.toCharArray(), false);
-
-    public void testParseNlmErrorOk() {
-        final ByteBuffer byteBuffer = ByteBuffer.wrap(NLM_ERROR_OK);
-        byteBuffer.order(ByteOrder.LITTLE_ENDIAN);  // For testing.
-        final NetlinkMessage msg = NetlinkMessage.parse(byteBuffer);
-        assertNotNull(msg);
-        assertTrue(msg instanceof NetlinkErrorMessage);
-        final NetlinkErrorMessage errorMsg = (NetlinkErrorMessage) msg;
-
-        final StructNlMsgHdr hdr = errorMsg.getHeader();
-        assertNotNull(hdr);
-        assertEquals(36, hdr.nlmsg_len);
-        assertEquals(NetlinkConstants.NLMSG_ERROR, hdr.nlmsg_type);
-        assertEquals(0, hdr.nlmsg_flags);
-        assertEquals(13606, hdr.nlmsg_seq);
-        assertEquals(4196, hdr.nlmsg_pid);
-
-        final StructNlMsgErr err = errorMsg.getNlMsgError();
-        assertNotNull(err);
-        assertEquals(0, err.error);
-        assertNotNull(err.msg);
-        assertEquals(48, err.msg.nlmsg_len);
-        assertEquals(NetlinkConstants.RTM_NEWNEIGH, err.msg.nlmsg_type);
-        assertEquals((NLM_F_REQUEST | NLM_F_ACK | NLM_F_REPLACE), err.msg.nlmsg_flags);
-        assertEquals(13606, err.msg.nlmsg_seq);
-        assertEquals(0, err.msg.nlmsg_pid);
-    }
-}
diff --git a/services/tests/servicestests/src/android/net/netlink/NetlinkSocketTest.java b/services/tests/servicestests/src/android/net/netlink/NetlinkSocketTest.java
deleted file mode 100644
index c599fe3e5b7..00000000000
--- a/services/tests/servicestests/src/android/net/netlink/NetlinkSocketTest.java
+++ /dev/null
@@ -1,116 +0,0 @@
-/*
- * Copyright (C) 2015 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package android.net.netlink;
-
-import android.net.netlink.NetlinkSocket;
-import android.net.netlink.RtNetlinkNeighborMessage;
-import android.net.netlink.StructNdMsg;
-import android.net.netlink.StructNlMsgHdr;
-import android.system.ErrnoException;
-import android.system.NetlinkSocketAddress;
-import android.system.OsConstants;
-import android.util.Log;
-import java.io.InterruptedIOException;
-import java.nio.ByteBuffer;
-import java.nio.ByteOrder;
-import junit.framework.TestCase;
-
-
-public class NetlinkSocketTest extends TestCase {
-    private final String TAG = "NetlinkSocketTest";
-
-    public void testBasicWorkingGetNeighborsQuery() throws Exception {
-        NetlinkSocket s = new NetlinkSocket(OsConstants.NETLINK_ROUTE);
-        assertNotNull(s);
-
-        s.connectToKernel();
-
-        NetlinkSocketAddress localAddr = s.getLocalAddress();
-        assertNotNull(localAddr);
-        assertEquals(0, localAddr.getGroupsMask());
-        assertTrue(0 != localAddr.getPortId());
-
-        final int TEST_SEQNO = 5;
-        final byte[] request = RtNetlinkNeighborMessage.newGetNeighborsRequest(TEST_SEQNO);
-        assertNotNull(request);
-
-        final long TIMEOUT = 500;
-        assertTrue(s.sendMessage(request, 0, request.length, TIMEOUT));
-
-        int neighMessageCount = 0;
-        int doneMessageCount = 0;
-
-        while (doneMessageCount == 0) {
-            ByteBuffer response = null;
-            response = s.recvMessage(TIMEOUT);
-            assertNotNull(response);
-            assertTrue(StructNlMsgHdr.STRUCT_SIZE <= response.limit());
-            assertEquals(0, response.position());
-            assertEquals(ByteOrder.nativeOrder(), response.order());
-
-            // Verify the messages at least appears minimally reasonable.
-            while (response.remaining() > 0) {
-                final NetlinkMessage msg = NetlinkMessage.parse(response);
-                assertNotNull(msg);
-                final StructNlMsgHdr hdr = msg.getHeader();
-                assertNotNull(hdr);
-
-                if (hdr.nlmsg_type == NetlinkConstants.NLMSG_DONE) {
-                    doneMessageCount++;
-                    continue;
-                }
-
-                assertEquals(NetlinkConstants.RTM_NEWNEIGH, hdr.nlmsg_type);
-                assertTrue(msg instanceof RtNetlinkNeighborMessage);
-                assertTrue((hdr.nlmsg_flags & StructNlMsgHdr.NLM_F_MULTI) != 0);
-                assertEquals(TEST_SEQNO, hdr.nlmsg_seq);
-                assertEquals(localAddr.getPortId(), hdr.nlmsg_pid);
-
-                neighMessageCount++;
-            }
-        }
-
-        assertEquals(1, doneMessageCount);
-        // TODO: make sure this test passes sanely in airplane mode.
-        assertTrue(neighMessageCount > 0);
-
-        s.close();
-    }
-
-    public void testRepeatedCloseCallsAreQuiet() throws Exception {
-        // Create a working NetlinkSocket.
-        NetlinkSocket s = new NetlinkSocket(OsConstants.NETLINK_ROUTE);
-        assertNotNull(s);
-        s.connectToKernel();
-        NetlinkSocketAddress localAddr = s.getLocalAddress();
-        assertNotNull(localAddr);
-        assertEquals(0, localAddr.getGroupsMask());
-        assertTrue(0 != localAddr.getPortId());
-        // Close once.
-        s.close();
-        // Test that it is closed.
-        boolean expectedErrorSeen = false;
-        try {
-            localAddr = s.getLocalAddress();
-        } catch (ErrnoException e) {
-            expectedErrorSeen = true;
-        }
-        assertTrue(expectedErrorSeen);
-        // Close once more.
-        s.close();
-    }
-}
diff --git a/services/tests/servicestests/src/android/net/netlink/RtNetlinkNeighborMessageTest.java b/services/tests/servicestests/src/android/net/netlink/RtNetlinkNeighborMessageTest.java
deleted file mode 100644
index 19ee00036b6..00000000000
--- a/services/tests/servicestests/src/android/net/netlink/RtNetlinkNeighborMessageTest.java
+++ /dev/null
@@ -1,257 +0,0 @@
-/*
- * Copyright (C) 2015 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package android.net.netlink;
-
-import android.net.netlink.NetlinkConstants;
-import android.net.netlink.NetlinkMessage;
-import android.net.netlink.RtNetlinkNeighborMessage;
-import android.net.netlink.StructNdMsg;
-import android.net.netlink.StructNlMsgHdr;
-import android.system.OsConstants;
-import android.util.Log;
-import libcore.util.HexEncoding;
-
-import java.net.InetAddress;
-import java.net.Inet4Address;
-import java.net.UnknownHostException;
-import java.nio.ByteBuffer;
-import java.nio.ByteOrder;
-import java.util.Arrays;
-import junit.framework.TestCase;
-
-
-public class RtNetlinkNeighborMessageTest extends TestCase {
-    private final String TAG = "RtNetlinkNeighborMessageTest";
-
-    // Hexadecimal representation of packet capture.
-    public static final String RTM_DELNEIGH_HEX =
-            // struct nlmsghdr
-            "4c000000" +     // length = 76
-            "1d00" +         // type = 29 (RTM_DELNEIGH)
-            "0000" +         // flags
-            "00000000" +     // seqno
-            "00000000" +     // pid (0 == kernel)
-            // struct ndmsg
-            "02" +           // family
-            "00" +           // pad1
-            "0000" +         // pad2
-            "15000000" +     // interface index (21  == wlan0, on test device)
-            "0400" +         // NUD state (0x04 == NUD_STALE)
-            "00" +           // flags
-            "01" +           // type
-            // struct nlattr: NDA_DST
-            "0800" +         // length = 8
-            "0100" +         // type (1 == NDA_DST, for neighbor messages)
-            "c0a89ffe" +     // IPv4 address (== 192.168.159.254)
-            // struct nlattr: NDA_LLADDR
-            "0a00" +         // length = 10
-            "0200" +         // type (2 == NDA_LLADDR, for neighbor messages)
-            "00005e000164" + // MAC Address (== 00:00:5e:00:01:64)
-            "0000" +         // padding, for 4 byte alignment
-            // struct nlattr: NDA_PROBES
-            "0800" +         // length = 8
-            "0400" +         // type (4 == NDA_PROBES, for neighbor messages)
-            "01000000" +     // number of probes
-            // struct nlattr: NDA_CACHEINFO
-            "1400" +         // length = 20
-            "0300" +         // type (3 == NDA_CACHEINFO, for neighbor messages)
-            "05190000" +     // ndm_used, as "clock ticks ago"
-            "05190000" +     // ndm_confirmed, as "clock ticks ago"
-            "190d0000" +     // ndm_updated, as "clock ticks ago"
-            "00000000";      // ndm_refcnt
-    public static final byte[] RTM_DELNEIGH =
-            HexEncoding.decode(RTM_DELNEIGH_HEX.toCharArray(), false);
-
-    // Hexadecimal representation of packet capture.
-    public static final String RTM_NEWNEIGH_HEX =
-            // struct nlmsghdr
-            "58000000" +     // length = 88
-            "1c00" +         // type = 28 (RTM_NEWNEIGH)
-            "0000" +         // flags
-            "00000000" +     // seqno
-            "00000000" +     // pid (0 == kernel)
-            // struct ndmsg
-            "0a" +           // family
-            "00" +           // pad1
-            "0000" +         // pad2
-            "15000000" +     // interface index (21  == wlan0, on test device)
-            "0400" +         // NUD state (0x04 == NUD_STALE)
-            "80" +           // flags
-            "01" +           // type
-            // struct nlattr: NDA_DST
-            "1400" +         // length = 20
-            "0100" +         // type (1 == NDA_DST, for neighbor messages)
-            "fe8000000000000086c9b2fffe6aed4b" + // IPv6 address (== fe80::86c9:b2ff:fe6a:ed4b)
-            // struct nlattr: NDA_LLADDR
-            "0a00" +         // length = 10
-            "0200" +         // type (2 == NDA_LLADDR, for neighbor messages)
-            "84c9b26aed4b" + // MAC Address (== 84:c9:b2:6a:ed:4b)
-            "0000" +         // padding, for 4 byte alignment
-            // struct nlattr: NDA_PROBES
-            "0800" +         // length = 8
-            "0400" +         // type (4 == NDA_PROBES, for neighbor messages)
-            "01000000" +     // number of probes
-            // struct nlattr: NDA_CACHEINFO
-            "1400" +         // length = 20
-            "0300" +         // type (3 == NDA_CACHEINFO, for neighbor messages)
-            "eb0e0000" +     // ndm_used, as "clock ticks ago"
-            "861f0000" +     // ndm_confirmed, as "clock ticks ago"
-            "00000000" +     // ndm_updated, as "clock ticks ago"
-            "05000000";      // ndm_refcnt
-    public static final byte[] RTM_NEWNEIGH =
-            HexEncoding.decode(RTM_NEWNEIGH_HEX.toCharArray(), false);
-
-    // An example of the full response from an RTM_GETNEIGH query.
-    private static final String RTM_GETNEIGH_RESPONSE_HEX =
-            // <-- struct nlmsghr             -->|<-- struct ndmsg           -->|<-- struct nlattr: NDA_DST             -->|<-- NDA_LLADDR          -->|<-- NDA_PROBES -->|<-- NDA_CACHEINFO                         -->|
-            "58000000 1c00 0200 00000000 3e2b0000 0a 00 0000 15000000 4000 00 05 1400 0100 ff020000000000000000000000000001 0a00 0200 333300000001 0000 0800 0400 00000000 1400 0300 a2280000 32110000 32110000 01000000" +
-            "58000000 1c00 0200 00000000 3e2b0000 0a 00 0000 15000000 4000 00 05 1400 0100 ff0200000000000000000001ff000001 0a00 0200 3333ff000001 0000 0800 0400 00000000 1400 0300 0d280000 9d100000 9d100000 00000000" +
-            "58000000 1c00 0200 00000000 3e2b0000 0a 00 0000 15000000 0400 80 01 1400 0100 20010db800040ca00000000000000001 0a00 0200 84c9b26aed4b 0000 0800 0400 04000000 1400 0300 90100000 90100000 90080000 01000000" +
-            "58000000 1c00 0200 00000000 3e2b0000 0a 00 0000 15000000 4000 00 05 1400 0100 ff0200000000000000000001ff47da19 0a00 0200 3333ff47da19 0000 0800 0400 00000000 1400 0300 a1280000 31110000 31110000 01000000" +
-            "58000000 1c00 0200 00000000 3e2b0000 0a 00 0000 14000000 4000 00 05 1400 0100 ff020000000000000000000000000016 0a00 0200 333300000016 0000 0800 0400 00000000 1400 0300 912a0000 21130000 21130000 00000000" +
-            "58000000 1c00 0200 00000000 3e2b0000 0a 00 0000 14000000 4000 00 05 1400 0100 ff0200000000000000000001ffeace3b 0a00 0200 3333ffeace3b 0000 0800 0400 00000000 1400 0300 922a0000 22130000 22130000 00000000" +
-            "58000000 1c00 0200 00000000 3e2b0000 0a 00 0000 15000000 4000 00 05 1400 0100 ff0200000000000000000001ff5c2a83 0a00 0200 3333ff5c2a83 0000 0800 0400 00000000 1400 0300 391c0000 c9040000 c9040000 01000000" +
-            "58000000 1c00 0200 00000000 3e2b0000 0a 00 0000 01000000 4000 00 02 1400 0100 00000000000000000000000000000000 0a00 0200 000000000000 0000 0800 0400 00000000 1400 0300 cd180200 5d010200 5d010200 08000000" +
-            "58000000 1c00 0200 00000000 3e2b0000 0a 00 0000 15000000 4000 00 05 1400 0100 ff020000000000000000000000000002 0a00 0200 333300000002 0000 0800 0400 00000000 1400 0300 352a0000 c5120000 c5120000 00000000" +
-            "58000000 1c00 0200 00000000 3e2b0000 0a 00 0000 15000000 4000 00 05 1400 0100 ff020000000000000000000000000016 0a00 0200 333300000016 0000 0800 0400 00000000 1400 0300 982a0000 28130000 28130000 00000000" +
-            "58000000 1c00 0200 00000000 3e2b0000 0a 00 0000 15000000 0800 80 01 1400 0100 fe8000000000000086c9b2fffe6aed4b 0a00 0200 84c9b26aed4b 0000 0800 0400 00000000 1400 0300 23000000 24000000 57000000 13000000" +
-            "58000000 1c00 0200 00000000 3e2b0000 0a 00 0000 15000000 4000 00 05 1400 0100 ff0200000000000000000001ffeace3b 0a00 0200 3333ffeace3b 0000 0800 0400 00000000 1400 0300 992a0000 29130000 29130000 01000000" +
-            "58000000 1c00 0200 00000000 3e2b0000 0a 00 0000 14000000 4000 00 05 1400 0100 ff020000000000000000000000000002 0a00 0200 333300000002 0000 0800 0400 00000000 1400 0300 2e2a0000 be120000 be120000 00000000" +
-            "44000000 1c00 0200 00000000 3e2b0000 02 00 0000 18000000 4000 00 03 0800 0100 00000000                         0400 0200                   0800 0400 00000000 1400 0300 75280000 05110000 05110000 22000000";
-    public static final byte[] RTM_GETNEIGH_RESPONSE =
-            HexEncoding.decode(RTM_GETNEIGH_RESPONSE_HEX.replaceAll(" ", "").toCharArray(), false);
-
-    public void testParseRtmDelNeigh() {
-        final ByteBuffer byteBuffer = ByteBuffer.wrap(RTM_DELNEIGH);
-        byteBuffer.order(ByteOrder.LITTLE_ENDIAN);  // For testing.
-        final NetlinkMessage msg = NetlinkMessage.parse(byteBuffer);
-        assertNotNull(msg);
-        assertTrue(msg instanceof RtNetlinkNeighborMessage);
-        final RtNetlinkNeighborMessage neighMsg = (RtNetlinkNeighborMessage) msg;
-
-        final StructNlMsgHdr hdr = neighMsg.getHeader();
-        assertNotNull(hdr);
-        assertEquals(76, hdr.nlmsg_len);
-        assertEquals(NetlinkConstants.RTM_DELNEIGH, hdr.nlmsg_type);
-        assertEquals(0, hdr.nlmsg_flags);
-        assertEquals(0, hdr.nlmsg_seq);
-        assertEquals(0, hdr.nlmsg_pid);
-
-        final StructNdMsg ndmsgHdr = neighMsg.getNdHeader();
-        assertNotNull(ndmsgHdr);
-        assertEquals((byte) OsConstants.AF_INET, ndmsgHdr.ndm_family);
-        assertEquals(21, ndmsgHdr.ndm_ifindex);
-        assertEquals(StructNdMsg.NUD_STALE, ndmsgHdr.ndm_state);
-        final InetAddress destination = neighMsg.getDestination();
-        assertNotNull(destination);
-        assertEquals(InetAddress.parseNumericAddress("192.168.159.254"), destination);
-    }
-
-    public void testParseRtmNewNeigh() {
-        final ByteBuffer byteBuffer = ByteBuffer.wrap(RTM_NEWNEIGH);
-        byteBuffer.order(ByteOrder.LITTLE_ENDIAN);  // For testing.
-        final NetlinkMessage msg = NetlinkMessage.parse(byteBuffer);
-        assertNotNull(msg);
-        assertTrue(msg instanceof RtNetlinkNeighborMessage);
-        final RtNetlinkNeighborMessage neighMsg = (RtNetlinkNeighborMessage) msg;
-
-        final StructNlMsgHdr hdr = neighMsg.getHeader();
-        assertNotNull(hdr);
-        assertEquals(88, hdr.nlmsg_len);
-        assertEquals(NetlinkConstants.RTM_NEWNEIGH, hdr.nlmsg_type);
-        assertEquals(0, hdr.nlmsg_flags);
-        assertEquals(0, hdr.nlmsg_seq);
-        assertEquals(0, hdr.nlmsg_pid);
-
-        final StructNdMsg ndmsgHdr = neighMsg.getNdHeader();
-        assertNotNull(ndmsgHdr);
-        assertEquals((byte) OsConstants.AF_INET6, ndmsgHdr.ndm_family);
-        assertEquals(21, ndmsgHdr.ndm_ifindex);
-        assertEquals(StructNdMsg.NUD_STALE, ndmsgHdr.ndm_state);
-        final InetAddress destination = neighMsg.getDestination();
-        assertNotNull(destination);
-        assertEquals(InetAddress.parseNumericAddress("fe80::86c9:b2ff:fe6a:ed4b"), destination);
-    }
-
-    public void testParseRtmGetNeighResponse() {
-        final ByteBuffer byteBuffer = ByteBuffer.wrap(RTM_GETNEIGH_RESPONSE);
-        byteBuffer.order(ByteOrder.LITTLE_ENDIAN);  // For testing.
-
-        int messageCount = 0;
-        while (byteBuffer.remaining() > 0) {
-            final NetlinkMessage msg = NetlinkMessage.parse(byteBuffer);
-            assertNotNull(msg);
-            assertTrue(msg instanceof RtNetlinkNeighborMessage);
-            final RtNetlinkNeighborMessage neighMsg = (RtNetlinkNeighborMessage) msg;
-
-            final StructNlMsgHdr hdr = neighMsg.getHeader();
-            assertNotNull(hdr);
-            assertEquals(NetlinkConstants.RTM_NEWNEIGH, hdr.nlmsg_type);
-            assertEquals(StructNlMsgHdr.NLM_F_MULTI, hdr.nlmsg_flags);
-            assertEquals(0, hdr.nlmsg_seq);
-            assertEquals(11070, hdr.nlmsg_pid);
-
-            messageCount++;
-        }
-        // TODO: add more detailed spot checks.
-        assertEquals(14, messageCount);
-    }
-
-    public void testCreateRtmNewNeighMessage() {
-        final int seqNo = 2635;
-        final int ifIndex = 14;
-        final byte[] llAddr =
-                new byte[] { (byte) 1, (byte) 2, (byte) 3, (byte) 4, (byte) 5, (byte) 6 };
-
-        // Hexadecimal representation of our created packet.
-        final String expectedNewNeighHex =
-                // struct nlmsghdr
-                "30000000" +     // length = 48
-                "1c00" +         // type = 28 (RTM_NEWNEIGH)
-                "0501" +         // flags (NLM_F_REQUEST | NLM_F_ACK | NLM_F_REPLACE)
-                "4b0a0000" +     // seqno
-                "00000000" +     // pid (0 == kernel)
-                // struct ndmsg
-                "02" +           // family
-                "00" +           // pad1
-                "0000" +         // pad2
-                "0e000000" +     // interface index (14)
-                "0800" +         // NUD state (0x08 == NUD_DELAY)
-                "00" +           // flags
-                "00" +           // type
-                // struct nlattr: NDA_DST
-                "0800" +         // length = 8
-                "0100" +         // type (1 == NDA_DST, for neighbor messages)
-                "7f000001" +     // IPv4 address (== 127.0.0.1)
-                // struct nlattr: NDA_LLADDR
-                "0a00" +         // length = 10
-                "0200" +         // type (2 == NDA_LLADDR, for neighbor messages)
-                "010203040506" + // MAC Address (== 01:02:03:04:05:06)
-                "0000";          // padding, for 4 byte alignment
-        final byte[] expectedNewNeigh =
-                HexEncoding.decode(expectedNewNeighHex.toCharArray(), false);
-
-        final byte[] bytes = RtNetlinkNeighborMessage.newNewNeighborMessage(
-            seqNo, Inet4Address.LOOPBACK, StructNdMsg.NUD_DELAY, ifIndex, llAddr);
-        if (!Arrays.equals(expectedNewNeigh, bytes)) {
-            assertEquals(expectedNewNeigh.length, bytes.length);
-            for (int i = 0; i < Math.min(expectedNewNeigh.length, bytes.length); i++) {
-                assertEquals(expectedNewNeigh[i], bytes[i]);
-            }
-        }
-    }
-}
diff --git a/services/tests/servicestests/src/com/android/internal/util/FakeSettingsProvider.java b/services/tests/servicestests/src/com/android/internal/util/FakeSettingsProvider.java
deleted file mode 100644
index 808f4dd7b84..00000000000
--- a/services/tests/servicestests/src/com/android/internal/util/FakeSettingsProvider.java
+++ /dev/null
@@ -1,130 +0,0 @@
-/*
- * Copyright (C) 2016 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.android.internal.util;
-
-import android.net.Uri;
-import android.os.Bundle;
-import android.provider.Settings;
-import android.test.mock.MockContentProvider;
-import android.util.Log;
-
-import java.util.HashMap;
-
-/**
- * Fake for system settings.
- *
- * To use, ensure that the Context used by the test code returns a ContentResolver that uses this
- * provider for the Settings authority:
- *
- *   class MyTestContext extends MockContext {
- *       ...
- *       private final MockContentResolver mContentResolver;
- *       public MyTestContext(...) {
- *           ...
- *           mContentResolver = new MockContentResolver();
- *           mContentResolver.addProvider(Settings.AUTHORITY, new FakeSettingsProvider());
- *       }
- *       ...
- *       @Override
- *       public ContentResolver getContentResolver() {
- *           return mContentResolver;
- *       }
- *
- * As long as the code under test is using the test Context, the actual code under test does not
- * need to be modified, and can access Settings using the normal static methods:
- *
- *   Settings.Global.getInt(cr, "my_setting", 0);  // Returns 0.
- *   Settings.Global.putInt(cr, "my_setting", 5);
- *   Settings.Global.getInt(cr, "my_setting", 0);  // Returns 5.
- *
- * Note that this class cannot be used in the same process as real settings. This is because it
- * works by passing an alternate ContentResolver to Settings operations. Unfortunately, the Settings
- * class only fetches the content provider from the passed-in ContentResolver the first time it's
- * used, and after that stores it in a per-process static.
- *
- * TODO: evaluate implementing settings change notifications. This would require:
- *
- * 1. Making ContentResolver#registerContentObserver non-final and overriding it in
- *    MockContentResolver.
- * 2. Making FakeSettingsProvider take a ContentResolver argument.
- * 3. Calling ContentResolver#notifyChange(getUriFor(table, arg), ...) on every settings change.
- */
-public class FakeSettingsProvider extends MockContentProvider {
-
-    private static final String TAG = FakeSettingsProvider.class.getSimpleName();
-    private static final boolean DBG = false;
-    private static final String[] TABLES = { "system", "secure", "global" };
-
-    private final HashMap<String, HashMap<String, String>> mTables = new HashMap<>();
-
-    public FakeSettingsProvider() {
-        for (int i = 0; i < TABLES.length; i++) {
-            mTables.put(TABLES[i], new HashMap<String, String>());
-        }
-    }
-
-    private Uri getUriFor(String table, String key) {
-        switch (table) {
-            case "system":
-                return Settings.System.getUriFor(key);
-            case "secure":
-                return Settings.Secure.getUriFor(key);
-            case "global":
-                return Settings.Global.getUriFor(key);
-            default:
-                throw new UnsupportedOperationException("Unknown settings table " + table);
-        }
-    }
-
-    public Bundle call(String method, String arg, Bundle extras) {
-        // Methods are "GET_system", "GET_global", "PUT_secure", etc.
-        String[] commands = method.split("_", 2);
-        String op = commands[0];
-        String table = commands[1];
-
-        Bundle out = new Bundle();
-        String value;
-        switch (op) {
-            case "GET":
-                value = mTables.get(table).get(arg);
-                if (value != null) {
-                    if (DBG) {
-                        Log.d(TAG, String.format("Returning fake setting %s.%s = %s",
-                                table, arg, value));
-                    }
-                    out.putString(Settings.NameValueTable.VALUE, value);
-                }
-                break;
-            case "PUT":
-                value = extras.getString(Settings.NameValueTable.VALUE, null);
-                if (DBG) {
-                    Log.d(TAG, String.format("Inserting fake setting %s.%s = %s",
-                            table, arg, value));
-                }
-                if (value != null) {
-                    mTables.get(table).put(arg, value);
-                } else {
-                    mTables.get(table).remove(arg);
-                }
-                break;
-            default:
-                throw new UnsupportedOperationException("Unknown command " + method);
-        }
-
-        return out;
-    }
-}
diff --git a/services/tests/servicestests/src/com/android/internal/util/FakeSettingsProviderTest.java b/services/tests/servicestests/src/com/android/internal/util/FakeSettingsProviderTest.java
deleted file mode 100644
index 05de0a53e05..00000000000
--- a/services/tests/servicestests/src/com/android/internal/util/FakeSettingsProviderTest.java
+++ /dev/null
@@ -1,59 +0,0 @@
-/*
- * Copyright (C) 2016 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.android.internal.util;
-
-import android.content.ContentResolver;
-import android.database.ContentObserver;
-import android.net.Uri;
-import android.provider.Settings;
-import android.test.AndroidTestCase;
-import android.test.mock.MockContentResolver;
-import android.test.mock.MockContext;
-import android.test.suitebuilder.annotation.SmallTest;
-import android.test.suitebuilder.annotation.Suppress;
-import android.util.Log;
-
-import java.util.concurrent.CountDownLatch;
-import java.util.concurrent.TimeUnit;
-
-/**
- * Unit tests for FakeSettingsProvider.
- */
-public class FakeSettingsProviderTest extends AndroidTestCase {
-
-    private MockContentResolver mCr;
-
-    @Override
-    public void setUp() throws Exception {
-        mCr = new MockContentResolver();
-        mCr.addProvider(Settings.AUTHORITY, new FakeSettingsProvider());
-    }
-
-    @SmallTest
-    public void testBasicOperation() throws Exception {
-        String settingName = Settings.System.SCREEN_BRIGHTNESS;
-
-        try {
-            Settings.System.getInt(mCr, settingName);
-            fail("FakeSettingsProvider should start off empty.");
-        } catch (Settings.SettingNotFoundException expected) {}
-
-        // Check that fake settings can be written and read back.
-        Settings.System.putInt(mCr, settingName, 123);
-        assertEquals(123, Settings.System.getInt(mCr, settingName));
-    }
-}
diff --git a/services/tests/servicestests/src/com/android/server/AccessibilityManagerServiceTest.java b/services/tests/servicestests/src/com/android/server/AccessibilityManagerServiceTest.java
deleted file mode 100644
index 51e14d3fcb0..00000000000
--- a/services/tests/servicestests/src/com/android/server/AccessibilityManagerServiceTest.java
+++ /dev/null
@@ -1,757 +0,0 @@
-/*
- * Copyright (C) 2010 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.android.server;
-
-import android.accessibilityservice.AccessibilityService;
-import android.accessibilityservice.AccessibilityServiceInfo;
-import android.content.ComponentName;
-import android.content.Context;
-import android.content.pm.ServiceInfo;
-import android.os.IBinder;
-import android.os.Message;
-import android.os.ServiceManager;
-import android.os.SystemClock;
-import android.os.UserHandle;
-import android.provider.Settings;
-import android.test.AndroidTestCase;
-import android.test.suitebuilder.annotation.LargeTest;
-import android.view.accessibility.AccessibilityEvent;
-import android.view.accessibility.AccessibilityManager;
-import android.view.accessibility.IAccessibilityManager;
-import android.view.accessibility.IAccessibilityManagerClient;
-
-/**
- * This test exercises the
- * {@link com.android.server.accessibility.AccessibilityManagerService} by mocking the
- * {@link android.view.accessibility.AccessibilityManager} which talks to to the
- * service. The service itself is interacting with the platform. Note: Testing
- * the service in full isolation would require significant amount of work for
- * mocking all system interactions. It would also require a lot of mocking code.
- */
-public class AccessibilityManagerServiceTest extends AndroidTestCase {
-
-    /**
-     * Timeout required for pending Binder calls or event processing to
-     * complete.
-     */
-    private static final long TIMEOUT_BINDER_CALL = 100;
-
-    /**
-     * Timeout in which we are waiting for the system to start the mock
-     * accessibility services.
-     */
-    private static final long TIMEOUT_START_MOCK_ACCESSIBILITY_SERVICES = 1000;
-
-    /**
-     * Timeout used for testing that a service is notified only upon a
-     * notification timeout.
-     */
-    private static final long TIMEOUT_TEST_NOTIFICATION_TIMEOUT = 300;
-
-    /**
-     * The interface used to talk to the tested service.
-     */
-    private IAccessibilityManager mManagerService;
-
-    @Override
-    protected void setUp() throws Exception {
-        // Reset the state.
-        ensureOnlyMockServicesEnabled(getContext(), false, false);
-    }
-
-    @Override
-    public void setContext(Context context) {
-        super.setContext(context);
-        if (MyFirstMockAccessibilityService.sComponentName == null) {
-            MyFirstMockAccessibilityService.sComponentName = new ComponentName(
-                    context.getPackageName(), MyFirstMockAccessibilityService.class.getName())
-                    .flattenToShortString();
-        }
-        if (MySecondMockAccessibilityService.sComponentName == null) {
-            MySecondMockAccessibilityService.sComponentName = new ComponentName(
-                    context.getPackageName(), MySecondMockAccessibilityService.class.getName())
-                    .flattenToShortString();
-        }
-    }
-
-    /**
-     * Creates a new instance.
-     */
-    public AccessibilityManagerServiceTest() {
-        IBinder iBinder = ServiceManager.getService(Context.ACCESSIBILITY_SERVICE);
-        mManagerService = IAccessibilityManager.Stub.asInterface(iBinder);
-    }
-
-    @LargeTest
-    public void testAddClient_AccessibilityDisabledThenEnabled() throws Exception {
-        // at least some service must be enabled, otherwise accessibility will always be disabled.
-        ensureOnlyMockServicesEnabled(mContext, true, false);
-
-        // make sure accessibility is disabled
-        ensureAccessibilityEnabled(mContext, false);
-
-        // create a client mock instance
-        MyMockAccessibilityManagerClient mockClient = new MyMockAccessibilityManagerClient();
-
-        // invoke the method under test
-        final int stateFlagsDisabled =
-                mManagerService.addClient(mockClient, UserHandle.USER_CURRENT);
-        boolean enabledAccessibilityDisabled =
-            (stateFlagsDisabled & AccessibilityManager.STATE_FLAG_ACCESSIBILITY_ENABLED) != 0;
-
-        // check expected result
-        assertFalse("The client must be disabled since accessibility is disabled.",
-                enabledAccessibilityDisabled);
-
-        // enable accessibility
-        ensureAccessibilityEnabled(mContext, true);
-
-        // invoke the method under test
-        final int stateFlagsEnabled =
-                mManagerService.addClient(mockClient, UserHandle.USER_CURRENT);
-        boolean enabledAccessibilityEnabled =
-            (stateFlagsEnabled & AccessibilityManager.STATE_FLAG_ACCESSIBILITY_ENABLED) != 0;
-
-        // check expected result
-        assertTrue("The client must be enabled since accessibility is enabled.",
-                enabledAccessibilityEnabled);
-    }
-
-    @LargeTest
-    public void testAddClient_AccessibilityEnabledThenDisabled() throws Exception {
-        // at least some service must be enabled, otherwise accessibility will always be disabled.
-        ensureOnlyMockServicesEnabled(mContext, true, false);
-
-        // enable accessibility before registering the client
-        ensureAccessibilityEnabled(mContext, true);
-
-        // create a client mock instance
-        MyMockAccessibilityManagerClient mockClient = new MyMockAccessibilityManagerClient();
-
-        // invoke the method under test
-        final int stateFlagsEnabled =
-                mManagerService.addClient(mockClient, UserHandle.USER_CURRENT);
-        boolean enabledAccessibilityEnabled =
-            (stateFlagsEnabled & AccessibilityManager.STATE_FLAG_ACCESSIBILITY_ENABLED) != 0;
-
-        // check expected result
-        assertTrue("The client must be enabled since accessibility is enabled.",
-                enabledAccessibilityEnabled);
-
-        // disable accessibility
-        ensureAccessibilityEnabled(mContext, false);
-
-        // invoke the method under test
-        final int stateFlagsDisabled =
-                mManagerService.addClient(mockClient, UserHandle.USER_CURRENT);
-        boolean enabledAccessibilityDisabled =
-            (stateFlagsDisabled & AccessibilityManager.STATE_FLAG_ACCESSIBILITY_ENABLED) != 0;
-
-        // check expected result
-        assertFalse("The client must be disabled since accessibility is disabled.",
-                enabledAccessibilityDisabled);
-    }
-
-    @LargeTest
-    public void testGetAccessibilityServicesList() throws Exception {
-        boolean firstMockServiceInstalled = false;
-        boolean secondMockServiceInstalled = false;
-
-        String packageName = getContext().getPackageName();
-        String firstMockServiceClassName = MyFirstMockAccessibilityService.class.getName();
-        String secondMockServiceClassName = MySecondMockAccessibilityService.class.getName();
-
-        // look for the two mock services
-        for (AccessibilityServiceInfo info : mManagerService.getInstalledAccessibilityServiceList(
-                UserHandle.USER_CURRENT)) {
-            ServiceInfo serviceInfo = info.getResolveInfo().serviceInfo;
-            if (packageName.equals(serviceInfo.packageName)) {
-                if (firstMockServiceClassName.equals(serviceInfo.name)) {
-                    firstMockServiceInstalled = true;
-                } else if (secondMockServiceClassName.equals(serviceInfo.name)) {
-                    secondMockServiceInstalled = true;
-                }
-            }
-        }
-
-        // check expected result
-        assertTrue("First mock service must be installed", firstMockServiceInstalled);
-        assertTrue("Second mock service must be installed", secondMockServiceInstalled);
-    }
-
-    @LargeTest
-    public void testSendAccessibilityEvent_OneService_MatchingPackageAndEventType()
-            throws Exception {
-        // enable the mock accessibility service
-        ensureOnlyMockServicesEnabled(mContext, true, false);
-
-        // set the accessibility setting value
-        ensureAccessibilityEnabled(mContext, true);
-
-        // configure the mock service
-        MockAccessibilityService service = MyFirstMockAccessibilityService.sInstance;
-        service.setServiceInfo(MockAccessibilityService.createDefaultInfo());
-
-        // wait for the binder call to #setService to complete
-        Thread.sleep(TIMEOUT_BINDER_CALL);
-
-        // create and populate an event to be sent
-        AccessibilityEvent sentEvent = AccessibilityEvent.obtain();
-        fullyPopulateDefaultAccessibilityEvent(sentEvent);
-
-        // set expectations
-        service.expectEvent(sentEvent);
-        service.replay();
-
-        // send the event
-        mManagerService.sendAccessibilityEvent(sentEvent, UserHandle.USER_CURRENT);
-
-        // verify if all expected methods have been called
-        assertMockServiceVerifiedWithinTimeout(service);
-    }
-
-    @LargeTest
-    public void testSendAccessibilityEvent_OneService_NotMatchingPackage() throws Exception {
-        // enable the mock accessibility service
-        ensureOnlyMockServicesEnabled(mContext, true, false);
-
-        // set the accessibility setting value
-        ensureAccessibilityEnabled(mContext, true);
-
-        // configure the mock service
-        MockAccessibilityService service = MyFirstMockAccessibilityService.sInstance;
-        service.setServiceInfo(MockAccessibilityService.createDefaultInfo());
-
-        // wait for the binder call to #setService to complete
-        Thread.sleep(TIMEOUT_BINDER_CALL);
-
-        // create and populate an event to be sent
-        AccessibilityEvent sentEvent = AccessibilityEvent.obtain();
-        fullyPopulateDefaultAccessibilityEvent(sentEvent);
-        sentEvent.setPackageName("no.service.registered.for.this.package");
-
-        // set expectations
-        service.replay();
-
-        // send the event
-        mManagerService.sendAccessibilityEvent(sentEvent, UserHandle.USER_CURRENT);
-
-        // verify if all expected methods have been called
-        assertMockServiceVerifiedWithinTimeout(service);
-    }
-
-    @LargeTest
-    public void testSendAccessibilityEvent_OneService_NotMatchingEventType() throws Exception {
-        // enable the mock accessibility service
-        ensureOnlyMockServicesEnabled(mContext, true, false);
-
-        // set the accessibility setting value
-        ensureAccessibilityEnabled(mContext, true);
-
-        // configure the mock service
-        MockAccessibilityService service = MyFirstMockAccessibilityService.sInstance;
-        service.setServiceInfo(MockAccessibilityService.createDefaultInfo());
-
-        // wait for the binder call to #setService to complete
-        Thread.sleep(TIMEOUT_BINDER_CALL);
-
-        // create and populate an event to be sent
-        AccessibilityEvent sentEvent = AccessibilityEvent.obtain();
-        fullyPopulateDefaultAccessibilityEvent(sentEvent);
-        sentEvent.setEventType(AccessibilityEvent.TYPE_NOTIFICATION_STATE_CHANGED);
-
-        // set expectations
-        service.replay();
-
-        // send the event
-        mManagerService.sendAccessibilityEvent(sentEvent, UserHandle.USER_CURRENT);
-
-        // verify if all expected methods have been called
-        assertMockServiceVerifiedWithinTimeout(service);
-    }
-
-    @LargeTest
-    public void testSendAccessibilityEvent_OneService_NotifivationAfterTimeout() throws Exception {
-        // enable the mock accessibility service
-        ensureOnlyMockServicesEnabled(mContext, true, false);
-
-        // set the accessibility setting value
-        ensureAccessibilityEnabled(mContext, true);
-
-        // configure the mock service
-        MockAccessibilityService service = MyFirstMockAccessibilityService.sInstance;
-        AccessibilityServiceInfo info = MockAccessibilityService.createDefaultInfo();
-        info.notificationTimeout = TIMEOUT_TEST_NOTIFICATION_TIMEOUT;
-        service.setServiceInfo(info);
-
-        // wait for the binder call to #setService to complete
-        Thread.sleep(TIMEOUT_BINDER_CALL);
-
-        // create and populate the first event to be sent
-        AccessibilityEvent firstEvent = AccessibilityEvent.obtain();
-        fullyPopulateDefaultAccessibilityEvent(firstEvent);
-
-        // create and populate the second event to be sent
-        AccessibilityEvent secondEvent = AccessibilityEvent.obtain();
-        fullyPopulateDefaultAccessibilityEvent(secondEvent);
-
-        // set expectations
-        service.expectEvent(secondEvent);
-        service.replay();
-
-        // send the events
-        mManagerService.sendAccessibilityEvent(firstEvent, UserHandle.USER_CURRENT);
-        mManagerService.sendAccessibilityEvent(secondEvent, UserHandle.USER_CURRENT);
-
-        // wait for #sendAccessibilityEvent to reach the backing service
-        Thread.sleep(TIMEOUT_BINDER_CALL);
-
-        try {
-            service.verify();
-            fail("No events must be dispatched before the expiration of the notification timeout.");
-        } catch (IllegalStateException ise) {
-            /* expected */
-        }
-
-        // wait for the configured notification timeout to expire
-        Thread.sleep(TIMEOUT_TEST_NOTIFICATION_TIMEOUT);
-
-        // verify if all expected methods have been called
-        assertMockServiceVerifiedWithinTimeout(service);
-    }
-
-    @LargeTest
-    public void testSendAccessibilityEvent_TwoServices_MatchingPackageAndEventType_DiffFeedback()
-            throws Exception {
-        // enable the mock accessibility services
-        ensureOnlyMockServicesEnabled(mContext, true, true);
-
-        // set the accessibility setting value
-        ensureAccessibilityEnabled(mContext, true);
-
-        // configure the first mock service
-        MockAccessibilityService firstService = MyFirstMockAccessibilityService.sInstance;
-        AccessibilityServiceInfo firstInfo = MockAccessibilityService.createDefaultInfo();
-        firstInfo.feedbackType = AccessibilityServiceInfo.FEEDBACK_AUDIBLE;
-        firstService.setServiceInfo(firstInfo);
-
-        // configure the second mock service
-        MockAccessibilityService secondService = MySecondMockAccessibilityService.sInstance;
-        AccessibilityServiceInfo secondInfo = MockAccessibilityService.createDefaultInfo();
-        secondInfo.feedbackType = AccessibilityServiceInfo.FEEDBACK_HAPTIC;
-        secondService.setServiceInfo(secondInfo);
-
-        // wait for the binder calls to #setService to complete
-        Thread.sleep(TIMEOUT_BINDER_CALL);
-
-        // create and populate an event to be sent
-        AccessibilityEvent sentEvent = AccessibilityEvent.obtain();
-        fullyPopulateDefaultAccessibilityEvent(sentEvent);
-
-        // set expectations for the first mock service
-        firstService.expectEvent(sentEvent);
-        firstService.replay();
-
-        // set expectations for the second mock service
-        secondService.expectEvent(sentEvent);
-        secondService.replay();
-
-        // send the event
-        mManagerService.sendAccessibilityEvent(sentEvent, UserHandle.USER_CURRENT);
-
-        // verify if all expected methods have been called
-        assertMockServiceVerifiedWithinTimeout(firstService);
-        assertMockServiceVerifiedWithinTimeout(secondService);
-    }
-
-    @LargeTest
-    public void testSendAccessibilityEvent_TwoServices_MatchingPackageAndEventType()
-            throws Exception {
-        // enable the mock accessibility services
-        ensureOnlyMockServicesEnabled(mContext, true, true);
-
-        // set the accessibility setting value
-        ensureAccessibilityEnabled(mContext, true);
-
-        // configure the first mock service
-        MockAccessibilityService firstService = MyFirstMockAccessibilityService.sInstance;
-        firstService.setServiceInfo(MockAccessibilityService.createDefaultInfo());
-
-        // configure the second mock service
-        MockAccessibilityService secondService = MySecondMockAccessibilityService.sInstance;
-        secondService.setServiceInfo(MockAccessibilityService.createDefaultInfo());
-
-        // wait for the binder calls to #setService to complete
-        Thread.sleep(TIMEOUT_BINDER_CALL);
-
-        // create and populate an event to be sent
-        AccessibilityEvent sentEvent = AccessibilityEvent.obtain();
-        fullyPopulateDefaultAccessibilityEvent(sentEvent);
-
-        // set expectations for the first mock service
-        firstService.expectEvent(sentEvent);
-        firstService.replay();
-
-        // set expectations for the second mock service
-        secondService.replay();
-
-        // send the event
-        mManagerService.sendAccessibilityEvent(sentEvent, UserHandle.USER_CURRENT);
-
-        // verify if all expected methods have been called
-        assertMockServiceVerifiedWithinTimeout(firstService);
-        assertMockServiceVerifiedWithinTimeout(secondService);
-    }
-
-    @LargeTest
-    public void testSendAccessibilityEvent_TwoServices_MatchingPackageAndEventType_OneDefault()
-            throws Exception {
-        // enable the mock accessibility services
-        ensureOnlyMockServicesEnabled(mContext, true, true);
-
-        // set the accessibility setting value
-        ensureAccessibilityEnabled(mContext, true);
-
-        // configure the first mock service
-        MockAccessibilityService firstService = MyFirstMockAccessibilityService.sInstance;
-        AccessibilityServiceInfo firstInfo = MyFirstMockAccessibilityService.createDefaultInfo();
-        firstInfo.flags = AccessibilityServiceInfo.DEFAULT;
-        firstService.setServiceInfo(firstInfo);
-
-        // configure the second mock service
-        MockAccessibilityService secondService = MySecondMockAccessibilityService.sInstance;
-        secondService.setServiceInfo(MySecondMockAccessibilityService.createDefaultInfo());
-
-        // wait for the binder calls to #setService to complete
-        Thread.sleep(TIMEOUT_BINDER_CALL);
-
-        // create and populate an event to be sent
-        AccessibilityEvent sentEvent = AccessibilityEvent.obtain();
-        fullyPopulateDefaultAccessibilityEvent(sentEvent);
-
-        // set expectations for the first mock service
-        firstService.replay();
-
-        // set expectations for the second mock service
-        secondService.expectEvent(sentEvent);
-        secondService.replay();
-
-        // send the event
-        mManagerService.sendAccessibilityEvent(sentEvent, UserHandle.USER_CURRENT);
-
-        // verify if all expected methods have been called
-        assertMockServiceVerifiedWithinTimeout(firstService);
-        assertMockServiceVerifiedWithinTimeout(secondService);
-    }
-
-    @LargeTest
-    public void testSendAccessibilityEvent_TwoServices_MatchingPackageAndEventType_TwoDefault()
-            throws Exception {
-        // enable the mock accessibility services
-        ensureOnlyMockServicesEnabled(mContext, true, true);
-
-        // set the accessibility setting value
-        ensureAccessibilityEnabled(mContext, true);
-
-        // configure the first mock service
-        MockAccessibilityService firstService = MyFirstMockAccessibilityService.sInstance;
-        AccessibilityServiceInfo firstInfo = MyFirstMockAccessibilityService.createDefaultInfo();
-        firstInfo.flags = AccessibilityServiceInfo.DEFAULT;
-        firstService.setServiceInfo(firstInfo);
-
-        // configure the second mock service
-        MockAccessibilityService secondService = MySecondMockAccessibilityService.sInstance;
-        AccessibilityServiceInfo secondInfo = MyFirstMockAccessibilityService.createDefaultInfo();
-        secondInfo.flags = AccessibilityServiceInfo.DEFAULT;
-        secondService.setServiceInfo(firstInfo);
-
-        // wait for the binder calls to #setService to complete
-        Thread.sleep(TIMEOUT_BINDER_CALL);
-
-        // create and populate an event to be sent
-        AccessibilityEvent sentEvent = AccessibilityEvent.obtain();
-        fullyPopulateDefaultAccessibilityEvent(sentEvent);
-
-        // set expectations for the first mock service
-        firstService.expectEvent(sentEvent);
-        firstService.replay();
-
-        // set expectations for the second mock service
-        secondService.replay();
-
-        // send the event
-        mManagerService.sendAccessibilityEvent(sentEvent, UserHandle.USER_CURRENT);
-
-        // verify if all expected methods have been called
-        assertMockServiceVerifiedWithinTimeout(firstService);
-        assertMockServiceVerifiedWithinTimeout(secondService);
-    }
-
-    @LargeTest
-    public void testInterrupt() throws Exception {
-        // enable the mock accessibility services
-        ensureOnlyMockServicesEnabled(mContext, true, true);
-
-        // set the accessibility setting value
-        ensureAccessibilityEnabled(mContext, true);
-
-        // configure the first mock service
-        MockAccessibilityService firstService = MyFirstMockAccessibilityService.sInstance;
-        firstService.setServiceInfo(MockAccessibilityService.createDefaultInfo());
-
-        // configure the second mock service
-        MockAccessibilityService secondService = MySecondMockAccessibilityService.sInstance;
-        secondService.setServiceInfo(MockAccessibilityService.createDefaultInfo());
-
-        // wait for the binder calls to #setService to complete
-        Thread.sleep(TIMEOUT_BINDER_CALL);
-
-        // set expectations for the first mock service
-        firstService.expectInterrupt();
-        firstService.replay();
-
-        // set expectations for the second mock service
-        secondService.expectInterrupt();
-        secondService.replay();
-
-        // call the method under test
-        mManagerService.interrupt(UserHandle.USER_CURRENT);
-
-        // verify if all expected methods have been called
-        assertMockServiceVerifiedWithinTimeout(firstService);
-        assertMockServiceVerifiedWithinTimeout(secondService);
-    }
-
-    /**
-     * Fully populates the {@link AccessibilityEvent} to marshal.
-     *
-     * @param sentEvent The event to populate.
-     */
-    private void fullyPopulateDefaultAccessibilityEvent(AccessibilityEvent sentEvent) {
-        sentEvent.setAddedCount(1);
-        sentEvent.setBeforeText("BeforeText");
-        sentEvent.setChecked(true);
-        sentEvent.setClassName("foo.bar.baz.Class");
-        sentEvent.setContentDescription("ContentDescription");
-        sentEvent.setCurrentItemIndex(1);
-        sentEvent.setEnabled(true);
-        sentEvent.setEventType(AccessibilityEvent.TYPE_ANNOUNCEMENT);
-        sentEvent.setEventTime(1000);
-        sentEvent.setFromIndex(1);
-        sentEvent.setFullScreen(true);
-        sentEvent.setItemCount(1);
-        sentEvent.setPackageName("foo.bar.baz");
-        sentEvent.setParcelableData(Message.obtain(null, 1, null));
-        sentEvent.setPassword(true);
-        sentEvent.setRemovedCount(1);
-    }
-
-    /**
-     * This class is a mock {@link IAccessibilityManagerClient}.
-     */
-    public class MyMockAccessibilityManagerClient extends IAccessibilityManagerClient.Stub {
-        int mState;
-
-        public void setState(int state) {
-            mState = state;
-        }
-
-        public void setTouchExplorationEnabled(boolean enabled) {
-        }
-    }
-
-    /**
-     * Ensures accessibility is in a given state by writing the state to the
-     * settings and waiting until the accessibility manager service pick it up.
-     *
-     * @param context A context handle to access the settings.
-     * @param enabled The accessibility state to write to the settings.
-     * @throws Exception If any error occurs.
-     */
-    private void ensureAccessibilityEnabled(Context context, boolean enabled) throws Exception {
-        boolean isEnabled = Settings.Secure.getInt(context.getContentResolver(),
-                Settings.Secure.ACCESSIBILITY_ENABLED, 0) == 1;
-
-        if (isEnabled == enabled) {
-            return;
-        }
-
-        Settings.Secure.putInt(context.getContentResolver(), Settings.Secure.ACCESSIBILITY_ENABLED,
-                enabled ? 1 : 0);
-
-        // wait the accessibility manager service to pick the change up
-        Thread.sleep(TIMEOUT_BINDER_CALL);
-    }
-
-    /**
-     * Ensures the only {@link MockAccessibilityService}s with given component
-     * names are enabled by writing to the system settings and waiting until the
-     * accessibility manager service picks that up or the
-     * {@link #TIMEOUT_START_MOCK_ACCESSIBILITY_SERVICES} is exceeded.
-     *
-     * @param context A context handle to access the settings.
-     * @param firstMockServiceEnabled If the first mock accessibility service is enabled.
-     * @param secondMockServiceEnabled If the second mock accessibility service is enabled.
-     * @throws IllegalStateException If some of the requested for enabling mock services
-     *         is not properly started.
-     * @throws Exception Exception If any error occurs.
-     */
-    private void ensureOnlyMockServicesEnabled(Context context, boolean firstMockServiceEnabled,
-            boolean secondMockServiceEnabled) throws Exception {
-        String enabledServices = Settings.Secure.getString(context.getContentResolver(),
-                Settings.Secure.ENABLED_ACCESSIBILITY_SERVICES);
-
-        StringBuilder servicesToEnable = new StringBuilder();
-        if (firstMockServiceEnabled) {
-            servicesToEnable.append(MyFirstMockAccessibilityService.sComponentName).append(":");
-        }
-        if (secondMockServiceEnabled) {
-            servicesToEnable.append(MySecondMockAccessibilityService.sComponentName).append(":");
-        }
-
-        Settings.Secure.putString(context.getContentResolver(),
-                Settings.Secure.ENABLED_ACCESSIBILITY_SERVICES, servicesToEnable.toString());
-
-        // Optimization. If things will not change, we don't have to do anything.
-        if (servicesToEnable.equals(enabledServices)) {
-            return;
-        }
-
-        // we have enabled the services of interest and need to wait until they
-        // are instantiated and started (if needed) and the system binds to them
-        boolean firstMockServiceOK = false;
-        boolean secondMockServiceOK = false;
-        long start = SystemClock.uptimeMillis();
-        long pollingInterval = TIMEOUT_START_MOCK_ACCESSIBILITY_SERVICES / 6;
-
-        while (SystemClock.uptimeMillis() - start < TIMEOUT_START_MOCK_ACCESSIBILITY_SERVICES)  {
-            firstMockServiceOK = !firstMockServiceEnabled
-                    || (MyFirstMockAccessibilityService.sInstance != null
-                    && MyFirstMockAccessibilityService.sInstance.isSystemBoundAsClient());
-
-            secondMockServiceOK = !secondMockServiceEnabled
-                    || (MySecondMockAccessibilityService.sInstance != null
-                    && MySecondMockAccessibilityService.sInstance.isSystemBoundAsClient());
-
-            if (firstMockServiceOK && secondMockServiceOK) {
-                return;
-            }
-
-            Thread.sleep(pollingInterval);
-        }
-
-        StringBuilder message = new StringBuilder();
-        message.append("Mock accessibility services not started or system not bound as a client: ");
-        if (!firstMockServiceOK) {
-            message.append(MyFirstMockAccessibilityService.sComponentName);
-            message.append(" ");
-        }
-        if (!secondMockServiceOK) {
-            message.append(MySecondMockAccessibilityService.sComponentName);
-        }
-        throw new IllegalStateException(message.toString());
-    }
-
-    /**
-     * Asserts the the mock accessibility service has been successfully verified
-     * (which is it has received the expected method calls with expected
-     * arguments) within the {@link #TIMEOUT_BINDER_CALL}. The verified state is
-     * checked by polling upon small intervals.
-     *
-     * @param service The service to verify.
-     * @throws Exception If the verification has failed with exception after the
-     *             {@link #TIMEOUT_BINDER_CALL}.
-     */
-    private void assertMockServiceVerifiedWithinTimeout(MockAccessibilityService service)
-            throws Exception {
-        Exception lastVerifyException = null;
-        long beginTime = SystemClock.uptimeMillis();
-        long pollTimeout = TIMEOUT_BINDER_CALL / 5;
-
-        // poll until the timeout has elapsed
-        while (SystemClock.uptimeMillis() - beginTime < TIMEOUT_BINDER_CALL) {
-            // sleep first since immediate call will always fail
-            try {
-                Thread.sleep(pollTimeout);
-            } catch (InterruptedException ie) {
-                /* ignore */
-            }
-            // poll for verification and if this fails save the exception and
-            // keep polling
-            try {
-                service.verify();
-                // reset so it does not accept more events
-                service.reset();
-                return;
-            } catch (Exception e) {
-                lastVerifyException = e;
-            }
-        }
-
-        // reset, we have already failed
-        service.reset();
-
-        // always not null
-        throw lastVerifyException;
-    }
-
-    /**
-     * This class is the first mock {@link AccessibilityService}.
-     */
-    public static class MyFirstMockAccessibilityService extends MockAccessibilityService {
-
-        /**
-         * The service {@link ComponentName} flattened as a string.
-         */
-        static String sComponentName;
-
-        /**
-         * Handle to the service instance.
-         */
-        static MyFirstMockAccessibilityService sInstance;
-
-        /**
-         * Creates a new instance.
-         */
-        public MyFirstMockAccessibilityService() {
-            sInstance = this;
-        }
-    }
-
-    /**
-     * This class is the first mock {@link AccessibilityService}.
-     */
-    public static class MySecondMockAccessibilityService extends MockAccessibilityService {
-
-        /**
-         * The service {@link ComponentName} flattened as a string.
-         */
-        static String sComponentName;
-
-        /**
-         * Handle to the service instance.
-         */
-        static MySecondMockAccessibilityService sInstance;
-
-        /**
-         * Creates a new instance.
-         */
-        public MySecondMockAccessibilityService() {
-            sInstance = this;
-        }
-    }
-}
diff --git a/services/tests/servicestests/src/com/android/server/AccessibilityManagerTest.java b/services/tests/servicestests/src/com/android/server/AccessibilityManagerTest.java
deleted file mode 100644
index 026a2adc1f9..00000000000
--- a/services/tests/servicestests/src/com/android/server/AccessibilityManagerTest.java
+++ /dev/null
@@ -1,162 +0,0 @@
-/*
- * Copyright (C) 2010 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.android.server;
-
-import static org.mockito.Matchers.any;
-import static org.mockito.Matchers.anyInt;
-import static org.mockito.Matchers.eq;
-import static org.mockito.Mockito.verify;
-import static org.mockito.Mockito.when;
-
-import android.accessibilityservice.AccessibilityServiceInfo;
-import android.os.UserHandle;
-import android.test.AndroidTestCase;
-import android.test.suitebuilder.annotation.LargeTest;
-import android.test.suitebuilder.annotation.MediumTest;
-import android.view.accessibility.AccessibilityEvent;
-import android.view.accessibility.AccessibilityManager;
-import android.view.accessibility.IAccessibilityManager;
-import android.view.accessibility.IAccessibilityManagerClient;
-
-import org.mockito.Mock;
-import org.mockito.MockitoAnnotations;
-
-import java.util.ArrayList;
-import java.util.List;
-
-/**
- * Tests for the AccessibilityManager which mocking the backing service.
- */
-public class AccessibilityManagerTest extends AndroidTestCase {
-
-    /**
-     * Timeout required for pending Binder calls or event processing to
-     * complete.
-     */
-    public static final long TIMEOUT_BINDER_CALL = 50;
-
-    @Mock
-    private IAccessibilityManager mMockService;
-
-    @Override
-    public void setUp() throws Exception {
-        MockitoAnnotations.initMocks(this);
-    }
-
-    private AccessibilityManager createManager(boolean enabled) throws Exception {
-        if (enabled) {
-            when(mMockService.addClient(any(IAccessibilityManagerClient.class), anyInt()))
-                    .thenReturn(AccessibilityManager.STATE_FLAG_ACCESSIBILITY_ENABLED);
-        } else {
-            when(mMockService.addClient(any(IAccessibilityManagerClient.class), anyInt()))
-                    .thenReturn(0);
-        }
-
-        AccessibilityManager manager =
-                new AccessibilityManager(mContext, mMockService, UserHandle.USER_CURRENT);
-
-        verify(mMockService).addClient(any(IAccessibilityManagerClient.class), anyInt());
-
-        return manager;
-    }
-
-    @MediumTest
-    public void testGetAccessibilityServiceList() throws Exception {
-        // create a list of installed accessibility services the mock service returns
-        List<AccessibilityServiceInfo> expectedServices = new ArrayList<>();
-        AccessibilityServiceInfo accessibilityServiceInfo = new AccessibilityServiceInfo();
-        accessibilityServiceInfo.packageNames = new String[] { "foo.bar" };
-        expectedServices.add(accessibilityServiceInfo);
-
-        // configure the mock service behavior
-        when(mMockService.getInstalledAccessibilityServiceList(anyInt()))
-                .thenReturn(expectedServices);
-
-        // invoke the method under test
-        AccessibilityManager manager = createManager(true);
-        List<AccessibilityServiceInfo> receivedServices =
-                manager.getInstalledAccessibilityServiceList();
-
-        verify(mMockService).getInstalledAccessibilityServiceList(UserHandle.USER_CURRENT);
-        // check expected result (list equals() compares it contents as well)
-        assertEquals("All expected services must be returned", expectedServices, receivedServices);
-    }
-
-    @MediumTest
-    public void testInterrupt() throws Exception {
-        AccessibilityManager manager = createManager(true);
-        manager.interrupt();
-
-        verify(mMockService).interrupt(UserHandle.USER_CURRENT);
-    }
-
-    @LargeTest
-    public void testIsEnabled() throws Exception {
-        // invoke the method under test
-        AccessibilityManager manager = createManager(true);
-        boolean isEnabledServiceEnabled = manager.isEnabled();
-
-        // check expected result
-        assertTrue("Must be enabled since the mock service is enabled", isEnabledServiceEnabled);
-
-        // disable accessibility
-        manager.getClient().setState(0);
-
-        // wait for the asynchronous IBinder call to complete
-        Thread.sleep(TIMEOUT_BINDER_CALL);
-
-        // invoke the method under test
-        boolean isEnabledServcieDisabled = manager.isEnabled();
-
-        // check expected result
-        assertFalse("Must be disabled since the mock service is disabled",
-                isEnabledServcieDisabled);
-    }
-
-    @MediumTest
-    public void testSendAccessibilityEvent_AccessibilityEnabled() throws Exception {
-        AccessibilityEvent sentEvent = AccessibilityEvent.obtain();
-
-        when(mMockService.sendAccessibilityEvent(eq(sentEvent), anyInt()))
-                .thenReturn(true  /* should recycle event object */)
-                .thenReturn(false /* should not recycle event object */);
-
-        AccessibilityManager manager = createManager(true);
-        manager.sendAccessibilityEvent(sentEvent);
-
-        assertSame("The event should be recycled.", sentEvent, AccessibilityEvent.obtain());
-
-        manager.sendAccessibilityEvent(sentEvent);
-
-        assertNotSame("The event should not be recycled.", sentEvent, AccessibilityEvent.obtain());
-    }
-
-    @MediumTest
-    public void testSendAccessibilityEvent_AccessibilityDisabled() throws Exception {
-        AccessibilityEvent sentEvent = AccessibilityEvent.obtain();
-
-        AccessibilityManager manager = createManager(false  /* disabled */);
-
-        try {
-            manager.sendAccessibilityEvent(sentEvent);
-            fail("No accessibility events are sent if accessibility is disabled");
-        } catch (IllegalStateException ise) {
-            // check expected result
-            assertEquals("Accessibility off. Did you forget to check that?", ise.getMessage());
-        }
-    }
-}
diff --git a/services/tests/servicestests/src/com/android/server/BroadcastInterceptingContext.java b/services/tests/servicestests/src/com/android/server/BroadcastInterceptingContext.java
deleted file mode 100644
index 13657ab7f02..00000000000
--- a/services/tests/servicestests/src/com/android/server/BroadcastInterceptingContext.java
+++ /dev/null
@@ -1,177 +0,0 @@
-/*
- * Copyright (C) 2011 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.android.server;
-
-import android.content.BroadcastReceiver;
-import android.content.Context;
-import android.content.ContextWrapper;
-import android.content.Intent;
-import android.content.IntentFilter;
-import android.os.Bundle;
-import android.os.Handler;
-import android.os.UserHandle;
-
-import com.google.common.collect.Lists;
-import com.google.common.util.concurrent.AbstractFuture;
-
-import java.util.Iterator;
-import java.util.List;
-import java.util.concurrent.ExecutionException;
-import java.util.concurrent.Future;
-import java.util.concurrent.TimeUnit;
-import java.util.concurrent.TimeoutException;
-
-/**
- * {@link ContextWrapper} that can attach listeners for upcoming
- * {@link Context#sendBroadcast(Intent)}.
- */
-public class BroadcastInterceptingContext extends ContextWrapper {
-    private static final String TAG = "WatchingContext";
-
-    private final List<BroadcastInterceptor> mInterceptors = Lists.newArrayList();
-
-    public class BroadcastInterceptor extends AbstractFuture<Intent> {
-        private final BroadcastReceiver mReceiver;
-        private final IntentFilter mFilter;
-
-        public BroadcastInterceptor(BroadcastReceiver receiver, IntentFilter filter) {
-            mReceiver = receiver;
-            mFilter = filter;
-        }
-
-        public boolean dispatchBroadcast(Intent intent) {
-            if (mFilter.match(getContentResolver(), intent, false, TAG) > 0) {
-                if (mReceiver != null) {
-                    final Context context = BroadcastInterceptingContext.this;
-                    mReceiver.onReceive(context, intent);
-                    return false;
-                } else {
-                    set(intent);
-                    return true;
-                }
-            } else {
-                return false;
-            }
-        }
-
-        @Override
-        public Intent get() throws InterruptedException, ExecutionException {
-            try {
-                return get(5, TimeUnit.SECONDS);
-            } catch (TimeoutException e) {
-                throw new RuntimeException(e);
-            }
-        }
-    }
-
-    public BroadcastInterceptingContext(Context base) {
-        super(base);
-    }
-
-    public Future<Intent> nextBroadcastIntent(String action) {
-        return nextBroadcastIntent(new IntentFilter(action));
-    }
-
-    public Future<Intent> nextBroadcastIntent(IntentFilter filter) {
-        final BroadcastInterceptor interceptor = new BroadcastInterceptor(null, filter);
-        synchronized (mInterceptors) {
-            mInterceptors.add(interceptor);
-        }
-        return interceptor;
-    }
-
-    @Override
-    public Intent registerReceiver(BroadcastReceiver receiver, IntentFilter filter) {
-        synchronized (mInterceptors) {
-            mInterceptors.add(new BroadcastInterceptor(receiver, filter));
-        }
-        return null;
-    }
-
-    @Override
-    public Intent registerReceiver(BroadcastReceiver receiver, IntentFilter filter,
-            String broadcastPermission, Handler scheduler) {
-        return registerReceiver(receiver, filter);
-    }
-
-    @Override
-    public void unregisterReceiver(BroadcastReceiver receiver) {
-        synchronized (mInterceptors) {
-            final Iterator<BroadcastInterceptor> i = mInterceptors.iterator();
-            while (i.hasNext()) {
-                final BroadcastInterceptor interceptor = i.next();
-                if (receiver.equals(interceptor.mReceiver)) {
-                    i.remove();
-                }
-            }
-        }
-    }
-
-    @Override
-    public void sendBroadcast(Intent intent) {
-        synchronized (mInterceptors) {
-            final Iterator<BroadcastInterceptor> i = mInterceptors.iterator();
-            while (i.hasNext()) {
-                final BroadcastInterceptor interceptor = i.next();
-                if (interceptor.dispatchBroadcast(intent)) {
-                    i.remove();
-                }
-            }
-        }
-    }
-
-    @Override
-    public void sendBroadcast(Intent intent, String receiverPermission) {
-        sendBroadcast(intent);
-    }
-
-    @Override
-    public void sendBroadcastMultiplePermissions(Intent intent, String[] receiverPermissions) {
-        sendBroadcast(intent);
-    }
-
-    @Override
-    public void sendBroadcastAsUser(Intent intent, UserHandle user) {
-        sendBroadcast(intent);
-    }
-
-    @Override
-    public void sendBroadcastAsUser(Intent intent, UserHandle user,
-            String receiverPermission) {
-        sendBroadcast(intent);
-    }
-
-    @Override
-    public void sendStickyBroadcast(Intent intent) {
-        sendBroadcast(intent);
-    }
-
-    @Override
-    public void sendStickyBroadcastAsUser(Intent intent, UserHandle user) {
-        sendBroadcast(intent);
-    }
-
-    @Override
-    public void sendStickyBroadcastAsUser(Intent intent, UserHandle user, Bundle options) {
-        sendBroadcast(intent);
-    }
-
-    @Override
-    public void removeStickyBroadcast(Intent intent) {
-        // ignored
-    }
-}
diff --git a/services/tests/servicestests/src/com/android/server/CertBlacklisterTest.java b/services/tests/servicestests/src/com/android/server/CertBlacklisterTest.java
deleted file mode 100644
index 10b9e7cf121..00000000000
--- a/services/tests/servicestests/src/com/android/server/CertBlacklisterTest.java
+++ /dev/null
@@ -1,169 +0,0 @@
-/*
- * Copyright (C) 2012 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.android.server;
-
-import android.content.Context;
-import android.content.Intent;
-import android.test.AndroidTestCase;
-import android.provider.Settings;
-import android.util.Log;
-
-import java.io.File;
-import java.io.FileInputStream;
-import java.io.IOException;
-import java.util.HashSet;
-
-import libcore.io.IoUtils;
-
-/**
- * Tests for {@link com.android.server.CertBlacklister}
- */
-public class CertBlacklisterTest extends AndroidTestCase {
-
-    private static final String BLACKLIST_ROOT = System.getenv("ANDROID_DATA") + "/misc/keychain/";
-
-    public static final String PUBKEY_PATH = BLACKLIST_ROOT + "pubkey_blacklist.txt";
-    public static final String SERIAL_PATH = BLACKLIST_ROOT + "serial_blacklist.txt";
-
-    public static final String PUBKEY_KEY = "pubkey_blacklist";
-    public static final String SERIAL_KEY = "serial_blacklist";
-
-    private void overrideSettings(String key, String value) throws Exception {
-        Settings.Secure.putString(mContext.getContentResolver(), key, value);
-        Thread.sleep(1000);
-    }
-
-    public void testClearBlacklistPubkey() throws Exception {
-        // clear the gservices setting for a clean slate
-        overrideSettings(PUBKEY_KEY, "");
-        // read the contents of the pubkey blacklist
-        String blacklist = IoUtils.readFileAsString(PUBKEY_PATH);
-        // Verify that it's empty
-        assertEquals("", blacklist);
-    }
-
-    public void testSetBlacklistPubkey() throws Exception {
-        // build a new thing to blacklist
-        String badPubkey = "7ccabd7db47e94a5759901b6a7dfd45d1c091ccc";
-        // add the gservices override
-        overrideSettings(PUBKEY_KEY, badPubkey);
-        // check the contents again
-        String blacklist = IoUtils.readFileAsString(PUBKEY_PATH);
-        // make sure that we're equal to the string we sent out
-        assertEquals(badPubkey, blacklist);
-    }
-
-    public void testChangeBlacklistPubkey() throws Exception {
-        String badPubkey = "6ccabd7db47e94a5759901b6a7dfd45d1c091ccc";
-        overrideSettings(PUBKEY_KEY, badPubkey);
-        badPubkey = "6ccabd7db47e94a5759901b6a7dfd45d1c091cce";
-        overrideSettings(PUBKEY_KEY, badPubkey);
-        String blacklist = IoUtils.readFileAsString(PUBKEY_PATH);
-        assertEquals(badPubkey, blacklist);
-    }
-
-    public void testMultiBlacklistPubkey() throws Exception {
-        String badPubkey = "6ccabd7db47e94a5759901b6a7dfd45d1c091ccc,6ccabd7db47e94a5759901b6a7dfd45d1c091ccd";
-        overrideSettings(PUBKEY_KEY, badPubkey);
-        String blacklist = IoUtils.readFileAsString(PUBKEY_PATH);
-        assertEquals(badPubkey, blacklist);
-    }
-
-    public void testInvalidMultiBlacklistPubkey() throws Exception {
-        String badPubkey = "6ccabd7db47e94a5759901b6a7dfd45d1c091ccc,ZZZZZ,6ccabd7db47e94a5759901b6a7dfd45d1c091ccd";
-        overrideSettings(PUBKEY_KEY, badPubkey);
-        String blacklist = IoUtils.readFileAsString(PUBKEY_PATH);
-        assertEquals(badPubkey, blacklist);
-    }
-
-    public void testInvalidCharsBlacklistPubkey() throws Exception {
-        String badPubkey = "\n6ccabd7db47e94a5759901b6a7dfd45d1c091ccc,-ZZZZZ,+6ccabd7db47e94a5759901b6a7dfd45d1c091ccd";
-        overrideSettings(PUBKEY_KEY, badPubkey);
-        String blacklist = IoUtils.readFileAsString(PUBKEY_PATH);
-        assertEquals(badPubkey, blacklist);
-    }
-
-    public void testLotsOfBlacklistedPubkeys() throws Exception {
-        StringBuilder bl = new StringBuilder();
-        for (int i=0; i < 1000; i++) {
-            bl.append("6ccabd7db47e94a5759901b6a7dfd45d1c091ccc,");
-        }
-        overrideSettings(PUBKEY_KEY, bl.toString());
-        String blacklist = IoUtils.readFileAsString(PUBKEY_PATH);
-        assertEquals(bl.toString(), blacklist);
-    }
-
-    public void testClearBlacklistSerial() throws Exception {
-        // clear the gservices setting for a clean slate
-        overrideSettings(SERIAL_KEY, "");
-        // read the contents of the pubkey blacklist
-        String blacklist = IoUtils.readFileAsString(SERIAL_PATH);
-        // Verify that it's empty
-        assertEquals("", blacklist);
-    }
-
-    public void testSetBlacklistSerial() throws Exception {
-        // build a new thing to blacklist
-        String badSerial = "22e514121e61c643b1e9b06bd4b9f7d0";
-        // add the gservices override
-        overrideSettings(SERIAL_KEY, badSerial);
-        // check the contents again
-        String blacklist = IoUtils.readFileAsString(SERIAL_PATH);
-        // make sure that we're equal to the string we sent out
-        assertEquals(badSerial, blacklist);
-    }
-
-    public void testChangeBlacklistSerial() throws Exception {
-        String badSerial = "22e514121e61c643b1e9b06bd4b9f7d0";
-        overrideSettings(SERIAL_KEY, badSerial);
-        badSerial = "22e514121e61c643b1e9b06bd4b9f7d1";
-        overrideSettings(SERIAL_KEY, badSerial);
-        String blacklist = IoUtils.readFileAsString(SERIAL_PATH);
-        assertEquals(badSerial, blacklist);
-    }
-
-    public void testMultiBlacklistSerial() throws Exception {
-        String badSerial = "22e514121e61c643b1e9b06bd4b9f7d0,22e514121e61c643b1e9b06bd4b9f7d1";
-        overrideSettings(SERIAL_KEY, badSerial);
-        String blacklist = IoUtils.readFileAsString(SERIAL_PATH);
-        assertEquals(badSerial, blacklist);
-    }
-
-    public void testInvalidMultiBlacklistSerial() throws Exception {
-        String badSerial = "22e514121e61c643b1e9b06bd4b9f7d0,ZZZZ,22e514121e61c643b1e9b06bd4b9f7d1";
-        overrideSettings(SERIAL_KEY, badSerial);
-        String blacklist = IoUtils.readFileAsString(SERIAL_PATH);
-        assertEquals(badSerial, blacklist);
-    }
-
-    public void testInvalidCharsBlacklistSerial() throws Exception {
-        String badSerial = "\n22e514121e61c643b1e9b06bd4b9f7d0,-ZZZZ,+22e514121e61c643b1e9b06bd4b9f7d1";
-        overrideSettings(SERIAL_KEY, badSerial);
-        String blacklist = IoUtils.readFileAsString(SERIAL_PATH);
-        assertEquals(badSerial, blacklist);
-    }
-
-    public void testLotsOfBlacklistedSerials() throws Exception {
-        StringBuilder bl = new StringBuilder();
-        for (int i=0; i < 1000; i++) {
-            bl.append("22e514121e61c643b1e9b06bd4b9f7d0,");
-        }
-        overrideSettings(SERIAL_KEY, bl.toString());
-        String blacklist = IoUtils.readFileAsString(SERIAL_PATH);
-        assertEquals(bl.toString(), blacklist);
-    }
-}
diff --git a/services/tests/servicestests/src/com/android/server/ConnectivityServiceTest.java b/services/tests/servicestests/src/com/android/server/ConnectivityServiceTest.java
index 65f9399c5a8..012bdd87b98 100644
--- a/services/tests/servicestests/src/com/android/server/ConnectivityServiceTest.java
+++ b/services/tests/servicestests/src/com/android/server/ConnectivityServiceTest.java
@@ -620,6 +620,19 @@ public class ConnectivityServiceTest extends AndroidTestCase {
         }
     }
 
+    private class WrappedAvoidBadWifiTracker extends AvoidBadWifiTracker {
+        public boolean configRestrictsAvoidBadWifi;
+
+        public WrappedAvoidBadWifiTracker(Context c, Handler h, Runnable r) {
+            super(c, h, r);
+        }
+
+        @Override
+        public boolean configRestrictsAvoidBadWifi() {
+            return configRestrictsAvoidBadWifi;
+        }
+    }
+
     private class WrappedConnectivityService extends ConnectivityService {
         public WrappedAvoidBadWifiTracker wrappedAvoidBadWifiTracker;
         private WrappedNetworkMonitor mLastCreatedNetworkMonitor;
diff --git a/services/tests/servicestests/src/com/android/server/CountryDetectorServiceTest.java b/services/tests/servicestests/src/com/android/server/CountryDetectorServiceTest.java
deleted file mode 100644
index 192c50c7dc1..00000000000
--- a/services/tests/servicestests/src/com/android/server/CountryDetectorServiceTest.java
+++ /dev/null
@@ -1,109 +0,0 @@
-/*
- * Copyright (C) 2010 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License
- */
-
-package com.android.server;
-
-import android.content.Context;
-import android.location.Country;
-import android.location.CountryListener;
-import android.location.ICountryListener;
-import android.os.RemoteException;
-import android.test.AndroidTestCase;
-
-public class CountryDetectorServiceTest extends AndroidTestCase {
-    private class CountryListenerTester extends ICountryListener.Stub {
-        private Country mCountry;
-
-        @Override
-        public void onCountryDetected(Country country) throws RemoteException {
-            mCountry = country;
-        }
-
-        public Country getCountry() {
-            return mCountry;
-        }
-
-        public boolean isNotified() {
-            return mCountry != null;
-        }
-    }
-
-    private class CountryDetectorServiceTester extends CountryDetectorService {
-
-        private CountryListener mListener;
-
-        public CountryDetectorServiceTester(Context context) {
-            super(context);
-        }
-
-        @Override
-        public void notifyReceivers(Country country) {
-            super.notifyReceivers(country);
-        }
-
-        @Override
-        protected void setCountryListener(final CountryListener listener) {
-            mListener = listener;
-        }
-
-        public boolean isListenerSet() {
-            return mListener != null;
-        }
-    }
-
-    public void testAddRemoveListener() throws RemoteException {
-        CountryDetectorServiceTester serviceTester = new CountryDetectorServiceTester(getContext());
-        serviceTester.systemRunning();
-        waitForSystemReady(serviceTester);
-        CountryListenerTester listenerTester = new CountryListenerTester();
-        serviceTester.addCountryListener(listenerTester);
-        assertTrue(serviceTester.isListenerSet());
-        serviceTester.removeCountryListener(listenerTester);
-        assertFalse(serviceTester.isListenerSet());
-    }
-
-    public void testNotifyListeners() throws RemoteException {
-        CountryDetectorServiceTester serviceTester = new CountryDetectorServiceTester(getContext());
-        CountryListenerTester listenerTesterA = new CountryListenerTester();
-        CountryListenerTester listenerTesterB = new CountryListenerTester();
-        Country country = new Country("US", Country.COUNTRY_SOURCE_NETWORK);
-        serviceTester.systemRunning();
-        waitForSystemReady(serviceTester);
-        serviceTester.addCountryListener(listenerTesterA);
-        serviceTester.addCountryListener(listenerTesterB);
-        serviceTester.notifyReceivers(country);
-        assertTrue(serviceTester.isListenerSet());
-        assertTrue(listenerTesterA.isNotified());
-        assertTrue(listenerTesterB.isNotified());
-        serviceTester.removeCountryListener(listenerTesterA);
-        serviceTester.removeCountryListener(listenerTesterB);
-        assertFalse(serviceTester.isListenerSet());
-    }
-
-    private void waitForSystemReady(CountryDetectorService service) {
-        int count = 5;
-        while (count-- > 0) {
-            try {
-                Thread.sleep(500);
-            } catch (Exception e) {
-            }
-            if (service.isSystemReady()) {
-                return;
-            }
-        }
-        throw new RuntimeException("Wait System Ready timeout");
-    }
-}
diff --git a/services/tests/servicestests/src/com/android/server/DropBoxTest.java b/services/tests/servicestests/src/com/android/server/DropBoxTest.java
deleted file mode 100644
index 7f28d442c77..00000000000
--- a/services/tests/servicestests/src/com/android/server/DropBoxTest.java
+++ /dev/null
@@ -1,775 +0,0 @@
-/*
- * Copyright (C) 2009 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.android.server;
-
-import android.content.ContentResolver;
-import android.content.Context;
-import android.content.Intent;
-import android.os.DropBoxManager;
-import android.os.Parcel;
-import android.os.Parcelable;
-import android.os.ParcelFileDescriptor;
-import android.os.Process;
-import android.os.ServiceManager;
-import android.os.StatFs;
-import android.provider.Settings;
-import android.test.AndroidTestCase;
-
-import com.android.server.DropBoxManagerService;
-
-import java.io.BufferedReader;
-import java.io.File;
-import java.io.FileOutputStream;
-import java.io.FileWriter;
-import java.io.IOException;
-import java.io.InputStream;
-import java.io.InputStreamReader;
-import java.util.Random;
-import java.util.zip.GZIPOutputStream;
-
-/** Test {@link DropBoxManager} functionality. */
-public class DropBoxTest extends AndroidTestCase {
-    public void tearDown() throws Exception {
-        ContentResolver cr = getContext().getContentResolver();
-        Settings.Global.putString(cr, Settings.Global.DROPBOX_AGE_SECONDS, "");
-        Settings.Global.putString(cr, Settings.Global.DROPBOX_MAX_FILES, "");
-        Settings.Global.putString(cr, Settings.Global.DROPBOX_QUOTA_KB, "");
-        Settings.Global.putString(cr, Settings.Global.DROPBOX_TAG_PREFIX + "DropBoxTest", "");
-    }
-
-    public void testAddText() throws Exception {
-        File dir = getEmptyDir("testAddText");
-        DropBoxManagerService service = new DropBoxManagerService(getContext(), dir);
-        DropBoxManager dropbox = new DropBoxManager(getContext(), service.getServiceStub());
-
-        long before = System.currentTimeMillis();
-        Thread.sleep(5);
-        dropbox.addText("DropBoxTest", "TEST0");
-        Thread.sleep(5);
-        long between = System.currentTimeMillis();
-        Thread.sleep(5);
-        dropbox.addText("DropBoxTest", "TEST1");
-        dropbox.addText("DropBoxTest", "TEST2");
-        Thread.sleep(5);
-        long after = System.currentTimeMillis();
-
-        DropBoxManager.Entry e0 = dropbox.getNextEntry("DropBoxTest", before);
-        DropBoxManager.Entry e1 = dropbox.getNextEntry("DropBoxTest", e0.getTimeMillis());
-        DropBoxManager.Entry e2 = dropbox.getNextEntry("DropBoxTest", e1.getTimeMillis());
-        assertTrue(null == dropbox.getNextEntry("DropBoxTest", e2.getTimeMillis()));
-
-        assertTrue(e0.getTimeMillis() > before);
-        assertTrue(e0.getTimeMillis() < between);
-        assertTrue(e1.getTimeMillis() > between);
-        assertTrue(e1.getTimeMillis() < e2.getTimeMillis());
-        assertTrue(e2.getTimeMillis() < after);
-
-        assertEquals("TEST0", e0.getText(80));
-        assertEquals("TEST1", e1.getText(80));
-        assertEquals("TES", e2.getText(3));
-
-        e0.close();
-        e1.close();
-        e2.close();
-    }
-
-    public void testAddData() throws Exception {
-        File dir = getEmptyDir("testAddData");
-        DropBoxManagerService service = new DropBoxManagerService(getContext(), dir);
-        DropBoxManager dropbox = new DropBoxManager(getContext(), service.getServiceStub());
-
-        long before = System.currentTimeMillis();
-        dropbox.addData("DropBoxTest", "TEST".getBytes(), 0);
-        long after = System.currentTimeMillis();
-
-        DropBoxManager.Entry e = dropbox.getNextEntry("DropBoxTest", before);
-        assertTrue(null == dropbox.getNextEntry("DropBoxTest", e.getTimeMillis()));
-
-        assertEquals("DropBoxTest", e.getTag());
-        assertTrue(e.getTimeMillis() >= before);
-        assertEquals(0, e.getFlags());
-        assertTrue(null == e.getText(80));
-
-        byte[] buf = new byte[80];
-        assertEquals("TEST", new String(buf, 0, e.getInputStream().read(buf)));
-
-        e.close();
-    }
-
-    public void testAddFile() throws Exception {
-        File dir = getEmptyDir("testAddFile");
-        long before = System.currentTimeMillis();
-
-        File f0 = new File(dir, "f0.txt");
-        File f1 = new File(dir, "f1.txt.gz");
-        File f2 = new File(dir, "f2.dat");
-        File f3 = new File(dir, "f2.dat.gz");
-
-        FileWriter w0 = new FileWriter(f0);
-        GZIPOutputStream gz1 = new GZIPOutputStream(new FileOutputStream(f1));
-        FileOutputStream os2 = new FileOutputStream(f2);
-        GZIPOutputStream gz3 = new GZIPOutputStream(new FileOutputStream(f3));
-
-        w0.write("FILE0");
-        gz1.write("FILE1".getBytes());
-        os2.write("DATA2".getBytes());
-        gz3.write("DATA3".getBytes());
-
-        w0.close();
-        gz1.close();
-        os2.close();
-        gz3.close();
-
-        DropBoxManagerService service = new DropBoxManagerService(getContext(), dir);
-        DropBoxManager dropbox = new DropBoxManager(getContext(), service.getServiceStub());
-
-        dropbox.addFile("DropBoxTest", f0, DropBoxManager.IS_TEXT);
-        dropbox.addFile("DropBoxTest", f1, DropBoxManager.IS_TEXT | DropBoxManager.IS_GZIPPED);
-        dropbox.addFile("DropBoxTest", f2, 0);
-        dropbox.addFile("DropBoxTest", f3, DropBoxManager.IS_GZIPPED);
-
-        DropBoxManager.Entry e0 = dropbox.getNextEntry("DropBoxTest", before);
-        DropBoxManager.Entry e1 = dropbox.getNextEntry("DropBoxTest", e0.getTimeMillis());
-        DropBoxManager.Entry e2 = dropbox.getNextEntry("DropBoxTest", e1.getTimeMillis());
-        DropBoxManager.Entry e3 = dropbox.getNextEntry("DropBoxTest", e2.getTimeMillis());
-        assertTrue(null == dropbox.getNextEntry("DropBoxTest", e3.getTimeMillis()));
-
-        assertTrue(e0.getTimeMillis() > before);
-        assertTrue(e1.getTimeMillis() > e0.getTimeMillis());
-        assertTrue(e2.getTimeMillis() > e1.getTimeMillis());
-        assertTrue(e3.getTimeMillis() > e2.getTimeMillis());
-
-        assertEquals(DropBoxManager.IS_TEXT, e0.getFlags());
-        assertEquals(DropBoxManager.IS_TEXT, e1.getFlags());
-        assertEquals(0, e2.getFlags());
-        assertEquals(0, e3.getFlags());
-
-        assertEquals("FILE0", e0.getText(80));
-
-        byte[] buf1 = new byte[80];
-        assertEquals("FILE1", new String(buf1, 0, e1.getInputStream().read(buf1)));
-
-        assertTrue(null == e2.getText(80));
-        byte[] buf2 = new byte[80];
-        assertEquals("DATA2", new String(buf2, 0, e2.getInputStream().read(buf2)));
-
-        assertTrue(null == e3.getText(80));
-        byte[] buf3 = new byte[80];
-        assertEquals("DATA3", new String(buf3, 0, e3.getInputStream().read(buf3)));
-
-        e0.close();
-        e1.close();
-        e2.close();
-        e3.close();
-    }
-
-    public void testAddEntriesInTheFuture() throws Exception {
-        File dir = getEmptyDir("testAddEntriesInTheFuture");
-        long before = System.currentTimeMillis();
-
-        // Near future: should be allowed to persist
-        FileWriter w0 = new FileWriter(new File(dir, "DropBoxTest@" + (before + 5000) + ".txt"));
-        w0.write("FUTURE0");
-        w0.close();
-
-        // Far future: should be collapsed
-        FileWriter w1 = new FileWriter(new File(dir, "DropBoxTest@" + (before + 100000) + ".txt"));
-        w1.write("FUTURE1");
-        w1.close();
-
-        // Another far future item, this one gzipped
-        File f2 = new File(dir, "DropBoxTest@" + (before + 100001) + ".txt.gz");
-        GZIPOutputStream gz2 = new GZIPOutputStream(new FileOutputStream(f2));
-        gz2.write("FUTURE2".getBytes());
-        gz2.close();
-
-        // Tombstone in the far future
-        new FileOutputStream(new File(dir, "DropBoxTest@" + (before + 100002) + ".lost")).close();
-
-        DropBoxManagerService service = new DropBoxManagerService(getContext(), dir);
-        DropBoxManager dropbox = new DropBoxManager(getContext(), service.getServiceStub());
-
-        // Until a write, the timestamps are taken at face value
-        DropBoxManager.Entry e0 = dropbox.getNextEntry(null, before);
-        DropBoxManager.Entry e1 = dropbox.getNextEntry(null, e0.getTimeMillis());
-        DropBoxManager.Entry e2 = dropbox.getNextEntry(null, e1.getTimeMillis());
-        DropBoxManager.Entry e3 = dropbox.getNextEntry(null, e2.getTimeMillis());
-        assertTrue(null == dropbox.getNextEntry(null, e3.getTimeMillis()));
-
-        assertEquals("FUTURE0", e0.getText(80));
-        assertEquals("FUTURE1", e1.getText(80));
-        assertEquals("FUTURE2", e2.getText(80));
-        assertEquals(null, e3.getText(80));
-
-        assertEquals(before + 5000, e0.getTimeMillis());
-        assertEquals(before + 100000, e1.getTimeMillis());
-        assertEquals(before + 100001, e2.getTimeMillis());
-        assertEquals(before + 100002, e3.getTimeMillis());
-
-        e0.close();
-        e1.close();
-        e2.close();
-        e3.close();
-
-        // Write something to force a collapse
-        dropbox.addText("NotDropBoxTest", "FUTURE");
-        e0 = dropbox.getNextEntry(null, before);
-        e1 = dropbox.getNextEntry(null, e0.getTimeMillis());
-        e2 = dropbox.getNextEntry(null, e1.getTimeMillis());
-        e3 = dropbox.getNextEntry(null, e2.getTimeMillis());
-        assertTrue(null == dropbox.getNextEntry("DropBoxTest", e3.getTimeMillis()));
-
-        assertEquals("FUTURE0", e0.getText(80));
-        assertEquals("FUTURE1", e1.getText(80));
-        assertEquals("FUTURE2", e2.getText(80));
-        assertEquals(null, e3.getText(80));
-
-        assertEquals(before + 5000, e0.getTimeMillis());
-        assertEquals(before + 5001, e1.getTimeMillis());
-        assertEquals(before + 5002, e2.getTimeMillis());
-        assertEquals(before + 5003, e3.getTimeMillis());
-
-        e0.close();
-        e1.close();
-        e2.close();
-        e3.close();
-    }
-
-    public void testIsTagEnabled() throws Exception {
-        File dir = getEmptyDir("testIsTagEnabled");
-        DropBoxManagerService service = new DropBoxManagerService(getContext(), dir);
-        DropBoxManager dropbox = new DropBoxManager(getContext(), service.getServiceStub());
-
-        long before = System.currentTimeMillis();
-        dropbox.addText("DropBoxTest", "TEST-ENABLED");
-        assertTrue(dropbox.isTagEnabled("DropBoxTest"));
-
-        ContentResolver cr = getContext().getContentResolver();
-        Settings.Global.putString(cr, Settings.Global.DROPBOX_TAG_PREFIX + "DropBoxTest",
-                                  "disabled");
-
-        dropbox.addText("DropBoxTest", "TEST-DISABLED");
-        assertFalse(dropbox.isTagEnabled("DropBoxTest"));
-
-        Settings.Global.putString(cr, Settings.Global.DROPBOX_TAG_PREFIX + "DropBoxTest",
-                                  "");
-
-        dropbox.addText("DropBoxTest", "TEST-ENABLED-AGAIN");
-        assertTrue(dropbox.isTagEnabled("DropBoxTest"));
-
-        DropBoxManager.Entry e0 = dropbox.getNextEntry("DropBoxTest", before);
-        DropBoxManager.Entry e1 = dropbox.getNextEntry("DropBoxTest", e0.getTimeMillis());
-        assertTrue(null == dropbox.getNextEntry("DropBoxTest", e1.getTimeMillis()));
-
-        assertEquals("TEST-ENABLED", e0.getText(80));
-        assertEquals("TEST-ENABLED-AGAIN", e1.getText(80));
-
-        e0.close();
-        e1.close();
-    }
-
-    public void testGetNextEntry() throws Exception {
-        File dir = getEmptyDir("testGetNextEntry");
-        DropBoxManagerService service = new DropBoxManagerService(getContext(), dir);
-        DropBoxManager dropbox = new DropBoxManager(getContext(), service.getServiceStub());
-
-        long before = System.currentTimeMillis();
-        dropbox.addText("DropBoxTest.A", "A0");
-        dropbox.addText("DropBoxTest.B", "B0");
-        dropbox.addText("DropBoxTest.A", "A1");
-
-        DropBoxManager.Entry a0 = dropbox.getNextEntry("DropBoxTest.A", before);
-        DropBoxManager.Entry a1 = dropbox.getNextEntry("DropBoxTest.A", a0.getTimeMillis());
-        assertTrue(null == dropbox.getNextEntry("DropBoxTest.A", a1.getTimeMillis()));
-
-        DropBoxManager.Entry b0 = dropbox.getNextEntry("DropBoxTest.B", before);
-        assertTrue(null == dropbox.getNextEntry("DropBoxTest.B", b0.getTimeMillis()));
-
-        DropBoxManager.Entry x0 = dropbox.getNextEntry(null, before);
-        DropBoxManager.Entry x1 = dropbox.getNextEntry(null, x0.getTimeMillis());
-        DropBoxManager.Entry x2 = dropbox.getNextEntry(null, x1.getTimeMillis());
-        assertTrue(null == dropbox.getNextEntry(null, x2.getTimeMillis()));
-
-        assertEquals("DropBoxTest.A", a0.getTag());
-        assertEquals("DropBoxTest.A", a1.getTag());
-        assertEquals("A0", a0.getText(80));
-        assertEquals("A1", a1.getText(80));
-
-        assertEquals("DropBoxTest.B", b0.getTag());
-        assertEquals("B0", b0.getText(80));
-
-        assertEquals("DropBoxTest.A", x0.getTag());
-        assertEquals("DropBoxTest.B", x1.getTag());
-        assertEquals("DropBoxTest.A", x2.getTag());
-        assertEquals("A0", x0.getText(80));
-        assertEquals("B0", x1.getText(80));
-        assertEquals("A1", x2.getText(80));
-
-        a0.close();
-        a1.close();
-        b0.close();
-        x0.close();
-        x1.close();
-        x2.close();
-    }
-
-    public void testSizeLimits() throws Exception {
-        File dir = getEmptyDir("testSizeLimits");
-        int blockSize =  new StatFs(dir.getPath()).getBlockSize();
-
-        // Limit storage to 10 blocks
-        int kb = blockSize * 10 / 1024;
-        ContentResolver cr = getContext().getContentResolver();
-        Settings.Global.putString(cr, Settings.Global.DROPBOX_QUOTA_KB, Integer.toString(kb));
-
-        // Three tags using a total of 12 blocks:
-        // DropBoxTest0 [ ][ ]
-        // DropBoxTest1 [x][ ][    ][ ][xxx(20 blocks)xxx]
-        // DropBoxTest2 [xxxxxxxxxx][ ][ ]
-        //
-        // The blocks marked "x" will be removed due to storage restrictions.
-        // Use random fill (so it doesn't compress), subtract a little for gzip overhead
-
-        final int overhead = 64;
-        long before = System.currentTimeMillis();
-        DropBoxManagerService service = new DropBoxManagerService(getContext(), dir);
-        DropBoxManager dropbox = new DropBoxManager(getContext(), service.getServiceStub());
-
-        addRandomEntry(dropbox, "DropBoxTest0", blockSize - overhead);
-        addRandomEntry(dropbox, "DropBoxTest0", blockSize - overhead);
-
-        addRandomEntry(dropbox, "DropBoxTest1", blockSize - overhead);
-        addRandomEntry(dropbox, "DropBoxTest1", blockSize - overhead);
-        addRandomEntry(dropbox, "DropBoxTest1", blockSize * 2 - overhead);
-        addRandomEntry(dropbox, "DropBoxTest1", blockSize - overhead);
-        addRandomEntry(dropbox, "DropBoxTest1", blockSize * 20 - overhead);
-
-        addRandomEntry(dropbox, "DropBoxTest2", blockSize * 4 - overhead);
-        addRandomEntry(dropbox, "DropBoxTest2", blockSize - overhead);
-        addRandomEntry(dropbox, "DropBoxTest2", blockSize - overhead);
-
-        DropBoxManager.Entry e0 = dropbox.getNextEntry(null, before);
-        DropBoxManager.Entry e1 = dropbox.getNextEntry(null, e0.getTimeMillis());
-        DropBoxManager.Entry e2 = dropbox.getNextEntry(null, e1.getTimeMillis());
-        DropBoxManager.Entry e3 = dropbox.getNextEntry(null, e2.getTimeMillis());
-        DropBoxManager.Entry e4 = dropbox.getNextEntry(null, e3.getTimeMillis());
-        DropBoxManager.Entry e5 = dropbox.getNextEntry(null, e4.getTimeMillis());
-        DropBoxManager.Entry e6 = dropbox.getNextEntry(null, e5.getTimeMillis());
-        DropBoxManager.Entry e7 = dropbox.getNextEntry(null, e6.getTimeMillis());
-        DropBoxManager.Entry e8 = dropbox.getNextEntry(null, e7.getTimeMillis());
-        DropBoxManager.Entry e9 = dropbox.getNextEntry(null, e8.getTimeMillis());
-        assertTrue(null == dropbox.getNextEntry(null, e9.getTimeMillis()));
-
-        assertEquals("DropBoxTest0", e0.getTag());
-        assertEquals("DropBoxTest0", e1.getTag());
-        assertEquals(blockSize - overhead, getEntrySize(e0));
-        assertEquals(blockSize - overhead, getEntrySize(e1));
-
-        assertEquals("DropBoxTest1", e2.getTag());
-        assertEquals("DropBoxTest1", e3.getTag());
-        assertEquals("DropBoxTest1", e4.getTag());
-        assertEquals("DropBoxTest1", e5.getTag());
-        assertEquals("DropBoxTest1", e6.getTag());
-        assertEquals(-1, getEntrySize(e2));  // Tombstone
-        assertEquals(blockSize - overhead, getEntrySize(e3));
-        assertEquals(blockSize * 2 - overhead, getEntrySize(e4));
-        assertEquals(blockSize - overhead, getEntrySize(e5));
-        assertEquals(-1, getEntrySize(e6));
-
-        assertEquals("DropBoxTest2", e7.getTag());
-        assertEquals("DropBoxTest2", e8.getTag());
-        assertEquals("DropBoxTest2", e9.getTag());
-        assertEquals(-1, getEntrySize(e7));  // Tombstone
-        assertEquals(blockSize - overhead, getEntrySize(e8));
-        assertEquals(blockSize - overhead, getEntrySize(e9));
-
-        e0.close();
-        e1.close();
-        e2.close();
-        e3.close();
-        e4.close();
-        e5.close();
-        e6.close();
-        e7.close();
-        e8.close();
-        e9.close();
-
-        // Specifying a tag name skips tombstone records.
-
-        DropBoxManager.Entry t0 = dropbox.getNextEntry("DropBoxTest1", before);
-        DropBoxManager.Entry t1 = dropbox.getNextEntry("DropBoxTest1", t0.getTimeMillis());
-        DropBoxManager.Entry t2 = dropbox.getNextEntry("DropBoxTest1", t1.getTimeMillis());
-        assertTrue(null == dropbox.getNextEntry("DropBoxTest1", t2.getTimeMillis()));
-
-        assertEquals("DropBoxTest1", t0.getTag());
-        assertEquals("DropBoxTest1", t1.getTag());
-        assertEquals("DropBoxTest1", t2.getTag());
-
-        assertEquals(blockSize - overhead, getEntrySize(t0));
-        assertEquals(blockSize * 2 - overhead, getEntrySize(t1));
-        assertEquals(blockSize - overhead, getEntrySize(t2));
-
-        t0.close();
-        t1.close();
-        t2.close();
-    }
-
-    public void testAgeLimits() throws Exception {
-        File dir = getEmptyDir("testAgeLimits");
-        int blockSize = new StatFs(dir.getPath()).getBlockSize();
-
-        // Limit storage to 10 blocks with an expiration of 1 second
-        int kb = blockSize * 10 / 1024;
-        ContentResolver cr = getContext().getContentResolver();
-        Settings.Global.putString(cr, Settings.Global.DROPBOX_AGE_SECONDS, "1");
-        Settings.Global.putString(cr, Settings.Global.DROPBOX_QUOTA_KB, Integer.toString(kb));
-
-        // Write one normal entry and another so big that it is instantly tombstoned
-        long before = System.currentTimeMillis();
-        DropBoxManagerService service = new DropBoxManagerService(getContext(), dir);
-        DropBoxManager dropbox = new DropBoxManager(getContext(), service.getServiceStub());
-
-        dropbox.addText("DropBoxTest", "TEST");
-        addRandomEntry(dropbox, "DropBoxTest", blockSize * 20);
-
-        // Verify that things are as expected
-        DropBoxManager.Entry e0 = dropbox.getNextEntry(null, before);
-        DropBoxManager.Entry e1 = dropbox.getNextEntry(null, e0.getTimeMillis());
-        assertTrue(null == dropbox.getNextEntry(null, e1.getTimeMillis()));
-
-        assertEquals("TEST", e0.getText(80));
-        assertEquals(null, e1.getText(80));
-        assertEquals(-1, getEntrySize(e1));
-
-        e0.close();
-        e1.close();
-
-        // Wait a second and write another entry -- old ones should be expunged
-        Thread.sleep(2000);
-        dropbox.addText("DropBoxTest", "TEST1");
-
-        e0 = dropbox.getNextEntry(null, before);
-        assertTrue(null == dropbox.getNextEntry(null, e0.getTimeMillis()));
-        assertEquals("TEST1", e0.getText(80));
-        e0.close();
-    }
-
-    public void testFileCountLimits() throws Exception {
-        File dir = getEmptyDir("testFileCountLimits");
-
-        DropBoxManagerService service = new DropBoxManagerService(getContext(), dir);
-        DropBoxManager dropbox = new DropBoxManager(getContext(), service.getServiceStub());
-        dropbox.addText("DropBoxTest", "TEST0");
-        dropbox.addText("DropBoxTest", "TEST1");
-        dropbox.addText("DropBoxTest", "TEST2");
-        dropbox.addText("DropBoxTest", "TEST3");
-        dropbox.addText("DropBoxTest", "TEST4");
-        dropbox.addText("DropBoxTest", "TEST5");
-
-        // Verify 6 files added
-        DropBoxManager.Entry e0 = dropbox.getNextEntry(null, 0);
-        DropBoxManager.Entry e1 = dropbox.getNextEntry(null, e0.getTimeMillis());
-        DropBoxManager.Entry e2 = dropbox.getNextEntry(null, e1.getTimeMillis());
-        DropBoxManager.Entry e3 = dropbox.getNextEntry(null, e2.getTimeMillis());
-        DropBoxManager.Entry e4 = dropbox.getNextEntry(null, e3.getTimeMillis());
-        DropBoxManager.Entry e5 = dropbox.getNextEntry(null, e4.getTimeMillis());
-        assertTrue(null == dropbox.getNextEntry(null, e5.getTimeMillis()));
-        assertEquals("TEST0", e0.getText(80));
-        assertEquals("TEST5", e5.getText(80));
-
-        e0.close();
-        e1.close();
-        e2.close();
-        e3.close();
-        e4.close();
-        e5.close();
-
-        // Limit to 3 files and add one more entry
-        ContentResolver cr = getContext().getContentResolver();
-        Settings.Global.putString(cr, Settings.Global.DROPBOX_MAX_FILES, "3");
-        dropbox.addText("DropBoxTest", "TEST6");
-
-        // Verify only 3 files left
-        DropBoxManager.Entry f0 = dropbox.getNextEntry(null, 0);
-        DropBoxManager.Entry f1 = dropbox.getNextEntry(null, f0.getTimeMillis());
-        DropBoxManager.Entry f2 = dropbox.getNextEntry(null, f1.getTimeMillis());
-        assertTrue(null == dropbox.getNextEntry(null, f2.getTimeMillis()));
-        assertEquals("TEST4", f0.getText(80));
-        assertEquals("TEST5", f1.getText(80));
-        assertEquals("TEST6", f2.getText(80));
-
-        f0.close();
-        f1.close();
-        f2.close();
-    }
-
-    public void testCreateDropBoxManagerWithInvalidDirectory() throws Exception {
-        // If created with an invalid directory, the DropBoxManager should suffer quietly
-        // and fail all operations (this is how it survives a full disk).
-        // Once the directory becomes possible to create, it will start working.
-
-        File dir = new File(getEmptyDir("testCreateDropBoxManagerWith"), "InvalidDirectory");
-        new FileOutputStream(dir).close();  // Create an empty file
-        DropBoxManagerService service = new DropBoxManagerService(getContext(), dir);
-        DropBoxManager dropbox = new DropBoxManager(getContext(), service.getServiceStub());
-
-        dropbox.addText("DropBoxTest", "should be ignored");
-        dropbox.addData("DropBoxTest", "should be ignored".getBytes(), 0);
-        assertTrue(null == dropbox.getNextEntry("DropBoxTest", 0));
-
-        dir.delete();  // Remove the file so a directory can be created
-        dropbox.addText("DropBoxTest", "TEST");
-        DropBoxManager.Entry e = dropbox.getNextEntry("DropBoxTest", 0);
-        assertTrue(null == dropbox.getNextEntry("DropBoxTest", e.getTimeMillis()));
-        assertEquals("DropBoxTest", e.getTag());
-        assertEquals("TEST", e.getText(80));
-        e.close();
-    }
-
-    public void testDropBoxEntrySerialization() throws Exception {
-        // Make sure DropBoxManager.Entry can be serialized to a Parcel and back
-        // under a variety of conditions.
-
-        Parcel parcel = Parcel.obtain();
-        File dir = getEmptyDir("testDropBoxEntrySerialization");
-
-        new DropBoxManager.Entry("empty", 1000000).writeToParcel(parcel, 0);
-        new DropBoxManager.Entry("string", 2000000, "String Value").writeToParcel(parcel, 0);
-        new DropBoxManager.Entry("bytes", 3000000, "Bytes Value".getBytes(),
-                DropBoxManager.IS_TEXT).writeToParcel(parcel, 0);
-        new DropBoxManager.Entry("zerobytes", 4000000, new byte[0], 0).writeToParcel(parcel, 0);
-        new DropBoxManager.Entry("emptybytes", 5000000, (byte[]) null,
-                DropBoxManager.IS_EMPTY).writeToParcel(parcel, 0);
-
-        try {
-            new DropBoxManager.Entry("badbytes", 99999,
-                    "Bad Bytes Value".getBytes(),
-                    DropBoxManager.IS_EMPTY).writeToParcel(parcel, 0);
-            fail("IllegalArgumentException expected for non-null byte[] and IS_EMPTY flags");
-        } catch (IllegalArgumentException e) {
-            // expected
-        }
-
-        try {
-            new DropBoxManager.Entry("badbytes", 99999, (byte[]) null, 0).writeToParcel(parcel, 0);
-            fail("IllegalArgumentException expected for null byte[] and non-IS_EMPTY flags");
-        } catch (IllegalArgumentException e) {
-            // expected
-        }
-
-        File f = new File(dir, "file.dat");
-        FileOutputStream os = new FileOutputStream(f);
-        os.write("File Value".getBytes());
-        os.close();
-
-        new DropBoxManager.Entry("file", 6000000, f, DropBoxManager.IS_TEXT).writeToParcel(
-                parcel, Parcelable.PARCELABLE_WRITE_RETURN_VALUE);
-        new DropBoxManager.Entry("binfile", 7000000, f, 0).writeToParcel(
-                parcel, Parcelable.PARCELABLE_WRITE_RETURN_VALUE);
-        new DropBoxManager.Entry("emptyfile", 8000000, (ParcelFileDescriptor) null,
-                DropBoxManager.IS_EMPTY).writeToParcel(parcel, 0);
-
-        try {
-            new DropBoxManager.Entry("badfile", 99999, new File(dir, "nonexist.dat"), 0);
-            fail("IOException expected for nonexistent file");
-        } catch (IOException e) {
-            // expected
-        }
-
-        try {
-            new DropBoxManager.Entry("badfile", 99999, f, DropBoxManager.IS_EMPTY).writeToParcel(
-                    parcel, 0);
-            fail("IllegalArgumentException expected for non-null file and IS_EMPTY flags");
-        } catch (IllegalArgumentException e) {
-            // expected
-        }
-
-        try {
-            new DropBoxManager.Entry("badfile", 99999, (ParcelFileDescriptor) null, 0);
-            fail("IllegalArgumentException expected for null PFD and non-IS_EMPTY flags");
-        } catch (IllegalArgumentException e) {
-            // expected
-        }
-
-        File gz = new File(dir, "file.gz");
-        GZIPOutputStream gzout = new GZIPOutputStream(new FileOutputStream(gz));
-        gzout.write("Gzip File Value".getBytes());
-        gzout.close();
-
-        new DropBoxManager.Entry("gzipfile", 9000000, gz,
-                DropBoxManager.IS_TEXT | DropBoxManager.IS_GZIPPED).writeToParcel(
-                    parcel, Parcelable.PARCELABLE_WRITE_RETURN_VALUE);
-        new DropBoxManager.Entry("gzipbinfile", 10000000, gz,
-                DropBoxManager.IS_GZIPPED).writeToParcel(
-                    parcel, Parcelable.PARCELABLE_WRITE_RETURN_VALUE);
-
-        //
-        // Switch from writing to reading
-        //
-
-        parcel.setDataPosition(0);
-        DropBoxManager.Entry e;
-
-        e = DropBoxManager.Entry.CREATOR.createFromParcel(parcel);
-        assertEquals("empty", e.getTag());
-        assertEquals(1000000, e.getTimeMillis());
-        assertEquals(DropBoxManager.IS_EMPTY, e.getFlags());
-        assertEquals(null, e.getText(100));
-        assertEquals(null, e.getInputStream());
-        e.close();
-
-        e = DropBoxManager.Entry.CREATOR.createFromParcel(parcel);
-        assertEquals("string", e.getTag());
-        assertEquals(2000000, e.getTimeMillis());
-        assertEquals(DropBoxManager.IS_TEXT, e.getFlags());
-        assertEquals("String Value", e.getText(100));
-        assertEquals("String Value",
-                new BufferedReader(new InputStreamReader(e.getInputStream())).readLine());
-        e.close();
-
-        e = DropBoxManager.Entry.CREATOR.createFromParcel(parcel);
-        assertEquals("bytes", e.getTag());
-        assertEquals(3000000, e.getTimeMillis());
-        assertEquals(DropBoxManager.IS_TEXT, e.getFlags());
-        assertEquals("Bytes Value", e.getText(100));
-        e.close();
-
-        e = DropBoxManager.Entry.CREATOR.createFromParcel(parcel);
-        assertEquals("zerobytes", e.getTag());
-        assertEquals(4000000, e.getTimeMillis());
-        assertEquals(0, e.getFlags());
-        assertEquals(null, e.getText(100));
-        assertEquals(null,
-                new BufferedReader(new InputStreamReader(e.getInputStream())).readLine());
-        e.close();
-
-        e = DropBoxManager.Entry.CREATOR.createFromParcel(parcel);
-        assertEquals("emptybytes", e.getTag());
-        assertEquals(5000000, e.getTimeMillis());
-        assertEquals(DropBoxManager.IS_EMPTY, e.getFlags());
-        assertEquals(null, e.getText(100));
-        assertEquals(null, e.getInputStream());
-        e.close();
-
-        e = DropBoxManager.Entry.CREATOR.createFromParcel(parcel);
-        assertEquals("file", e.getTag());
-        assertEquals(6000000, e.getTimeMillis());
-        assertEquals(DropBoxManager.IS_TEXT, e.getFlags());
-        assertEquals("File Value", e.getText(100));
-        e.close();
-
-        e = DropBoxManager.Entry.CREATOR.createFromParcel(parcel);
-        assertEquals("binfile", e.getTag());
-        assertEquals(7000000, e.getTimeMillis());
-        assertEquals(0, e.getFlags());
-        assertEquals(null, e.getText(100));
-        assertEquals("File Value",
-                new BufferedReader(new InputStreamReader(e.getInputStream())).readLine());
-        e.close();
-        e = DropBoxManager.Entry.CREATOR.createFromParcel(parcel);
-        assertEquals("emptyfile", e.getTag());
-        assertEquals(8000000, e.getTimeMillis());
-        assertEquals(DropBoxManager.IS_EMPTY, e.getFlags());
-        assertEquals(null, e.getText(100));
-        assertEquals(null, e.getInputStream());
-        e.close();
-
-        e = DropBoxManager.Entry.CREATOR.createFromParcel(parcel);
-        assertEquals("gzipfile", e.getTag());
-        assertEquals(9000000, e.getTimeMillis());
-        assertEquals(DropBoxManager.IS_TEXT, e.getFlags());
-        assertEquals("Gzip File Value", e.getText(100));
-        e.close();
-
-        e = DropBoxManager.Entry.CREATOR.createFromParcel(parcel);
-        assertEquals("gzipbinfile", e.getTag());
-        assertEquals(10000000, e.getTimeMillis());
-        assertEquals(0, e.getFlags());
-        assertEquals(null, e.getText(100));
-        assertEquals("Gzip File Value",
-                new BufferedReader(new InputStreamReader(e.getInputStream())).readLine());
-        e.close();
-        assertEquals(0, parcel.dataAvail());
-        parcel.recycle();
-    }
-
-    public void testDropBoxEntrySerializationDoesntLeakFileDescriptors() throws Exception {
-        File dir = getEmptyDir("testDropBoxEntrySerialization");
-        File f = new File(dir, "file.dat");
-        FileOutputStream os = new FileOutputStream(f);
-        os.write("File Value".getBytes());
-        os.close();
-
-        int before = countOpenFiles();
-        assertTrue(before > 0);
-
-        for (int i = 0; i < 1000; i++) {
-            Parcel parcel = Parcel.obtain();
-            new DropBoxManager.Entry("file", 1000000, f, 0).writeToParcel(
-                    parcel, Parcelable.PARCELABLE_WRITE_RETURN_VALUE);
-
-            parcel.setDataPosition(0);
-            DropBoxManager.Entry e = DropBoxManager.Entry.CREATOR.createFromParcel(parcel);
-            assertEquals("file", e.getTag());
-            e.close();
-
-            parcel.recycle();
-        }
-
-        int after = countOpenFiles();
-        assertTrue(after > 0);
-        assertTrue(after < before + 20);
-    }
-
-    private void addRandomEntry(DropBoxManager dropbox, String tag, int size) throws Exception {
-        byte[] bytes = new byte[size];
-        new Random(System.currentTimeMillis()).nextBytes(bytes);
-
-        File f = new File(getEmptyDir("addRandomEntry"), "random.dat");
-        FileOutputStream os = new FileOutputStream(f);
-        os.write(bytes);
-        os.close();
-
-        dropbox.addFile(tag, f, 0);
-    }
-
-    private int getEntrySize(DropBoxManager.Entry e) throws Exception {
-        InputStream is = e.getInputStream();
-        if (is == null) return -1;
-        int length = 0;
-        while (is.read() != -1) length++;
-        return length;
-    }
-
-    private void recursiveDelete(File file) {
-        if (!file.delete() && file.isDirectory()) {
-            for (File f : file.listFiles()) recursiveDelete(f);
-            file.delete();
-        }
-    }
-
-    private File getEmptyDir(String name) {
-        File dir = getContext().getDir("DropBoxTest." + name, 0);
-        for (File f : dir.listFiles()) recursiveDelete(f);
-        assertTrue(dir.listFiles().length == 0);
-        return dir;
-    }
-
-    private int countOpenFiles() {
-        return new File("/proc/" + Process.myPid() + "/fd").listFiles().length;
-    }
-}
diff --git a/services/tests/servicestests/src/com/android/server/EntropyMixerTest.java b/services/tests/servicestests/src/com/android/server/EntropyMixerTest.java
deleted file mode 100644
index 50e7a0395a2..00000000000
--- a/services/tests/servicestests/src/com/android/server/EntropyMixerTest.java
+++ /dev/null
@@ -1,41 +0,0 @@
-/*
- * Copyright (C) 2010 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.android.server;
-
-import android.content.Context;
-import android.os.FileUtils;
-import android.test.AndroidTestCase;
-
-import java.io.File;
-
-/**
- * Tests for {@link com.android.server.EntropyMixer}
- */
-public class EntropyMixerTest extends AndroidTestCase {
-
-    public void testInitialWrite() throws Exception {
-        File dir = getContext().getDir("testInitialWrite", Context.MODE_PRIVATE);
-        File file = File.createTempFile("testInitialWrite", "dat", dir);
-        file.deleteOnExit();
-        assertEquals(0, FileUtils.readTextFile(file, 0, null).length());
-
-        // The constructor has the side effect of writing to file
-        new EntropyMixer(getContext(), "/dev/null", file.getCanonicalPath(), "/dev/null");
-
-        assertTrue(FileUtils.readTextFile(file, 0, null).length() > 0);
-    }
-}
diff --git a/services/tests/servicestests/src/com/android/server/LockSettingsStorageTests.java b/services/tests/servicestests/src/com/android/server/LockSettingsStorageTests.java
deleted file mode 100644
index 7d28e3964f8..00000000000
--- a/services/tests/servicestests/src/com/android/server/LockSettingsStorageTests.java
+++ /dev/null
@@ -1,357 +0,0 @@
-/*
- * Copyright (C) 2014 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License
- */
-
-package com.android.server;
-
-import android.content.Context;
-import android.content.ContextWrapper;
-import android.content.pm.UserInfo;
-import android.database.sqlite.SQLiteDatabase;
-import android.os.FileUtils;
-import android.os.UserManager;
-import android.test.AndroidTestCase;
-
-import java.io.File;
-import java.util.ArrayList;
-import java.util.Arrays;
-import java.util.List;
-import java.util.concurrent.CountDownLatch;
-
-public class LockSettingsStorageTests extends AndroidTestCase {
-    LockSettingsStorage mStorage;
-    File mStorageDir;
-
-    private File mDb;
-
-    @Override
-    protected void setUp() throws Exception {
-        super.setUp();
-        mStorageDir = new File(getContext().getFilesDir(), "locksettings");
-        mDb = getContext().getDatabasePath("locksettings.db");
-
-        assertTrue(mStorageDir.exists() || mStorageDir.mkdirs());
-        assertTrue(FileUtils.deleteContents(mStorageDir));
-        assertTrue(!mDb.exists() || mDb.delete());
-
-        final Context ctx = getContext();
-        setContext(new ContextWrapper(ctx) {
-            @Override
-            public Object getSystemService(String name) {
-                if (USER_SERVICE.equals(name)) {
-                    return new UserManager(ctx, null) {
-                        @Override
-                        public UserInfo getProfileParent(int userHandle) {
-                            if (userHandle == 2) {
-                                // User 2 is a profile of user 1.
-                                return new UserInfo(1, "name", 0);
-                            }
-                            if (userHandle == 3) {
-                                // User 3 is a profile of user 0.
-                                return new UserInfo(0, "name", 0);
-                            }
-                            return null;
-                        }
-                    };
-                }
-                return super.getSystemService(name);
-            }
-        });
-
-        mStorage = new LockSettingsStorage(getContext(), new LockSettingsStorage.Callback() {
-            @Override
-            public void initialize(SQLiteDatabase db) {
-                mStorage.writeKeyValue(db, "initializedKey", "initialValue", 0);
-            }
-        }) {
-            @Override
-            String getLockPatternFilename(int userId) {
-                return new File(mStorageDir,
-                        super.getLockPatternFilename(userId).replace('/', '-')).getAbsolutePath();
-            }
-
-            @Override
-            String getLockPasswordFilename(int userId) {
-                return new File(mStorageDir,
-                        super.getLockPasswordFilename(userId).replace('/', '-')).getAbsolutePath();
-            }
-
-            @Override
-            String getChildProfileLockFile(int userId) {
-                return new File(mStorageDir,
-                        super.getChildProfileLockFile(userId).replace('/', '-')).getAbsolutePath();
-            }
-        };
-    }
-
-    @Override
-    protected void tearDown() throws Exception {
-        super.tearDown();
-        mStorage.closeDatabase();
-    }
-
-    public void testKeyValue_InitializeWorked() {
-        assertEquals("initialValue", mStorage.readKeyValue("initializedKey", "default", 0));
-        mStorage.clearCache();
-        assertEquals("initialValue", mStorage.readKeyValue("initializedKey", "default", 0));
-    }
-
-    public void testKeyValue_WriteThenRead() {
-        mStorage.writeKeyValue("key", "value", 0);
-        assertEquals("value", mStorage.readKeyValue("key", "default", 0));
-        mStorage.clearCache();
-        assertEquals("value", mStorage.readKeyValue("key", "default", 0));
-    }
-
-    public void testKeyValue_DefaultValue() {
-        assertEquals("default", mStorage.readKeyValue("unititialized key", "default", 0));
-        assertEquals("default2", mStorage.readKeyValue("unititialized key", "default2", 0));
-    }
-
-    public void testKeyValue_Concurrency() {
-        final Object monitor = new Object();
-        List<Thread> threads = new ArrayList<>();
-        for (int i = 0; i < 100; i++) {
-            final int threadId = i;
-            threads.add(new Thread() {
-                @Override
-                public void run() {
-                    synchronized (monitor) {
-                        try {
-                            monitor.wait();
-                        } catch (InterruptedException e) {
-                            return;
-                        }
-                        mStorage.writeKeyValue("key", "1 from thread " + threadId, 0);
-                        mStorage.readKeyValue("key", "default", 0);
-                        mStorage.writeKeyValue("key", "2 from thread " + threadId, 0);
-                        mStorage.readKeyValue("key", "default", 0);
-                        mStorage.writeKeyValue("key", "3 from thread " + threadId, 0);
-                        mStorage.readKeyValue("key", "default", 0);
-                        mStorage.writeKeyValue("key", "4 from thread " + threadId, 0);
-                        mStorage.readKeyValue("key", "default", 0);
-                        mStorage.writeKeyValue("key", "5 from thread " + threadId, 0);
-                        mStorage.readKeyValue("key", "default", 0);
-                    }
-                }
-            });
-            threads.get(i).start();
-        }
-        mStorage.writeKeyValue("key", "initalValue", 0);
-        synchronized (monitor) {
-            monitor.notifyAll();
-        }
-        for (int i = 0; i < threads.size(); i++) {
-            try {
-                threads.get(i).join();
-            } catch (InterruptedException e) {
-            }
-        }
-        assertEquals('5', mStorage.readKeyValue("key", "default", 0).charAt(0));
-        mStorage.clearCache();
-        assertEquals('5', mStorage.readKeyValue("key", "default", 0).charAt(0));
-    }
-
-    public void testKeyValue_CacheStarvedWriter() {
-        final CountDownLatch latch = new CountDownLatch(1);
-        List<Thread> threads = new ArrayList<>();
-        for (int i = 0; i < 100; i++) {
-            final int threadId = i;
-            threads.add(new Thread() {
-                @Override
-                public void run() {
-                    try {
-                        latch.await();
-                    } catch (InterruptedException e) {
-                        return;
-                    }
-                    if (threadId == 50) {
-                        mStorage.writeKeyValue("starvedWriterKey", "value", 0);
-                    } else {
-                        mStorage.readKeyValue("starvedWriterKey", "default", 0);
-                    }
-                }
-            });
-            threads.get(i).start();
-        }
-        latch.countDown();
-        for (int i = 0; i < threads.size(); i++) {
-            try {
-                threads.get(i).join();
-            } catch (InterruptedException e) {
-            }
-        }
-        String cached = mStorage.readKeyValue("key", "default", 0);
-        mStorage.clearCache();
-        String storage = mStorage.readKeyValue("key", "default", 0);
-        assertEquals("Cached value didn't match stored value", storage, cached);
-    }
-
-    public void testRemoveUser() {
-        mStorage.writeKeyValue("key", "value", 0);
-        mStorage.writePasswordHash(new byte[]{1}, 0);
-        mStorage.writePatternHash(new byte[]{2}, 0);
-
-        mStorage.writeKeyValue("key", "value", 1);
-        mStorage.writePasswordHash(new byte[]{1}, 1);
-        mStorage.writePatternHash(new byte[]{2}, 1);
-
-        mStorage.removeUser(0);
-
-        assertEquals("value", mStorage.readKeyValue("key", "default", 1));
-        assertEquals("default", mStorage.readKeyValue("key", "default", 0));
-        assertNotNull(mStorage.readPasswordHash(1));
-        assertNull(mStorage.readPasswordHash(0));
-        assertNotNull(mStorage.readPatternHash(1));
-        assertNull(mStorage.readPatternHash(0));
-    }
-
-    public void testPassword_Default() {
-        assertNull(mStorage.readPasswordHash(0));
-    }
-
-    public void testPassword_Write() {
-        mStorage.writePasswordHash("thepassword".getBytes(), 0);
-
-        assertArrayEquals("thepassword".getBytes(), mStorage.readPasswordHash(0).hash);
-        mStorage.clearCache();
-        assertArrayEquals("thepassword".getBytes(), mStorage.readPasswordHash(0).hash);
-    }
-
-    public void testPassword_WriteProfileWritesParent() {
-        mStorage.writePasswordHash("parentpasswordd".getBytes(), 1);
-        mStorage.writePasswordHash("profilepassword".getBytes(), 2);
-
-        assertArrayEquals("profilepassword".getBytes(), mStorage.readPasswordHash(1).hash);
-        assertArrayEquals("profilepassword".getBytes(), mStorage.readPasswordHash(2).hash);
-        mStorage.clearCache();
-        assertArrayEquals("profilepassword".getBytes(), mStorage.readPasswordHash(1).hash);
-        assertArrayEquals("profilepassword".getBytes(), mStorage.readPasswordHash(2).hash);
-    }
-
-    public void testLockType_WriteProfileWritesParent() {
-        mStorage.writePasswordHash("parentpassword".getBytes(), 10);
-        mStorage.writePatternHash("12345678".getBytes(), 20);
-
-        assertEquals(2, mStorage.getStoredCredentialType(10));
-        assertEquals(1, mStorage.getStoredCredentialType(20));
-        mStorage.clearCache();
-        assertEquals(2, mStorage.getStoredCredentialType(10));
-        assertEquals(1, mStorage.getStoredCredentialType(20));
-    }
-
-    public void testProfileLock_ReadWriteChildProfileLock() {
-        assertFalse(mStorage.hasChildProfileLock(20));
-        mStorage.writeChildProfileLock(20, "profilepassword".getBytes());
-        assertArrayEquals("profilepassword".getBytes(), mStorage.readChildProfileLock(20));
-        assertTrue(mStorage.hasChildProfileLock(20));
-        mStorage.clearCache();
-        assertArrayEquals("profilepassword".getBytes(), mStorage.readChildProfileLock(20));
-        assertTrue(mStorage.hasChildProfileLock(20));
-    }
-
-    public void testPassword_WriteParentWritesProfile() {
-        mStorage.writePasswordHash("profilepassword".getBytes(), 2);
-        mStorage.writePasswordHash("parentpasswordd".getBytes(), 1);
-
-        assertArrayEquals("parentpasswordd".getBytes(), mStorage.readPasswordHash(1).hash);
-        assertArrayEquals("parentpasswordd".getBytes(), mStorage.readPasswordHash(2).hash);
-        mStorage.clearCache();
-        assertArrayEquals("parentpasswordd".getBytes(), mStorage.readPasswordHash(1).hash);
-        assertArrayEquals("parentpasswordd".getBytes(), mStorage.readPasswordHash(2).hash);
-    }
-
-    public void testPattern_Default() {
-        assertNull(mStorage.readPasswordHash(0));
-    }
-
-    public void testPattern_Write() {
-        mStorage.writePatternHash("thepattern".getBytes(), 0);
-
-        assertArrayEquals("thepattern".getBytes(), mStorage.readPatternHash(0).hash);
-        mStorage.clearCache();
-        assertArrayEquals("thepattern".getBytes(), mStorage.readPatternHash(0).hash);
-    }
-
-    public void testPattern_WriteProfileWritesParent() {
-        mStorage.writePatternHash("parentpatternn".getBytes(), 1);
-        mStorage.writePatternHash("profilepattern".getBytes(), 2);
-
-        assertArrayEquals("profilepattern".getBytes(), mStorage.readPatternHash(1).hash);
-        assertArrayEquals("profilepattern".getBytes(), mStorage.readPatternHash(2).hash);
-        mStorage.clearCache();
-        assertArrayEquals("profilepattern".getBytes(), mStorage.readPatternHash(1).hash);
-        assertArrayEquals("profilepattern".getBytes(), mStorage.readPatternHash(2).hash);
-    }
-
-    public void testPattern_WriteParentWritesProfile() {
-        mStorage.writePatternHash("profilepattern".getBytes(), 2);
-        mStorage.writePatternHash("parentpatternn".getBytes(), 1);
-
-        assertArrayEquals("parentpatternn".getBytes(), mStorage.readPatternHash(1).hash);
-        assertArrayEquals("parentpatternn".getBytes(), mStorage.readPatternHash(2).hash);
-        mStorage.clearCache();
-        assertArrayEquals("parentpatternn".getBytes(), mStorage.readPatternHash(1).hash);
-        assertArrayEquals("parentpatternn".getBytes(), mStorage.readPatternHash(2).hash);
-    }
-
-    public void testPrefetch() {
-        mStorage.writeKeyValue("key", "toBeFetched", 0);
-        mStorage.writePatternHash("pattern".getBytes(), 0);
-        mStorage.writePasswordHash("password".getBytes(), 0);
-
-        mStorage.clearCache();
-        mStorage.prefetchUser(0);
-
-        assertEquals("toBeFetched", mStorage.readKeyValue("key", "default", 0));
-        assertArrayEquals("pattern".getBytes(), mStorage.readPatternHash(0).hash);
-        assertArrayEquals("password".getBytes(), mStorage.readPasswordHash(0).hash);
-    }
-
-    public void testFileLocation_Owner() {
-        LockSettingsStorage storage = new LockSettingsStorage(getContext(), null);
-
-        assertEquals("/data/system/gesture.key", storage.getLockPatternFilename(0));
-        assertEquals("/data/system/password.key", storage.getLockPasswordFilename(0));
-    }
-
-    public void testFileLocation_SecondaryUser() {
-        LockSettingsStorage storage = new LockSettingsStorage(getContext(), null);
-
-        assertEquals("/data/system/users/1/gesture.key", storage.getLockPatternFilename(1));
-        assertEquals("/data/system/users/1/password.key", storage.getLockPasswordFilename(1));
-    }
-
-    public void testFileLocation_ProfileToSecondary() {
-        LockSettingsStorage storage = new LockSettingsStorage(getContext(), null);
-
-        assertEquals("/data/system/users/1/gesture.key", storage.getLockPatternFilename(2));
-        assertEquals("/data/system/users/1/password.key", storage.getLockPasswordFilename(2));
-    }
-
-    public void testFileLocation_ProfileToOwner() {
-        LockSettingsStorage storage = new LockSettingsStorage(getContext(), null);
-
-        assertEquals("/data/system/gesture.key", storage.getLockPatternFilename(3));
-        assertEquals("/data/system/password.key", storage.getLockPasswordFilename(3));
-    }
-
-    private static void assertArrayEquals(byte[] expected, byte[] actual) {
-        if (!Arrays.equals(expected, actual)) {
-            fail("expected:<" + Arrays.toString(expected) +
-                    "> but was:<" + Arrays.toString(actual) + ">");
-        }
-    }
-}
diff --git a/services/tests/servicestests/src/com/android/server/MockAccessibilityService.java b/services/tests/servicestests/src/com/android/server/MockAccessibilityService.java
deleted file mode 100644
index e1c5cee752e..00000000000
--- a/services/tests/servicestests/src/com/android/server/MockAccessibilityService.java
+++ /dev/null
@@ -1,256 +0,0 @@
-/*
- * Copyright (C) 2010 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.android.server;
-
-import android.accessibilityservice.AccessibilityService;
-import android.accessibilityservice.AccessibilityServiceInfo;
-import android.content.Intent;
-import android.os.Message;
-import android.view.accessibility.AccessibilityEvent;
-
-import java.util.Iterator;
-import java.util.LinkedList;
-import java.util.List;
-import java.util.Queue;
-
-import junit.framework.TestCase;
-
-/**
- * This is the base class for mock {@link AccessibilityService}s.
- */
-public abstract class MockAccessibilityService extends AccessibilityService {
-
-    /**
-     * The event this service expects to receive.
-     */
-    private final Queue<AccessibilityEvent> mExpectedEvents = new LinkedList<AccessibilityEvent>();
-
-    /**
-     * Interruption call this service expects to receive.
-     */
-    private boolean mExpectedInterrupt;
-
-    /**
-     * Flag if the mock is currently replaying.
-     */
-    private boolean mReplaying;
-
-    /**
-     * Flag if the system is bound as a client to this service.
-     */
-    private boolean mIsSystemBoundAsClient;
-
-    /**
-     * Creates an {@link AccessibilityServiceInfo} populated with default
-     * values.
-     *
-     * @return The default info.
-     */
-    public static AccessibilityServiceInfo createDefaultInfo() {
-        AccessibilityServiceInfo defaultInfo = new AccessibilityServiceInfo();
-        defaultInfo.eventTypes = AccessibilityEvent.TYPE_ANNOUNCEMENT;
-        defaultInfo.feedbackType = AccessibilityServiceInfo.FEEDBACK_AUDIBLE;
-        defaultInfo.flags = 0;
-        defaultInfo.notificationTimeout = 0;
-        defaultInfo.packageNames = new String[] {
-            "foo.bar.baz"
-        };
-
-        return defaultInfo;
-    }
-
-    /**
-     * Starts replaying the mock.
-     */
-    public void replay() {
-        mReplaying = true;
-    }
-
-    /**
-     * Verifies if all expected service methods have been called.
-     */
-    public void verify() {
-        if (!mReplaying) {
-            throw new IllegalStateException("Did you forget to call replay()");
-        }
-
-        if (mExpectedInterrupt) {
-            throw new IllegalStateException("Expected call to #interrupt() not received");
-        }
-        if (!mExpectedEvents.isEmpty()) {
-            throw new IllegalStateException("Expected a call to onAccessibilityEvent() for "
-                    + "events \"" + mExpectedEvents + "\" not received");
-        }
-    }
-
-    /**
-     * Resets this instance so it can be reused.
-     */
-    public void reset() {
-        mExpectedEvents.clear();
-        mExpectedInterrupt = false;
-        mReplaying = false;
-    }
-
-    /**
-     * Sets an expected call to
-     * {@link #onAccessibilityEvent(AccessibilityEvent)} with given event as
-     * argument.
-     *
-     * @param expectedEvent The expected event argument.
-     */
-    public void expectEvent(AccessibilityEvent expectedEvent) {
-        mExpectedEvents.add(expectedEvent);
-    }
-
-    /**
-     * Sets an expected call of {@link #onInterrupt()}.
-     */
-    public void expectInterrupt() {
-        mExpectedInterrupt = true;
-    }
-
-    @Override
-    public void onAccessibilityEvent(AccessibilityEvent receivedEvent) {
-        if (!mReplaying) {
-            return;
-        }
-
-        if (mExpectedEvents.isEmpty()) {
-            throw new IllegalStateException("Unexpected event: " + receivedEvent);
-        }
-
-        AccessibilityEvent expectedEvent = mExpectedEvents.poll();
-        assertEqualsAccessiblityEvent(expectedEvent, receivedEvent);
-    }
-
-    @Override
-    public void onInterrupt() {
-        if (!mReplaying) {
-            return;
-        }
-
-        if (!mExpectedInterrupt) {
-            throw new IllegalStateException("Unexpected call to onInterrupt()");
-        }
-
-        mExpectedInterrupt = false;
-    }
-
-    @Override
-    protected void onServiceConnected() {
-        mIsSystemBoundAsClient = true;
-    }
-
-    @Override
-    public boolean onUnbind(Intent intent) {
-        mIsSystemBoundAsClient = false;
-        return false;
-    }
-
-    /**
-     * Returns if the system is bound as client to this service.
-     *
-     * @return True if the system is bound, false otherwise.
-     */
-    public boolean isSystemBoundAsClient() {
-        return mIsSystemBoundAsClient;
-    }
-
-    /**
-     * Compares all properties of the <code>expectedEvent</code> and the
-     * <code>receviedEvent</code> to verify that the received event is the one
-     * that is expected.
-     */
-    private void assertEqualsAccessiblityEvent(AccessibilityEvent expectedEvent,
-            AccessibilityEvent receivedEvent) {
-        TestCase.assertEquals("addedCount has incorrect value", expectedEvent.getAddedCount(),
-                receivedEvent.getAddedCount());
-        TestCase.assertEquals("beforeText has incorrect value", expectedEvent.getBeforeText(),
-                receivedEvent.getBeforeText());
-        TestCase.assertEquals("checked has incorrect value", expectedEvent.isChecked(),
-                receivedEvent.isChecked());
-        TestCase.assertEquals("className has incorrect value", expectedEvent.getClassName(),
-                receivedEvent.getClassName());
-        TestCase.assertEquals("contentDescription has incorrect value", expectedEvent
-                .getContentDescription(), receivedEvent.getContentDescription());
-        TestCase.assertEquals("currentItemIndex has incorrect value", expectedEvent
-                .getCurrentItemIndex(), receivedEvent.getCurrentItemIndex());
-        TestCase.assertEquals("enabled has incorrect value", expectedEvent.isEnabled(),
-                receivedEvent.isEnabled());
-        TestCase.assertEquals("eventType has incorrect value", expectedEvent.getEventType(),
-                receivedEvent.getEventType());
-        TestCase.assertEquals("fromIndex has incorrect value", expectedEvent.getFromIndex(),
-                receivedEvent.getFromIndex());
-        TestCase.assertEquals("fullScreen has incorrect value", expectedEvent.isFullScreen(),
-                receivedEvent.isFullScreen());
-        TestCase.assertEquals("itemCount has incorrect value", expectedEvent.getItemCount(),
-                receivedEvent.getItemCount());
-        assertEqualsNotificationAsParcelableData(expectedEvent, receivedEvent);
-        TestCase.assertEquals("password has incorrect value", expectedEvent.isPassword(),
-                receivedEvent.isPassword());
-        TestCase.assertEquals("removedCount has incorrect value", expectedEvent.getRemovedCount(),
-                receivedEvent.getRemovedCount());
-        assertEqualsText(expectedEvent, receivedEvent);
-    }
-
-    /**
-     * Compares the {@link android.os.Parcelable} data of the
-     * <code>expectedEvent</code> and <code>receivedEvent</code> to verify that
-     * the received event is the one that is expected.
-     */
-    private void assertEqualsNotificationAsParcelableData(AccessibilityEvent expectedEvent,
-            AccessibilityEvent receivedEvent) {
-        String message = "parcelableData has incorrect value";
-        Message expectedMessage = (Message) expectedEvent.getParcelableData();
-        Message receivedMessage = (Message) receivedEvent.getParcelableData();
-
-        if (expectedMessage == null) {
-            if (receivedMessage == null) {
-                return;
-            }
-        }
-
-        TestCase.assertNotNull(message, receivedMessage);
-
-        // we do a very simple sanity check since we do not test Message
-        TestCase.assertEquals(message, expectedMessage.what, receivedMessage.what);
-    }
-
-    /**
-     * Compares the text of the <code>expectedEvent</code> and
-     * <code>receivedEvent</code> by comparing the string representation of the
-     * corresponding {@link CharSequence}s.
-     */
-    private void assertEqualsText(AccessibilityEvent expectedEvent,
-            AccessibilityEvent receivedEvent) {
-        String message = "text has incorrect value";
-        List<CharSequence> expectedText = expectedEvent.getText();
-        List<CharSequence> receivedText = receivedEvent.getText();
-
-        TestCase.assertEquals(message, expectedText.size(), receivedText.size());
-
-        Iterator<CharSequence> expectedTextIterator = expectedText.iterator();
-        Iterator<CharSequence> receivedTextIterator = receivedText.iterator();
-
-        for (int i = 0; i < expectedText.size(); i++) {
-            // compare the string representation
-            TestCase.assertEquals(message, expectedTextIterator.next().toString(),
-                    receivedTextIterator.next().toString());
-        }
-    }
-}
diff --git a/services/tests/servicestests/src/com/android/server/MountServiceTests.java b/services/tests/servicestests/src/com/android/server/MountServiceTests.java
deleted file mode 100644
index ecfe0db103f..00000000000
--- a/services/tests/servicestests/src/com/android/server/MountServiceTests.java
+++ /dev/null
@@ -1,274 +0,0 @@
-/*
- * Copyright (C) 2010 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.android.server;
-
-import android.content.Context;
-import android.content.res.Resources;
-import android.content.res.Resources.NotFoundException;
-import android.os.FileUtils;
-import android.os.storage.OnObbStateChangeListener;
-import android.os.storage.StorageManager;
-import android.test.AndroidTestCase;
-import android.test.ComparisonFailure;
-import android.test.suitebuilder.annotation.LargeTest;
-import android.util.Log;
-
-import com.android.frameworks.servicestests.R;
-
-import java.io.File;
-import java.io.InputStream;
-
-public class MountServiceTests extends AndroidTestCase {
-    private static final String TAG = "MountServiceTests";
-
-    private static final long MAX_WAIT_TIME = 25*1000;
-    private static final long WAIT_TIME_INCR = 5*1000;
-
-    private static final String OBB_MOUNT_PREFIX = "/mnt/obb/";
-
-    private static void assertStartsWith(String message, String prefix, String actual) {
-        if (!actual.startsWith(prefix)) {
-            throw new ComparisonFailure(message, prefix, actual);
-        }
-    }
-
-    private static class ObbObserver extends OnObbStateChangeListener {
-        private String path;
-
-        public int state = -1;
-        boolean done = false;
-
-        @Override
-        public void onObbStateChange(String path, int state) {
-            Log.d(TAG, "Received message.  path=" + path + ", state=" + state);
-            synchronized (this) {
-                this.path = path;
-                this.state = state;
-                done = true;
-                notifyAll();
-            }
-        }
-
-        public String getPath() {
-            assertTrue("Expected ObbObserver to have received a state change.", done);
-            return path;
-        }
-
-        public int getState() {
-            assertTrue("Expected ObbObserver to have received a state change.", done);
-            return state;
-        }
-
-        public void reset() {
-            this.path = null;
-            this.state = -1;
-            done = false;
-        }
-
-        public boolean isDone() {
-            return done;
-        }
-
-        public boolean waitForCompletion() {
-            long waitTime = 0;
-            synchronized (this) {
-                while (!isDone() && waitTime < MAX_WAIT_TIME) {
-                    try {
-                        wait(WAIT_TIME_INCR);
-                        waitTime += WAIT_TIME_INCR;
-                    } catch (InterruptedException e) {
-                        Log.i(TAG, "Interrupted during sleep", e);
-                    }
-                }
-            }
-
-            return isDone();
-        }
-    }
-
-    private File getFilePath(String name) {
-        final File filesDir = mContext.getFilesDir();
-        final File outFile = new File(filesDir, name);
-        return outFile;
-    }
-
-    private void copyRawToFile(int rawResId, File outFile) {
-        Resources res = mContext.getResources();
-        InputStream is = null;
-        try {
-            is = res.openRawResource(rawResId);
-        } catch (NotFoundException e) {
-            fail("Failed to load resource with id: " + rawResId);
-        }
-        FileUtils.setPermissions(outFile.getPath(), FileUtils.S_IRWXU | FileUtils.S_IRWXG
-                | FileUtils.S_IRWXO, -1, -1);
-        assertTrue(FileUtils.copyToFile(is, outFile));
-        FileUtils.setPermissions(outFile.getPath(), FileUtils.S_IRWXU | FileUtils.S_IRWXG
-                | FileUtils.S_IRWXO, -1, -1);
-    }
-
-    private StorageManager getStorageManager() {
-        return (StorageManager) getContext().getSystemService(Context.STORAGE_SERVICE);
-    }
-
-    private void mountObb(StorageManager sm, final int resource, final File file,
-            int expectedState) {
-        copyRawToFile(resource, file);
-
-        final ObbObserver observer = new ObbObserver();
-        assertTrue("mountObb call on " + file.getPath() + " should succeed",
-                sm.mountObb(file.getPath(), null, observer));
-
-        assertTrue("Mount should have completed",
-                observer.waitForCompletion());
-
-        if (expectedState == OnObbStateChangeListener.MOUNTED) {
-            assertTrue("OBB should be mounted", sm.isObbMounted(file.getPath()));
-        }
-
-        assertEquals("Actual file and resolved file should be the same",
-                file.getPath(), observer.getPath());
-
-        assertEquals(expectedState, observer.getState());
-    }
-
-    private ObbObserver mountObbWithoutWait(final StorageManager sm, final int resource,
-            final File file) {
-        copyRawToFile(resource, file);
-
-        final ObbObserver observer = new ObbObserver();
-        assertTrue("mountObb call on " + file.getPath() + " should succeed", sm.mountObb(file
-                .getPath(), null, observer));
-
-        return observer;
-    }
-
-    private void waitForObbActionCompletion(final StorageManager sm, final File file,
-            final ObbObserver observer, int expectedState, boolean checkPath) {
-        assertTrue("Mount should have completed", observer.waitForCompletion());
-
-        assertTrue("OBB should be mounted", sm.isObbMounted(file.getPath()));
-
-        if (checkPath) {
-            assertEquals("Actual file and resolved file should be the same", file.getPath(),
-                    observer.getPath());
-        }
-
-        assertEquals(expectedState, observer.getState());
-    }
-
-    private String checkMountedPath(final StorageManager sm, final File file) {
-        final String mountPath = sm.getMountedObbPath(file.getPath());
-        assertStartsWith("Path should be in " + OBB_MOUNT_PREFIX,
-                OBB_MOUNT_PREFIX,
-                mountPath);
-        return mountPath;
-    }
-
-    private void unmountObb(final StorageManager sm, final File file, int expectedState) {
-        final ObbObserver observer = new ObbObserver();
-
-        assertTrue("unmountObb call on test1.obb should succeed",
-                sm.unmountObb(file.getPath(), false, observer));
-
-        assertTrue("Unmount should have completed",
-                observer.waitForCompletion());
-
-        assertEquals(expectedState, observer.getState());
-
-        if (expectedState == OnObbStateChangeListener.UNMOUNTED) {
-            assertFalse("OBB should not be mounted", sm.isObbMounted(file.getPath()));
-        }
-    }
-
-    @LargeTest
-    public void testMountAndUnmountObbNormal() {
-        StorageManager sm = getStorageManager();
-
-        final File outFile = getFilePath("test1.obb");
-
-        mountObb(sm, R.raw.test1, outFile, OnObbStateChangeListener.MOUNTED);
-
-        mountObb(sm, R.raw.test1, outFile, OnObbStateChangeListener.ERROR_ALREADY_MOUNTED);
-
-        final String mountPath = checkMountedPath(sm, outFile);
-        final File mountDir = new File(mountPath);
-
-        assertTrue("OBB mounted path should be a directory",
-                mountDir.isDirectory());
-
-        unmountObb(sm, outFile, OnObbStateChangeListener.UNMOUNTED);
-    }
-
-    @LargeTest
-    public void testAttemptMountNonObb() {
-        StorageManager sm = getStorageManager();
-
-        final File outFile = getFilePath("test1_nosig.obb");
-
-        mountObb(sm, R.raw.test1_nosig, outFile, OnObbStateChangeListener.ERROR_INTERNAL);
-
-        assertFalse("OBB should not be mounted",
-                sm.isObbMounted(outFile.getPath()));
-
-        assertNull("OBB's mounted path should be null",
-                sm.getMountedObbPath(outFile.getPath()));
-    }
-
-    @LargeTest
-    public void testAttemptMountObbWrongPackage() {
-        StorageManager sm = getStorageManager();
-
-        final File outFile = getFilePath("test1_wrongpackage.obb");
-
-        mountObb(sm, R.raw.test1_wrongpackage, outFile,
-                OnObbStateChangeListener.ERROR_PERMISSION_DENIED);
-
-        assertFalse("OBB should not be mounted",
-                sm.isObbMounted(outFile.getPath()));
-
-        assertNull("OBB's mounted path should be null",
-                sm.getMountedObbPath(outFile.getPath()));
-    }
-
-    @LargeTest
-    public void testMountAndUnmountTwoObbs() {
-        StorageManager sm = getStorageManager();
-
-        final File file1 = getFilePath("test1.obb");
-        final File file2 = getFilePath("test2.obb");
-
-        ObbObserver oo1 = mountObbWithoutWait(sm, R.raw.test1, file1);
-        ObbObserver oo2 = mountObbWithoutWait(sm, R.raw.test1, file2);
-
-        Log.d(TAG, "Waiting for OBB #1 to complete mount");
-        waitForObbActionCompletion(sm, file1, oo1, OnObbStateChangeListener.MOUNTED, false);
-        Log.d(TAG, "Waiting for OBB #2 to complete mount");
-        waitForObbActionCompletion(sm, file2, oo2, OnObbStateChangeListener.MOUNTED, false);
-
-        final String mountPath1 = checkMountedPath(sm, file1);
-        final File mountDir1 = new File(mountPath1);
-        assertTrue("OBB mounted path should be a directory", mountDir1.isDirectory());
-
-        final String mountPath2 = checkMountedPath(sm, file2);
-        final File mountDir2 = new File(mountPath2);
-        assertTrue("OBB mounted path should be a directory", mountDir2.isDirectory());
-
-        unmountObb(sm, file1, OnObbStateChangeListener.UNMOUNTED);
-        unmountObb(sm, file2, OnObbStateChangeListener.UNMOUNTED);
-    }
-}
diff --git a/services/tests/servicestests/src/com/android/server/NativeDaemonConnectorTest.java b/services/tests/servicestests/src/com/android/server/NativeDaemonConnectorTest.java
deleted file mode 100644
index e2253a2151b..00000000000
--- a/services/tests/servicestests/src/com/android/server/NativeDaemonConnectorTest.java
+++ /dev/null
@@ -1,97 +0,0 @@
-/*
- * Copyright (C) 2011 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.android.server;
-
-import static com.android.server.NativeDaemonConnector.appendEscaped;
-import static com.android.server.NativeDaemonConnector.makeCommand;
-
-import android.test.AndroidTestCase;
-import android.test.suitebuilder.annotation.MediumTest;
-
-import com.android.server.NativeDaemonConnector.SensitiveArg;
-
-/**
- * Tests for {@link NativeDaemonConnector}.
- */
-@MediumTest
-public class NativeDaemonConnectorTest extends AndroidTestCase {
-    private static final String TAG = "NativeDaemonConnectorTest";
-
-    public void testArgumentNormal() throws Exception {
-        final StringBuilder builder = new StringBuilder();
-
-        builder.setLength(0);
-        appendEscaped(builder, "");
-        assertEquals("", builder.toString());
-
-        builder.setLength(0);
-        appendEscaped(builder, "foo");
-        assertEquals("foo", builder.toString());
-
-        builder.setLength(0);
-        appendEscaped(builder, "foo\"bar");
-        assertEquals("foo\\\"bar", builder.toString());
-
-        builder.setLength(0);
-        appendEscaped(builder, "foo\\bar\\\"baz");
-        assertEquals("foo\\\\bar\\\\\\\"baz", builder.toString());
-    }
-
-    public void testArgumentWithSpaces() throws Exception {
-        final StringBuilder builder = new StringBuilder();
-
-        builder.setLength(0);
-        appendEscaped(builder, "foo bar");
-        assertEquals("\"foo bar\"", builder.toString());
-
-        builder.setLength(0);
-        appendEscaped(builder, "foo\"bar\\baz foo");
-        assertEquals("\"foo\\\"bar\\\\baz foo\"", builder.toString());
-    }
-
-    public void testArgumentWithUtf() throws Exception {
-        final StringBuilder builder = new StringBuilder();
-
-        builder.setLength(0);
-        appendEscaped(builder, "caf\u00E9 c\u00F6ffee");
-        assertEquals("\"caf\u00E9 c\u00F6ffee\"", builder.toString());
-    }
-
-    public void testSensitiveArgs() throws Exception {
-        final StringBuilder rawBuilder = new StringBuilder();
-        final StringBuilder logBuilder = new StringBuilder();
-
-        rawBuilder.setLength(0);
-        logBuilder.setLength(0);
-        makeCommand(rawBuilder, logBuilder, 1, "foo", "bar", "baz");
-        assertEquals("1 foo bar baz\0", rawBuilder.toString());
-        assertEquals("1 foo bar baz", logBuilder.toString());
-
-        rawBuilder.setLength(0);
-        logBuilder.setLength(0);
-        makeCommand(rawBuilder, logBuilder, 1, "foo", new SensitiveArg("bar"), "baz");
-        assertEquals("1 foo bar baz\0", rawBuilder.toString());
-        assertEquals("1 foo [scrubbed] baz", logBuilder.toString());
-
-        rawBuilder.setLength(0);
-        logBuilder.setLength(0);
-        makeCommand(rawBuilder, logBuilder, 1, "foo", new SensitiveArg("foo bar"), "baz baz",
-                new SensitiveArg("wat"));
-        assertEquals("1 foo \"foo bar\" \"baz baz\" wat\0", rawBuilder.toString());
-        assertEquals("1 foo [scrubbed] \"baz baz\" [scrubbed]", logBuilder.toString());
-    }
-}
diff --git a/services/tests/servicestests/src/com/android/server/NetworkManagementServiceTest.java b/services/tests/servicestests/src/com/android/server/NetworkManagementServiceTest.java
deleted file mode 100644
index 0d5daa5def9..00000000000
--- a/services/tests/servicestests/src/com/android/server/NetworkManagementServiceTest.java
+++ /dev/null
@@ -1,226 +0,0 @@
-/*
- * Copyright (C) 2012 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.android.server;
-
-import android.content.Context;
-import android.net.LinkAddress;
-import android.net.LocalSocket;
-import android.net.LocalServerSocket;
-import android.os.Binder;
-import android.test.AndroidTestCase;
-import android.test.suitebuilder.annotation.LargeTest;
-import com.android.server.net.BaseNetworkObserver;
-
-import static org.mockito.Mockito.doReturn;
-import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.reset;
-import static org.mockito.Mockito.timeout;
-import static org.mockito.Mockito.verify;
-import static org.mockito.Mockito.verifyNoMoreInteractions;
-
-import java.io.IOException;
-import java.io.OutputStream;
-
-/**
- * Tests for {@link NetworkManagementService}.
- */
-@LargeTest
-public class NetworkManagementServiceTest extends AndroidTestCase {
-
-    private static final String SOCKET_NAME = "__test__NetworkManagementServiceTest";
-    private NetworkManagementService mNMService;
-    private LocalServerSocket mServerSocket;
-    private LocalSocket mSocket;
-    private OutputStream mOutputStream;
-
-    @Override
-    public void setUp() throws Exception {
-        super.setUp();
-        // TODO: make this unnecessary. runtest might already make it unnecessary.
-        System.setProperty("dexmaker.dexcache", getContext().getCacheDir().toString());
-
-        // Set up a sheltered test environment.
-        BroadcastInterceptingContext context = new BroadcastInterceptingContext(getContext());
-        mServerSocket = new LocalServerSocket(SOCKET_NAME);
-
-        // Start the service and wait until it connects to our socket.
-        mNMService = NetworkManagementService.create(context, SOCKET_NAME);
-        mSocket = mServerSocket.accept();
-        mOutputStream = mSocket.getOutputStream();
-    }
-
-    @Override
-    public void tearDown() throws Exception {
-        if (mSocket != null) mSocket.close();
-        if (mServerSocket != null) mServerSocket.close();
-        super.tearDown();
-    }
-
-    /**
-     * Sends a message on the netd socket and gives the events some time to make it back.
-     */
-    private void sendMessage(String message) throws IOException {
-        // Strings are null-terminated, so add "\0" at the end.
-        mOutputStream.write((message + "\0").getBytes());
-    }
-
-    private static <T> T expectSoon(T mock) {
-        return verify(mock, timeout(100));
-    }
-
-    /**
-     * Tests that network observers work properly.
-     */
-    public void testNetworkObservers() throws Exception {
-        BaseNetworkObserver observer = mock(BaseNetworkObserver.class);
-        doReturn(new Binder()).when(observer).asBinder();  // Used by registerObserver.
-        mNMService.registerObserver(observer);
-
-        // Forget everything that happened to the mock so far, so we can explicitly verify
-        // everything that happens and does not happen to it from now on.
-        reset(observer);
-
-        // Now send NetworkManagementService messages and ensure that the observer methods are
-        // called. After every valid message we expect a callback soon after; to ensure that
-        // invalid messages don't cause any callbacks, we call verifyNoMoreInteractions at the end.
-
-        /**
-         * Interface changes.
-         */
-        sendMessage("600 Iface added rmnet12");
-        expectSoon(observer).interfaceAdded("rmnet12");
-
-        sendMessage("600 Iface removed eth1");
-        expectSoon(observer).interfaceRemoved("eth1");
-
-        sendMessage("607 Iface removed eth1");
-        // Invalid code.
-
-        sendMessage("600 Iface borked lo down");
-        // Invalid event.
-
-        sendMessage("600 Iface changed clat4 up again");
-        // Extra tokens.
-
-        sendMessage("600 Iface changed clat4 up");
-        expectSoon(observer).interfaceStatusChanged("clat4", true);
-
-        sendMessage("600 Iface linkstate rmnet0 down");
-        expectSoon(observer).interfaceLinkStateChanged("rmnet0", false);
-
-        sendMessage("600 IFACE linkstate clat4 up");
-        // Invalid group.
-
-        /**
-         * Bandwidth control events.
-         */
-        sendMessage("601 limit alert data rmnet_usb0");
-        expectSoon(observer).limitReached("data", "rmnet_usb0");
-
-        sendMessage("601 invalid alert data rmnet0");
-        // Invalid group.
-
-        sendMessage("601 limit increased data rmnet0");
-        // Invalid event.
-
-
-        /**
-         * Interface class activity.
-         */
-
-        sendMessage("613 IfaceClass active rmnet0");
-        expectSoon(observer).interfaceClassDataActivityChanged("rmnet0", true, 0);
-
-        sendMessage("613 IfaceClass active rmnet0 1234");
-        expectSoon(observer).interfaceClassDataActivityChanged("rmnet0", true, 1234);
-
-        sendMessage("613 IfaceClass idle eth0");
-        expectSoon(observer).interfaceClassDataActivityChanged("eth0", false, 0);
-
-        sendMessage("613 IfaceClass idle eth0 1234");
-        expectSoon(observer).interfaceClassDataActivityChanged("eth0", false, 1234);
-
-        sendMessage("613 IfaceClass reallyactive rmnet0 1234");
-        expectSoon(observer).interfaceClassDataActivityChanged("rmnet0", false, 1234);
-
-        sendMessage("613 InterfaceClass reallyactive rmnet0");
-        // Invalid group.
-
-
-        /**
-         * IP address changes.
-         */
-        sendMessage("614 Address updated fe80::1/64 wlan0 128 253");
-        expectSoon(observer).addressUpdated("wlan0", new LinkAddress("fe80::1/64", 128, 253));
-
-        // There is no "added", so we take this as "removed".
-        sendMessage("614 Address added fe80::1/64 wlan0 128 253");
-        expectSoon(observer).addressRemoved("wlan0", new LinkAddress("fe80::1/64", 128, 253));
-
-        sendMessage("614 Address removed 2001:db8::1/64 wlan0 1 0");
-        expectSoon(observer).addressRemoved("wlan0", new LinkAddress("2001:db8::1/64", 1, 0));
-
-        sendMessage("614 Address removed 2001:db8::1/64 wlan0 1");
-        // Not enough arguments.
-
-        sendMessage("666 Address removed 2001:db8::1/64 wlan0 1 0");
-        // Invalid code.
-
-
-        /**
-         * DNS information broadcasts.
-         */
-        sendMessage("615 DnsInfo servers rmnet_usb0 3600 2001:db8::1");
-        expectSoon(observer).interfaceDnsServerInfo("rmnet_usb0", 3600,
-                new String[]{"2001:db8::1"});
-
-        sendMessage("615 DnsInfo servers wlan0 14400 2001:db8::1,2001:db8::2");
-        expectSoon(observer).interfaceDnsServerInfo("wlan0", 14400,
-                new String[]{"2001:db8::1", "2001:db8::2"});
-
-        // We don't check for negative lifetimes, only for parse errors.
-        sendMessage("615 DnsInfo servers wlan0 -3600 ::1");
-        expectSoon(observer).interfaceDnsServerInfo("wlan0", -3600,
-                new String[]{"::1"});
-
-        sendMessage("615 DnsInfo servers wlan0 SIXHUNDRED ::1");
-        // Non-numeric lifetime.
-
-        sendMessage("615 DnsInfo servers wlan0 2001:db8::1");
-        // Missing lifetime.
-
-        sendMessage("615 DnsInfo servers wlan0 3600");
-        // No servers.
-
-        sendMessage("615 DnsInfo servers 3600 wlan0 2001:db8::1,2001:db8::2");
-        // Non-numeric lifetime.
-
-        sendMessage("615 DnsInfo wlan0 7200 2001:db8::1,2001:db8::2");
-        // Invalid tokens.
-
-        sendMessage("666 DnsInfo servers wlan0 5400 2001:db8::1");
-        // Invalid code.
-
-        // No syntax checking on the addresses.
-        sendMessage("615 DnsInfo servers wlan0 600 ,::,,foo,::1,");
-        expectSoon(observer).interfaceDnsServerInfo("wlan0", 600,
-                new String[]{"", "::", "", "foo", "::1"});
-
-        // Make sure nothing else was called.
-        verifyNoMoreInteractions(observer);
-    }
-}
diff --git a/services/tests/servicestests/src/com/android/server/NetworkPolicyManagerServiceTest.java b/services/tests/servicestests/src/com/android/server/NetworkPolicyManagerServiceTest.java
deleted file mode 100644
index 541be3dad37..00000000000
--- a/services/tests/servicestests/src/com/android/server/NetworkPolicyManagerServiceTest.java
+++ /dev/null
@@ -1,1014 +0,0 @@
-/*
- * Copyright (C) 2011 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.android.server;
-
-import static android.content.Intent.ACTION_UID_REMOVED;
-import static android.content.Intent.EXTRA_UID;
-import static android.net.ConnectivityManager.CONNECTIVITY_ACTION;
-import static android.net.ConnectivityManager.TYPE_WIFI;
-import static android.net.NetworkPolicy.CYCLE_NONE;
-import static android.net.NetworkPolicy.LIMIT_DISABLED;
-import static android.net.NetworkPolicy.WARNING_DISABLED;
-import static android.net.NetworkPolicyManager.POLICY_NONE;
-import static android.net.NetworkPolicyManager.POLICY_REJECT_METERED_BACKGROUND;
-import static android.net.NetworkPolicyManager.RULE_ALLOW_ALL;
-import static android.net.NetworkPolicyManager.RULE_REJECT_METERED;
-import static android.net.NetworkPolicyManager.computeLastCycleBoundary;
-import static android.net.NetworkPolicyManager.computeNextCycleBoundary;
-import static android.net.TrafficStats.KB_IN_BYTES;
-import static android.net.TrafficStats.MB_IN_BYTES;
-import static android.text.format.DateUtils.DAY_IN_MILLIS;
-import static android.text.format.DateUtils.MINUTE_IN_MILLIS;
-import static android.text.format.Time.TIMEZONE_UTC;
-import static com.android.server.net.NetworkPolicyManagerService.TYPE_LIMIT;
-import static com.android.server.net.NetworkPolicyManagerService.TYPE_LIMIT_SNOOZED;
-import static com.android.server.net.NetworkPolicyManagerService.TYPE_WARNING;
-import static org.easymock.EasyMock.anyInt;
-import static org.easymock.EasyMock.anyLong;
-import static org.easymock.EasyMock.aryEq;
-import static org.easymock.EasyMock.capture;
-import static org.easymock.EasyMock.createMock;
-import static org.easymock.EasyMock.eq;
-import static org.easymock.EasyMock.expect;
-import static org.easymock.EasyMock.expectLastCall;
-import static org.easymock.EasyMock.isA;
-
-import android.app.IActivityManager;
-import android.app.INotificationManager;
-import android.app.IProcessObserver;
-import android.app.Notification;
-import android.content.Intent;
-import android.content.pm.PackageInfo;
-import android.content.pm.PackageManager;
-import android.content.pm.Signature;
-import android.net.ConnectivityManager;
-import android.net.IConnectivityManager;
-import android.net.INetworkManagementEventObserver;
-import android.net.INetworkPolicyListener;
-import android.net.INetworkStatsService;
-import android.net.LinkProperties;
-import android.net.NetworkInfo;
-import android.net.NetworkInfo.DetailedState;
-import android.net.NetworkPolicy;
-import android.net.NetworkState;
-import android.net.NetworkStats;
-import android.net.NetworkTemplate;
-import android.os.Binder;
-import android.os.INetworkManagementService;
-import android.os.MessageQueue.IdleHandler;
-import android.os.UserHandle;
-import android.test.AndroidTestCase;
-import android.test.mock.MockPackageManager;
-import android.test.suitebuilder.annotation.LargeTest;
-import android.test.suitebuilder.annotation.Suppress;
-import android.text.format.Time;
-import android.util.TrustedTime;
-
-import com.android.server.net.NetworkPolicyManagerService;
-import com.google.common.util.concurrent.AbstractFuture;
-
-import org.easymock.Capture;
-import org.easymock.EasyMock;
-import org.easymock.IAnswer;
-
-import java.io.File;
-import java.util.Calendar;
-import java.util.LinkedHashSet;
-import java.util.TimeZone;
-import java.util.concurrent.ExecutionException;
-import java.util.concurrent.Future;
-import java.util.concurrent.TimeUnit;
-import java.util.concurrent.TimeoutException;
-import java.util.logging.Handler;
-
-import libcore.io.IoUtils;
-
-/**
- * Tests for {@link NetworkPolicyManagerService}.
- */
-@LargeTest
-public class NetworkPolicyManagerServiceTest extends AndroidTestCase {
-    private static final String TAG = "NetworkPolicyManagerServiceTest";
-
-    private static final long TEST_START = 1194220800000L;
-    private static final String TEST_IFACE = "test0";
-    private static final String TEST_SSID = "AndroidAP";
-
-    private static NetworkTemplate sTemplateWifi = NetworkTemplate.buildTemplateWifi(TEST_SSID);
-
-    private BroadcastInterceptingContext mServiceContext;
-    private File mPolicyDir;
-
-    private IActivityManager mActivityManager;
-    private INetworkStatsService mStatsService;
-    private INetworkManagementService mNetworkManager;
-    private INetworkPolicyListener mPolicyListener;
-    private TrustedTime mTime;
-    private IConnectivityManager mConnManager;
-    private INotificationManager mNotifManager;
-
-    private NetworkPolicyManagerService mService;
-    private IProcessObserver mProcessObserver;
-    private INetworkManagementEventObserver mNetworkObserver;
-
-    private Binder mStubBinder = new Binder();
-
-    private long mStartTime;
-    private long mElapsedRealtime;
-
-    private static final int USER_ID = 0;
-
-    private static final int APP_ID_A = android.os.Process.FIRST_APPLICATION_UID + 800;
-    private static final int APP_ID_B = android.os.Process.FIRST_APPLICATION_UID + 801;
-
-    private static final int UID_A = UserHandle.getUid(USER_ID, APP_ID_A);
-    private static final int UID_B = UserHandle.getUid(USER_ID, APP_ID_B);
-
-    private static final int PID_1 = 400;
-    private static final int PID_2 = 401;
-    private static final int PID_3 = 402;
-
-    public void _setUp() throws Exception {
-        super.setUp();
-
-        setCurrentTimeMillis(TEST_START);
-
-        // intercept various broadcasts, and pretend that uids have packages
-        mServiceContext = new BroadcastInterceptingContext(getContext()) {
-            @Override
-            public PackageManager getPackageManager() {
-                return new MockPackageManager() {
-                    @Override
-                    public String[] getPackagesForUid(int uid) {
-                        return new String[] { "com.example" };
-                    }
-
-                    @Override
-                    public PackageInfo getPackageInfo(String packageName, int flags) {
-                        final PackageInfo info = new PackageInfo();
-                        final Signature signature;
-                        if ("android".equals(packageName)) {
-                            signature = new Signature("F00D");
-                        } else {
-                            signature = new Signature("DEAD");
-                        }
-                        info.signatures = new Signature[] { signature };
-                        return info;
-                    }
-
-                };
-            }
-
-            @Override
-            public void startActivity(Intent intent) {
-                // ignored
-            }
-        };
-
-        mPolicyDir = getContext().getFilesDir();
-        if (mPolicyDir.exists()) {
-            IoUtils.deleteContents(mPolicyDir);
-        }
-
-        mActivityManager = createMock(IActivityManager.class);
-        mStatsService = createMock(INetworkStatsService.class);
-        mNetworkManager = createMock(INetworkManagementService.class);
-        mPolicyListener = createMock(INetworkPolicyListener.class);
-        mTime = createMock(TrustedTime.class);
-        mConnManager = createMock(IConnectivityManager.class);
-        mNotifManager = createMock(INotificationManager.class);
-
-        mService = new NetworkPolicyManagerService(mServiceContext, mActivityManager,
-                mStatsService, mNetworkManager, mTime, mPolicyDir, true);
-        mService.bindConnectivityManager(mConnManager);
-        mService.bindNotificationManager(mNotifManager);
-
-        // RemoteCallbackList needs a binder to use as key
-        expect(mPolicyListener.asBinder()).andReturn(mStubBinder).atLeastOnce();
-        replay();
-        mService.registerListener(mPolicyListener);
-        verifyAndReset();
-
-        // catch IProcessObserver during systemReady()
-        final Capture<IProcessObserver> processObserver = new Capture<IProcessObserver>();
-        mActivityManager.registerProcessObserver(capture(processObserver));
-        expectLastCall().atLeastOnce();
-
-        // catch INetworkManagementEventObserver during systemReady()
-        final Capture<INetworkManagementEventObserver> networkObserver = new Capture<
-                INetworkManagementEventObserver>();
-        mNetworkManager.registerObserver(capture(networkObserver));
-        expectLastCall().atLeastOnce();
-
-        expect(mNetworkManager.isBandwidthControlEnabled()).andReturn(true).atLeastOnce();
-        expectCurrentTime();
-
-        replay();
-        mService.systemReady();
-        verifyAndReset();
-
-        mProcessObserver = processObserver.getValue();
-        mNetworkObserver = networkObserver.getValue();
-
-    }
-
-    public void _tearDown() throws Exception {
-        for (File file : mPolicyDir.listFiles()) {
-            file.delete();
-        }
-
-        mServiceContext = null;
-        mPolicyDir = null;
-
-        mActivityManager = null;
-        mStatsService = null;
-        mPolicyListener = null;
-        mTime = null;
-
-        mService = null;
-        mProcessObserver = null;
-
-        super.tearDown();
-    }
-
-    @Suppress
-    public void testPolicyChangeTriggersBroadcast() throws Exception {
-        mService.setUidPolicy(APP_ID_A, POLICY_NONE);
-
-        // change background policy and expect broadcast
-        final Future<Intent> backgroundChanged = mServiceContext.nextBroadcastIntent(
-                ConnectivityManager.ACTION_BACKGROUND_DATA_SETTING_CHANGED);
-
-        mService.setUidPolicy(APP_ID_A, POLICY_REJECT_METERED_BACKGROUND);
-
-        backgroundChanged.get();
-    }
-
-    @Suppress
-    public void testPidForegroundCombined() throws Exception {
-        IdleFuture idle;
-
-        // push all uid into background
-        idle = expectIdle();
-        mProcessObserver.onForegroundActivitiesChanged(PID_1, UID_A, false);
-        mProcessObserver.onForegroundActivitiesChanged(PID_2, UID_A, false);
-        mProcessObserver.onForegroundActivitiesChanged(PID_3, UID_B, false);
-        idle.get();
-        assertFalse(mService.isUidForeground(UID_A));
-        assertFalse(mService.isUidForeground(UID_B));
-
-        // push one of the shared pids into foreground
-        idle = expectIdle();
-        mProcessObserver.onForegroundActivitiesChanged(PID_2, UID_A, true);
-        idle.get();
-        assertTrue(mService.isUidForeground(UID_A));
-        assertFalse(mService.isUidForeground(UID_B));
-
-        // and swap another uid into foreground
-        idle = expectIdle();
-        mProcessObserver.onForegroundActivitiesChanged(PID_2, UID_A, false);
-        mProcessObserver.onForegroundActivitiesChanged(PID_3, UID_B, true);
-        idle.get();
-        assertFalse(mService.isUidForeground(UID_A));
-        assertTrue(mService.isUidForeground(UID_B));
-
-        // push both pid into foreground
-        idle = expectIdle();
-        mProcessObserver.onForegroundActivitiesChanged(PID_1, UID_A, true);
-        mProcessObserver.onForegroundActivitiesChanged(PID_2, UID_A, true);
-        idle.get();
-        assertTrue(mService.isUidForeground(UID_A));
-
-        // pull one out, should still be foreground
-        idle = expectIdle();
-        mProcessObserver.onForegroundActivitiesChanged(PID_1, UID_A, false);
-        idle.get();
-        assertTrue(mService.isUidForeground(UID_A));
-
-        // pull final pid out, should now be background
-        idle = expectIdle();
-        mProcessObserver.onForegroundActivitiesChanged(PID_2, UID_A, false);
-        idle.get();
-        assertFalse(mService.isUidForeground(UID_A));
-    }
-
-    @Suppress
-    public void testPolicyNone() throws Exception {
-        Future<Void> future;
-
-        expectSetUidMeteredNetworkBlacklist(UID_A, false);
-        expectSetUidForeground(UID_A, true);
-        future = expectRulesChanged(UID_A, RULE_ALLOW_ALL);
-        replay();
-        mProcessObserver.onForegroundActivitiesChanged(PID_1, UID_A, true);
-        future.get();
-        verifyAndReset();
-
-        // POLICY_NONE should RULE_ALLOW in foreground
-        expectSetUidMeteredNetworkBlacklist(UID_A, false);
-        expectSetUidForeground(UID_A, true);
-        future = expectRulesChanged(UID_A, RULE_ALLOW_ALL);
-        replay();
-        mService.setUidPolicy(APP_ID_A, POLICY_NONE);
-        future.get();
-        verifyAndReset();
-
-        // POLICY_NONE should RULE_ALLOW in background
-        expectSetUidMeteredNetworkBlacklist(UID_A, false);
-        expectSetUidForeground(UID_A, false);
-        future = expectRulesChanged(UID_A, RULE_ALLOW_ALL);
-        replay();
-        mProcessObserver.onForegroundActivitiesChanged(PID_1, UID_A, false);
-        future.get();
-        verifyAndReset();
-    }
-
-    @Suppress
-    public void testPolicyReject() throws Exception {
-        Future<Void> future;
-
-        // POLICY_REJECT should RULE_ALLOW in background
-        expectSetUidMeteredNetworkBlacklist(UID_A, true);
-        expectSetUidForeground(UID_A, false);
-        future = expectRulesChanged(UID_A, RULE_REJECT_METERED);
-        replay();
-        mService.setUidPolicy(APP_ID_A, POLICY_REJECT_METERED_BACKGROUND);
-        future.get();
-        verifyAndReset();
-
-        // POLICY_REJECT should RULE_ALLOW in foreground
-        expectSetUidMeteredNetworkBlacklist(UID_A, false);
-        expectSetUidForeground(UID_A, true);
-        future = expectRulesChanged(UID_A, RULE_ALLOW_ALL);
-        replay();
-        mProcessObserver.onForegroundActivitiesChanged(PID_1, UID_A, true);
-        future.get();
-        verifyAndReset();
-
-        // POLICY_REJECT should RULE_REJECT in background
-        expectSetUidMeteredNetworkBlacklist(UID_A, true);
-        expectSetUidForeground(UID_A, false);
-        future = expectRulesChanged(UID_A, RULE_REJECT_METERED);
-        replay();
-        mProcessObserver.onForegroundActivitiesChanged(PID_1, UID_A, false);
-        future.get();
-        verifyAndReset();
-    }
-
-    @Suppress
-    public void testPolicyRejectAddRemove() throws Exception {
-        Future<Void> future;
-
-        // POLICY_NONE should have RULE_ALLOW in background
-        expectSetUidMeteredNetworkBlacklist(UID_A, false);
-        expectSetUidForeground(UID_A, false);
-        future = expectRulesChanged(UID_A, RULE_ALLOW_ALL);
-        replay();
-        mProcessObserver.onForegroundActivitiesChanged(PID_1, UID_A, false);
-        mService.setUidPolicy(APP_ID_A, POLICY_NONE);
-        future.get();
-        verifyAndReset();
-
-        // adding POLICY_REJECT should cause RULE_REJECT
-        expectSetUidMeteredNetworkBlacklist(UID_A, true);
-        expectSetUidForeground(UID_A, false);
-        future = expectRulesChanged(UID_A, RULE_REJECT_METERED);
-        replay();
-        mService.setUidPolicy(APP_ID_A, POLICY_REJECT_METERED_BACKGROUND);
-        future.get();
-        verifyAndReset();
-
-        // removing POLICY_REJECT should return us to RULE_ALLOW
-        expectSetUidMeteredNetworkBlacklist(UID_A, false);
-        expectSetUidForeground(UID_A, false);
-        future = expectRulesChanged(UID_A, RULE_ALLOW_ALL);
-        replay();
-        mService.setUidPolicy(APP_ID_A, POLICY_NONE);
-        future.get();
-        verifyAndReset();
-    }
-
-    public void testLastCycleBoundaryThisMonth() throws Exception {
-        // assume cycle day of "5th", which should be in same month
-        final long currentTime = parseTime("2007-11-14T00:00:00.000Z");
-        final long expectedCycle = parseTime("2007-11-05T00:00:00.000Z");
-
-        final NetworkPolicy policy = new NetworkPolicy(
-                sTemplateWifi, 5, TIMEZONE_UTC, 1024L, 1024L, false);
-        final long actualCycle = computeLastCycleBoundary(currentTime, policy);
-        assertTimeEquals(expectedCycle, actualCycle);
-    }
-
-    public void testLastCycleBoundaryLastMonth() throws Exception {
-        // assume cycle day of "20th", which should be in last month
-        final long currentTime = parseTime("2007-11-14T00:00:00.000Z");
-        final long expectedCycle = parseTime("2007-10-20T00:00:00.000Z");
-
-        final NetworkPolicy policy = new NetworkPolicy(
-                sTemplateWifi, 20, TIMEZONE_UTC, 1024L, 1024L, false);
-        final long actualCycle = computeLastCycleBoundary(currentTime, policy);
-        assertTimeEquals(expectedCycle, actualCycle);
-    }
-
-    public void testLastCycleBoundaryThisMonthFebruary() throws Exception {
-        // assume cycle day of "30th" in february; should go to january
-        final long currentTime = parseTime("2007-02-14T00:00:00.000Z");
-        final long expectedCycle = parseTime("2007-01-30T00:00:00.000Z");
-
-        final NetworkPolicy policy = new NetworkPolicy(
-                sTemplateWifi, 30, TIMEZONE_UTC, 1024L, 1024L, false);
-        final long actualCycle = computeLastCycleBoundary(currentTime, policy);
-        assertTimeEquals(expectedCycle, actualCycle);
-    }
-
-    public void testLastCycleBoundaryLastMonthFebruary() throws Exception {
-        // assume cycle day of "30th" in february, which should clamp
-        final long currentTime = parseTime("2007-03-14T00:00:00.000Z");
-        final long expectedCycle = parseTime("2007-02-28T23:59:59.000Z");
-
-        final NetworkPolicy policy = new NetworkPolicy(
-                sTemplateWifi, 30, TIMEZONE_UTC, 1024L, 1024L, false);
-        final long actualCycle = computeLastCycleBoundary(currentTime, policy);
-        assertTimeEquals(expectedCycle, actualCycle);
-    }
-
-    public void testCycleBoundaryLeapYear() throws Exception {
-        final NetworkPolicy policy = new NetworkPolicy(
-                sTemplateWifi, 29, TIMEZONE_UTC, 1024L, 1024L, false);
-
-        assertTimeEquals(parseTime("2012-01-29T00:00:00.000Z"),
-                computeNextCycleBoundary(parseTime("2012-01-14T00:00:00.000Z"), policy));
-        assertTimeEquals(parseTime("2012-02-29T00:00:00.000Z"),
-                computeNextCycleBoundary(parseTime("2012-02-14T00:00:00.000Z"), policy));
-        assertTimeEquals(parseTime("2012-02-29T00:00:00.000Z"),
-                computeLastCycleBoundary(parseTime("2012-03-14T00:00:00.000Z"), policy));
-        assertTimeEquals(parseTime("2012-03-29T00:00:00.000Z"),
-                computeNextCycleBoundary(parseTime("2012-03-14T00:00:00.000Z"), policy));
-
-        assertTimeEquals(parseTime("2007-01-29T00:00:00.000Z"),
-                computeNextCycleBoundary(parseTime("2007-01-14T00:00:00.000Z"), policy));
-        assertTimeEquals(parseTime("2007-02-28T23:59:59.000Z"),
-                computeNextCycleBoundary(parseTime("2007-02-14T00:00:00.000Z"), policy));
-        assertTimeEquals(parseTime("2007-02-28T23:59:59.000Z"),
-                computeLastCycleBoundary(parseTime("2007-03-14T00:00:00.000Z"), policy));
-        assertTimeEquals(parseTime("2007-03-29T00:00:00.000Z"),
-                computeNextCycleBoundary(parseTime("2007-03-14T00:00:00.000Z"), policy));
-    }
-
-    public void testNextCycleTimezoneAfterUtc() throws Exception {
-        // US/Central is UTC-6
-        final NetworkPolicy policy = new NetworkPolicy(
-                sTemplateWifi, 10, "US/Central", 1024L, 1024L, false);
-        assertTimeEquals(parseTime("2012-01-10T06:00:00.000Z"),
-                computeNextCycleBoundary(parseTime("2012-01-05T00:00:00.000Z"), policy));
-    }
-
-    public void testNextCycleTimezoneBeforeUtc() throws Exception {
-        // Israel is UTC+2
-        final NetworkPolicy policy = new NetworkPolicy(
-                sTemplateWifi, 10, "Israel", 1024L, 1024L, false);
-        assertTimeEquals(parseTime("2012-01-09T22:00:00.000Z"),
-                computeNextCycleBoundary(parseTime("2012-01-05T00:00:00.000Z"), policy));
-    }
-
-    public void testNextCycleSane() throws Exception {
-        final NetworkPolicy policy = new NetworkPolicy(
-                sTemplateWifi, 31, TIMEZONE_UTC, WARNING_DISABLED, LIMIT_DISABLED, false);
-        final LinkedHashSet<Long> seen = new LinkedHashSet<Long>();
-
-        // walk forwards, ensuring that cycle boundaries don't get stuck
-        long currentCycle = computeNextCycleBoundary(parseTime("2011-08-01T00:00:00.000Z"), policy);
-        for (int i = 0; i < 128; i++) {
-            long nextCycle = computeNextCycleBoundary(currentCycle, policy);
-            assertEqualsFuzzy(DAY_IN_MILLIS * 30, nextCycle - currentCycle, DAY_IN_MILLIS * 3);
-            assertUnique(seen, nextCycle);
-            currentCycle = nextCycle;
-        }
-    }
-
-    public void testLastCycleSane() throws Exception {
-        final NetworkPolicy policy = new NetworkPolicy(
-                sTemplateWifi, 31, TIMEZONE_UTC, WARNING_DISABLED, LIMIT_DISABLED, false);
-        final LinkedHashSet<Long> seen = new LinkedHashSet<Long>();
-
-        // walk backwards, ensuring that cycle boundaries look sane
-        long currentCycle = computeLastCycleBoundary(parseTime("2011-08-04T00:00:00.000Z"), policy);
-        for (int i = 0; i < 128; i++) {
-            long lastCycle = computeLastCycleBoundary(currentCycle, policy);
-            assertEqualsFuzzy(DAY_IN_MILLIS * 30, currentCycle - lastCycle, DAY_IN_MILLIS * 3);
-            assertUnique(seen, lastCycle);
-            currentCycle = lastCycle;
-        }
-    }
-
-    public void testCycleTodayJanuary() throws Exception {
-        final NetworkPolicy policy = new NetworkPolicy(
-                sTemplateWifi, 14, "US/Pacific", 1024L, 1024L, false);
-
-        assertTimeEquals(parseTime("2013-01-14T00:00:00.000-08:00"),
-                computeNextCycleBoundary(parseTime("2013-01-13T23:59:59.000-08:00"), policy));
-        assertTimeEquals(parseTime("2013-02-14T00:00:00.000-08:00"),
-                computeNextCycleBoundary(parseTime("2013-01-14T00:00:01.000-08:00"), policy));
-        assertTimeEquals(parseTime("2013-02-14T00:00:00.000-08:00"),
-                computeNextCycleBoundary(parseTime("2013-01-14T15:11:00.000-08:00"), policy));
-
-        assertTimeEquals(parseTime("2012-12-14T00:00:00.000-08:00"),
-                computeLastCycleBoundary(parseTime("2013-01-13T23:59:59.000-08:00"), policy));
-        assertTimeEquals(parseTime("2013-01-14T00:00:00.000-08:00"),
-                computeLastCycleBoundary(parseTime("2013-01-14T00:00:01.000-08:00"), policy));
-        assertTimeEquals(parseTime("2013-01-14T00:00:00.000-08:00"),
-                computeLastCycleBoundary(parseTime("2013-01-14T15:11:00.000-08:00"), policy));
-    }
-
-    public void testLastCycleBoundaryDST() throws Exception {
-        final long currentTime = parseTime("1989-01-02T07:30:00.000");
-        final long expectedCycle = parseTime("1988-12-03T02:00:00.000Z");
-
-        final NetworkPolicy policy = new NetworkPolicy(
-                sTemplateWifi, 3, "America/Argentina/Buenos_Aires", 1024L, 1024L, false);
-        final long actualCycle = computeLastCycleBoundary(currentTime, policy);
-        assertTimeEquals(expectedCycle, actualCycle);
-    }
-
-    @Suppress
-    public void testNetworkPolicyAppliedCycleLastMonth() throws Exception {
-        NetworkState[] state = null;
-        NetworkStats stats = null;
-        Future<Void> future;
-
-        final long TIME_FEB_15 = 1171497600000L;
-        final long TIME_MAR_10 = 1173484800000L;
-        final int CYCLE_DAY = 15;
-
-        setCurrentTimeMillis(TIME_MAR_10);
-
-        // first, pretend that wifi network comes online. no policy active,
-        // which means we shouldn't push limit to interface.
-        state = new NetworkState[] { buildWifi() };
-        expect(mConnManager.getAllNetworkState()).andReturn(state).atLeastOnce();
-        expectCurrentTime();
-        expectClearNotifications();
-        expectAdvisePersistThreshold();
-        future = expectMeteredIfacesChanged();
-
-        replay();
-        mServiceContext.sendBroadcast(new Intent(CONNECTIVITY_ACTION));
-        future.get();
-        verifyAndReset();
-
-        // now change cycle to be on 15th, and test in early march, to verify we
-        // pick cycle day in previous month.
-        expect(mConnManager.getAllNetworkState()).andReturn(state).atLeastOnce();
-        expectCurrentTime();
-
-        // pretend that 512 bytes total have happened
-        stats = new NetworkStats(getElapsedRealtime(), 1)
-                .addIfaceValues(TEST_IFACE, 256L, 2L, 256L, 2L);
-        expect(mStatsService.getNetworkTotalBytes(sTemplateWifi, TIME_FEB_15, TIME_MAR_10))
-                .andReturn(stats.getTotalBytes()).atLeastOnce();
-        expectPolicyDataEnable(TYPE_WIFI, true);
-
-        // TODO: consider making strongly ordered mock
-        expectRemoveInterfaceQuota(TEST_IFACE);
-        expectSetInterfaceQuota(TEST_IFACE, (2 * MB_IN_BYTES) - 512);
-
-        expectClearNotifications();
-        expectAdvisePersistThreshold();
-        future = expectMeteredIfacesChanged(TEST_IFACE);
-
-        replay();
-        setNetworkPolicies(new NetworkPolicy(
-                sTemplateWifi, CYCLE_DAY, TIMEZONE_UTC, 1 * MB_IN_BYTES, 2 * MB_IN_BYTES, false));
-        future.get();
-        verifyAndReset();
-    }
-
-    @Suppress
-    public void testUidRemovedPolicyCleared() throws Exception {
-        Future<Void> future;
-
-        // POLICY_REJECT should RULE_REJECT in background
-        expectSetUidMeteredNetworkBlacklist(UID_A, true);
-        expectSetUidForeground(UID_A, false);
-        future = expectRulesChanged(UID_A, RULE_REJECT_METERED);
-        replay();
-        mService.setUidPolicy(APP_ID_A, POLICY_REJECT_METERED_BACKGROUND);
-        future.get();
-        verifyAndReset();
-
-        // uninstall should clear RULE_REJECT
-        expectSetUidMeteredNetworkBlacklist(UID_A, false);
-        expectSetUidForeground(UID_A, false);
-        future = expectRulesChanged(UID_A, RULE_ALLOW_ALL);
-        replay();
-        final Intent intent = new Intent(ACTION_UID_REMOVED);
-        intent.putExtra(EXTRA_UID, UID_A);
-        mServiceContext.sendBroadcast(intent);
-        future.get();
-        verifyAndReset();
-    }
-
-    @Suppress
-    public void testOverWarningLimitNotification() throws Exception {
-        NetworkState[] state = null;
-        NetworkStats stats = null;
-        Future<Void> future;
-        Future<String> tagFuture;
-
-        final long TIME_FEB_15 = 1171497600000L;
-        final long TIME_MAR_10 = 1173484800000L;
-        final int CYCLE_DAY = 15;
-
-        setCurrentTimeMillis(TIME_MAR_10);
-
-        // assign wifi policy
-        state = new NetworkState[] {};
-        stats = new NetworkStats(getElapsedRealtime(), 1)
-                .addIfaceValues(TEST_IFACE, 0L, 0L, 0L, 0L);
-
-        {
-            expectCurrentTime();
-            expect(mConnManager.getAllNetworkState()).andReturn(state).atLeastOnce();
-            expect(mStatsService.getNetworkTotalBytes(sTemplateWifi, TIME_FEB_15, currentTimeMillis()))
-                    .andReturn(stats.getTotalBytes()).atLeastOnce();
-            expectPolicyDataEnable(TYPE_WIFI, true);
-
-            expectClearNotifications();
-            expectAdvisePersistThreshold();
-            future = expectMeteredIfacesChanged();
-
-            replay();
-            setNetworkPolicies(new NetworkPolicy(sTemplateWifi, CYCLE_DAY, TIMEZONE_UTC, 1
-                    * MB_IN_BYTES, 2 * MB_IN_BYTES, false));
-            future.get();
-            verifyAndReset();
-        }
-
-        // bring up wifi network
-        incrementCurrentTime(MINUTE_IN_MILLIS);
-        state = new NetworkState[] { buildWifi() };
-        stats = new NetworkStats(getElapsedRealtime(), 1)
-                .addIfaceValues(TEST_IFACE, 0L, 0L, 0L, 0L);
-
-        {
-            expectCurrentTime();
-            expect(mConnManager.getAllNetworkState()).andReturn(state).atLeastOnce();
-            expect(mStatsService.getNetworkTotalBytes(sTemplateWifi, TIME_FEB_15, currentTimeMillis()))
-                    .andReturn(stats.getTotalBytes()).atLeastOnce();
-            expectPolicyDataEnable(TYPE_WIFI, true);
-
-            expectRemoveInterfaceQuota(TEST_IFACE);
-            expectSetInterfaceQuota(TEST_IFACE, 2 * MB_IN_BYTES);
-
-            expectClearNotifications();
-            expectAdvisePersistThreshold();
-            future = expectMeteredIfacesChanged(TEST_IFACE);
-
-            replay();
-            mServiceContext.sendBroadcast(new Intent(CONNECTIVITY_ACTION));
-            future.get();
-            verifyAndReset();
-        }
-
-        // go over warning, which should kick notification
-        incrementCurrentTime(MINUTE_IN_MILLIS);
-        stats = new NetworkStats(getElapsedRealtime(), 1)
-                .addIfaceValues(TEST_IFACE, 1536 * KB_IN_BYTES, 15L, 0L, 0L);
-
-        {
-            expectCurrentTime();
-            expect(mStatsService.getNetworkTotalBytes(sTemplateWifi, TIME_FEB_15, currentTimeMillis()))
-                    .andReturn(stats.getTotalBytes()).atLeastOnce();
-            expectPolicyDataEnable(TYPE_WIFI, true);
-
-            expectForceUpdate();
-            expectClearNotifications();
-            tagFuture = expectEnqueueNotification();
-
-            replay();
-            mNetworkObserver.limitReached(null, TEST_IFACE);
-            assertNotificationType(TYPE_WARNING, tagFuture.get());
-            verifyAndReset();
-        }
-
-        // go over limit, which should kick notification and dialog
-        incrementCurrentTime(MINUTE_IN_MILLIS);
-        stats = new NetworkStats(getElapsedRealtime(), 1)
-                .addIfaceValues(TEST_IFACE, 5 * MB_IN_BYTES, 512L, 0L, 0L);
-
-        {
-            expectCurrentTime();
-            expect(mStatsService.getNetworkTotalBytes(sTemplateWifi, TIME_FEB_15, currentTimeMillis()))
-                    .andReturn(stats.getTotalBytes()).atLeastOnce();
-            expectPolicyDataEnable(TYPE_WIFI, false);
-
-            expectForceUpdate();
-            expectClearNotifications();
-            tagFuture = expectEnqueueNotification();
-
-            replay();
-            mNetworkObserver.limitReached(null, TEST_IFACE);
-            assertNotificationType(TYPE_LIMIT, tagFuture.get());
-            verifyAndReset();
-        }
-
-        // now snooze policy, which should remove quota
-        incrementCurrentTime(MINUTE_IN_MILLIS);
-
-        {
-            expectCurrentTime();
-            expect(mConnManager.getAllNetworkState()).andReturn(state).atLeastOnce();
-            expect(mStatsService.getNetworkTotalBytes(sTemplateWifi, TIME_FEB_15, currentTimeMillis()))
-                    .andReturn(stats.getTotalBytes()).atLeastOnce();
-            expectPolicyDataEnable(TYPE_WIFI, true);
-
-            // snoozed interface still has high quota so background data is
-            // still restricted.
-            expectRemoveInterfaceQuota(TEST_IFACE);
-            expectSetInterfaceQuota(TEST_IFACE, Long.MAX_VALUE);
-            expectAdvisePersistThreshold();
-            expectMeteredIfacesChanged(TEST_IFACE);
-
-            future = expectClearNotifications();
-            tagFuture = expectEnqueueNotification();
-
-            replay();
-            mService.snoozeLimit(sTemplateWifi);
-            assertNotificationType(TYPE_LIMIT_SNOOZED, tagFuture.get());
-            future.get();
-            verifyAndReset();
-        }
-    }
-
-    @Suppress
-    public void testMeteredNetworkWithoutLimit() throws Exception {
-        NetworkState[] state = null;
-        NetworkStats stats = null;
-        Future<Void> future;
-        Future<String> tagFuture;
-
-        final long TIME_FEB_15 = 1171497600000L;
-        final long TIME_MAR_10 = 1173484800000L;
-        final int CYCLE_DAY = 15;
-
-        setCurrentTimeMillis(TIME_MAR_10);
-
-        // bring up wifi network with metered policy
-        state = new NetworkState[] { buildWifi() };
-        stats = new NetworkStats(getElapsedRealtime(), 1)
-                .addIfaceValues(TEST_IFACE, 0L, 0L, 0L, 0L);
-
-        {
-            expectCurrentTime();
-            expect(mConnManager.getAllNetworkState()).andReturn(state).atLeastOnce();
-            expect(mStatsService.getNetworkTotalBytes(sTemplateWifi, TIME_FEB_15, currentTimeMillis()))
-                    .andReturn(stats.getTotalBytes()).atLeastOnce();
-            expectPolicyDataEnable(TYPE_WIFI, true);
-
-            expectRemoveInterfaceQuota(TEST_IFACE);
-            expectSetInterfaceQuota(TEST_IFACE, Long.MAX_VALUE);
-
-            expectClearNotifications();
-            expectAdvisePersistThreshold();
-            future = expectMeteredIfacesChanged(TEST_IFACE);
-
-            replay();
-            setNetworkPolicies(new NetworkPolicy(
-                    sTemplateWifi, CYCLE_DAY, TIMEZONE_UTC, WARNING_DISABLED, LIMIT_DISABLED,
-                    true));
-            future.get();
-            verifyAndReset();
-        }
-    }
-
-    private static long parseTime(String time) {
-        final Time result = new Time();
-        result.parse3339(time);
-        return result.toMillis(true);
-    }
-
-    private void setNetworkPolicies(NetworkPolicy... policies) {
-        mService.setNetworkPolicies(policies);
-    }
-
-    private static NetworkState buildWifi() {
-        final NetworkInfo info = new NetworkInfo(TYPE_WIFI, 0, null, null);
-        info.setDetailedState(DetailedState.CONNECTED, null, null);
-        final LinkProperties prop = new LinkProperties();
-        prop.setInterfaceName(TEST_IFACE);
-        return new NetworkState(info, prop, null, null, null, TEST_SSID);
-    }
-
-    private void expectCurrentTime() throws Exception {
-        expect(mTime.forceRefresh()).andReturn(false).anyTimes();
-        expect(mTime.hasCache()).andReturn(true).anyTimes();
-        expect(mTime.currentTimeMillis()).andReturn(currentTimeMillis()).anyTimes();
-        expect(mTime.getCacheAge()).andReturn(0L).anyTimes();
-        expect(mTime.getCacheCertainty()).andReturn(0L).anyTimes();
-    }
-
-    private void expectForceUpdate() throws Exception {
-        mStatsService.forceUpdate();
-        expectLastCall().atLeastOnce();
-    }
-
-    private Future<Void> expectClearNotifications() throws Exception {
-        final FutureAnswer future = new FutureAnswer();
-        mNotifManager.cancelNotificationWithTag(
-                isA(String.class), isA(String.class), anyInt(), anyInt());
-        expectLastCall().andAnswer(future).anyTimes();
-        return future;
-    }
-
-    private Future<String> expectEnqueueNotification() throws Exception {
-        final FutureCapture<String> tag = new FutureCapture<String>();
-        mNotifManager.enqueueNotificationWithTag(isA(String.class), isA(String.class),
-                capture(tag.capture), anyInt(),
-                isA(Notification.class), isA(int[].class), UserHandle.myUserId());
-        return tag;
-    }
-
-    private void expectSetInterfaceQuota(String iface, long quotaBytes) throws Exception {
-        mNetworkManager.setInterfaceQuota(iface, quotaBytes);
-        expectLastCall().atLeastOnce();
-    }
-
-    private void expectRemoveInterfaceQuota(String iface) throws Exception {
-        mNetworkManager.removeInterfaceQuota(iface);
-        expectLastCall().atLeastOnce();
-    }
-
-    private void expectSetInterfaceAlert(String iface, long alertBytes) throws Exception {
-        mNetworkManager.setInterfaceAlert(iface, alertBytes);
-        expectLastCall().atLeastOnce();
-    }
-
-    private void expectRemoveInterfaceAlert(String iface) throws Exception {
-        mNetworkManager.removeInterfaceAlert(iface);
-        expectLastCall().atLeastOnce();
-    }
-
-    private void expectSetUidMeteredNetworkBlacklist(int uid, boolean rejectOnQuotaInterfaces)
-            throws Exception {
-        mNetworkManager.setUidMeteredNetworkBlacklist(uid, rejectOnQuotaInterfaces);
-        expectLastCall().atLeastOnce();
-    }
-
-    private void expectSetUidForeground(int uid, boolean uidForeground) throws Exception {
-        mStatsService.setUidForeground(uid, uidForeground);
-        expectLastCall().atLeastOnce();
-    }
-
-    private Future<Void> expectRulesChanged(int uid, int policy) throws Exception {
-        final FutureAnswer future = new FutureAnswer();
-        mPolicyListener.onUidRulesChanged(eq(uid), eq(policy));
-        expectLastCall().andAnswer(future);
-        return future;
-    }
-
-    private Future<Void> expectMeteredIfacesChanged(String... ifaces) throws Exception {
-        final FutureAnswer future = new FutureAnswer();
-        mPolicyListener.onMeteredIfacesChanged(aryEq(ifaces));
-        expectLastCall().andAnswer(future);
-        return future;
-    }
-
-    private Future<Void> expectPolicyDataEnable(int type, boolean enabled) throws Exception {
-        // TODO: bring back this test
-        return null;
-    }
-
-    private void expectAdvisePersistThreshold() throws Exception {
-        mStatsService.advisePersistThreshold(anyLong());
-        expectLastCall().anyTimes();
-    }
-
-    private static class TestAbstractFuture<T> extends AbstractFuture<T> {
-        @Override
-        public T get() throws InterruptedException, ExecutionException {
-            try {
-                return get(5, TimeUnit.SECONDS);
-            } catch (TimeoutException e) {
-                throw new RuntimeException(e);
-            }
-        }
-    }
-
-    private static class FutureAnswer extends TestAbstractFuture<Void> implements IAnswer<Void> {
-        @Override
-        public Void answer() {
-            set(null);
-            return null;
-        }
-    }
-
-    private static class FutureCapture<T> extends TestAbstractFuture<T> {
-        public Capture<T> capture = new Capture<T>() {
-            @Override
-            public void setValue(T value) {
-                super.setValue(value);
-                set(value);
-            }
-        };
-    }
-
-    private static class IdleFuture extends AbstractFuture<Void> implements IdleHandler {
-        @Override
-        public Void get() throws InterruptedException, ExecutionException {
-            try {
-                return get(5, TimeUnit.SECONDS);
-            } catch (TimeoutException e) {
-                throw new RuntimeException(e);
-            }
-        }
-
-        @Override
-        public boolean queueIdle() {
-            set(null);
-            return false;
-        }
-    }
-
-    /**
-     * Wait until {@link #mService} internal {@link Handler} is idle.
-     */
-    private IdleFuture expectIdle() {
-        final IdleFuture future = new IdleFuture();
-        mService.addIdleHandler(future);
-        return future;
-    }
-
-    private static void assertTimeEquals(long expected, long actual) {
-        if (expected != actual) {
-            fail("expected " + formatTime(expected) + " but was actually " + formatTime(actual));
-        }
-    }
-
-    private static String formatTime(long millis) {
-        final Time time = new Time(Time.TIMEZONE_UTC);
-        time.set(millis);
-        return time.format3339(false);
-    }
-
-    private static void assertEqualsFuzzy(long expected, long actual, long fuzzy) {
-        final long low = expected - fuzzy;
-        final long high = expected + fuzzy;
-        if (actual < low || actual > high) {
-            fail("value " + actual + " is outside [" + low + "," + high + "]");
-        }
-    }
-
-    private static void assertUnique(LinkedHashSet<Long> seen, Long value) {
-        if (!seen.add(value)) {
-            fail("found duplicate time " + value + " in series " + seen.toString());
-        }
-    }
-
-    private static void assertNotificationType(int expected, String actualTag) {
-        assertEquals(
-                Integer.toString(expected), actualTag.substring(actualTag.lastIndexOf(':') + 1));
-    }
-
-    private long getElapsedRealtime() {
-        return mElapsedRealtime;
-    }
-
-    private void setCurrentTimeMillis(long currentTimeMillis) {
-        mStartTime = currentTimeMillis;
-        mElapsedRealtime = 0L;
-    }
-
-    private long currentTimeMillis() {
-        return mStartTime + mElapsedRealtime;
-    }
-
-    private void incrementCurrentTime(long duration) {
-        mElapsedRealtime += duration;
-    }
-
-    private void replay() {
-        EasyMock.replay(mActivityManager, mStatsService, mPolicyListener, mNetworkManager, mTime,
-                mConnManager, mNotifManager);
-    }
-
-    private void verifyAndReset() {
-        EasyMock.verify(mActivityManager, mStatsService, mPolicyListener, mNetworkManager, mTime,
-                mConnManager, mNotifManager);
-        EasyMock.reset(mActivityManager, mStatsService, mPolicyListener, mNetworkManager, mTime,
-                mConnManager, mNotifManager);
-    }
-}
diff --git a/services/tests/servicestests/src/com/android/server/Vector3Test.java b/services/tests/servicestests/src/com/android/server/Vector3Test.java
deleted file mode 100644
index 88dbe70b994..00000000000
--- a/services/tests/servicestests/src/com/android/server/Vector3Test.java
+++ /dev/null
@@ -1,164 +0,0 @@
-/*
- * Copyright (C) 2016 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.android.server;
-
-import android.test.AndroidTestCase;
-
-import java.lang.Exception;
-import java.lang.Math;
-
-/**
- * Tests for {@link com.android.server.AnyMotionDetector.Vector3}
- */
-public class Vector3Test extends AndroidTestCase {
-    private static final float tolerance = 1.0f / (1 << 12);
-    private static final float STATIONARY_ANGLE_THRESHOLD = 0.05f;
-
-    private AnyMotionDetector.Vector3 unitXAxis;
-    private AnyMotionDetector.Vector3 unitYAxis;
-    private AnyMotionDetector.Vector3 unitZAxis;
-    private AnyMotionDetector.Vector3 x3;
-    private AnyMotionDetector.Vector3 case1A;
-    private AnyMotionDetector.Vector3 case1B;
-    private AnyMotionDetector.Vector3 case2A;
-    private AnyMotionDetector.Vector3 case2B;
-    private AnyMotionDetector.Vector3 x1y1;
-    private AnyMotionDetector.Vector3 xn1y1;
-    private AnyMotionDetector.Vector3 x1z1;
-    private AnyMotionDetector.Vector3 y1z1;
-    private AnyMotionDetector.Vector3 piOverSixUnitCircle;
-
-
-    private boolean nearlyEqual(float a, float b) {
-        return Math.abs(a - b) <= tolerance;
-    }
-
-    public void setUp() throws Exception {
-        super.setUp();
-        unitXAxis = new AnyMotionDetector.Vector3(0, 1, 0, 0);
-        unitYAxis = new AnyMotionDetector.Vector3(0, 0, 1, 0);
-        unitZAxis = new AnyMotionDetector.Vector3(0, 0, 0, 1);
-        x3 = new AnyMotionDetector.Vector3(0, 3, 0, 0);
-        x1y1 = new AnyMotionDetector.Vector3(0, 1, 1, 0);
-        xn1y1 = new AnyMotionDetector.Vector3(0, -1, 1, 0);
-        x1z1 = new AnyMotionDetector.Vector3(0, 1, 0, 1);
-        y1z1 = new AnyMotionDetector.Vector3(0, 0, 1, 1);
-        piOverSixUnitCircle = new AnyMotionDetector.Vector3(
-                0, (float)Math.sqrt(3)/2, (float)0.5, 0);
-
-        case1A = new AnyMotionDetector.Vector3(0, -9.81f, -0.02f, 0.3f);
-        case1B = new AnyMotionDetector.Vector3(0, -9.80f, -0.02f, 0.3f);
-        case2A = new AnyMotionDetector.Vector3(0, 1f, 2f, 3f);
-        case2B = new AnyMotionDetector.Vector3(0, 4f, 5f, 6f);
-    }
-
-    public void testVector3Norm() {
-        assertTrue(nearlyEqual(unitXAxis.norm(), 1.0f));
-        assertTrue(nearlyEqual(unitYAxis.norm(), 1.0f));
-        assertTrue(nearlyEqual(unitZAxis.norm(), 1.0f));
-        assertTrue(nearlyEqual(x1y1.norm(), (float)Math.sqrt(2)));
-    }
-
-    public void testVector3AngleBetween() {
-        // Zero angle.
-        assertTrue(nearlyEqual(unitXAxis.angleBetween(unitXAxis), 0.0f));
-        assertTrue(nearlyEqual(unitYAxis.angleBetween(unitYAxis), 0.0f));
-        assertTrue(nearlyEqual(unitZAxis.angleBetween(unitZAxis), 0.0f));
-
-        // Unit axes should be perpendicular.
-        assertTrue(nearlyEqual(unitXAxis.angleBetween(unitYAxis), 90.0f));
-        assertTrue(nearlyEqual(unitXAxis.angleBetween(unitZAxis), 90.0f));
-        assertTrue(nearlyEqual(unitYAxis.angleBetween(unitZAxis), 90.0f));
-
-        // 45 degree angles.
-        assertTrue(nearlyEqual(unitXAxis.angleBetween(x1y1), 45.0f));
-        assertTrue(nearlyEqual(unitYAxis.angleBetween(x1y1), 45.0f));
-
-        // 135 degree angles.
-        assertTrue(nearlyEqual(xn1y1.angleBetween(unitXAxis), 135.0f));
-
-        // 30 degree angles.
-        assertTrue(nearlyEqual(piOverSixUnitCircle.angleBetween(unitXAxis), 30.0f));
-
-        // These vectors are expected to be still.
-        assertTrue(case1A.angleBetween(case1A) < STATIONARY_ANGLE_THRESHOLD);
-        assertTrue(case1A.angleBetween(case1B) < STATIONARY_ANGLE_THRESHOLD);
-        assertTrue(unitXAxis.angleBetween(unitXAxis) < STATIONARY_ANGLE_THRESHOLD);
-        assertTrue(unitYAxis.angleBetween(unitYAxis) < STATIONARY_ANGLE_THRESHOLD);
-        assertTrue(unitZAxis.angleBetween(unitZAxis) < STATIONARY_ANGLE_THRESHOLD);
-    }
-
-    public void testVector3Normalized() {
-        AnyMotionDetector.Vector3 unitXAxisNormalized = unitXAxis.normalized();
-        assertTrue(nearlyEqual(unitXAxisNormalized.x, unitXAxis.x));
-        assertTrue(nearlyEqual(unitXAxisNormalized.y, unitXAxis.y));
-        assertTrue(nearlyEqual(unitXAxisNormalized.z, unitXAxis.z));
-
-        // Normalizing the vector created by multiplying the unit vector by 3 gets the unit vector.
-        AnyMotionDetector.Vector3 x3Normalized = x3.normalized();
-        assertTrue(nearlyEqual(x3Normalized.x, unitXAxis.x));
-        assertTrue(nearlyEqual(x3Normalized.y, unitXAxis.y));
-        assertTrue(nearlyEqual(x3Normalized.z, unitXAxis.z));
-    }
-
-    public void testVector3Cross() {
-        AnyMotionDetector.Vector3 xCrossX = unitXAxis.cross(unitXAxis);
-        assertTrue(nearlyEqual(xCrossX.x, 0f));
-        assertTrue(nearlyEqual(xCrossX.y, 0f));
-        assertTrue(nearlyEqual(xCrossX.z, 0f));
-
-        AnyMotionDetector.Vector3 xCrossNx = unitXAxis.cross(unitXAxis.times(-1));
-        assertTrue(nearlyEqual(xCrossNx.x, 0f));
-        assertTrue(nearlyEqual(xCrossNx.y, 0f));
-        assertTrue(nearlyEqual(xCrossNx.z, 0f));
-
-        AnyMotionDetector.Vector3 cross2 = case2A.cross(case2B);
-        assertTrue(nearlyEqual(cross2.x, -3));
-        assertTrue(nearlyEqual(cross2.y, 6));
-        assertTrue(nearlyEqual(cross2.z, -3));
-    }
-
-     public void testVector3Times() {
-         AnyMotionDetector.Vector3 yTimes2 = unitYAxis.times(2);
-         assertTrue(nearlyEqual(yTimes2.x, 0f));
-         assertTrue(nearlyEqual(yTimes2.y, 2f));
-         assertTrue(nearlyEqual(yTimes2.z, 0f));
-     }
-
-     public void testVector3Plus() {
-         AnyMotionDetector.Vector3 xPlusY = unitXAxis.plus(unitYAxis);
-         assertTrue(nearlyEqual(xPlusY.x, 1f));
-         assertTrue(nearlyEqual(xPlusY.y, 1f));
-         assertTrue(nearlyEqual(xPlusY.z, 0f));
-     }
-
-     public void testVector3Minus() {
-         AnyMotionDetector.Vector3 xMinusY = unitXAxis.minus(unitYAxis);
-         assertTrue(nearlyEqual(xMinusY.x, 1f));
-         assertTrue(nearlyEqual(xMinusY.y, -1f));
-         assertTrue(nearlyEqual(xMinusY.z, 0f));
-     }
-
-     public void testVector3DotProduct() {
-         float xDotX = unitXAxis.dotProduct(unitXAxis);
-         float xDotY = unitXAxis.dotProduct(unitYAxis);
-         float xDotZ = unitXAxis.dotProduct(unitZAxis);
-         assertTrue(nearlyEqual(xDotX, 1f));
-         assertTrue(nearlyEqual(xDotY, 0f));
-         assertTrue(nearlyEqual(xDotZ, 0f));
-     }
-}
diff --git a/services/tests/servicestests/src/com/android/server/accounts/AccountManagerServiceTest.java b/services/tests/servicestests/src/com/android/server/accounts/AccountManagerServiceTest.java
deleted file mode 100644
index a3d0afab88e..00000000000
--- a/services/tests/servicestests/src/com/android/server/accounts/AccountManagerServiceTest.java
+++ /dev/null
@@ -1,466 +0,0 @@
-/*
- * Copyright (C) 2009 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.android.server.accounts;
-
-import static org.mockito.Matchers.eq;
-import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.when;
-
-import android.accounts.Account;
-import android.accounts.AccountManagerInternal;
-import android.accounts.AuthenticatorDescription;
-import android.app.AppOpsManager;
-import android.app.Notification;
-import android.content.BroadcastReceiver;
-import android.content.Context;
-import android.content.Intent;
-import android.content.IntentFilter;
-import android.content.pm.PackageManager;
-import android.content.pm.RegisteredServicesCache.ServiceInfo;
-import android.content.pm.RegisteredServicesCacheListener;
-import android.content.pm.UserInfo;
-import android.database.Cursor;
-import android.database.DatabaseErrorHandler;
-import android.database.sqlite.SQLiteDatabase;
-import android.os.Bundle;
-import android.os.Handler;
-import android.os.UserHandle;
-import android.os.UserManager;
-import android.test.AndroidTestCase;
-import android.test.mock.MockContext;
-import android.test.mock.MockPackageManager;
-import android.util.Log;
-
-import com.android.server.LocalServices;
-
-import java.io.File;
-import java.io.FileDescriptor;
-import java.io.PrintWriter;
-import java.util.ArrayList;
-import java.util.Arrays;
-import java.util.Collection;
-import java.util.Comparator;
-
-public class AccountManagerServiceTest extends AndroidTestCase {
-    private static final String TAG = AccountManagerServiceTest.class.getSimpleName();
-
-    static final String PREN_DB = "pren.db";
-    static final String DE_DB = "de.db";
-    static final String CE_DB = "ce.db";
-    private AccountManagerService mAms;
-
-    @Override
-    protected void setUp() throws Exception {
-        Context realTestContext = getContext();
-        Context mockContext = new MyMockContext(realTestContext);
-        setContext(mockContext);
-        mAms = createAccountManagerService(mockContext, realTestContext);
-    }
-
-    @Override
-    protected void tearDown() throws Exception {
-        SQLiteDatabase.deleteDatabase(new File(mAms.getCeDatabaseName(UserHandle.USER_SYSTEM)));
-        SQLiteDatabase.deleteDatabase(new File(mAms.getDeDatabaseName(UserHandle.USER_SYSTEM)));
-        SQLiteDatabase.deleteDatabase(new File(mAms.getPreNDatabaseName(UserHandle.USER_SYSTEM)));
-        LocalServices.removeServiceForTest(AccountManagerInternal.class);
-        super.tearDown();
-    }
-
-    public class AccountSorter implements Comparator<Account> {
-        public int compare(Account object1, Account object2) {
-            if (object1 == object2) return 0;
-            if (object1 == null) return 1;
-            if (object2 == null) return -1;
-            int result = object1.type.compareTo(object2.type);
-            if (result != 0) return result;
-            return object1.name.compareTo(object2.name);
-        }
-    }
-
-    public void testCheckAddAccount() throws Exception {
-        unlockSystemUser();
-        Account a11 = new Account("account1", "type1");
-        Account a21 = new Account("account2", "type1");
-        Account a31 = new Account("account3", "type1");
-        Account a12 = new Account("account1", "type2");
-        Account a22 = new Account("account2", "type2");
-        Account a32 = new Account("account3", "type2");
-        mAms.addAccountExplicitly(a11, "p11", null);
-        mAms.addAccountExplicitly(a12, "p12", null);
-        mAms.addAccountExplicitly(a21, "p21", null);
-        mAms.addAccountExplicitly(a22, "p22", null);
-        mAms.addAccountExplicitly(a31, "p31", null);
-        mAms.addAccountExplicitly(a32, "p32", null);
-
-        Account[] accounts = mAms.getAccounts(null, mContext.getOpPackageName());
-        Arrays.sort(accounts, new AccountSorter());
-        assertEquals(6, accounts.length);
-        assertEquals(a11, accounts[0]);
-        assertEquals(a21, accounts[1]);
-        assertEquals(a31, accounts[2]);
-        assertEquals(a12, accounts[3]);
-        assertEquals(a22, accounts[4]);
-        assertEquals(a32, accounts[5]);
-
-        accounts = mAms.getAccounts("type1", mContext.getOpPackageName());
-        Arrays.sort(accounts, new AccountSorter());
-        assertEquals(3, accounts.length);
-        assertEquals(a11, accounts[0]);
-        assertEquals(a21, accounts[1]);
-        assertEquals(a31, accounts[2]);
-
-        mAms.removeAccountInternal(a21);
-
-        accounts = mAms.getAccounts("type1", mContext.getOpPackageName());
-        Arrays.sort(accounts, new AccountSorter());
-        assertEquals(2, accounts.length);
-        assertEquals(a11, accounts[0]);
-        assertEquals(a31, accounts[1]);
-    }
-
-    public void testPasswords() throws Exception {
-        unlockSystemUser();
-        Account a11 = new Account("account1", "type1");
-        Account a12 = new Account("account1", "type2");
-        mAms.addAccountExplicitly(a11, "p11", null);
-        mAms.addAccountExplicitly(a12, "p12", null);
-
-        assertEquals("p11", mAms.getPassword(a11));
-        assertEquals("p12", mAms.getPassword(a12));
-
-        mAms.setPassword(a11, "p11b");
-
-        assertEquals("p11b", mAms.getPassword(a11));
-        assertEquals("p12", mAms.getPassword(a12));
-    }
-
-    public void testUserdata() throws Exception {
-        unlockSystemUser();
-        Account a11 = new Account("account1", "type1");
-        Bundle u11 = new Bundle();
-        u11.putString("a", "a_a11");
-        u11.putString("b", "b_a11");
-        u11.putString("c", "c_a11");
-        Account a12 = new Account("account1", "type2");
-        Bundle u12 = new Bundle();
-        u12.putString("a", "a_a12");
-        u12.putString("b", "b_a12");
-        u12.putString("c", "c_a12");
-        mAms.addAccountExplicitly(a11, "p11", u11);
-        mAms.addAccountExplicitly(a12, "p12", u12);
-
-        assertEquals("a_a11", mAms.getUserData(a11, "a"));
-        assertEquals("b_a11", mAms.getUserData(a11, "b"));
-        assertEquals("c_a11", mAms.getUserData(a11, "c"));
-        assertEquals("a_a12", mAms.getUserData(a12, "a"));
-        assertEquals("b_a12", mAms.getUserData(a12, "b"));
-        assertEquals("c_a12", mAms.getUserData(a12, "c"));
-
-        mAms.setUserData(a11, "b", "b_a11b");
-        mAms.setUserData(a12, "c", null);
-
-        assertEquals("a_a11", mAms.getUserData(a11, "a"));
-        assertEquals("b_a11b", mAms.getUserData(a11, "b"));
-        assertEquals("c_a11", mAms.getUserData(a11, "c"));
-        assertEquals("a_a12", mAms.getUserData(a12, "a"));
-        assertEquals("b_a12", mAms.getUserData(a12, "b"));
-        assertNull(mAms.getUserData(a12, "c"));
-    }
-
-    public void testAuthtokens() throws Exception {
-        unlockSystemUser();
-        Account a11 = new Account("account1", "type1");
-        Account a12 = new Account("account1", "type2");
-        mAms.addAccountExplicitly(a11, "p11", null);
-        mAms.addAccountExplicitly(a12, "p12", null);
-
-        mAms.setAuthToken(a11, "att1", "a11_att1");
-        mAms.setAuthToken(a11, "att2", "a11_att2");
-        mAms.setAuthToken(a11, "att3", "a11_att3");
-        mAms.setAuthToken(a12, "att1", "a12_att1");
-        mAms.setAuthToken(a12, "att2", "a12_att2");
-        mAms.setAuthToken(a12, "att3", "a12_att3");
-
-        assertEquals("a11_att1", mAms.peekAuthToken(a11, "att1"));
-        assertEquals("a11_att2", mAms.peekAuthToken(a11, "att2"));
-        assertEquals("a11_att3", mAms.peekAuthToken(a11, "att3"));
-        assertEquals("a12_att1", mAms.peekAuthToken(a12, "att1"));
-        assertEquals("a12_att2", mAms.peekAuthToken(a12, "att2"));
-        assertEquals("a12_att3", mAms.peekAuthToken(a12, "att3"));
-
-        mAms.setAuthToken(a11, "att3", "a11_att3b");
-        mAms.invalidateAuthToken(a12.type, "a12_att2");
-
-        assertEquals("a11_att1", mAms.peekAuthToken(a11, "att1"));
-        assertEquals("a11_att2", mAms.peekAuthToken(a11, "att2"));
-        assertEquals("a11_att3b", mAms.peekAuthToken(a11, "att3"));
-        assertEquals("a12_att1", mAms.peekAuthToken(a12, "att1"));
-        assertNull(mAms.peekAuthToken(a12, "att2"));
-        assertEquals("a12_att3", mAms.peekAuthToken(a12, "att3"));
-
-        assertNull(mAms.peekAuthToken(a12, "att2"));
-    }
-
-    public void testRemovedAccountSync() throws Exception {
-        unlockSystemUser();
-        Account a1 = new Account("account1", "type1");
-        Account a2 = new Account("account2", "type2");
-        mAms.addAccountExplicitly(a1, "p1", null);
-        mAms.addAccountExplicitly(a2, "p2", null);
-
-        Context originalContext = ((MyMockContext)getContext()).mTestContext;
-        // create a separate instance of AMS. It initially assumes that user0 is locked
-        AccountManagerService ams2 = createAccountManagerService(getContext(), originalContext);
-
-        // Verify that account can be removed when user is locked
-        ams2.removeAccountInternal(a1);
-        Account[] accounts = ams2.getAccounts(UserHandle.USER_SYSTEM, mContext.getOpPackageName());
-        assertEquals(1, accounts.length);
-        assertEquals("Only a2 should be returned", a2, accounts[0]);
-
-        // Verify that CE db file is unchanged and still has 2 accounts
-        String ceDatabaseName = mAms.getCeDatabaseName(UserHandle.USER_SYSTEM);
-        int accountsNumber = readNumberOfAccountsFromDbFile(originalContext, ceDatabaseName);
-        assertEquals("CE database should still have 2 accounts", 2, accountsNumber);
-
-        // Unlock the user and verify that db has been updated
-        ams2.onUserUnlocked(newIntentForUser(UserHandle.USER_SYSTEM));
-        accountsNumber = readNumberOfAccountsFromDbFile(originalContext, ceDatabaseName);
-        assertEquals("CE database should now have 1 account", 2, accountsNumber);
-        accounts = ams2.getAccounts(UserHandle.USER_SYSTEM, mContext.getOpPackageName());
-        assertEquals(1, accounts.length);
-        assertEquals("Only a2 should be returned", a2, accounts[0]);
-    }
-
-    public void testPreNDatabaseMigration() throws Exception {
-        String preNDatabaseName = mAms.getPreNDatabaseName(UserHandle.USER_SYSTEM);
-        Context originalContext = ((MyMockContext) getContext()).mTestContext;
-        PreNTestDatabaseHelper.createV4Database(originalContext, preNDatabaseName);
-        // Assert that database was created with 1 account
-        int n = readNumberOfAccountsFromDbFile(originalContext, preNDatabaseName);
-        assertEquals("pre-N database should have 1 account", 1, n);
-
-        // Start testing
-        unlockSystemUser();
-        Account[] accounts = mAms.getAccounts(null, mContext.getOpPackageName());
-        assertEquals("1 account should be migrated", 1, accounts.length);
-        assertEquals(PreNTestDatabaseHelper.ACCOUNT_NAME, accounts[0].name);
-        assertEquals(PreNTestDatabaseHelper.ACCOUNT_PASSWORD, mAms.getPassword(accounts[0]));
-        assertEquals("Authtoken should be migrated",
-                PreNTestDatabaseHelper.TOKEN_STRING,
-                mAms.peekAuthToken(accounts[0], PreNTestDatabaseHelper.TOKEN_TYPE));
-
-        assertFalse("pre-N database file should be removed but was found at " + preNDatabaseName,
-                new File(preNDatabaseName).exists());
-
-        // Verify that ce/de files are present
-        String deDatabaseName = mAms.getDeDatabaseName(UserHandle.USER_SYSTEM);
-        String ceDatabaseName = mAms.getCeDatabaseName(UserHandle.USER_SYSTEM);
-        assertTrue("DE database file should be created at " + deDatabaseName,
-                new File(deDatabaseName).exists());
-        assertTrue("CE database file should be created at " + ceDatabaseName,
-                new File(ceDatabaseName).exists());
-    }
-
-    private int readNumberOfAccountsFromDbFile(Context context, String dbName) {
-        SQLiteDatabase ceDb = context.openOrCreateDatabase(dbName, 0, null);
-        try (Cursor cursor = ceDb.rawQuery("SELECT count(*) FROM accounts", null)) {
-            assertTrue(cursor.moveToNext());
-            return cursor.getInt(0);
-        }
-    }
-
-    private AccountManagerService createAccountManagerService(Context mockContext,
-            Context realContext) {
-        LocalServices.removeServiceForTest(AccountManagerInternal.class);
-        return new MyAccountManagerService(mockContext,
-                new MyMockPackageManager(), new MockAccountAuthenticatorCache(), realContext);
-    }
-
-    private void unlockSystemUser() {
-        mAms.onUserUnlocked(newIntentForUser(UserHandle.USER_SYSTEM));
-    }
-
-    private static Intent newIntentForUser(int userId) {
-        Intent intent = new Intent();
-        intent.putExtra(Intent.EXTRA_USER_HANDLE, userId);
-        return intent;
-    }
-
-    static public class MockAccountAuthenticatorCache implements IAccountAuthenticatorCache {
-        private ArrayList<ServiceInfo<AuthenticatorDescription>> mServices;
-
-        public MockAccountAuthenticatorCache() {
-            mServices = new ArrayList<>();
-            AuthenticatorDescription d1 = new AuthenticatorDescription("type1", "p1", 0, 0, 0, 0);
-            AuthenticatorDescription d2 = new AuthenticatorDescription("type2", "p2", 0, 0, 0, 0);
-            mServices.add(new ServiceInfo<>(d1, null, null));
-            mServices.add(new ServiceInfo<>(d2, null, null));
-        }
-
-        @Override
-        public ServiceInfo<AuthenticatorDescription> getServiceInfo(
-                AuthenticatorDescription type, int userId) {
-            for (ServiceInfo<AuthenticatorDescription> service : mServices) {
-                if (service.type.equals(type)) {
-                    return service;
-                }
-            }
-            return null;
-        }
-
-        @Override
-        public Collection<ServiceInfo<AuthenticatorDescription>> getAllServices(int userId) {
-            return mServices;
-        }
-
-        @Override
-        public void dump(
-                final FileDescriptor fd, final PrintWriter fout, final String[] args, int userId) {
-        }
-
-        @Override
-        public void setListener(
-                final RegisteredServicesCacheListener<AuthenticatorDescription> listener,
-                final Handler handler) {
-        }
-
-        @Override
-        public void invalidateCache(int userId) {
-        }
-
-        @Override
-        public void updateServices(int userId) {
-        }
-    }
-
-    static public class MyMockContext extends MockContext {
-        private Context mTestContext;
-        private AppOpsManager mAppOpsManager;
-        private UserManager mUserManager;
-        private PackageManager mPackageManager;
-
-        public MyMockContext(Context testContext) {
-            this.mTestContext = testContext;
-            this.mAppOpsManager = mock(AppOpsManager.class);
-            this.mUserManager = mock(UserManager.class);
-            this.mPackageManager = mock(PackageManager.class);
-            final UserInfo ui = new UserInfo(UserHandle.USER_SYSTEM, "user0", 0);
-            when(mUserManager.getUserInfo(eq(ui.id))).thenReturn(ui);
-        }
-
-        @Override
-        public int checkCallingOrSelfPermission(final String permission) {
-            return PackageManager.PERMISSION_GRANTED;
-        }
-
-        @Override
-        public PackageManager getPackageManager() {
-            return mPackageManager;
-        }
-
-        @Override
-        public Object getSystemService(String name) {
-            if (Context.APP_OPS_SERVICE.equals(name)) {
-                return mAppOpsManager;
-            } else if( Context.USER_SERVICE.equals(name)) {
-                return mUserManager;
-            }
-            return null;
-        }
-
-        @Override
-        public String getSystemServiceName(Class<?> serviceClass) {
-            if (AppOpsManager.class.equals(serviceClass)) {
-                return Context.APP_OPS_SERVICE;
-            }
-            return null;
-        }
-
-        @Override
-        public Intent registerReceiver(BroadcastReceiver receiver, IntentFilter filter) {
-            return null;
-        }
-
-        @Override
-        public Intent registerReceiverAsUser(BroadcastReceiver receiver, UserHandle user,
-                IntentFilter filter, String broadcastPermission, Handler scheduler) {
-            return null;
-        }
-
-        @Override
-        public SQLiteDatabase openOrCreateDatabase(String file, int mode,
-                SQLiteDatabase.CursorFactory factory, DatabaseErrorHandler errorHandler) {
-            Log.i(TAG, "openOrCreateDatabase " + file + " mode " + mode);
-            return mTestContext.openOrCreateDatabase(file, mode, factory,errorHandler);
-        }
-
-        @Override
-        public void sendBroadcastAsUser(Intent intent, UserHandle user) {
-            Log.i(TAG, "sendBroadcastAsUser " + intent + " " + user);
-        }
-
-        @Override
-        public String getOpPackageName() {
-            return null;
-        }
-    }
-
-    static public class MyMockPackageManager extends MockPackageManager {
-        @Override
-        public int checkSignatures(final int uid1, final int uid2) {
-            return PackageManager.SIGNATURE_MATCH;
-        }
-
-        @Override
-        public void addOnPermissionsChangeListener(
-                OnPermissionsChangedListener listener) {
-        }
-    }
-
-    static public class MyAccountManagerService extends AccountManagerService {
-        private Context mRealTestContext;
-        public MyAccountManagerService(Context context, PackageManager packageManager,
-                IAccountAuthenticatorCache authenticatorCache, Context realTestContext) {
-            super(context, packageManager, authenticatorCache);
-            this.mRealTestContext = realTestContext;
-        }
-
-        @Override
-        protected void installNotification(final int notificationId, final Notification n, UserHandle user) {
-        }
-
-        @Override
-        protected void cancelNotification(final int id, UserHandle user) {
-        }
-
-        @Override
-        protected String getCeDatabaseName(int userId) {
-            return new File(mRealTestContext.getCacheDir(), CE_DB).getPath();
-        }
-
-        @Override
-        protected String getDeDatabaseName(int userId) {
-            return new File(mRealTestContext.getCacheDir(), DE_DB).getPath();
-        }
-
-        @Override
-        String getPreNDatabaseName(int userId) {
-            return new File(mRealTestContext.getCacheDir(), PREN_DB).getPath();
-        }
-    }
-}
diff --git a/services/tests/servicestests/src/com/android/server/accounts/PreNTestDatabaseHelper.java b/services/tests/servicestests/src/com/android/server/accounts/PreNTestDatabaseHelper.java
deleted file mode 100644
index 97adbe6417b..00000000000
--- a/services/tests/servicestests/src/com/android/server/accounts/PreNTestDatabaseHelper.java
+++ /dev/null
@@ -1,98 +0,0 @@
-/*
- * Copyright (C) 2016 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License
- */
-
-package com.android.server.accounts;
-
-import android.content.Context;
-import android.database.sqlite.SQLiteDatabase;
-import android.database.sqlite.SQLiteOpenHelper;
-
-/**
- * Helper class for emulating pre-N database
- */
-class PreNTestDatabaseHelper extends SQLiteOpenHelper {
-
-    public static final String TOKEN_STRING = "token-string-123";
-    public static final String ACCOUNT_TYPE = "type1";
-    public static final String ACCOUNT_NAME = "account@" + ACCOUNT_TYPE;
-    public static final String ACCOUNT_PASSWORD = "Password";
-    public static final String TOKEN_TYPE = "SID";
-
-    public PreNTestDatabaseHelper(Context context, String name) {
-        super(context, name, null, 4);
-    }
-
-    @Override
-    public void onCreate(SQLiteDatabase db) {
-        db.execSQL("CREATE TABLE accounts ( "
-                + "_id INTEGER PRIMARY KEY AUTOINCREMENT, "
-                + "name TEXT NOT NULL, "
-                + "type TEXT NOT NULL, "
-                + "password TEXT, "
-                + "UNIQUE(name, type))");
-        db.execSQL("INSERT INTO accounts (name, type, password) VALUES "
-                + "('" + ACCOUNT_NAME + "', '" + ACCOUNT_TYPE + "', '" + ACCOUNT_PASSWORD + "')");
-
-        db.execSQL("CREATE TABLE authtokens (  "
-                + "_id INTEGER PRIMARY KEY AUTOINCREMENT,  "
-                + "accounts_id INTEGER NOT NULL, "
-                + "type TEXT NOT NULL,  "
-                + "authtoken TEXT, "
-                + "UNIQUE (accounts_id, type ))");
-        db.execSQL("INSERT INTO authtokens (accounts_id, type, authtoken) VALUES "
-                + "(1, '" + TOKEN_TYPE + "', '" + TOKEN_STRING + "')");
-
-        db.execSQL("CREATE TABLE grants (  "
-                + "accounts_id INTEGER NOT NULL, "
-                + "auth_token_type STRING NOT NULL,  "
-                + "uid INTEGER NOT NULL,  "
-                + "UNIQUE (accounts_id,auth_token_type,uid))");
-
-        db.execSQL("CREATE TABLE extras ( "
-                + "_id INTEGER PRIMARY KEY AUTOINCREMENT, "
-                + "accounts_id INTEGER, "
-                + "key TEXT NOT NULL, "
-                + "value TEXT, "
-                + "UNIQUE(accounts_id , key))");
-
-        db.execSQL("CREATE TABLE meta ( "
-                + "key TEXT PRIMARY KEY NOT NULL, "
-                + "value TEXT)");
-
-        db.execSQL(""
-                + " CREATE TRIGGER accountsDelete DELETE ON accounts "
-                + " BEGIN"
-                + "   DELETE FROM authtokens"
-                + "     WHERE accounts_id=OLD._id;"
-                + "   DELETE FROM extras"
-                + "     WHERE accounts_id=OLD._id;"
-                + "   DELETE FROM grants"
-                + "     WHERE accounts_id=OLD._id;"
-                + " END");
-    }
-
-    @Override
-    public void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) {
-        throw new UnsupportedOperationException("Upgrade of test database is not supported");
-    }
-
-    public static void createV4Database(Context context, String name) {
-        PreNTestDatabaseHelper helper = new PreNTestDatabaseHelper(context, name);
-        helper.getWritableDatabase();
-        helper.close();
-    }
-
-}
diff --git a/services/tests/servicestests/src/com/android/server/am/ActivityManagerTest.java b/services/tests/servicestests/src/com/android/server/am/ActivityManagerTest.java
deleted file mode 100644
index bd9e6d19269..00000000000
--- a/services/tests/servicestests/src/com/android/server/am/ActivityManagerTest.java
+++ /dev/null
@@ -1,55 +0,0 @@
-/*
- * Copyright (C) 2016 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.android.server.am;
-
-import android.app.ActivityManager;
-import android.app.ActivityManagerNative;
-import android.app.IActivityManager;
-import android.os.ServiceManager;
-import android.os.UserHandle;
-import android.os.RemoteException;
-import android.test.AndroidTestCase;
-
-import java.util.List;
-
-public class ActivityManagerTest extends AndroidTestCase {
-
-    IActivityManager service;
-    @Override
-    public void setUp() throws Exception {
-        super.setUp();
-        service = ActivityManagerNative.getDefault();
-    }
-
-    public void testTaskIdsForRunningUsers() throws RemoteException {
-        for(int userId : service.getRunningUserIds()) {
-            testTaskIdsForUser(userId);
-        }
-    }
-
-    private void testTaskIdsForUser(int userId) throws RemoteException {
-        List<ActivityManager.RecentTaskInfo> recentTasks = service.getRecentTasks(
-                100, 0, userId).getList();
-        if(recentTasks != null) {
-            for(ActivityManager.RecentTaskInfo recentTask : recentTasks) {
-                int taskId = recentTask.persistentId;
-                assertEquals("The task id " + taskId + " should not belong to user " + userId,
-                        taskId / UserHandle.PER_USER_RANGE, userId);
-            }
-        }
-    }
-}
\ No newline at end of file
diff --git a/services/tests/servicestests/src/com/android/server/am/TaskPersisterTest.java b/services/tests/servicestests/src/com/android/server/am/TaskPersisterTest.java
deleted file mode 100644
index 984a484dadc..00000000000
--- a/services/tests/servicestests/src/com/android/server/am/TaskPersisterTest.java
+++ /dev/null
@@ -1,85 +0,0 @@
-/*
- * Copyright (C) 2016 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.android.server.am;
-
-import android.content.pm.UserInfo;
-import android.os.Environment;
-import android.os.UserHandle;
-import android.os.UserManager;
-import android.test.AndroidTestCase;
-import android.util.Log;
-import android.util.SparseBooleanArray;
-
-import com.android.server.am.TaskPersister;
-
-import java.io.File;
-import java.util.Random;
-
-public class TaskPersisterTest extends AndroidTestCase {
-    private static final String TEST_USER_NAME = "AM-Test-User";
-
-    private TaskPersister mTaskPersister;
-    private int testUserId;
-    private UserManager mUserManager;
-
-    @Override
-    public void setUp() throws Exception {
-        super.setUp();
-        mUserManager = UserManager.get(getContext());
-        mTaskPersister = new TaskPersister(getContext().getFilesDir());
-        testUserId = createUser(TEST_USER_NAME, 0);
-    }
-
-    @Override
-    public void tearDown() throws Exception {
-        super.tearDown();
-        mTaskPersister.unloadUserDataFromMemory(testUserId);
-        removeUser(testUserId);
-    }
-
-    private int getRandomTaskIdForUser(int userId) {
-        int taskId = (int) (Math.random() * UserHandle.PER_USER_RANGE);
-        taskId += UserHandle.PER_USER_RANGE * userId;
-        return taskId;
-    }
-
-    public void testTaskIdsPersistence() {
-        SparseBooleanArray taskIdsOnFile = mTaskPersister.loadPersistedTaskIdsForUser(testUserId);
-        for (int i = 0; i < 100; i++) {
-            taskIdsOnFile.put(getRandomTaskIdForUser(testUserId), true);
-        }
-        mTaskPersister.writePersistedTaskIdsForUser(taskIdsOnFile, testUserId);
-        SparseBooleanArray newTaskIdsOnFile = mTaskPersister
-                .loadPersistedTaskIdsForUser(testUserId);
-        assertTrue("TaskIds written differ from TaskIds read back from file",
-                taskIdsOnFile.equals(newTaskIdsOnFile));
-    }
-
-    private int createUser(String name, int flags) {
-        UserInfo user = mUserManager.createUser(name, flags);
-        if (user == null) {
-            fail("Error while creating the test user: " + TEST_USER_NAME);
-        }
-        return user.id;
-    }
-
-    private void removeUser(int userId) {
-        if (!mUserManager.removeUser(userId)) {
-            fail("Error while removing the test user: " + TEST_USER_NAME);
-        }
-    }
-}
\ No newline at end of file
diff --git a/services/tests/servicestests/src/com/android/server/connectivity/IpConnectivityEventBuilderTest.java b/services/tests/servicestests/src/com/android/server/connectivity/IpConnectivityEventBuilderTest.java
deleted file mode 100644
index 011e505c46c..00000000000
--- a/services/tests/servicestests/src/com/android/server/connectivity/IpConnectivityEventBuilderTest.java
+++ /dev/null
@@ -1,389 +0,0 @@
-/*
- * Copyright (C) 2016 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.android.server.connectivity;
-
-import static com.android.server.connectivity.MetricsTestUtil.aBool;
-import static com.android.server.connectivity.MetricsTestUtil.aByteArray;
-import static com.android.server.connectivity.MetricsTestUtil.aLong;
-import static com.android.server.connectivity.MetricsTestUtil.aString;
-import static com.android.server.connectivity.MetricsTestUtil.aType;
-import static com.android.server.connectivity.MetricsTestUtil.anInt;
-import static com.android.server.connectivity.MetricsTestUtil.anIntArray;
-import static com.android.server.connectivity.MetricsTestUtil.b;
-import static com.android.server.connectivity.MetricsTestUtil.describeIpEvent;
-import static com.android.server.connectivity.metrics.IpConnectivityLogClass.IpConnectivityLog;
-
-import android.net.ConnectivityMetricsEvent;
-import android.net.metrics.ApfProgramEvent;
-import android.net.metrics.ApfStats;
-import android.net.metrics.DefaultNetworkEvent;
-import android.net.metrics.DhcpClientEvent;
-import android.net.metrics.DhcpErrorEvent;
-import android.net.metrics.DnsEvent;
-import android.net.metrics.IpManagerEvent;
-import android.net.metrics.IpReachabilityEvent;
-import android.net.metrics.NetworkEvent;
-import android.net.metrics.RaEvent;
-import android.net.metrics.ValidationProbeEvent;
-import android.test.suitebuilder.annotation.SmallTest;
-import java.util.Arrays;
-import junit.framework.TestCase;
-
-public class IpConnectivityEventBuilderTest extends TestCase {
-
-    @SmallTest
-    public void testDefaultNetworkEventSerialization() {
-        ConnectivityMetricsEvent ev = describeIpEvent(
-                aType(DefaultNetworkEvent.class),
-                anInt(102),
-                anIntArray(1, 2, 3),
-                anInt(101),
-                aBool(true),
-                aBool(false));
-
-        String want = joinLines(
-                "dropped_events: 0",
-                "events <",
-                "  time_ms: 1",
-                "  transport: 0",
-                "  default_network_event <",
-                "    network_id <",
-                "      network_id: 102",
-                "    >",
-                "    previous_network_id <",
-                "      network_id: 101",
-                "    >",
-                "    previous_network_ip_support: 1",
-                "    transport_types: 1",
-                "    transport_types: 2",
-                "    transport_types: 3",
-                "  >",
-                ">",
-                "version: 2");
-
-        verifySerialization(want, ev);
-    }
-
-    @SmallTest
-    public void testDhcpClientEventSerialization() {
-        ConnectivityMetricsEvent ev = describeIpEvent(
-                aType(DhcpClientEvent.class),
-                aString("wlan0"),
-                aString("SomeState"),
-                anInt(192));
-
-        String want = joinLines(
-                "dropped_events: 0",
-                "events <",
-                "  time_ms: 1",
-                "  transport: 0",
-                "  dhcp_event <",
-                "    duration_ms: 192",
-                "    if_name: \"wlan0\"",
-                "    state_transition: \"SomeState\"",
-                "  >",
-                ">",
-                "version: 2");
-
-        verifySerialization(want, ev);
-    }
-
-    @SmallTest
-    public void testDhcpErrorEventSerialization() {
-        ConnectivityMetricsEvent ev = describeIpEvent(
-                aType(DhcpErrorEvent.class),
-                aString("wlan0"),
-                anInt(DhcpErrorEvent.L4_NOT_UDP));
-
-        String want = joinLines(
-                "dropped_events: 0",
-                "events <",
-                "  time_ms: 1",
-                "  transport: 0",
-                "  dhcp_event <",
-                "    duration_ms: 0",
-                "    if_name: \"wlan0\"",
-                "    error_code: 50397184",
-                "  >",
-                ">",
-                "version: 2");
-
-        verifySerialization(want, ev);
-    }
-
-    @SmallTest
-    public void testDnsEventSerialization() {
-        ConnectivityMetricsEvent ev = describeIpEvent(
-                aType(DnsEvent.class),
-                anInt(101),
-                aByteArray(b(1), b(1), b(2), b(1), b(1), b(1), b(2), b(2)),
-                aByteArray(b(0), b(0), b(22), b(3), b(1), b(0), b(200), b(178)),
-                anIntArray(3456, 267, 1230, 45, 2111, 450, 638, 1300));
-
-        String want = joinLines(
-                "dropped_events: 0",
-                "events <",
-                "  time_ms: 1",
-                "  transport: 0",
-                "  dns_lookup_batch <",
-                "    event_types: 1",
-                "    event_types: 1",
-                "    event_types: 2",
-                "    event_types: 1",
-                "    event_types: 1",
-                "    event_types: 1",
-                "    event_types: 2",
-                "    event_types: 2",
-                "    latencies_ms: 3456",
-                "    latencies_ms: 267",
-                "    latencies_ms: 1230",
-                "    latencies_ms: 45",
-                "    latencies_ms: 2111",
-                "    latencies_ms: 450",
-                "    latencies_ms: 638",
-                "    latencies_ms: 1300",
-                "    network_id <",
-                "      network_id: 101",
-                "    >",
-                "    return_codes: 0",
-                "    return_codes: 0",
-                "    return_codes: 22",
-                "    return_codes: 3",
-                "    return_codes: 1",
-                "    return_codes: 0",
-                "    return_codes: 200",
-                "    return_codes: 178",
-                "  >",
-                ">",
-                "version: 2");
-
-        verifySerialization(want, ev);
-    }
-
-    @SmallTest
-    public void testIpManagerEventSerialization() {
-        ConnectivityMetricsEvent ev = describeIpEvent(
-                aType(IpManagerEvent.class),
-                aString("wlan0"),
-                anInt(IpManagerEvent.PROVISIONING_OK),
-                aLong(5678));
-
-        String want = joinLines(
-                "dropped_events: 0",
-                "events <",
-                "  time_ms: 1",
-                "  transport: 0",
-                "  ip_provisioning_event <",
-                "    event_type: 1",
-                "    if_name: \"wlan0\"",
-                "    latency_ms: 5678",
-                "  >",
-                ">",
-                "version: 2");
-
-        verifySerialization(want, ev);
-    }
-
-    @SmallTest
-    public void testIpReachabilityEventSerialization() {
-        ConnectivityMetricsEvent ev = describeIpEvent(
-                aType(IpReachabilityEvent.class),
-                aString("wlan0"),
-                anInt(IpReachabilityEvent.NUD_FAILED));
-
-        String want = joinLines(
-                "dropped_events: 0",
-                "events <",
-                "  time_ms: 1",
-                "  transport: 0",
-                "  ip_reachability_event <",
-                "    event_type: 512",
-                "    if_name: \"wlan0\"",
-                "  >",
-                ">",
-                "version: 2");
-
-        verifySerialization(want, ev);
-    }
-
-    @SmallTest
-    public void testNetworkEventSerialization() {
-        ConnectivityMetricsEvent ev = describeIpEvent(
-                aType(NetworkEvent.class),
-                anInt(100),
-                anInt(5),
-                aLong(20410));
-
-        String want = joinLines(
-                "dropped_events: 0",
-                "events <",
-                "  time_ms: 1",
-                "  transport: 0",
-                "  network_event <",
-                "    event_type: 5",
-                "    latency_ms: 20410",
-                "    network_id <",
-                "      network_id: 100",
-                "    >",
-                "  >",
-                ">",
-                "version: 2");
-
-        verifySerialization(want, ev);
-    }
-
-    @SmallTest
-    public void testValidationProbeEventSerialization() {
-        ConnectivityMetricsEvent ev = describeIpEvent(
-                aType(ValidationProbeEvent.class),
-                anInt(120),
-                aLong(40730),
-                anInt(ValidationProbeEvent.PROBE_HTTP),
-                anInt(204));
-
-        String want = joinLines(
-                "dropped_events: 0",
-                "events <",
-                "  time_ms: 1",
-                "  transport: 0",
-                "  validation_probe_event <",
-                "    latency_ms: 40730",
-                "    network_id <",
-                "      network_id: 120",
-                "    >",
-                "    probe_result: 204",
-                "    probe_type: 1",
-                "  >",
-                ">",
-                "version: 2");
-
-        verifySerialization(want, ev);
-    }
-
-    @SmallTest
-    public void testApfProgramEventSerialization() {
-        ConnectivityMetricsEvent ev = describeIpEvent(
-                aType(ApfProgramEvent.class),
-                aLong(200),
-                anInt(7),
-                anInt(9),
-                anInt(2048),
-                anInt(3));
-
-        String want = joinLines(
-                "dropped_events: 0",
-                "events <",
-                "  time_ms: 1",
-                "  transport: 0",
-                "  apf_program_event <",
-                "    current_ras: 9",
-                "    drop_multicast: true",
-                "    filtered_ras: 7",
-                "    has_ipv4_addr: true",
-                "    lifetime: 200",
-                "    program_length: 2048",
-                "  >",
-                ">",
-                "version: 2");
-
-        verifySerialization(want, ev);
-    }
-
-    @SmallTest
-    public void testApfStatsSerialization() {
-        ConnectivityMetricsEvent ev = describeIpEvent(
-                aType(ApfStats.class),
-                aLong(45000),
-                anInt(10),
-                anInt(2),
-                anInt(2),
-                anInt(1),
-                anInt(2),
-                anInt(4),
-                anInt(2048));
-
-        String want = joinLines(
-                "dropped_events: 0",
-                "events <",
-                "  time_ms: 1",
-                "  transport: 0",
-                "  apf_statistics <",
-                "    dropped_ras: 2",
-                "    duration_ms: 45000",
-                "    matching_ras: 2",
-                "    max_program_size: 2048",
-                "    parse_errors: 2",
-                "    program_updates: 4",
-                "    received_ras: 10",
-                "    zero_lifetime_ras: 1",
-                "  >",
-                ">",
-                "version: 2");
-
-        verifySerialization(want, ev);
-    }
-
-    @SmallTest
-    public void testRaEventSerialization() {
-        ConnectivityMetricsEvent ev = describeIpEvent(
-                aType(RaEvent.class),
-                aLong(2000),
-                aLong(400),
-                aLong(300),
-                aLong(-1),
-                aLong(1000),
-                aLong(-1));
-
-        String want = joinLines(
-                "dropped_events: 0",
-                "events <",
-                "  time_ms: 1",
-                "  transport: 0",
-                "  ra_event <",
-                "    dnssl_lifetime: -1",
-                "    prefix_preferred_lifetime: 300",
-                "    prefix_valid_lifetime: 400",
-                "    rdnss_lifetime: 1000",
-                "    route_info_lifetime: -1",
-                "    router_lifetime: 2000",
-                "  >",
-                ">",
-                "version: 2");
-
-        verifySerialization(want, ev);
-    }
-
-    static void verifySerialization(String want, ConnectivityMetricsEvent... input) {
-        try {
-            byte[] got = IpConnectivityEventBuilder.serialize(0,
-                    IpConnectivityEventBuilder.toProto(Arrays.asList(input)));
-            IpConnectivityLog log = IpConnectivityLog.parseFrom(got);
-            assertEquals(want, log.toString());
-        } catch (Exception e) {
-            fail(e.toString());
-        }
-    }
-
-    static String joinLines(String ... elems) {
-        StringBuilder b = new StringBuilder();
-        for (String s : elems) {
-            b.append(s);
-            b.append("\n");
-        }
-        return b.toString();
-    }
-}
diff --git a/services/tests/servicestests/src/com/android/server/connectivity/IpConnectivityMetricsTest.java b/services/tests/servicestests/src/com/android/server/connectivity/IpConnectivityMetricsTest.java
deleted file mode 100644
index 450653cdb01..00000000000
--- a/services/tests/servicestests/src/com/android/server/connectivity/IpConnectivityMetricsTest.java
+++ /dev/null
@@ -1,296 +0,0 @@
-/*
- * Copyright (C) 2016, The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.android.server.connectivity;
-
-import static org.mockito.Mockito.timeout;
-import static org.mockito.Mockito.verify;
-
-import android.content.Context;
-import android.net.ConnectivityMetricsEvent;
-import android.net.IIpConnectivityMetrics;
-import android.net.metrics.ApfProgramEvent;
-import android.net.metrics.ApfStats;
-import android.net.metrics.DefaultNetworkEvent;
-import android.net.metrics.DhcpClientEvent;
-import android.net.metrics.IpConnectivityLog;
-import android.net.metrics.IpManagerEvent;
-import android.net.metrics.IpReachabilityEvent;
-import android.net.metrics.RaEvent;
-import android.net.metrics.ValidationProbeEvent;
-import android.os.Parcelable;
-import android.test.suitebuilder.annotation.SmallTest;
-import android.util.Base64;
-import com.android.server.connectivity.metrics.IpConnectivityLogClass;
-import java.io.PrintWriter;
-import java.io.StringWriter;
-import java.util.Collections;
-import java.util.Comparator;
-import java.util.Iterator;
-import java.util.List;
-import junit.framework.TestCase;
-import org.mockito.ArgumentCaptor;
-import org.mockito.Mock;
-import org.mockito.MockitoAnnotations;
-
-public class IpConnectivityMetricsTest extends TestCase {
-    static final IpReachabilityEvent FAKE_EV =
-            new IpReachabilityEvent("wlan0", IpReachabilityEvent.NUD_FAILED);
-
-    @Mock Context mCtx;
-    @Mock IIpConnectivityMetrics mMockService;
-
-    IpConnectivityMetrics mService;
-
-    public void setUp() {
-        MockitoAnnotations.initMocks(this);
-        mService = new IpConnectivityMetrics(mCtx, (ctx) -> 2000);
-    }
-
-    @SmallTest
-    public void testLoggingEvents() throws Exception {
-        IpConnectivityLog logger = new IpConnectivityLog(mMockService);
-
-        assertTrue(logger.log(1, FAKE_EV));
-        assertTrue(logger.log(2, FAKE_EV));
-        assertTrue(logger.log(3, FAKE_EV));
-
-        List<ConnectivityMetricsEvent> got = verifyEvents(3);
-        assertEventsEqual(expectedEvent(1), got.get(0));
-        assertEventsEqual(expectedEvent(2), got.get(1));
-        assertEventsEqual(expectedEvent(3), got.get(2));
-    }
-
-    @SmallTest
-    public void testLoggingEventsWithMultipleCallers() throws Exception {
-        IpConnectivityLog logger = new IpConnectivityLog(mMockService);
-
-        final int nCallers = 10;
-        final int nEvents = 10;
-        for (int n = 0; n < nCallers; n++) {
-            final int i = n;
-            new Thread() {
-                public void run() {
-                    for (int j = 0; j < nEvents; j++) {
-                        assertTrue(logger.log(i * 100 + j, FAKE_EV));
-                    }
-                }
-            }.start();
-        }
-
-        List<ConnectivityMetricsEvent> got = verifyEvents(nCallers * nEvents, 100);
-        Collections.sort(got, EVENT_COMPARATOR);
-        Iterator<ConnectivityMetricsEvent> iter = got.iterator();
-        for (int i = 0; i < nCallers; i++) {
-            for (int j = 0; j < nEvents; j++) {
-                int expectedTimestamp = i * 100 + j;
-                assertEventsEqual(expectedEvent(expectedTimestamp), iter.next());
-            }
-        }
-    }
-
-    @SmallTest
-    public void testBufferFlushing() {
-        String output1 = getdump("flush");
-        assertEquals("", output1);
-
-        new IpConnectivityLog(mService.impl).log(1, FAKE_EV);
-        String output2 = getdump("flush");
-        assertFalse("".equals(output2));
-
-        String output3 = getdump("flush");
-        assertEquals("", output3);
-    }
-
-    @SmallTest
-    public void testRateLimiting() {
-        final IpConnectivityLog logger = new IpConnectivityLog(mService.impl);
-        final ApfProgramEvent ev = new ApfProgramEvent(0, 0, 0, 0, 0);
-        final long fakeTimestamp = 1;
-
-        int attempt = 100; // More than burst quota, but less than buffer size.
-        for (int i = 0; i < attempt; i++) {
-            logger.log(ev);
-        }
-
-        String output1 = getdump("flush");
-        assertFalse("".equals(output1));
-
-        for (int i = 0; i < attempt; i++) {
-            assertFalse("expected event to be dropped", logger.log(fakeTimestamp, ev));
-        }
-
-        String output2 = getdump("flush");
-        assertEquals("", output2);
-    }
-
-    @SmallTest
-    public void testEndToEndLogging() {
-        IpConnectivityLog logger = new IpConnectivityLog(mService.impl);
-
-        Parcelable[] events = {
-            new IpReachabilityEvent("wlan0", IpReachabilityEvent.NUD_FAILED),
-            new DhcpClientEvent("wlan0", "SomeState", 192),
-            new DefaultNetworkEvent(102, new int[]{1,2,3}, 101, true, false),
-            new IpManagerEvent("wlan0", IpManagerEvent.PROVISIONING_OK, 5678),
-            new ValidationProbeEvent(120, 40730, ValidationProbeEvent.PROBE_HTTP, 204),
-            new ApfStats(45000, 10, 2, 2, 1, 2, 4, 2048),
-            new RaEvent(2000, 400, 300, -1, 1000, -1)
-        };
-
-        for (int i = 0; i < events.length; i++) {
-            logger.log(100 * (i + 1), events[i]);
-        }
-
-        String want = joinLines(
-                "dropped_events: 0",
-                "events <",
-                "  time_ms: 100",
-                "  transport: 0",
-                "  ip_reachability_event <",
-                "    event_type: 512",
-                "    if_name: \"wlan0\"",
-                "  >",
-                ">",
-                "events <",
-                "  time_ms: 200",
-                "  transport: 0",
-                "  dhcp_event <",
-                "    duration_ms: 192",
-                "    if_name: \"wlan0\"",
-                "    state_transition: \"SomeState\"",
-                "  >",
-                ">",
-                "events <",
-                "  time_ms: 300",
-                "  transport: 0",
-                "  default_network_event <",
-                "    network_id <",
-                "      network_id: 102",
-                "    >",
-                "    previous_network_id <",
-                "      network_id: 101",
-                "    >",
-                "    previous_network_ip_support: 1",
-                "    transport_types: 1",
-                "    transport_types: 2",
-                "    transport_types: 3",
-                "  >",
-                ">",
-                "events <",
-                "  time_ms: 400",
-                "  transport: 0",
-                "  ip_provisioning_event <",
-                "    event_type: 1",
-                "    if_name: \"wlan0\"",
-                "    latency_ms: 5678",
-                "  >",
-                ">",
-                "events <",
-                "  time_ms: 500",
-                "  transport: 0",
-                "  validation_probe_event <",
-                "    latency_ms: 40730",
-                "    network_id <",
-                "      network_id: 120",
-                "    >",
-                "    probe_result: 204",
-                "    probe_type: 1",
-                "  >",
-                ">",
-                "events <",
-                "  time_ms: 600",
-                "  transport: 0",
-                "  apf_statistics <",
-                "    dropped_ras: 2",
-                "    duration_ms: 45000",
-                "    matching_ras: 2",
-                "    max_program_size: 2048",
-                "    parse_errors: 2",
-                "    program_updates: 4",
-                "    received_ras: 10",
-                "    zero_lifetime_ras: 1",
-                "  >",
-                ">",
-                "events <",
-                "  time_ms: 700",
-                "  transport: 0",
-                "  ra_event <",
-                "    dnssl_lifetime: -1",
-                "    prefix_preferred_lifetime: 300",
-                "    prefix_valid_lifetime: 400",
-                "    rdnss_lifetime: 1000",
-                "    route_info_lifetime: -1",
-                "    router_lifetime: 2000",
-                "  >",
-                ">",
-                "version: 2");
-
-        verifySerialization(want, getdump("flush"));
-    }
-
-    String getdump(String ... command) {
-        StringWriter buffer = new StringWriter();
-        PrintWriter writer = new PrintWriter(buffer);
-        mService.impl.dump(null, writer, command);
-        return buffer.toString();
-    }
-
-    List<ConnectivityMetricsEvent> verifyEvents(int n, int timeoutMs) throws Exception {
-        ArgumentCaptor<ConnectivityMetricsEvent> captor =
-                ArgumentCaptor.forClass(ConnectivityMetricsEvent.class);
-        verify(mMockService, timeout(timeoutMs).times(n)).logEvent(captor.capture());
-        return captor.getAllValues();
-    }
-
-    List<ConnectivityMetricsEvent> verifyEvents(int n) throws Exception {
-        return verifyEvents(n, 10);
-    }
-
-    static void verifySerialization(String want, String output) {
-        try {
-            byte[] got = Base64.decode(output, Base64.DEFAULT);
-            IpConnectivityLogClass.IpConnectivityLog log =
-                    IpConnectivityLogClass.IpConnectivityLog.parseFrom(got);
-            assertEquals(want, log.toString());
-        } catch (Exception e) {
-            fail(e.toString());
-        }
-    }
-
-    static String joinLines(String ... elems) {
-        StringBuilder b = new StringBuilder();
-        for (String s : elems) {
-            b.append(s).append("\n");
-        }
-        return b.toString();
-    }
-
-    static ConnectivityMetricsEvent expectedEvent(int timestamp) {
-        return new ConnectivityMetricsEvent((long)timestamp, 0, 0, FAKE_EV);
-    }
-
-    /** Outer equality for ConnectivityMetricsEvent to avoid overriding equals() and hashCode(). */
-    static void assertEventsEqual(ConnectivityMetricsEvent expected, ConnectivityMetricsEvent got) {
-        assertEquals(expected.timestamp, got.timestamp);
-        assertEquals(expected.componentTag, got.componentTag);
-        assertEquals(expected.eventTag, got.eventTag);
-        assertEquals(expected.data, got.data);
-    }
-
-    static final Comparator<ConnectivityMetricsEvent> EVENT_COMPARATOR =
-        Comparator.comparingLong((ev) -> ev.timestamp);
-}
diff --git a/services/tests/servicestests/src/com/android/server/connectivity/LingerMonitorTest.java b/services/tests/servicestests/src/com/android/server/connectivity/LingerMonitorTest.java
deleted file mode 100644
index bce5787ed9a..00000000000
--- a/services/tests/servicestests/src/com/android/server/connectivity/LingerMonitorTest.java
+++ /dev/null
@@ -1,349 +0,0 @@
-/*
- * Copyright (C) 2016, The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.android.server.connectivity;
-
-import android.app.PendingIntent;
-import android.content.Context;
-import android.content.res.Resources;
-import android.net.ConnectivityManager;
-import android.net.Network;
-import android.net.NetworkCapabilities;
-import android.net.NetworkInfo;
-import android.net.NetworkMisc;
-import android.text.format.DateUtils;
-import com.android.internal.R;
-import com.android.server.ConnectivityService;
-import com.android.server.connectivity.NetworkNotificationManager;
-import com.android.server.connectivity.NetworkNotificationManager.NotificationType;
-import junit.framework.TestCase;
-import org.mockito.Mock;
-import org.mockito.MockitoAnnotations;
-
-import static org.mockito.Mockito.any;
-import static org.mockito.Mockito.anyBoolean;
-import static org.mockito.Mockito.anyInt;
-import static org.mockito.Mockito.eq;
-import static org.mockito.Mockito.never;
-import static org.mockito.Mockito.times;
-import static org.mockito.Mockito.verify;
-import static org.mockito.Mockito.when;
-import static org.mockito.Mockito.reset;
-
-public class LingerMonitorTest extends TestCase {
-    static final String CELLULAR = "CELLULAR";
-    static final String WIFI     = "WIFI";
-
-    static final long LOW_RATE_LIMIT = DateUtils.MINUTE_IN_MILLIS;
-    static final long HIGH_RATE_LIMIT = 0;
-
-    static final int LOW_DAILY_LIMIT = 2;
-    static final int HIGH_DAILY_LIMIT = 1000;
-
-    LingerMonitor mMonitor;
-
-    @Mock ConnectivityService mConnService;
-    @Mock Context mCtx;
-    @Mock NetworkMisc mMisc;
-    @Mock NetworkNotificationManager mNotifier;
-    @Mock Resources mResources;
-
-    public void setUp() {
-        MockitoAnnotations.initMocks(this);
-        when(mCtx.getResources()).thenReturn(mResources);
-        when(mCtx.getPackageName()).thenReturn("com.android.server.connectivity");
-        when(mConnService.createNetworkMonitor(any(), any(), any(), any())).thenReturn(null);
-
-        mMonitor = new TestableLingerMonitor(mCtx, mNotifier, HIGH_DAILY_LIMIT, HIGH_RATE_LIMIT);
-    }
-
-    public void testTransitions() {
-        setNotificationSwitch(transition(WIFI, CELLULAR));
-        NetworkAgentInfo nai1 = wifiNai(100);
-        NetworkAgentInfo nai2 = cellNai(101);
-
-        assertTrue(mMonitor.isNotificationEnabled(nai1, nai2));
-        assertFalse(mMonitor.isNotificationEnabled(nai2, nai1));
-    }
-
-    public void testNotificationOnLinger() {
-        setNotificationSwitch(transition(WIFI, CELLULAR));
-        setNotificationType(LingerMonitor.NOTIFY_TYPE_NOTIFICATION);
-        NetworkAgentInfo from = wifiNai(100);
-        NetworkAgentInfo to = cellNai(101);
-
-        mMonitor.noteLingerDefaultNetwork(from, to);
-        verifyNotification(from, to);
-    }
-
-    public void testToastOnLinger() {
-        setNotificationSwitch(transition(WIFI, CELLULAR));
-        setNotificationType(LingerMonitor.NOTIFY_TYPE_TOAST);
-        NetworkAgentInfo from = wifiNai(100);
-        NetworkAgentInfo to = cellNai(101);
-
-        mMonitor.noteLingerDefaultNetwork(from, to);
-        verifyToast(from, to);
-    }
-
-    public void testNotificationClearedAfterDisconnect() {
-        setNotificationSwitch(transition(WIFI, CELLULAR));
-        setNotificationType(LingerMonitor.NOTIFY_TYPE_NOTIFICATION);
-        NetworkAgentInfo from = wifiNai(100);
-        NetworkAgentInfo to = cellNai(101);
-
-        mMonitor.noteLingerDefaultNetwork(from, to);
-        verifyNotification(from, to);
-
-        mMonitor.noteDisconnect(to);
-        verify(mNotifier, times(1)).clearNotification(100);
-    }
-
-    public void testNotificationClearedAfterSwitchingBack() {
-        setNotificationSwitch(transition(WIFI, CELLULAR));
-        setNotificationType(LingerMonitor.NOTIFY_TYPE_NOTIFICATION);
-        NetworkAgentInfo from = wifiNai(100);
-        NetworkAgentInfo to = cellNai(101);
-
-        mMonitor.noteLingerDefaultNetwork(from, to);
-        verifyNotification(from, to);
-
-        mMonitor.noteLingerDefaultNetwork(to, from);
-        verify(mNotifier, times(1)).clearNotification(100);
-    }
-
-    public void testUniqueToast() {
-        setNotificationSwitch(transition(WIFI, CELLULAR));
-        setNotificationType(LingerMonitor.NOTIFY_TYPE_TOAST);
-        NetworkAgentInfo from = wifiNai(100);
-        NetworkAgentInfo to = cellNai(101);
-
-        mMonitor.noteLingerDefaultNetwork(from, to);
-        verifyToast(from, to);
-
-        mMonitor.noteLingerDefaultNetwork(to, from);
-        verify(mNotifier, times(1)).clearNotification(100);
-
-        reset(mNotifier);
-        mMonitor.noteLingerDefaultNetwork(from, to);
-        verifyNoNotifications();
-    }
-
-    public void testMultipleNotifications() {
-        setNotificationSwitch(transition(WIFI, CELLULAR));
-        setNotificationType(LingerMonitor.NOTIFY_TYPE_NOTIFICATION);
-        NetworkAgentInfo wifi1 = wifiNai(100);
-        NetworkAgentInfo wifi2 = wifiNai(101);
-        NetworkAgentInfo cell = cellNai(102);
-
-        mMonitor.noteLingerDefaultNetwork(wifi1, cell);
-        verifyNotification(wifi1, cell);
-
-        mMonitor.noteLingerDefaultNetwork(cell, wifi2);
-        verify(mNotifier, times(1)).clearNotification(100);
-
-        reset(mNotifier);
-        mMonitor.noteLingerDefaultNetwork(wifi2, cell);
-        verifyNotification(wifi2, cell);
-    }
-
-    public void testRateLimiting() throws InterruptedException {
-        mMonitor = new TestableLingerMonitor(mCtx, mNotifier, HIGH_DAILY_LIMIT, LOW_RATE_LIMIT);
-
-        setNotificationSwitch(transition(WIFI, CELLULAR));
-        setNotificationType(LingerMonitor.NOTIFY_TYPE_NOTIFICATION);
-        NetworkAgentInfo wifi1 = wifiNai(100);
-        NetworkAgentInfo wifi2 = wifiNai(101);
-        NetworkAgentInfo wifi3 = wifiNai(102);
-        NetworkAgentInfo cell = cellNai(103);
-
-        mMonitor.noteLingerDefaultNetwork(wifi1, cell);
-        verifyNotification(wifi1, cell);
-        reset(mNotifier);
-
-        Thread.sleep(50);
-        mMonitor.noteLingerDefaultNetwork(cell, wifi2);
-        mMonitor.noteLingerDefaultNetwork(wifi2, cell);
-        verifyNoNotifications();
-
-        Thread.sleep(50);
-        mMonitor.noteLingerDefaultNetwork(cell, wifi3);
-        mMonitor.noteLingerDefaultNetwork(wifi3, cell);
-        verifyNoNotifications();
-    }
-
-    public void testDailyLimiting() throws InterruptedException {
-        mMonitor = new TestableLingerMonitor(mCtx, mNotifier, LOW_DAILY_LIMIT, HIGH_RATE_LIMIT);
-
-        setNotificationSwitch(transition(WIFI, CELLULAR));
-        setNotificationType(LingerMonitor.NOTIFY_TYPE_NOTIFICATION);
-        NetworkAgentInfo wifi1 = wifiNai(100);
-        NetworkAgentInfo wifi2 = wifiNai(101);
-        NetworkAgentInfo wifi3 = wifiNai(102);
-        NetworkAgentInfo cell = cellNai(103);
-
-        mMonitor.noteLingerDefaultNetwork(wifi1, cell);
-        verifyNotification(wifi1, cell);
-        reset(mNotifier);
-
-        Thread.sleep(50);
-        mMonitor.noteLingerDefaultNetwork(cell, wifi2);
-        mMonitor.noteLingerDefaultNetwork(wifi2, cell);
-        verifyNotification(wifi2, cell);
-        reset(mNotifier);
-
-        Thread.sleep(50);
-        mMonitor.noteLingerDefaultNetwork(cell, wifi3);
-        mMonitor.noteLingerDefaultNetwork(wifi3, cell);
-        verifyNoNotifications();
-    }
-
-    public void testUniqueNotification() {
-        setNotificationSwitch(transition(WIFI, CELLULAR));
-        setNotificationType(LingerMonitor.NOTIFY_TYPE_NOTIFICATION);
-        NetworkAgentInfo from = wifiNai(100);
-        NetworkAgentInfo to = cellNai(101);
-
-        mMonitor.noteLingerDefaultNetwork(from, to);
-        verifyNotification(from, to);
-
-        mMonitor.noteLingerDefaultNetwork(to, from);
-        verify(mNotifier, times(1)).clearNotification(100);
-
-        mMonitor.noteLingerDefaultNetwork(from, to);
-        verifyNotification(from, to);
-    }
-
-    public void testIgnoreNeverValidatedNetworks() {
-        setNotificationType(LingerMonitor.NOTIFY_TYPE_TOAST);
-        setNotificationSwitch(transition(WIFI, CELLULAR));
-        NetworkAgentInfo from = wifiNai(100);
-        NetworkAgentInfo to = cellNai(101);
-        from.everValidated = false;
-
-        mMonitor.noteLingerDefaultNetwork(from, to);
-        verifyNoNotifications();
-    }
-
-    public void testIgnoreCurrentlyValidatedNetworks() {
-        setNotificationType(LingerMonitor.NOTIFY_TYPE_TOAST);
-        setNotificationSwitch(transition(WIFI, CELLULAR));
-        NetworkAgentInfo from = wifiNai(100);
-        NetworkAgentInfo to = cellNai(101);
-        from.lastValidated = true;
-
-        mMonitor.noteLingerDefaultNetwork(from, to);
-        verifyNoNotifications();
-    }
-
-    public void testNoNotificationType() {
-        setNotificationType(LingerMonitor.NOTIFY_TYPE_TOAST);
-        setNotificationSwitch();
-        NetworkAgentInfo from = wifiNai(100);
-        NetworkAgentInfo to = cellNai(101);
-
-        mMonitor.noteLingerDefaultNetwork(from, to);
-        verifyNoNotifications();
-    }
-
-    public void testNoTransitionToNotify() {
-        setNotificationType(LingerMonitor.NOTIFY_TYPE_NONE);
-        setNotificationSwitch(transition(WIFI, CELLULAR));
-        NetworkAgentInfo from = wifiNai(100);
-        NetworkAgentInfo to = cellNai(101);
-
-        mMonitor.noteLingerDefaultNetwork(from, to);
-        verifyNoNotifications();
-    }
-
-    public void testDifferentTransitionToNotify() {
-        setNotificationType(LingerMonitor.NOTIFY_TYPE_TOAST);
-        setNotificationSwitch(transition(CELLULAR, WIFI));
-        NetworkAgentInfo from = wifiNai(100);
-        NetworkAgentInfo to = cellNai(101);
-
-        mMonitor.noteLingerDefaultNetwork(from, to);
-        verifyNoNotifications();
-    }
-
-    void setNotificationSwitch(String... transitions) {
-        when(mResources.getStringArray(R.array.config_networkNotifySwitches))
-                .thenReturn(transitions);
-    }
-
-    String transition(String from, String to) {
-        return from + "-" + to;
-    }
-
-    void setNotificationType(int type) {
-        when(mResources.getInteger(R.integer.config_networkNotifySwitchType)).thenReturn(type);
-    }
-
-    void verifyNoToast() {
-        verify(mNotifier, never()).showToast(any(), any());
-    }
-
-    void verifyNoNotification() {
-        verify(mNotifier, never())
-                .showNotification(anyInt(), any(), any(), any(), any(), anyBoolean());
-    }
-
-    void verifyNoNotifications() {
-        verifyNoToast();
-        verifyNoNotification();
-    }
-
-    void verifyToast(NetworkAgentInfo from, NetworkAgentInfo to) {
-        verifyNoNotification();
-        verify(mNotifier, times(1)).showToast(from, to);
-    }
-
-    void verifyNotification(NetworkAgentInfo from, NetworkAgentInfo to) {
-        verifyNoToast();
-        verify(mNotifier, times(1)).showNotification(eq(from.network.netId),
-                eq(NotificationType.NETWORK_SWITCH), eq(from), eq(to), any(), eq(true));
-    }
-
-    NetworkAgentInfo nai(int netId, int transport, int networkType, String networkTypeName) {
-        NetworkInfo info = new NetworkInfo(networkType, 0, networkTypeName, "");
-        NetworkCapabilities caps = new NetworkCapabilities();
-        caps.addCapability(0);
-        caps.addTransportType(transport);
-        NetworkAgentInfo nai = new NetworkAgentInfo(null, null, new Network(netId), info, null,
-                caps, 50, mCtx, null, mMisc, null, mConnService);
-        nai.everValidated = true;
-        return nai;
-    }
-
-    NetworkAgentInfo wifiNai(int netId) {
-        return nai(netId, NetworkCapabilities.TRANSPORT_WIFI,
-                ConnectivityManager.TYPE_WIFI, WIFI);
-    }
-
-    NetworkAgentInfo cellNai(int netId) {
-        return nai(netId, NetworkCapabilities.TRANSPORT_CELLULAR,
-                ConnectivityManager.TYPE_MOBILE, CELLULAR);
-    }
-
-    public static class TestableLingerMonitor extends LingerMonitor {
-        public TestableLingerMonitor(Context c, NetworkNotificationManager n, int l, long r) {
-            super(c, n, l, r);
-        }
-        @Override protected PendingIntent createNotificationIntent() {
-            return null;
-        }
-    }
-}
diff --git a/services/tests/servicestests/src/com/android/server/connectivity/MetricsLoggerServiceTest.java b/services/tests/servicestests/src/com/android/server/connectivity/MetricsLoggerServiceTest.java
deleted file mode 100644
index 5f84ea1bfd9..00000000000
--- a/services/tests/servicestests/src/com/android/server/connectivity/MetricsLoggerServiceTest.java
+++ /dev/null
@@ -1,181 +0,0 @@
-/*
- * Copyright (C) 2016, The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.android.server.connectivity;
-
-import android.content.Context;
-import android.net.ConnectivityMetricsEvent;
-import android.os.Bundle;
-import android.os.RemoteException;
-import static android.net.ConnectivityMetricsEvent.Reference;
-
-import junit.framework.TestCase;
-import org.junit.Before;
-import org.junit.Test;
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertArrayEquals;
-
-import org.mockito.Mock;
-import org.mockito.MockitoAnnotations;
-
-import java.io.FileDescriptor;
-import java.io.FileOutputStream;
-import java.util.Arrays;
-import java.util.Comparator;
-import java.util.concurrent.CountDownLatch;
-import java.util.concurrent.TimeUnit;
-
-/*
- * TODO:
- *  - allow overriding MetricsLoggerService constants in tests.
- *  - test intents are correctly sent after the notification threshold.
- *  - test oldest events are correctly pushed out when internal deque is full.
- *  - test throttling triggers correctly.
- */
-public class MetricsLoggerServiceTest extends TestCase {
-
-    static final int COMPONENT_TAG = 1;
-    static final long N_EVENTS = 10L;
-    static final ConnectivityMetricsEvent EVENTS[] = new ConnectivityMetricsEvent[(int)N_EVENTS];
-    static {
-        for (int i = 0; i < N_EVENTS; i++) {
-            EVENTS[i] = new ConnectivityMetricsEvent(i, COMPONENT_TAG, i, new Bundle());
-        }
-    }
-
-    static final ConnectivityMetricsEvent NO_EVENTS[] = new ConnectivityMetricsEvent[0];
-
-    @Mock Context mContext;
-    MetricsLoggerService mService;
-
-    public void setUp() {
-        MockitoAnnotations.initMocks(this);
-        mService = new MetricsLoggerService(mContext);
-        mService.onStart();
-    }
-
-    public void testGetNoEvents() throws Exception {
-        Reference r = new Reference(0);
-        assertArrayEquals(NO_EVENTS, mService.mBinder.getEvents(r));
-        assertEquals(0, r.getValue());
-    }
-
-    public void testLogAndGetEvents() throws Exception {
-        mService.mBinder.logEvents(EVENTS);
-
-        Reference r = new Reference(0);
-
-        assertArrayEquals(EVENTS, mService.mBinder.getEvents(r));
-        assertEquals(N_EVENTS, r.getValue());
-
-        assertArrayEquals(NO_EVENTS, mService.mBinder.getEvents(r));
-        assertEquals(N_EVENTS, r.getValue());
-    }
-
-    public void testLogOneByOne() throws Exception {
-        for (ConnectivityMetricsEvent ev : EVENTS) {
-            mService.mBinder.logEvent(ev);
-        }
-
-        Reference r = new Reference(0);
-
-        assertArrayEquals(EVENTS, mService.mBinder.getEvents(r));
-        assertEquals(N_EVENTS, r.getValue());
-
-        assertArrayEquals(NO_EVENTS, mService.mBinder.getEvents(r));
-        assertEquals(N_EVENTS, r.getValue());
-    }
-
-    public void testInterleavedLogAndGet() throws Exception {
-        mService.mBinder.logEvents(Arrays.copyOfRange(EVENTS, 0, 3));
-
-        Reference r = new Reference(0);
-
-        assertArrayEquals(Arrays.copyOfRange(EVENTS, 0, 3), mService.mBinder.getEvents(r));
-        assertEquals(3, r.getValue());
-
-        mService.mBinder.logEvents(Arrays.copyOfRange(EVENTS, 3, 8));
-        mService.mBinder.logEvents(Arrays.copyOfRange(EVENTS, 8, 10));
-
-        assertArrayEquals(Arrays.copyOfRange(EVENTS, 3, 10), mService.mBinder.getEvents(r));
-        assertEquals(N_EVENTS, r.getValue());
-
-        assertArrayEquals(NO_EVENTS, mService.mBinder.getEvents(r));
-        assertEquals(N_EVENTS, r.getValue());
-    }
-
-    public void testMultipleGetAll() throws Exception {
-        mService.mBinder.logEvents(Arrays.copyOf(EVENTS, 3));
-
-        Reference r1 = new Reference(0);
-        assertArrayEquals(Arrays.copyOf(EVENTS, 3), mService.mBinder.getEvents(r1));
-        assertEquals(3, r1.getValue());
-
-        mService.mBinder.logEvents(Arrays.copyOfRange(EVENTS, 3, 10));
-
-        Reference r2 = new Reference(0);
-        assertArrayEquals(EVENTS, mService.mBinder.getEvents(r2));
-        assertEquals(N_EVENTS, r2.getValue());
-    }
-
-    public void testLogAndDumpConcurrently() throws Exception {
-        for (int i = 0; i < 50; i++) {
-            mContext = null;
-            mService = null;
-            setUp();
-            logAndDumpConcurrently();
-        }
-    }
-
-    public void logAndDumpConcurrently() throws Exception {
-        final CountDownLatch latch = new CountDownLatch((int)N_EVENTS);
-        final FileDescriptor fd = new FileOutputStream("/dev/null").getFD();
-
-        for (ConnectivityMetricsEvent ev : EVENTS) {
-            new Thread() {
-                public void run() {
-                    mService.mBinder.logEvent(ev);
-                    latch.countDown();
-                }
-            }.start();
-        }
-
-        new Thread() {
-            public void run() {
-                while (latch.getCount() > 0) {
-                    mService.mBinder.dump(fd, new String[]{"--all"});
-                }
-            }
-        }.start();
-
-        latch.await(100, TimeUnit.MILLISECONDS);
-
-        Reference r = new Reference(0);
-        ConnectivityMetricsEvent[] got = mService.mBinder.getEvents(r);
-        Arrays.sort(got, new EventComparator());
-        assertArrayEquals(EVENTS, got);
-        assertEquals(N_EVENTS, r.getValue());
-    }
-
-    static class EventComparator implements Comparator<ConnectivityMetricsEvent> {
-        public int compare(ConnectivityMetricsEvent ev1, ConnectivityMetricsEvent ev2) {
-            return Long.compare(ev1.timestamp, ev2.timestamp);
-        }
-        public boolean equal(Object o) {
-            return o instanceof EventComparator;
-        }
-    };
-}
diff --git a/services/tests/servicestests/src/com/android/server/connectivity/MetricsTestUtil.java b/services/tests/servicestests/src/com/android/server/connectivity/MetricsTestUtil.java
deleted file mode 100644
index e2010127812..00000000000
--- a/services/tests/servicestests/src/com/android/server/connectivity/MetricsTestUtil.java
+++ /dev/null
@@ -1,120 +0,0 @@
-/*
- * Copyright (C) 2016 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.android.server.connectivity;
-
-import android.net.ConnectivityMetricsEvent;
-import android.net.ConnectivityMetricsLogger;
-import android.os.Bundle;
-import android.os.Parcel;
-import android.os.Parcelable;
-
-abstract public class MetricsTestUtil {
-    private MetricsTestUtil() {
-    }
-
-    static ConnectivityMetricsEvent ipEv(Parcelable p) {
-        return ev(ConnectivityMetricsLogger.COMPONENT_TAG_CONNECTIVITY, p);
-    }
-
-    static ConnectivityMetricsEvent telephonyEv() {
-        return ev(ConnectivityMetricsLogger.COMPONENT_TAG_TELEPHONY, new Bundle());
-    }
-
-    static ConnectivityMetricsEvent ev(int tag, Parcelable p) {
-        return new ConnectivityMetricsEvent(1L, tag, 0, p);
-    }
-
-    // Utiliy interface for describing the content of a Parcel. This relies on
-    // the implementation defails of Parcelable and on the fact that the fully
-    // qualified Parcelable class names are written as string in the Parcels.
-    interface ParcelField {
-        void write(Parcel p);
-    }
-
-    static ConnectivityMetricsEvent describeIpEvent(ParcelField... fs) {
-        Parcel p = Parcel.obtain();
-        for (ParcelField f : fs) {
-            f.write(p);
-        }
-        p.setDataPosition(0);
-        return ipEv(p.readParcelable(ClassLoader.getSystemClassLoader()));
-    }
-
-    static ParcelField aType(Class<?> c) {
-        return new ParcelField() {
-            public void write(Parcel p) {
-                p.writeString(c.getName());
-            }
-        };
-    }
-
-    static ParcelField aBool(boolean b) {
-        return aByte((byte) (b ? 1 : 0));
-    }
-
-    static ParcelField aByte(byte b) {
-        return new ParcelField() {
-            public void write(Parcel p) {
-                p.writeByte(b);
-            }
-        };
-    }
-
-    static ParcelField anInt(int i) {
-        return new ParcelField() {
-            public void write(Parcel p) {
-                p.writeInt(i);
-            }
-        };
-    }
-
-    static ParcelField aLong(long l) {
-        return new ParcelField() {
-            public void write(Parcel p) {
-                p.writeLong(l);
-            }
-        };
-    }
-
-    static ParcelField aString(String s) {
-        return new ParcelField() {
-            public void write(Parcel p) {
-                p.writeString(s);
-            }
-        };
-    }
-
-    static ParcelField aByteArray(byte... ary) {
-        return new ParcelField() {
-            public void write(Parcel p) {
-                p.writeByteArray(ary);
-            }
-        };
-    }
-
-    static ParcelField anIntArray(int... ary) {
-        return new ParcelField() {
-            public void write(Parcel p) {
-                p.writeIntArray(ary);
-            }
-        };
-    }
-
-    static byte b(int i) {
-        return (byte) i;
-    }
-}
diff --git a/services/tests/servicestests/src/com/android/server/connectivity/VpnTest.java b/services/tests/servicestests/src/com/android/server/connectivity/VpnTest.java
deleted file mode 100644
index 5d8b843bbc1..00000000000
--- a/services/tests/servicestests/src/com/android/server/connectivity/VpnTest.java
+++ /dev/null
@@ -1,310 +0,0 @@
-/*
- * Copyright (C) 2016 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.android.server.connectivity;
-
-import static android.content.pm.UserInfo.FLAG_ADMIN;
-import static android.content.pm.UserInfo.FLAG_MANAGED_PROFILE;
-import static android.content.pm.UserInfo.FLAG_PRIMARY;
-import static android.content.pm.UserInfo.FLAG_RESTRICTED;
-import static org.mockito.AdditionalMatchers.*;
-import static org.mockito.Mockito.*;
-
-import android.annotation.UserIdInt;
-import android.app.AppOpsManager;
-import android.content.Context;
-import android.content.pm.PackageManager;
-import android.content.pm.UserInfo;
-import android.net.UidRange;
-import android.os.INetworkManagementService;
-import android.os.Looper;
-import android.os.UserHandle;
-import android.os.UserManager;
-import android.test.AndroidTestCase;
-import android.test.suitebuilder.annotation.SmallTest;
-import android.util.ArrayMap;
-import android.util.ArraySet;
-
-import java.util.ArrayList;
-import java.util.Arrays;
-import java.util.Map;
-import java.util.Set;
-
-import org.mockito.Mock;
-import org.mockito.MockitoAnnotations;
-
-/**
- * Tests for {@link Vpn}.
- *
- * Build, install and run with:
- *  runtest --path src/com/android/server/connectivity/VpnTest.java
- */
-public class VpnTest extends AndroidTestCase {
-    private static final String TAG = "VpnTest";
-
-    // Mock users
-    static final UserInfo primaryUser = new UserInfo(27, "Primary", FLAG_ADMIN | FLAG_PRIMARY);
-    static final UserInfo secondaryUser = new UserInfo(15, "Secondary", FLAG_ADMIN);
-    static final UserInfo restrictedProfileA = new UserInfo(40, "RestrictedA", FLAG_RESTRICTED);
-    static final UserInfo restrictedProfileB = new UserInfo(42, "RestrictedB", FLAG_RESTRICTED);
-    static final UserInfo managedProfileA = new UserInfo(45, "ManagedA", FLAG_MANAGED_PROFILE);
-    static {
-        restrictedProfileA.restrictedProfileParentId = primaryUser.id;
-        restrictedProfileB.restrictedProfileParentId = secondaryUser.id;
-        managedProfileA.profileGroupId = primaryUser.id;
-    }
-
-    /**
-     * Names and UIDs for some fake packages. Important points:
-     *  - UID is ordered increasing.
-     *  - One pair of packages have consecutive UIDs.
-     */
-    static final String[] PKGS = {"com.example", "org.example", "net.example", "web.vpn"};
-    static final int[] PKG_UIDS = {66, 77, 78, 400};
-
-    // Mock packages
-    static final Map<String, Integer> mPackages = new ArrayMap<>();
-    static {
-        for (int i = 0; i < PKGS.length; i++) {
-            mPackages.put(PKGS[i], PKG_UIDS[i]);
-        }
-    }
-
-    @Mock private Context mContext;
-    @Mock private UserManager mUserManager;
-    @Mock private PackageManager mPackageManager;
-    @Mock private INetworkManagementService mNetService;
-    @Mock private AppOpsManager mAppOps;
-
-    @Override
-    public void setUp() throws Exception {
-        MockitoAnnotations.initMocks(this);
-        when(mContext.getPackageManager()).thenReturn(mPackageManager);
-        setMockedPackages(mPackages);
-        when(mContext.getSystemService(eq(Context.USER_SERVICE))).thenReturn(mUserManager);
-        when(mContext.getSystemService(eq(Context.APP_OPS_SERVICE))).thenReturn(mAppOps);
-        doNothing().when(mNetService).registerObserver(any());
-    }
-
-    @SmallTest
-    public void testRestrictedProfilesAreAddedToVpn() {
-        setMockedUsers(primaryUser, secondaryUser, restrictedProfileA, restrictedProfileB);
-
-        final Vpn vpn = new MockVpn(primaryUser.id);
-        final Set<UidRange> ranges = vpn.createUserAndRestrictedProfilesRanges(primaryUser.id,
-                null, null);
-
-        assertEquals(new ArraySet<>(Arrays.asList(new UidRange[] {
-            UidRange.createForUser(primaryUser.id),
-            UidRange.createForUser(restrictedProfileA.id)
-        })), ranges);
-    }
-
-    @SmallTest
-    public void testManagedProfilesAreNotAddedToVpn() {
-        setMockedUsers(primaryUser, managedProfileA);
-
-        final Vpn vpn = new MockVpn(primaryUser.id);
-        final Set<UidRange> ranges = vpn.createUserAndRestrictedProfilesRanges(primaryUser.id,
-                null, null);
-
-        assertEquals(new ArraySet<>(Arrays.asList(new UidRange[] {
-            UidRange.createForUser(primaryUser.id)
-        })), ranges);
-    }
-
-    @SmallTest
-    public void testAddUserToVpnOnlyAddsOneUser() {
-        setMockedUsers(primaryUser, restrictedProfileA, managedProfileA);
-
-        final Vpn vpn = new MockVpn(primaryUser.id);
-        final Set<UidRange> ranges = new ArraySet<>();
-        vpn.addUserToRanges(ranges, primaryUser.id, null, null);
-
-        assertEquals(new ArraySet<>(Arrays.asList(new UidRange[] {
-            UidRange.createForUser(primaryUser.id)
-        })), ranges);
-    }
-
-    @SmallTest
-    public void testUidWhiteAndBlacklist() throws Exception {
-        final Vpn vpn = new MockVpn(primaryUser.id);
-        final UidRange user = UidRange.createForUser(primaryUser.id);
-        final String[] packages = {PKGS[0], PKGS[1], PKGS[2]};
-
-        // Whitelist
-        final Set<UidRange> allow = vpn.createUserAndRestrictedProfilesRanges(primaryUser.id,
-                Arrays.asList(packages), null);
-        assertEquals(new ArraySet<>(Arrays.asList(new UidRange[] {
-            new UidRange(user.start + PKG_UIDS[0], user.start + PKG_UIDS[0]),
-            new UidRange(user.start + PKG_UIDS[1], user.start + PKG_UIDS[2])
-        })), allow);
-
-        // Blacklist
-        final Set<UidRange> disallow = vpn.createUserAndRestrictedProfilesRanges(primaryUser.id,
-                null, Arrays.asList(packages));
-        assertEquals(new ArraySet<>(Arrays.asList(new UidRange[] {
-            new UidRange(user.start, user.start + PKG_UIDS[0] - 1),
-            new UidRange(user.start + PKG_UIDS[0] + 1, user.start + PKG_UIDS[1] - 1),
-            /* Empty range between UIDS[1] and UIDS[2], should be excluded, */
-            new UidRange(user.start + PKG_UIDS[2] + 1, user.stop)
-        })), disallow);
-    }
-
-    @SmallTest
-    public void testLockdownChangingPackage() throws Exception {
-        final MockVpn vpn = new MockVpn(primaryUser.id);
-        final UidRange user = UidRange.createForUser(primaryUser.id);
-
-        // Default state.
-        vpn.assertUnblocked(user.start + PKG_UIDS[0], user.start + PKG_UIDS[1], user.start + PKG_UIDS[2], user.start + PKG_UIDS[3]);
-
-        // Set always-on without lockdown.
-        assertTrue(vpn.setAlwaysOnPackage(PKGS[1], false));
-        vpn.assertUnblocked(user.start + PKG_UIDS[0], user.start + PKG_UIDS[1], user.start + PKG_UIDS[2], user.start + PKG_UIDS[3]);
-
-        // Set always-on with lockdown.
-        assertTrue(vpn.setAlwaysOnPackage(PKGS[1], true));
-        verify(mNetService).setAllowOnlyVpnForUids(eq(true), aryEq(new UidRange[] {
-            new UidRange(user.start, user.start + PKG_UIDS[1] - 1),
-            new UidRange(user.start + PKG_UIDS[1] + 1, user.stop)
-        }));
-        vpn.assertBlocked(user.start + PKG_UIDS[0], user.start + PKG_UIDS[2], user.start + PKG_UIDS[3]);
-        vpn.assertUnblocked(user.start + PKG_UIDS[1]);
-
-        // Switch to another app.
-        assertTrue(vpn.setAlwaysOnPackage(PKGS[3], true));
-        verify(mNetService).setAllowOnlyVpnForUids(eq(false), aryEq(new UidRange[] {
-            new UidRange(user.start, user.start + PKG_UIDS[1] - 1),
-            new UidRange(user.start + PKG_UIDS[1] + 1, user.stop)
-        }));
-        verify(mNetService).setAllowOnlyVpnForUids(eq(true), aryEq(new UidRange[] {
-            new UidRange(user.start, user.start + PKG_UIDS[3] - 1),
-            new UidRange(user.start + PKG_UIDS[3] + 1, user.stop)
-        }));
-        vpn.assertBlocked(user.start + PKG_UIDS[0], user.start + PKG_UIDS[1], user.start + PKG_UIDS[2]);
-        vpn.assertUnblocked(user.start + PKG_UIDS[3]);
-    }
-
-    @SmallTest
-    public void testLockdownAddingAProfile() throws Exception {
-        final MockVpn vpn = new MockVpn(primaryUser.id);
-        setMockedUsers(primaryUser);
-
-        // Make a copy of the restricted profile, as we're going to mark it deleted halfway through.
-        final UserInfo tempProfile = new UserInfo(restrictedProfileA.id, restrictedProfileA.name,
-                restrictedProfileA.flags);
-        tempProfile.restrictedProfileParentId = primaryUser.id;
-
-        final UidRange user = UidRange.createForUser(primaryUser.id);
-        final UidRange profile = UidRange.createForUser(tempProfile.id);
-
-        // Set lockdown.
-        assertTrue(vpn.setAlwaysOnPackage(PKGS[3], true));
-        verify(mNetService).setAllowOnlyVpnForUids(eq(true), aryEq(new UidRange[] {
-            new UidRange(user.start, user.start + PKG_UIDS[3] - 1),
-            new UidRange(user.start + PKG_UIDS[3] + 1, user.stop)
-        }));
-
-        // Verify restricted user isn't affected at first.
-        vpn.assertUnblocked(profile.start + PKG_UIDS[0]);
-
-        // Add the restricted user.
-        setMockedUsers(primaryUser, tempProfile);
-        vpn.onUserAdded(tempProfile.id);
-        verify(mNetService).setAllowOnlyVpnForUids(eq(true), aryEq(new UidRange[] {
-            new UidRange(profile.start, profile.start + PKG_UIDS[3] - 1),
-            new UidRange(profile.start + PKG_UIDS[3] + 1, profile.stop)
-        }));
-
-        // Remove the restricted user.
-        tempProfile.partial = true;
-        vpn.onUserRemoved(tempProfile.id);
-        verify(mNetService).setAllowOnlyVpnForUids(eq(false), aryEq(new UidRange[] {
-            new UidRange(profile.start, profile.start + PKG_UIDS[3] - 1),
-            new UidRange(profile.start + PKG_UIDS[3] + 1, profile.stop)
-        }));
-    }
-
-    /**
-     * A subclass of {@link Vpn} with some of the fields pre-mocked.
-     */
-    private class MockVpn extends Vpn {
-        public MockVpn(@UserIdInt int userId) {
-            super(Looper.myLooper(), mContext, mNetService, userId);
-        }
-
-        public void assertBlocked(int... uids) {
-            for (int uid : uids) {
-                assertTrue("Uid " + uid + " should be blocked", isBlockingUid(uid));
-            }
-        }
-
-        public void assertUnblocked(int... uids) {
-            for (int uid : uids) {
-                assertFalse("Uid " + uid + " should not be blocked", isBlockingUid(uid));
-            }
-        }
-    }
-
-    /**
-     * Populate {@link #mUserManager} with a list of fake users.
-     */
-    private void setMockedUsers(UserInfo... users) {
-        final Map<Integer, UserInfo> userMap = new ArrayMap<>();
-        for (UserInfo user : users) {
-            userMap.put(user.id, user);
-        }
-
-        /**
-         * @see UserManagerService#getUsers(boolean)
-         */
-        doAnswer(invocation -> {
-            final boolean excludeDying = (boolean) invocation.getArguments()[0];
-            final ArrayList<UserInfo> result = new ArrayList<>(users.length);
-            for (UserInfo ui : users) {
-                if (!excludeDying || (ui.isEnabled() && !ui.partial)) {
-                    result.add(ui);
-                }
-            }
-            return result;
-        }).when(mUserManager).getUsers(anyBoolean());
-
-        doAnswer(invocation -> {
-            final int id = (int) invocation.getArguments()[0];
-            return userMap.get(id);
-        }).when(mUserManager).getUserInfo(anyInt());
-
-        doAnswer(invocation -> {
-            final int id = (int) invocation.getArguments()[0];
-            return (userMap.get(id).flags & UserInfo.FLAG_ADMIN) != 0;
-        }).when(mUserManager).canHaveRestrictedProfile(anyInt());
-    }
-
-    /**
-     * Populate {@link #mPackageManager} with a fake packageName-to-UID mapping.
-     */
-    private void setMockedPackages(final Map<String, Integer> packages) {
-        try {
-            doAnswer(invocation -> {
-                final String appName = (String) invocation.getArguments()[0];
-                final int userId = (int) invocation.getArguments()[1];
-                return UserHandle.getUid(userId, packages.get(appName));
-            }).when(mPackageManager).getPackageUidAsUser(anyString(), anyInt());
-        } catch (Exception e) {
-        }
-    }
-}
diff --git a/services/tests/servicestests/src/com/android/server/connectivity/tethering/TetherInterfaceStateMachineTest.java b/services/tests/servicestests/src/com/android/server/connectivity/tethering/TetherInterfaceStateMachineTest.java
deleted file mode 100644
index a30b3629d5c..00000000000
--- a/services/tests/servicestests/src/com/android/server/connectivity/tethering/TetherInterfaceStateMachineTest.java
+++ /dev/null
@@ -1,277 +0,0 @@
-/*
- * Copyright (C) 2016 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.android.server.connectivity.tethering;
-
-import static org.mockito.Matchers.anyString;
-import static org.mockito.Mockito.doThrow;
-import static org.mockito.Mockito.inOrder;
-import static org.mockito.Mockito.reset;
-import static org.mockito.Mockito.verify;
-import static org.mockito.Mockito.verifyNoMoreInteractions;
-import static org.mockito.Mockito.when;
-
-import static android.net.ConnectivityManager.TETHER_ERROR_ENABLE_NAT_ERROR;
-import static android.net.ConnectivityManager.TETHER_ERROR_NO_ERROR;
-import static android.net.ConnectivityManager.TETHER_ERROR_TETHER_IFACE_ERROR;
-import static android.net.ConnectivityManager.TETHER_ERROR_UNTETHER_IFACE_ERROR;
-import static com.android.server.connectivity.tethering.IControlsTethering.STATE_AVAILABLE;
-import static com.android.server.connectivity.tethering.IControlsTethering.STATE_TETHERED;
-import static com.android.server.connectivity.tethering.IControlsTethering.STATE_UNAVAILABLE;
-
-import android.net.ConnectivityManager;
-import android.net.INetworkStatsService;
-import android.net.InterfaceConfiguration;
-import android.os.INetworkManagementService;
-import android.os.RemoteException;
-import android.os.test.TestLooper;
-import android.support.test.filters.SmallTest;
-import android.support.test.runner.AndroidJUnit4;
-
-import org.junit.Before;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.mockito.InOrder;
-import org.mockito.Mock;
-import org.mockito.MockitoAnnotations;
-
-@RunWith(AndroidJUnit4.class)
-@SmallTest
-public class TetherInterfaceStateMachineTest {
-    private static final String IFACE_NAME = "testnet1";
-    private static final String UPSTREAM_IFACE = "upstream0";
-    private static final String UPSTREAM_IFACE2 = "upstream1";
-
-    @Mock private INetworkManagementService mNMService;
-    @Mock private INetworkStatsService mStatsService;
-    @Mock private IControlsTethering mTetherHelper;
-    @Mock private InterfaceConfiguration mInterfaceConfiguration;
-
-    private final TestLooper mLooper = new TestLooper();
-    private TetherInterfaceStateMachine mTestedSm;
-
-    private void initStateMachine(int interfaceType) throws Exception {
-        mTestedSm = new TetherInterfaceStateMachine(IFACE_NAME, mLooper.getLooper(), interfaceType,
-                mNMService, mStatsService, mTetherHelper);
-        mTestedSm.start();
-        // Starting the state machine always puts us in a consistent state and notifies
-        // the test of the world that we've changed from an unknown to available state.
-        mLooper.dispatchAll();
-        reset(mNMService, mStatsService, mTetherHelper);
-        when(mNMService.getInterfaceConfig(IFACE_NAME)).thenReturn(mInterfaceConfiguration);
-    }
-
-    private void initTetheredStateMachine(int interfaceType, String upstreamIface) throws Exception {
-        initStateMachine(interfaceType);
-        dispatchCommand(TetherInterfaceStateMachine.CMD_TETHER_REQUESTED);
-        if (upstreamIface != null) {
-            dispatchTetherConnectionChanged(upstreamIface);
-        }
-        reset(mNMService, mStatsService, mTetherHelper);
-        when(mNMService.getInterfaceConfig(IFACE_NAME)).thenReturn(mInterfaceConfiguration);
-    }
-
-    @Before public void setUp() throws Exception {
-        MockitoAnnotations.initMocks(this);
-    }
-
-    @Test
-    public void startsOutAvailable() {
-        mTestedSm = new TetherInterfaceStateMachine(IFACE_NAME, mLooper.getLooper(),
-                ConnectivityManager.TETHERING_BLUETOOTH, mNMService, mStatsService, mTetherHelper);
-        mTestedSm.start();
-        mLooper.dispatchAll();
-        verify(mTetherHelper).notifyInterfaceStateChange(
-                IFACE_NAME, mTestedSm, STATE_AVAILABLE, TETHER_ERROR_NO_ERROR);
-        verifyNoMoreInteractions(mTetherHelper, mNMService, mStatsService);
-    }
-
-    @Test
-    public void shouldDoNothingUntilRequested() throws Exception {
-        initStateMachine(ConnectivityManager.TETHERING_BLUETOOTH);
-        final int [] NOOP_COMMANDS = {
-            TetherInterfaceStateMachine.CMD_TETHER_UNREQUESTED,
-            TetherInterfaceStateMachine.CMD_IP_FORWARDING_ENABLE_ERROR,
-            TetherInterfaceStateMachine.CMD_IP_FORWARDING_DISABLE_ERROR,
-            TetherInterfaceStateMachine.CMD_START_TETHERING_ERROR,
-            TetherInterfaceStateMachine.CMD_STOP_TETHERING_ERROR,
-            TetherInterfaceStateMachine.CMD_SET_DNS_FORWARDERS_ERROR,
-            TetherInterfaceStateMachine.CMD_TETHER_CONNECTION_CHANGED
-        };
-        for (int command : NOOP_COMMANDS) {
-            // None of these commands should trigger us to request action from
-            // the rest of the system.
-            dispatchCommand(command);
-            verifyNoMoreInteractions(mNMService, mStatsService, mTetherHelper);
-        }
-    }
-
-    @Test
-    public void handlesImmediateInterfaceDown() throws Exception {
-        initStateMachine(ConnectivityManager.TETHERING_BLUETOOTH);
-
-        dispatchCommand(TetherInterfaceStateMachine.CMD_INTERFACE_DOWN);
-        verify(mTetherHelper).notifyInterfaceStateChange(
-                IFACE_NAME, mTestedSm, STATE_UNAVAILABLE, TETHER_ERROR_NO_ERROR);
-        verifyNoMoreInteractions(mNMService, mStatsService, mTetherHelper);
-    }
-
-    @Test
-    public void canBeTethered() throws Exception {
-        initStateMachine(ConnectivityManager.TETHERING_BLUETOOTH);
-
-        dispatchCommand(TetherInterfaceStateMachine.CMD_TETHER_REQUESTED);
-        InOrder inOrder = inOrder(mTetherHelper, mNMService);
-        inOrder.verify(mNMService).tetherInterface(IFACE_NAME);
-        inOrder.verify(mTetherHelper).notifyInterfaceStateChange(
-                IFACE_NAME, mTestedSm, STATE_TETHERED, TETHER_ERROR_NO_ERROR);
-        verifyNoMoreInteractions(mNMService, mStatsService, mTetherHelper);
-    }
-
-    @Test
-    public void canUnrequestTethering() throws Exception {
-        initTetheredStateMachine(ConnectivityManager.TETHERING_BLUETOOTH, null);
-
-        dispatchCommand(TetherInterfaceStateMachine.CMD_TETHER_UNREQUESTED);
-        InOrder inOrder = inOrder(mNMService, mStatsService, mTetherHelper);
-        inOrder.verify(mNMService).untetherInterface(IFACE_NAME);
-        inOrder.verify(mTetherHelper).notifyInterfaceStateChange(
-                IFACE_NAME, mTestedSm, STATE_AVAILABLE, TETHER_ERROR_NO_ERROR);
-        verifyNoMoreInteractions(mNMService, mStatsService, mTetherHelper);
-    }
-
-    @Test
-    public void canBeTetheredAsUsb() throws Exception {
-        initStateMachine(ConnectivityManager.TETHERING_USB);
-
-        dispatchCommand(TetherInterfaceStateMachine.CMD_TETHER_REQUESTED);
-        InOrder inOrder = inOrder(mTetherHelper, mNMService);
-        inOrder.verify(mNMService).getInterfaceConfig(IFACE_NAME);
-        inOrder.verify(mNMService).setInterfaceConfig(IFACE_NAME, mInterfaceConfiguration);
-        inOrder.verify(mNMService).tetherInterface(IFACE_NAME);
-        inOrder.verify(mTetherHelper).notifyInterfaceStateChange(
-                IFACE_NAME, mTestedSm, STATE_TETHERED, TETHER_ERROR_NO_ERROR);
-        verifyNoMoreInteractions(mNMService, mStatsService, mTetherHelper);
-    }
-
-    @Test
-    public void handlesFirstUpstreamChange() throws Exception {
-        initTetheredStateMachine(ConnectivityManager.TETHERING_BLUETOOTH, null);
-
-        // Telling the state machine about its upstream interface triggers a little more configuration.
-        dispatchTetherConnectionChanged(UPSTREAM_IFACE);
-        InOrder inOrder = inOrder(mNMService);
-        inOrder.verify(mNMService).enableNat(IFACE_NAME, UPSTREAM_IFACE);
-        inOrder.verify(mNMService).startInterfaceForwarding(IFACE_NAME, UPSTREAM_IFACE);
-        verifyNoMoreInteractions(mNMService, mStatsService, mTetherHelper);
-    }
-
-    @Test
-    public void handlesChangingUpstream() throws Exception {
-        initTetheredStateMachine(ConnectivityManager.TETHERING_BLUETOOTH, UPSTREAM_IFACE);
-
-        dispatchTetherConnectionChanged(UPSTREAM_IFACE2);
-        InOrder inOrder = inOrder(mNMService, mStatsService);
-        inOrder.verify(mStatsService).forceUpdate();
-        inOrder.verify(mNMService).stopInterfaceForwarding(IFACE_NAME, UPSTREAM_IFACE);
-        inOrder.verify(mNMService).disableNat(IFACE_NAME, UPSTREAM_IFACE);
-        inOrder.verify(mNMService).enableNat(IFACE_NAME, UPSTREAM_IFACE2);
-        inOrder.verify(mNMService).startInterfaceForwarding(IFACE_NAME, UPSTREAM_IFACE2);
-        verifyNoMoreInteractions(mNMService, mStatsService, mTetherHelper);
-    }
-
-    @Test
-    public void canUnrequestTetheringWithUpstream() throws Exception {
-        initTetheredStateMachine(ConnectivityManager.TETHERING_BLUETOOTH, UPSTREAM_IFACE);
-
-        dispatchCommand(TetherInterfaceStateMachine.CMD_TETHER_UNREQUESTED);
-        InOrder inOrder = inOrder(mNMService, mStatsService, mTetherHelper);
-        inOrder.verify(mStatsService).forceUpdate();
-        inOrder.verify(mNMService).stopInterfaceForwarding(IFACE_NAME, UPSTREAM_IFACE);
-        inOrder.verify(mNMService).disableNat(IFACE_NAME, UPSTREAM_IFACE);
-        inOrder.verify(mNMService).untetherInterface(IFACE_NAME);
-        inOrder.verify(mTetherHelper).notifyInterfaceStateChange(
-                IFACE_NAME, mTestedSm, STATE_AVAILABLE, TETHER_ERROR_NO_ERROR);
-        verifyNoMoreInteractions(mNMService, mStatsService, mTetherHelper);
-    }
-
-    @Test
-    public void interfaceDownLeadsToUnavailable() throws Exception {
-        for (boolean shouldThrow : new boolean[]{true, false}) {
-            initTetheredStateMachine(ConnectivityManager.TETHERING_USB, null);
-
-            if (shouldThrow) {
-                doThrow(RemoteException.class).when(mNMService).untetherInterface(IFACE_NAME);
-            }
-            dispatchCommand(TetherInterfaceStateMachine.CMD_INTERFACE_DOWN);
-            InOrder usbTeardownOrder = inOrder(mNMService, mInterfaceConfiguration, mTetherHelper);
-            usbTeardownOrder.verify(mInterfaceConfiguration).setInterfaceDown();
-            usbTeardownOrder.verify(mNMService).setInterfaceConfig(
-                    IFACE_NAME, mInterfaceConfiguration);
-            usbTeardownOrder.verify(mTetherHelper).notifyInterfaceStateChange(
-                    IFACE_NAME, mTestedSm, STATE_UNAVAILABLE, TETHER_ERROR_NO_ERROR);
-        }
-    }
-
-    @Test
-    public void usbShouldBeTornDownOnTetherError() throws Exception {
-        initStateMachine(ConnectivityManager.TETHERING_USB);
-
-        doThrow(RemoteException.class).when(mNMService).tetherInterface(IFACE_NAME);
-        dispatchCommand(TetherInterfaceStateMachine.CMD_TETHER_REQUESTED);
-        InOrder usbTeardownOrder = inOrder(mNMService, mInterfaceConfiguration, mTetherHelper);
-        usbTeardownOrder.verify(mInterfaceConfiguration).setInterfaceDown();
-        usbTeardownOrder.verify(mNMService).setInterfaceConfig(
-                IFACE_NAME, mInterfaceConfiguration);
-        usbTeardownOrder.verify(mTetherHelper).notifyInterfaceStateChange(
-                IFACE_NAME, mTestedSm, STATE_AVAILABLE, TETHER_ERROR_TETHER_IFACE_ERROR);
-    }
-
-    @Test
-    public void shouldTearDownUsbOnUpstreamError() throws Exception {
-        initTetheredStateMachine(ConnectivityManager.TETHERING_USB, null);
-
-        doThrow(RemoteException.class).when(mNMService).enableNat(anyString(), anyString());
-        dispatchTetherConnectionChanged(UPSTREAM_IFACE);
-        InOrder usbTeardownOrder = inOrder(mNMService, mInterfaceConfiguration, mTetherHelper);
-        usbTeardownOrder.verify(mInterfaceConfiguration).setInterfaceDown();
-        usbTeardownOrder.verify(mNMService).setInterfaceConfig(IFACE_NAME, mInterfaceConfiguration);
-        usbTeardownOrder.verify(mTetherHelper).notifyInterfaceStateChange(
-                IFACE_NAME, mTestedSm, STATE_AVAILABLE, TETHER_ERROR_ENABLE_NAT_ERROR);
-    }
-
-    /**
-     * Send a command to the state machine under test, and run the event loop to idle.
-     *
-     * @param command One of the TetherInterfaceStateMachine.CMD_* constants.
-     */
-    private void dispatchCommand(int command) {
-        mTestedSm.sendMessage(command);
-        mLooper.dispatchAll();
-    }
-
-    /**
-     * Special override to tell the state machine that the upstream interface has changed.
-     *
-     * @see #dispatchCommand(int)
-     * @param upstreamIface String name of upstream interface (or null)
-     */
-    private void dispatchTetherConnectionChanged(String upstreamIface) {
-        mTestedSm.sendMessage(TetherInterfaceStateMachine.CMD_TETHER_CONNECTION_CHANGED,
-                upstreamIface);
-        mLooper.dispatchAll();
-    }
-}
\ No newline at end of file
diff --git a/services/tests/servicestests/src/com/android/server/content/ObserverNodeTest.java b/services/tests/servicestests/src/com/android/server/content/ObserverNodeTest.java
deleted file mode 100644
index 07280bc881d..00000000000
--- a/services/tests/servicestests/src/com/android/server/content/ObserverNodeTest.java
+++ /dev/null
@@ -1,100 +0,0 @@
-/*
- * Copyright (C) 2007 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.android.server.content;
-
-import java.util.ArrayList;
-
-import android.database.ContentObserver;
-import android.net.Uri;
-import android.os.Handler;
-import android.os.UserHandle;
-import android.test.AndroidTestCase;
-
-import com.android.server.content.ContentService.ObserverCall;
-import com.android.server.content.ContentService.ObserverNode;
-
-public class ObserverNodeTest extends AndroidTestCase {
-    static class TestObserver  extends ContentObserver {
-        public TestObserver() {
-            super(new Handler());
-        }
-    }
-
-    public void testUri() {
-        final int myUserHandle = UserHandle.myUserId();
-
-        ObserverNode root = new ObserverNode("");
-        Uri[] uris = new Uri[] {
-            Uri.parse("content://c/a/"),
-            Uri.parse("content://c/"),
-            Uri.parse("content://x/"),
-            Uri.parse("content://c/b/"),
-            Uri.parse("content://c/a/a1/1/"),
-            Uri.parse("content://c/a/a1/2/"),
-            Uri.parse("content://c/b/1/"),
-            Uri.parse("content://c/b/2/"),
-        };
-
-        int[] nums = new int[] {4, 7, 1, 4, 2, 2, 3, 3};
-
-        // special case
-        root.addObserverLocked(uris[0], new TestObserver().getContentObserver(), false, root,
-                0, 0, myUserHandle);
-        for(int i = 1; i < uris.length; i++) {
-            root.addObserverLocked(uris[i], new TestObserver().getContentObserver(), true, root,
-                    0, 0, myUserHandle);
-        }
-
-        ArrayList<ObserverCall> calls = new ArrayList<ObserverCall>();
-
-        for (int i = nums.length - 1; i >=0; --i) {
-            root.collectObserversLocked(uris[i], 0, null, false, 0, myUserHandle, calls);
-            assertEquals(nums[i], calls.size());
-            calls.clear();
-        }
-    }
-
-    public void testUriNotNotify() {
-        final int myUserHandle = UserHandle.myUserId();
-
-        ObserverNode root = new ObserverNode("");
-        Uri[] uris = new Uri[] {
-            Uri.parse("content://c/"),
-            Uri.parse("content://x/"),
-            Uri.parse("content://c/a/"),
-            Uri.parse("content://c/b/"),
-            Uri.parse("content://c/a/1/"),
-            Uri.parse("content://c/a/2/"),
-            Uri.parse("content://c/b/1/"),
-            Uri.parse("content://c/b/2/"),
-        };
-        int[] nums = new int[] {7, 1, 3, 3, 1, 1, 1, 1};
-
-        for(int i = 0; i < uris.length; i++) {
-            root.addObserverLocked(uris[i], new TestObserver().getContentObserver(), false, root,
-                    0, 0, myUserHandle);
-        }
-
-        ArrayList<ObserverCall> calls = new ArrayList<ObserverCall>();
-
-        for (int i = uris.length - 1; i >=0; --i) {
-            root.collectObserversLocked(uris[i], 0, null, false, 0, myUserHandle, calls);
-            assertEquals(nums[i], calls.size());
-            calls.clear();
-        }
-    }
-}
diff --git a/services/tests/servicestests/src/com/android/server/content/SyncManagerTest.java b/services/tests/servicestests/src/com/android/server/content/SyncManagerTest.java
deleted file mode 100644
index be6861c4369..00000000000
--- a/services/tests/servicestests/src/com/android/server/content/SyncManagerTest.java
+++ /dev/null
@@ -1,64 +0,0 @@
-package com.android.server.content;
-
-import android.os.Bundle;
-
-import junit.framework.TestCase;
-
-public class SyncManagerTest extends TestCase {
-
-    final String KEY_1 = "key_1";
-    final String KEY_2 = "key_2";
-
-    public void testSyncExtrasEquals_WithNull() throws Exception {
-        Bundle b1 = new Bundle();
-        Bundle b2 = new Bundle();
-
-        b1.putString(KEY_1, null);
-        b2.putString(KEY_1, null);
-
-        assertTrue("Null extra not properly compared between bundles.",
-                SyncManager.syncExtrasEquals(b1, b2, false /* don't care about system extras */));
-    }
-
-    public void testSyncExtrasEqualsBigger_WithNull() throws Exception {
-        Bundle b1 = new Bundle();
-        Bundle b2 = new Bundle();
-
-        b1.putString(KEY_1, null);
-        b2.putString(KEY_1, null);
-
-        b1.putString(KEY_2, "bla");
-        b2.putString(KEY_2, "bla");
-
-        assertTrue("Extras not properly compared between bundles.",
-                SyncManager.syncExtrasEquals(b1, b2, false /* don't care about system extras */));
-    }
-
-    public void testSyncExtrasEqualsFails_differentValues() throws Exception {
-        Bundle b1 = new Bundle();
-        Bundle b2 = new Bundle();
-
-        b1.putString(KEY_1, null);
-        b2.putString(KEY_1, null);
-
-        b1.putString(KEY_2, "bla");
-        b2.putString(KEY_2, "ble");  // different key
-
-        assertFalse("Extras considered equal when they are different.",
-                SyncManager.syncExtrasEquals(b1, b2, false /* don't care about system extras */));
-    }
-
-    public void testSyncExtrasEqualsFails_differentNulls() throws Exception {
-        Bundle b1 = new Bundle();
-        Bundle b2 = new Bundle();
-
-        b1.putString(KEY_1, null);
-        b2.putString(KEY_1, "bla");  // different key
-
-        b1.putString(KEY_2, "ble");
-        b2.putString(KEY_2, "ble");
-
-        assertFalse("Extras considered equal when they are different.",
-                SyncManager.syncExtrasEquals(b1, b2, false /* don't care about system extras */));
-    }
-}
diff --git a/services/tests/servicestests/src/com/android/server/content/SyncOperationTest.java b/services/tests/servicestests/src/com/android/server/content/SyncOperationTest.java
deleted file mode 100644
index e45b92a1b48..00000000000
--- a/services/tests/servicestests/src/com/android/server/content/SyncOperationTest.java
+++ /dev/null
@@ -1,154 +0,0 @@
-/*
- * Copyright (C) 2010 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.android.server.content;
-
-import android.accounts.Account;
-import android.content.ContentResolver;
-import android.content.Context;
-import android.os.Bundle;
-import android.os.PersistableBundle;
-import android.os.SystemClock;
-import android.provider.Settings;
-import android.test.AndroidTestCase;
-import android.test.suitebuilder.annotation.SmallTest;
-
-/**
- * You can run those tests with:
- *
- * adb shell am instrument
- * -e debug false
- * -w
- * -e class android.content.SyncOperationTest com.android.frameworks.coretests/android.test.InstrumentationTestRunner
- */
-
-public class SyncOperationTest extends AndroidTestCase {
-
-    Account mDummy;
-    /** Indicate an unimportant long that we're not testing. */
-    long mUnimportantLong = 0L;
-    /** Empty bundle. */
-    Bundle mEmpty;
-    /** Silly authority. */
-    String mAuthority;
-
-    @Override
-    public void setUp() {
-        mDummy = new Account("account1", "type1");
-        mEmpty = new Bundle();
-        mAuthority = "authority1";
-    }
-
-    @SmallTest
-    public void testToKey() {
-        Account account1 = new Account("account1", "type1");
-        Account account2 = new Account("account2", "type2");
-
-        Bundle b1 = new Bundle();
-        Bundle b2 = new Bundle();
-        b2.putBoolean("b2", true);
-
-        SyncOperation op1 = new SyncOperation(account1, 0,
-                1, "foo", 0,
-                SyncOperation.REASON_PERIODIC,
-                "authority1",
-                b1,
-                false);
-
-        // Same as op1 but different time infos
-        SyncOperation op2 = new SyncOperation(account1, 0,
-                1, "foo", 0,
-                SyncOperation.REASON_PERIODIC,
-                "authority1",
-                b1,
-                false);
-
-        // Same as op1 but different authority
-        SyncOperation op3 = new SyncOperation(account1, 0,
-                1, "foo", 0,
-                SyncOperation.REASON_PERIODIC,
-                "authority2",
-                b1,
-                false);
-
-        // Same as op1 but different account
-        SyncOperation op4 = new SyncOperation(account2, 0,
-                1, "foo", 0,
-                SyncOperation.REASON_PERIODIC,
-                "authority1",
-                b1,
-                false);
-
-        // Same as op1 but different bundle
-        SyncOperation op5 = new SyncOperation(account1, 0,
-                1, "foo", 0,
-                SyncOperation.REASON_PERIODIC,
-                "authority1",
-                b2,
-                false);
-
-        assertEquals(op1.key, op2.key);
-        assertNotSame(op1.key, op3.key);
-        assertNotSame(op1.key, op4.key);
-        assertNotSame(op1.key, op5.key);
-    }
-
-    @SmallTest
-    public void testConversionToExtras() {
-        Account account1 = new Account("account1", "type1");
-        Bundle b1 = new Bundle();
-        b1.putParcelable("acc", account1);
-        b1.putString("str", "String");
-
-        SyncOperation op1 = new SyncOperation(account1, 0,
-                1, "foo", 0,
-                SyncOperation.REASON_PERIODIC,
-                "authority1",
-                b1,
-                false);
-
-        PersistableBundle pb = op1.toJobInfoExtras();
-        SyncOperation op2 = SyncOperation.maybeCreateFromJobExtras(pb);
-
-        assertTrue("Account fields in extras not persisted.",
-                account1.equals(op2.extras.get("acc")));
-        assertTrue("Fields in extras not persisted", "String".equals(op2.extras.getString("str")));
-    }
-
-    @SmallTest
-    public void testConversionFromExtras() {
-        PersistableBundle extras = new PersistableBundle();
-        SyncOperation op = SyncOperation.maybeCreateFromJobExtras(extras);
-        assertTrue("Non sync operation bundle falsely converted to SyncOperation.", op == null);
-    }
-
-    /**
-     * Tests whether a failed periodic sync operation is converted correctly into a one time
-     * sync operation, and whether the periodic sync can be re-created from the one-time operation.
-     */
-    @SmallTest
-    public void testFailedPeriodicConversion() {
-        SyncStorageEngine.EndPoint ep = new SyncStorageEngine.EndPoint(new Account("name", "type"),
-                "provider", 0);
-        Bundle extras = new Bundle();
-        SyncOperation periodic = new SyncOperation(ep, 0, "package", 0, 0, extras, false, true,
-                SyncOperation.NO_JOB_ID, 60000, 10000);
-        SyncOperation oneoff = periodic.createOneTimeSyncOperation();
-        assertFalse("Conversion to oneoff sync failed.", oneoff.isPeriodic);
-        assertEquals("Period not restored", periodic.periodMillis, oneoff.periodMillis);
-        assertEquals("Flex not restored", periodic.flexMillis, oneoff.flexMillis);
-    }
-}
diff --git a/services/tests/servicestests/src/com/android/server/content/SyncStorageEngineTest.java b/services/tests/servicestests/src/com/android/server/content/SyncStorageEngineTest.java
deleted file mode 100644
index 91c0de64cb8..00000000000
--- a/services/tests/servicestests/src/com/android/server/content/SyncStorageEngineTest.java
+++ /dev/null
@@ -1,343 +0,0 @@
-/*
- * Copyright (C) 2007 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.android.server.content;
-
-import android.accounts.Account;
-import android.content.ComponentName;
-import android.content.ContentResolver;
-import android.content.Context;
-import android.content.ContextWrapper;
-import android.content.Intent;
-import android.content.PeriodicSync;
-import android.content.res.Resources;
-import android.os.Bundle;
-import android.test.AndroidTestCase;
-import android.test.RenamingDelegatingContext;
-import android.test.mock.MockContentResolver;
-import android.test.mock.MockContext;
-import android.test.suitebuilder.annotation.LargeTest;
-import android.test.suitebuilder.annotation.MediumTest;
-import android.test.suitebuilder.annotation.SmallTest;
-
-import com.android.server.content.SyncStorageEngine.EndPoint;
-
-import com.android.internal.os.AtomicFile;
-
-import java.io.File;
-import java.io.FileOutputStream;
-import java.util.List;
-
-public class SyncStorageEngineTest extends AndroidTestCase {
-
-    protected Account account1;
-    protected Account account2;
-    protected ComponentName syncService1;
-    protected String authority1 = "testprovider";
-    protected Bundle defaultBundle;
-    protected final int DEFAULT_USER = 0;
-
-    /* Some default poll frequencies. */
-    final long dayPoll = (60 * 60 * 24);
-    final long dayFuzz = 60;
-    final long thousandSecs = 1000;
-    final long thousandSecsFuzz = 100;
-
-    MockContentResolver mockResolver;
-    SyncStorageEngine engine;
-
-    private File getSyncDir() {
-        return new File(new File(getContext().getFilesDir(), "system"), "sync");
-    }
-
-    @Override
-    public void setUp() {
-        account1 = new Account("a@example.com", "example.type");
-        account2 = new Account("b@example.com", "example.type");
-        syncService1 = new ComponentName("com.example", "SyncService");
-        // Default bundle.
-        defaultBundle = new Bundle();
-        defaultBundle.putInt("int_key", 0);
-        defaultBundle.putString("string_key", "hello");
-        // Set up storage engine.
-        mockResolver = new MockContentResolver();
-        engine = SyncStorageEngine.newTestInstance(
-                new TestContext(mockResolver, getContext()));
-    }
-
-    /**
-     * Test that we handle the case of a history row being old enough to purge before the
-     * corresponding sync is finished. This can happen if the clock changes while we are syncing.
-     *
-     */
-    // TODO: this test causes AidlTest to fail. Omit for now
-    // @SmallTest
-    public void testPurgeActiveSync() throws Exception {
-        final Account account = new Account("a@example.com", "example.type");
-        final String authority = "testprovider";
-
-        MockContentResolver mockResolver = new MockContentResolver();
-
-        SyncStorageEngine engine = SyncStorageEngine.newTestInstance(
-                new TestContext(mockResolver, getContext()));
-        long time0 = 1000;
-        SyncOperation op = new SyncOperation(account, 0, 0, "foo",
-                SyncOperation.REASON_PERIODIC,
-                SyncStorageEngine.SOURCE_LOCAL,
-                authority,
-                Bundle.EMPTY, true);
-        long historyId = engine.insertStartSyncEvent(op, time0);
-        long time1 = time0 + SyncStorageEngine.MILLIS_IN_4WEEKS * 2;
-        engine.stopSyncEvent(historyId, time1 - time0, "yay", 0, 0);
-    }
-
-    @LargeTest
-    public void testAuthorityPersistence() throws Exception {
-        final Account account1 = new Account("a@example.com", "example.type");
-        final Account account2 = new Account("b@example.com", "example.type.2");
-        final String authority1 = "testprovider1";
-        final String authority2 = "testprovider2";
-
-        engine.setMasterSyncAutomatically(false, 0);
-
-        engine.setIsSyncable(account1, 0, authority1, 1);
-        engine.setSyncAutomatically(account1, 0, authority1, true);
-
-        engine.setIsSyncable(account2, 0, authority1, 1);
-        engine.setSyncAutomatically(account2, 0, authority1, true);
-
-        engine.setIsSyncable(account1, 0, authority2, 1);
-        engine.setSyncAutomatically(account1, 0, authority2, false);
-
-        engine.setIsSyncable(account2, 0, authority2, 0);
-        engine.setSyncAutomatically(account2, 0, authority2, true);
-
-        engine.writeAllState();
-        engine.clearAndReadState();
-
-        assertEquals(true, engine.getSyncAutomatically(account1, 0, authority1));
-        assertEquals(true, engine.getSyncAutomatically(account2, 0, authority1));
-        assertEquals(false, engine.getSyncAutomatically(account1, 0, authority2));
-        assertEquals(true, engine.getSyncAutomatically(account2, 0, authority2));
-
-        assertEquals(1, engine.getIsSyncable(account1, 0, authority1));
-        assertEquals(1, engine.getIsSyncable(account2, 0, authority1));
-        assertEquals(1, engine.getIsSyncable(account1, 0, authority2));
-        assertEquals(0, engine.getIsSyncable(account2, 0, authority2));
-    }
-
-    @MediumTest
-    public void testListenForTicklesParsing() throws Exception {
-        byte[] accountsFileData = ("<?xml version='1.0' encoding='utf-8' standalone='yes' ?>\n"
-                + "<accounts>\n"
-                + "<listenForTickles user=\"0\" enabled=\"false\" />"
-                + "<listenForTickles user=\"1\" enabled=\"true\" />"
-                + "<authority id=\"0\" user=\"0\" account=\"account1\" type=\"type1\" authority=\"auth1\" />\n"
-                + "<authority id=\"1\" user=\"1\" account=\"account1\" type=\"type1\" authority=\"auth1\" />\n"
-                + "</accounts>\n").getBytes();
-
-        MockContentResolver mockResolver = new MockContentResolver();
-        final TestContext testContext = new TestContext(mockResolver, getContext());
-
-        File syncDir = getSyncDir();
-        syncDir.mkdirs();
-        AtomicFile accountInfoFile = new AtomicFile(new File(syncDir, "accounts.xml"));
-        FileOutputStream fos = accountInfoFile.startWrite();
-        fos.write(accountsFileData);
-        accountInfoFile.finishWrite(fos);
-
-        SyncStorageEngine engine = SyncStorageEngine.newTestInstance(testContext);
-
-        assertEquals(false, engine.getMasterSyncAutomatically(0));
-        assertEquals(true, engine.getMasterSyncAutomatically(1));
-        assertEquals(true, engine.getMasterSyncAutomatically(2));
-
-    }
-
-    @MediumTest
-    public void testAuthorityRenaming() throws Exception {
-        final Account account1 = new Account("acc1", "type1");
-        final Account account2 = new Account("acc2", "type2");
-        final String authorityContacts = "contacts";
-        final String authorityCalendar = "calendar";
-        final String authorityOther = "other";
-        final String authorityContactsNew = "com.android.contacts";
-        final String authorityCalendarNew = "com.android.calendar";
-
-        MockContentResolver mockResolver = new MockContentResolver();
-
-        final TestContext testContext = new TestContext(mockResolver, getContext());
-
-        byte[] accountsFileData = ("<?xml version='1.0' encoding='utf-8' standalone='yes' ?>\n"
-                + "<accounts>\n"
-                + "<authority id=\"0\" account=\"acc1\" type=\"type1\" authority=\"contacts\" />\n"
-                + "<authority id=\"1\" account=\"acc1\" type=\"type1\" authority=\"calendar\" />\n"
-                + "<authority id=\"2\" account=\"acc1\" type=\"type1\" authority=\"other\" />\n"
-                + "<authority id=\"3\" account=\"acc2\" type=\"type2\" authority=\"contacts\" />\n"
-                + "<authority id=\"4\" account=\"acc2\" type=\"type2\" authority=\"calendar\" />\n"
-                + "<authority id=\"5\" account=\"acc2\" type=\"type2\" authority=\"other\" />\n"
-                + "<authority id=\"6\" account=\"acc2\" type=\"type2\" enabled=\"false\""
-                + " authority=\"com.android.calendar\" />\n"
-                + "<authority id=\"7\" account=\"acc2\" type=\"type2\" enabled=\"false\""
-                + " authority=\"com.android.contacts\" />\n"
-                + "</accounts>\n").getBytes();
-
-        File syncDir = new File(new File(testContext.getFilesDir(), "system"), "sync");
-        syncDir.mkdirs();
-        AtomicFile accountInfoFile = new AtomicFile(new File(syncDir, "accounts.xml"));
-        FileOutputStream fos = accountInfoFile.startWrite();
-        fos.write(accountsFileData);
-        accountInfoFile.finishWrite(fos);
-
-        SyncStorageEngine engine = SyncStorageEngine.newTestInstance(testContext);
-
-        assertEquals(false, engine.getSyncAutomatically(account1, 0, authorityContacts));
-        assertEquals(false, engine.getSyncAutomatically(account1, 0, authorityCalendar));
-        assertEquals(true, engine.getSyncAutomatically(account1, 0, authorityOther));
-        assertEquals(true, engine.getSyncAutomatically(account1, 0, authorityContactsNew));
-        assertEquals(true, engine.getSyncAutomatically(account1, 0, authorityCalendarNew));
-
-        assertEquals(false, engine.getSyncAutomatically(account2, 0, authorityContacts));
-        assertEquals(false, engine.getSyncAutomatically(account2, 0, authorityCalendar));
-        assertEquals(true, engine.getSyncAutomatically(account2, 0, authorityOther));
-        assertEquals(false, engine.getSyncAutomatically(account2, 0, authorityContactsNew));
-        assertEquals(false, engine.getSyncAutomatically(account2, 0, authorityCalendarNew));
-    }
-
-    @SmallTest
-    public void testSyncableMigration() throws Exception {
-        final Account account = new Account("acc", "type");
-
-        MockContentResolver mockResolver = new MockContentResolver();
-
-        final TestContext testContext = new TestContext(mockResolver, getContext());
-
-        byte[] accountsFileData = ("<?xml version='1.0' encoding='utf-8' standalone='yes' ?>\n"
-                + "<accounts>\n"
-                + "<authority id=\"0\" account=\"acc\" authority=\"other1\" />\n"
-                + "<authority id=\"1\" account=\"acc\" type=\"type\" authority=\"other2\" />\n"
-                + "<authority id=\"2\" account=\"acc\" type=\"type\" syncable=\"false\""
-                + " authority=\"other3\" />\n"
-                + "<authority id=\"3\" account=\"acc\" type=\"type\" syncable=\"true\""
-                + " authority=\"other4\" />\n"
-                + "</accounts>\n").getBytes();
-
-        File syncDir = new File(new File(testContext.getFilesDir(), "system"), "sync");
-        syncDir.mkdirs();
-        AtomicFile accountInfoFile = new AtomicFile(new File(syncDir, "accounts.xml"));
-        FileOutputStream fos = accountInfoFile.startWrite();
-        fos.write(accountsFileData);
-        accountInfoFile.finishWrite(fos);
-
-        SyncStorageEngine engine = SyncStorageEngine.newTestInstance(testContext);
-
-        assertEquals(-1, engine.getIsSyncable(account, 0, "other1"));
-        assertEquals(1, engine.getIsSyncable(account, 0, "other2"));
-        assertEquals(0, engine.getIsSyncable(account, 0, "other3"));
-        assertEquals(1, engine.getIsSyncable(account, 0, "other4"));
-    }
-
-    /**
-     * Verify that the API cannot cause a run-time reboot by passing in the empty string as an
-     * authority. The problem here is that
-     * {@link SyncStorageEngine#getOrCreateAuthorityLocked(account, provider)} would register
-     * an empty authority which causes a RTE in {@link SyncManager#scheduleReadyPeriodicSyncs()}.
-     * This is not strictly a SSE test, but it does depend on the SSE data structures.
-     */
-    @SmallTest
-    public void testExpectedIllegalArguments() throws Exception {
-        try {
-            ContentResolver.setSyncAutomatically(account1, "", true);
-            fail("empty provider string should throw IllegalArgumentException");
-        } catch (IllegalArgumentException expected) {}
-
-        try {
-            ContentResolver.addPeriodicSync(account1, "", Bundle.EMPTY, 84000L);
-            fail("empty provider string should throw IllegalArgumentException");
-        } catch (IllegalArgumentException expected) {}
-
-        try {
-            ContentResolver.removePeriodicSync(account1, "", Bundle.EMPTY);
-            fail("empty provider string should throw IllegalArgumentException");
-        } catch (IllegalArgumentException expected) {}
-
-        try {
-            ContentResolver.cancelSync(account1, "");
-            fail("empty provider string should throw IllegalArgumentException");
-        } catch (IllegalArgumentException expected) {}
-
-        try {
-            ContentResolver.setIsSyncable(account1, "", 0);
-            fail("empty provider string should throw IllegalArgumentException");
-        } catch (IllegalArgumentException expected) {}
-
-        try {
-            ContentResolver.cancelSync(account1, "");
-            fail("empty provider string should throw IllegalArgumentException");
-        } catch (IllegalArgumentException expected) {}
-
-        try {
-            ContentResolver.requestSync(account1, "", Bundle.EMPTY);
-            fail("empty provider string should throw IllegalArgumentException");
-        } catch (IllegalArgumentException expected) {}
-
-        try {
-            ContentResolver.getSyncStatus(account1, "");
-            fail("empty provider string should throw IllegalArgumentException");
-        } catch (IllegalArgumentException expected) {}
-
-        // Make sure we aren't blocking null account/provider for those functions that use it
-        // to specify ALL accounts/providers.
-        ContentResolver.requestSync(null, null, Bundle.EMPTY);
-        ContentResolver.cancelSync(null, null);
-    }
-}
-
-class TestContext extends ContextWrapper {
-
-    ContentResolver mResolver;
-
-    private final Context mRealContext;
-
-    public TestContext(ContentResolver resolver, Context realContext) {
-        super(new RenamingDelegatingContext(new MockContext(), realContext, "test."));
-        mRealContext = realContext;
-        mResolver = resolver;
-    }
-
-    @Override
-    public Resources getResources() {
-        return mRealContext.getResources();
-    }
-
-    @Override
-    public File getFilesDir() {
-        return mRealContext.getFilesDir();
-    }
-
-    @Override
-    public void enforceCallingOrSelfPermission(String permission, String message) {
-    }
-
-    @Override
-    public void sendBroadcast(Intent intent) {
-    }
-
-    @Override
-    public ContentResolver getContentResolver() {
-        return mResolver;
-    }
-}
diff --git a/services/tests/servicestests/src/com/android/server/devicepolicy/DevicePolicyManagerServiceMigrationTest.java b/services/tests/servicestests/src/com/android/server/devicepolicy/DevicePolicyManagerServiceMigrationTest.java
deleted file mode 100644
index 3a6b983854a..00000000000
--- a/services/tests/servicestests/src/com/android/server/devicepolicy/DevicePolicyManagerServiceMigrationTest.java
+++ /dev/null
@@ -1,280 +0,0 @@
-/*
- * Copyright (C) 2015 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.android.server.devicepolicy;
-
-import com.android.server.LocalServices;
-import com.android.server.SystemService;
-import com.android.server.devicepolicy.DevicePolicyManagerServiceTestable.OwnersTestable;
-
-import android.app.admin.DevicePolicyManager;
-import android.app.admin.DevicePolicyManagerInternal;
-import android.content.pm.PackageManager;
-import android.content.pm.UserInfo;
-import android.os.Bundle;
-import android.os.UserHandle;
-import android.os.UserManager;
-import android.util.Pair;
-
-import org.mockito.invocation.InvocationOnMock;
-import org.mockito.stubbing.Answer;
-
-import java.io.File;
-import java.util.HashMap;
-import java.util.Map;
-
-import static org.mockito.Matchers.any;
-import static org.mockito.Matchers.anyInt;
-import static org.mockito.Matchers.eq;
-import static org.mockito.Mockito.doAnswer;
-import static org.mockito.Mockito.when;
-
-public class DevicePolicyManagerServiceMigrationTest extends DpmTestBase {
-    private DpmMockContext mContext;
-
-    @Override
-    protected void setUp() throws Exception {
-        super.setUp();
-
-        mContext = getContext();
-
-        when(mContext.packageManager.hasSystemFeature(eq(PackageManager.FEATURE_DEVICE_ADMIN)))
-                .thenReturn(true);
-    }
-
-    public void testMigration() throws Exception {
-        final File user10dir = mMockContext.addUser(10, 0);
-        final File user11dir = mMockContext.addUser(11, UserInfo.FLAG_MANAGED_PROFILE);
-        final File user12dir = mMockContext.addUser(12, 0);
-
-        setUpPackageManagerForAdmin(admin1, DpmMockContext.CALLER_SYSTEM_USER_UID);
-        setUpPackageManagerForAdmin(admin2, UserHandle.getUid(10, 123));
-        setUpPackageManagerForAdmin(admin3, UserHandle.getUid(11, 456));
-
-        // Create the legacy owners & policies file.
-        DpmTestUtils.writeToFile(
-                (new File(mContext.dataDir, OwnersTestable.LEGACY_FILE)).getAbsoluteFile(),
-                DpmTestUtils.readAsset(mRealTestContext,
-                        "DevicePolicyManagerServiceMigrationTest/legacy_device_owner.xml"));
-
-        DpmTestUtils.writeToFile(
-                (new File(mContext.systemUserDataDir, "device_policies.xml")).getAbsoluteFile(),
-                DpmTestUtils.readAsset(mRealTestContext,
-                        "DevicePolicyManagerServiceMigrationTest/legacy_device_policies.xml"));
-
-        DpmTestUtils.writeToFile(
-                (new File(user10dir, "device_policies.xml")).getAbsoluteFile(),
-                DpmTestUtils.readAsset(mRealTestContext,
-                        "DevicePolicyManagerServiceMigrationTest/legacy_device_policies_10.xml"));
-        DpmTestUtils.writeToFile(
-                (new File(user11dir, "device_policies.xml")).getAbsoluteFile(),
-                DpmTestUtils.readAsset(mRealTestContext,
-                        "DevicePolicyManagerServiceMigrationTest/legacy_device_policies_11.xml"));
-
-        // Set up UserManager
-        when(mMockContext.userManagerInternal.getBaseUserRestrictions(
-                eq(UserHandle.USER_SYSTEM))).thenReturn(DpmTestUtils.newRestrictions(
-                UserManager.DISALLOW_ADD_USER,
-                UserManager.DISALLOW_RECORD_AUDIO));
-
-        when(mMockContext.userManagerInternal.getBaseUserRestrictions(
-                eq(10))).thenReturn(DpmTestUtils.newRestrictions(
-                UserManager.DISALLOW_REMOVE_USER,
-                UserManager.DISALLOW_ADD_USER,
-                UserManager.DISALLOW_SMS,
-                UserManager.DISALLOW_OUTGOING_CALLS,
-                UserManager.DISALLOW_WALLPAPER,
-                UserManager.DISALLOW_RECORD_AUDIO));
-
-        when(mMockContext.userManagerInternal.getBaseUserRestrictions(
-                eq(11))).thenReturn(DpmTestUtils.newRestrictions(
-                UserManager.DISALLOW_REMOVE_USER,
-                UserManager.DISALLOW_ADD_USER,
-                UserManager.DISALLOW_SMS,
-                UserManager.DISALLOW_OUTGOING_CALLS,
-                UserManager.DISALLOW_WALLPAPER,
-                UserManager.DISALLOW_RECORD_AUDIO));
-
-        final Map<Integer, Bundle> newBaseRestrictions = new HashMap<>();
-
-        doAnswer(new Answer<Void>() {
-            @Override
-            public Void answer(InvocationOnMock invocation) throws Throwable {
-                Integer userId = (Integer) invocation.getArguments()[0];
-                Bundle bundle = (Bundle) invocation.getArguments()[1];
-
-                newBaseRestrictions.put(userId, bundle);
-
-                return null;
-            }
-        }).when(mContext.userManagerInternal).setBaseUserRestrictionsByDpmsForMigration(
-                anyInt(), any(Bundle.class));
-
-        // Initialize DPM/DPMS and let it migrate the persisted information.
-        // (Need clearCallingIdentity() to pass permission checks.)
-
-        final DevicePolicyManagerServiceTestable dpms;
-
-        final long ident = mContext.binder.clearCallingIdentity();
-        try {
-            LocalServices.removeServiceForTest(DevicePolicyManagerInternal.class);
-
-            dpms = new DevicePolicyManagerServiceTestable(mContext, dataDir);
-
-            dpms.systemReady(SystemService.PHASE_LOCK_SETTINGS_READY);
-            dpms.systemReady(SystemService.PHASE_BOOT_COMPLETED);
-        } finally {
-            mContext.binder.restoreCallingIdentity(ident);
-        }
-
-        assertTrue(dpms.mOwners.hasDeviceOwner());
-        assertFalse(dpms.mOwners.hasProfileOwner(UserHandle.USER_SYSTEM));
-        assertTrue(dpms.mOwners.hasProfileOwner(10));
-        assertTrue(dpms.mOwners.hasProfileOwner(11));
-        assertFalse(dpms.mOwners.hasProfileOwner(12));
-
-        // Now all information should be migrated.
-        assertFalse(dpms.mOwners.getDeviceOwnerUserRestrictionsNeedsMigration());
-        assertFalse(dpms.mOwners.getProfileOwnerUserRestrictionsNeedsMigration(
-                UserHandle.USER_SYSTEM));
-        assertFalse(dpms.mOwners.getProfileOwnerUserRestrictionsNeedsMigration(10));
-        assertFalse(dpms.mOwners.getProfileOwnerUserRestrictionsNeedsMigration(11));
-        assertFalse(dpms.mOwners.getProfileOwnerUserRestrictionsNeedsMigration(12));
-
-        // Check the new base restrictions.
-        DpmTestUtils.assertRestrictions(
-                DpmTestUtils.newRestrictions(
-                        UserManager.DISALLOW_RECORD_AUDIO
-                ),
-                newBaseRestrictions.get(UserHandle.USER_SYSTEM));
-
-        DpmTestUtils.assertRestrictions(
-                DpmTestUtils.newRestrictions(
-                        UserManager.DISALLOW_ADD_USER,
-                        UserManager.DISALLOW_SMS,
-                        UserManager.DISALLOW_OUTGOING_CALLS,
-                        UserManager.DISALLOW_RECORD_AUDIO,
-                        UserManager.DISALLOW_WALLPAPER
-                ),
-                newBaseRestrictions.get(10));
-
-        DpmTestUtils.assertRestrictions(
-                DpmTestUtils.newRestrictions(
-                        UserManager.DISALLOW_ADD_USER,
-                        UserManager.DISALLOW_SMS,
-                        UserManager.DISALLOW_OUTGOING_CALLS,
-                        UserManager.DISALLOW_WALLPAPER,
-                        UserManager.DISALLOW_RECORD_AUDIO
-                ),
-                newBaseRestrictions.get(11));
-
-        // Check the new owner restrictions.
-        DpmTestUtils.assertRestrictions(
-                DpmTestUtils.newRestrictions(
-                        UserManager.DISALLOW_ADD_USER
-                ),
-                dpms.getDeviceOwnerAdminLocked().ensureUserRestrictions());
-
-        DpmTestUtils.assertRestrictions(
-                DpmTestUtils.newRestrictions(
-                        UserManager.DISALLOW_REMOVE_USER
-                ),
-                dpms.getProfileOwnerAdminLocked(10).ensureUserRestrictions());
-
-        DpmTestUtils.assertRestrictions(
-                DpmTestUtils.newRestrictions(
-                        UserManager.DISALLOW_REMOVE_USER
-                ),
-                dpms.getProfileOwnerAdminLocked(11).ensureUserRestrictions());
-    }
-
-    public void testMigration2_profileOwnerOnUser0() throws Exception {
-        setUpPackageManagerForAdmin(admin2, DpmMockContext.CALLER_SYSTEM_USER_UID);
-
-        // Create the legacy owners & policies file.
-        DpmTestUtils.writeToFile(
-                (new File(mContext.dataDir, OwnersTestable.LEGACY_FILE)).getAbsoluteFile(),
-                DpmTestUtils.readAsset(mRealTestContext,
-                        "DevicePolicyManagerServiceMigrationTest2/legacy_device_owner.xml"));
-
-        DpmTestUtils.writeToFile(
-                (new File(mContext.systemUserDataDir, "device_policies.xml")).getAbsoluteFile(),
-                DpmTestUtils.readAsset(mRealTestContext,
-                        "DevicePolicyManagerServiceMigrationTest2/legacy_device_policies.xml"));
-
-        // Set up UserManager
-        when(mMockContext.userManagerInternal.getBaseUserRestrictions(
-                eq(UserHandle.USER_SYSTEM))).thenReturn(DpmTestUtils.newRestrictions(
-                UserManager.DISALLOW_ADD_USER,
-                UserManager.DISALLOW_RECORD_AUDIO,
-                UserManager.DISALLOW_SMS,
-                UserManager.DISALLOW_OUTGOING_CALLS));
-
-        final Map<Integer, Bundle> newBaseRestrictions = new HashMap<>();
-
-        doAnswer(new Answer<Void>() {
-            @Override
-            public Void answer(InvocationOnMock invocation) throws Throwable {
-                Integer userId = (Integer) invocation.getArguments()[0];
-                Bundle bundle = (Bundle) invocation.getArguments()[1];
-
-                newBaseRestrictions.put(userId, bundle);
-
-                return null;
-            }
-        }).when(mContext.userManagerInternal).setBaseUserRestrictionsByDpmsForMigration(
-                anyInt(), any(Bundle.class));
-
-        // Initialize DPM/DPMS and let it migrate the persisted information.
-        // (Need clearCallingIdentity() to pass permission checks.)
-
-        final DevicePolicyManagerServiceTestable dpms;
-
-        final long ident = mContext.binder.clearCallingIdentity();
-        try {
-            LocalServices.removeServiceForTest(DevicePolicyManagerInternal.class);
-
-            dpms = new DevicePolicyManagerServiceTestable(mContext, dataDir);
-
-            dpms.systemReady(SystemService.PHASE_LOCK_SETTINGS_READY);
-            dpms.systemReady(SystemService.PHASE_BOOT_COMPLETED);
-        } finally {
-            mContext.binder.restoreCallingIdentity(ident);
-        }
-        assertFalse(dpms.mOwners.hasDeviceOwner());
-        assertTrue(dpms.mOwners.hasProfileOwner(UserHandle.USER_SYSTEM));
-
-        // Now all information should be migrated.
-        assertFalse(dpms.mOwners.getDeviceOwnerUserRestrictionsNeedsMigration());
-        assertFalse(dpms.mOwners.getProfileOwnerUserRestrictionsNeedsMigration(
-                UserHandle.USER_SYSTEM));
-
-        // Check the new base restrictions.
-        DpmTestUtils.assertRestrictions(
-                DpmTestUtils.newRestrictions(
-                        UserManager.DISALLOW_RECORD_AUDIO
-                ),
-                newBaseRestrictions.get(UserHandle.USER_SYSTEM));
-
-        // Check the new owner restrictions.
-        DpmTestUtils.assertRestrictions(
-                DpmTestUtils.newRestrictions(
-                        UserManager.DISALLOW_ADD_USER,
-                        UserManager.DISALLOW_SMS,
-                        UserManager.DISALLOW_OUTGOING_CALLS
-                ),
-                dpms.getProfileOwnerAdminLocked(UserHandle.USER_SYSTEM).ensureUserRestrictions());
-    }
-}
diff --git a/services/tests/servicestests/src/com/android/server/devicepolicy/DevicePolicyManagerServiceTestable.java b/services/tests/servicestests/src/com/android/server/devicepolicy/DevicePolicyManagerServiceTestable.java
deleted file mode 100644
index 6cb4a823872..00000000000
--- a/services/tests/servicestests/src/com/android/server/devicepolicy/DevicePolicyManagerServiceTestable.java
+++ /dev/null
@@ -1,361 +0,0 @@
-/*
- * Copyright (C) 2015 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.android.server.devicepolicy;
-
-import android.app.IActivityManager;
-import android.app.NotificationManager;
-import android.app.backup.IBackupManager;
-import android.content.pm.IPackageManager;
-import android.content.pm.PackageManagerInternal;
-import android.database.ContentObserver;
-import android.media.IAudioService;
-import android.net.Uri;
-import android.os.Looper;
-import android.os.PowerManagerInternal;
-import android.os.UserHandle;
-import android.os.UserManager;
-import android.os.UserManagerInternal;
-import android.telephony.TelephonyManager;
-import android.util.ArrayMap;
-import android.util.Pair;
-import android.view.IWindowManager;
-
-import com.android.internal.widget.LockPatternUtils;
-
-import java.io.File;
-import java.util.Map;
-
-/**
- * Overrides {@link #DevicePolicyManagerService} for dependency injection.
- */
-public class DevicePolicyManagerServiceTestable extends DevicePolicyManagerService {
-    /**
-     * Overrides {@link #Owners} for dependency injection.
-     */
-    public static class OwnersTestable extends Owners {
-        public static final String LEGACY_FILE = "legacy.xml";
-        public static final String DEVICE_OWNER_FILE = "device_owner2.xml";
-        public static final String PROFILE_OWNER_FILE_BASE = "profile_owner.xml";
-
-        private final File mLegacyFile;
-        private final File mDeviceOwnerFile;
-        private final File mProfileOwnerBase;
-
-        public OwnersTestable(DpmMockContext context) {
-            super(context.userManager, context.userManagerInternal, context.packageManagerInternal);
-            mLegacyFile = new File(context.dataDir, LEGACY_FILE);
-            mDeviceOwnerFile = new File(context.dataDir, DEVICE_OWNER_FILE);
-            mProfileOwnerBase = new File(context.dataDir, PROFILE_OWNER_FILE_BASE);
-        }
-
-        @Override
-        File getLegacyConfigFileWithTestOverride() {
-            return mLegacyFile;
-        }
-
-        @Override
-        File getDeviceOwnerFileWithTestOverride() {
-            return mDeviceOwnerFile;
-        }
-
-        @Override
-        File getProfileOwnerFileWithTestOverride(int userId) {
-            return new File(mDeviceOwnerFile.getAbsoluteFile() + "-" + userId);
-        }
-    }
-
-    public final DpmMockContext context;
-    private final MockInjector mMockInjector;
-
-    public DevicePolicyManagerServiceTestable(DpmMockContext context, File dataDir) {
-        this(new MockInjector(context, dataDir));
-    }
-
-    private DevicePolicyManagerServiceTestable(MockInjector injector) {
-        super(injector);
-        mMockInjector = injector;
-        this.context = injector.context;
-    }
-
-
-    public void notifyChangeToContentObserver(Uri uri, int userHandle) {
-        ContentObserver co = mMockInjector.mContentObservers
-                .get(new Pair<Uri, Integer>(uri, userHandle));
-        if (co != null) {
-            co.onChange(false, uri, userHandle); // notify synchronously
-        }
-
-        // Notify USER_ALL observer too.
-        co = mMockInjector.mContentObservers
-                .get(new Pair<Uri, Integer>(uri, UserHandle.USER_ALL));
-        if (co != null) {
-            co.onChange(false, uri, userHandle); // notify synchronously
-        }
-    }
-
-
-    private static class MockInjector extends Injector {
-
-        public final DpmMockContext context;
-
-        public final File dataDir;
-
-        // Key is a pair of uri and userId
-        private final Map<Pair<Uri, Integer>, ContentObserver> mContentObservers = new ArrayMap<>();
-
-        private MockInjector(DpmMockContext context, File dataDir) {
-            super(context);
-            this.context = context;
-            this.dataDir = dataDir;
-        }
-
-        @Override
-        Owners newOwners() {
-            return new OwnersTestable(context);
-        }
-
-        @Override
-        UserManager getUserManager() {
-            return context.userManager;
-        }
-
-        @Override
-        UserManagerInternal getUserManagerInternal() {
-            return context.userManagerInternal;
-        }
-
-        @Override
-        PackageManagerInternal getPackageManagerInternal() {
-            return context.packageManagerInternal;
-        }
-
-        @Override
-        PowerManagerInternal getPowerManagerInternal() {
-            return context.powerManagerInternal;
-        }
-
-        @Override
-        NotificationManager getNotificationManager() {
-            return context.notificationManager;
-        }
-
-        @Override
-        IWindowManager getIWindowManager() {
-            return context.iwindowManager;
-        }
-
-        @Override
-        IActivityManager getIActivityManager() {
-            return context.iactivityManager;
-        }
-
-        @Override
-        IPackageManager getIPackageManager() {
-            return context.ipackageManager;
-        }
-
-        @Override
-        IBackupManager getIBackupManager() {
-            return context.ibackupManager;
-        }
-
-        @Override
-        IAudioService getIAudioService() {
-            return context.iaudioService;
-        }
-
-        @Override
-        Looper getMyLooper() {
-            return Looper.getMainLooper();
-        }
-
-        @Override
-        LockPatternUtils newLockPatternUtils() {
-            return context.lockPatternUtils;
-        }
-
-        @Override
-        boolean storageManagerIsFileBasedEncryptionEnabled() {
-            return context.storageManager.isFileBasedEncryptionEnabled();
-        }
-
-        @Override
-        boolean storageManagerIsNonDefaultBlockEncrypted() {
-            return context.storageManager.isNonDefaultBlockEncrypted();
-        }
-
-        @Override
-        boolean storageManagerIsEncrypted() {
-            return context.storageManager.isEncrypted();
-        }
-
-        @Override
-        boolean storageManagerIsEncryptable() {
-            return context.storageManager.isEncryptable();
-        }
-
-        @Override
-        String getDevicePolicyFilePathForSystemUser() {
-            return context.systemUserDataDir.getAbsolutePath() + "/";
-        }
-
-        @Override
-        long binderClearCallingIdentity() {
-            return context.binder.clearCallingIdentity();
-        }
-
-        @Override
-        void binderRestoreCallingIdentity(long token) {
-            context.binder.restoreCallingIdentity(token);
-        }
-
-        @Override
-        int binderGetCallingUid() {
-            return context.binder.getCallingUid();
-        }
-
-        @Override
-        int binderGetCallingPid() {
-            return context.binder.getCallingPid();
-        }
-
-        @Override
-        UserHandle binderGetCallingUserHandle() {
-            return context.binder.getCallingUserHandle();
-        }
-
-        @Override
-        boolean binderIsCallingUidMyUid() {
-            return context.binder.isCallerUidMyUid();
-        }
-
-        @Override
-        File environmentGetUserSystemDirectory(int userId) {
-            return context.environment.getUserSystemDirectory(userId);
-        }
-
-        @Override
-        void powerManagerGoToSleep(long time, int reason, int flags) {
-            context.powerManager.goToSleep(time, reason, flags);
-        }
-
-        @Override
-        void powerManagerReboot(String reason) {
-            context.powerManager.reboot(reason);
-        }
-
-        @Override
-        boolean systemPropertiesGetBoolean(String key, boolean def) {
-            return context.systemProperties.getBoolean(key, def);
-        }
-
-        @Override
-        long systemPropertiesGetLong(String key, long def) {
-            return context.systemProperties.getLong(key, def);
-        }
-
-        @Override
-        String systemPropertiesGet(String key, String def) {
-            return context.systemProperties.get(key, def);
-        }
-
-        @Override
-        String systemPropertiesGet(String key) {
-            return context.systemProperties.get(key);
-        }
-
-        @Override
-        void systemPropertiesSet(String key, String value) {
-            context.systemProperties.set(key, value);
-        }
-
-        @Override
-        boolean userManagerIsSplitSystemUser() {
-            return context.userManagerForMock.isSplitSystemUser();
-        }
-
-        @Override
-        void registerContentObserver(Uri uri, boolean notifyForDescendents,
-                ContentObserver observer, int userHandle) {
-            mContentObservers.put(new Pair<Uri, Integer>(uri, userHandle), observer);
-        }
-
-        @Override
-        int settingsSecureGetIntForUser(String name, int def, int userHandle) {
-            return context.settings.settingsSecureGetIntForUser(name, def, userHandle);
-        }
-
-        @Override
-        void settingsSecurePutIntForUser(String name, int value, int userHandle) {
-            context.settings.settingsSecurePutIntForUser(name, value, userHandle);
-        }
-
-        @Override
-        void settingsSecurePutStringForUser(String name, String value, int userHandle) {
-            context.settings.settingsSecurePutStringForUser(name, value, userHandle);
-        }
-
-        @Override
-        void settingsGlobalPutStringForUser(String name, String value, int userHandle) {
-            context.settings.settingsGlobalPutStringForUser(name, value, userHandle);
-        }
-
-        @Override
-        void settingsSecurePutInt(String name, int value) {
-            context.settings.settingsSecurePutInt(name, value);
-        }
-
-        @Override
-        void settingsGlobalPutInt(String name, int value) {
-            context.settings.settingsGlobalPutInt(name, value);
-        }
-
-        @Override
-        void settingsSecurePutString(String name, String value) {
-            context.settings.settingsSecurePutString(name, value);
-        }
-
-        @Override
-        void settingsGlobalPutString(String name, String value) {
-            context.settings.settingsGlobalPutString(name, value);
-        }
-
-        @Override
-        int settingsGlobalGetInt(String name, int def) {
-            return context.settings.settingsGlobalGetInt(name, def);
-        }
-
-        @Override
-        void securityLogSetLoggingEnabledProperty(boolean enabled) {
-            context.settings.securityLogSetLoggingEnabledProperty(enabled);
-        }
-
-        @Override
-        boolean securityLogGetLoggingEnabledProperty() {
-            return context.settings.securityLogGetLoggingEnabledProperty();
-        }
-
-        @Override
-        boolean securityLogIsLoggingEnabled() {
-            return context.settings.securityLogIsLoggingEnabled();
-        }
-
-        @Override
-        TelephonyManager getTelephonyManager() {
-            return context.telephonyManager;
-        }
-    }
-}
diff --git a/services/tests/servicestests/src/com/android/server/devicepolicy/DevicePolicyManagerTest.java b/services/tests/servicestests/src/com/android/server/devicepolicy/DevicePolicyManagerTest.java
deleted file mode 100644
index 11ec7ac64ed..00000000000
--- a/services/tests/servicestests/src/com/android/server/devicepolicy/DevicePolicyManagerTest.java
+++ /dev/null
@@ -1,2186 +0,0 @@
-/*
- * Copyright (C) 2015 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.android.server.devicepolicy;
-
-import android.Manifest.permission;
-import android.app.Activity;
-import android.app.admin.DeviceAdminReceiver;
-import android.app.admin.DevicePolicyManager;
-import android.app.admin.DevicePolicyManagerInternal;
-import android.content.BroadcastReceiver;
-import android.content.ComponentName;
-import android.content.pm.ApplicationInfo;
-import android.content.pm.PackageInfo;
-import android.content.pm.PackageManager;
-import android.net.wifi.WifiInfo;
-import android.os.Build.VERSION_CODES;
-import android.os.Bundle;
-import android.os.Process;
-import android.os.UserHandle;
-import android.os.UserManager;
-import android.provider.Settings;
-import android.telephony.TelephonyManager;
-import android.test.MoreAsserts;
-import android.test.suitebuilder.annotation.SmallTest;
-import android.util.ArraySet;
-import android.util.Pair;
-
-import com.android.server.LocalServices;
-import com.android.server.SystemService;
-
-import org.mockito.invocation.InvocationOnMock;
-import org.mockito.stubbing.Answer;
-
-import java.util.ArrayList;
-import java.util.Arrays;
-import java.util.HashMap;
-import java.util.List;
-import java.util.Map;
-import java.util.Set;
-
-import static org.mockito.Matchers.any;
-import static org.mockito.Matchers.anyInt;
-import static org.mockito.Matchers.anyString;
-import static org.mockito.Matchers.eq;
-import static org.mockito.Matchers.isNull;
-import static org.mockito.Mockito.doAnswer;
-import static org.mockito.Mockito.doReturn;
-import static org.mockito.Mockito.reset;
-import static org.mockito.Mockito.times;
-import static org.mockito.Mockito.verify;
-import static org.mockito.Mockito.when;
-
-/**
- * Tests for DevicePolicyManager( and DevicePolicyManagerService).
- *
- m FrameworksServicesTests &&
- adb install \
-   -r ${ANDROID_PRODUCT_OUT}/data/app/FrameworksServicesTests/FrameworksServicesTests.apk &&
- adb shell am instrument -e class com.android.server.devicepolicy.DevicePolicyManagerTest \
-   -w com.android.frameworks.servicestests/android.support.test.runner.AndroidJUnitRunner
-
- (mmma frameworks/base/services/tests/servicestests/ for non-ninja build)
- */
-@SmallTest
-public class DevicePolicyManagerTest extends DpmTestBase {
-    private static final List<String> OWNER_SETUP_PERMISSIONS = Arrays.asList(
-            permission.MANAGE_DEVICE_ADMINS, permission.MANAGE_PROFILE_AND_DEVICE_OWNERS,
-            permission.MANAGE_USERS, permission.INTERACT_ACROSS_USERS_FULL);
-
-    private DpmMockContext mContext;
-    public DevicePolicyManager dpm;
-    public DevicePolicyManagerServiceTestable dpms;
-
-    @Override
-    protected void setUp() throws Exception {
-        super.setUp();
-
-        mContext = getContext();
-
-        when(mContext.packageManager.hasSystemFeature(eq(PackageManager.FEATURE_DEVICE_ADMIN)))
-                .thenReturn(true);
-
-        // By default, pretend all users are running and unlocked.
-        when(mContext.userManager.isUserUnlocked(anyInt())).thenReturn(true);
-
-        initializeDpms();
-
-        setUpPackageManagerForAdmin(admin1, DpmMockContext.CALLER_UID);
-        setUpPackageManagerForAdmin(admin2, DpmMockContext.CALLER_UID);
-        setUpPackageManagerForAdmin(admin3, DpmMockContext.CALLER_UID);
-        setUpPackageManagerForAdmin(adminNoPerm, DpmMockContext.CALLER_UID);
-
-        setUpUserManager();
-    }
-
-    private void initializeDpms() {
-        // Need clearCallingIdentity() to pass permission checks.
-        final long ident = mContext.binder.clearCallingIdentity();
-        try {
-            LocalServices.removeServiceForTest(DevicePolicyManagerInternal.class);
-
-            dpms = new DevicePolicyManagerServiceTestable(mContext, dataDir);
-
-            dpms.systemReady(SystemService.PHASE_LOCK_SETTINGS_READY);
-            dpms.systemReady(SystemService.PHASE_BOOT_COMPLETED);
-
-            dpm = new DevicePolicyManagerTestable(mContext, dpms);
-        } finally {
-            mContext.binder.restoreCallingIdentity(ident);
-        }
-    }
-
-    private void setUpUserManager() {
-        // Emulate UserManager.set/getApplicationRestriction().
-        final Map<Pair<String, UserHandle>, Bundle> appRestrictions = new HashMap<>();
-
-        // UM.setApplicationRestrictions() will save to appRestrictions.
-        doAnswer(new Answer<Void>() {
-            @Override
-            public Void answer(InvocationOnMock invocation) throws Throwable {
-                String pkg = (String) invocation.getArguments()[0];
-                Bundle bundle = (Bundle) invocation.getArguments()[1];
-                UserHandle user = (UserHandle) invocation.getArguments()[2];
-
-                appRestrictions.put(Pair.create(pkg, user), bundle);
-
-                return null;
-            }
-        }).when(mContext.userManager).setApplicationRestrictions(
-                anyString(), any(Bundle.class), any(UserHandle.class));
-
-        // UM.getApplicationRestrictions() will read from appRestrictions.
-        doAnswer(new Answer<Bundle>() {
-            @Override
-            public Bundle answer(InvocationOnMock invocation) throws Throwable {
-                String pkg = (String) invocation.getArguments()[0];
-                UserHandle user = (UserHandle) invocation.getArguments()[1];
-
-                return appRestrictions.get(Pair.create(pkg, user));
-            }
-        }).when(mContext.userManager).getApplicationRestrictions(
-                anyString(), any(UserHandle.class));
-
-        // Add the first secondary user.
-        mContext.addUser(DpmMockContext.CALLER_USER_HANDLE, 0);
-    }
-
-    private void setAsProfileOwner(ComponentName admin) {
-        mContext.callerPermissions.add(permission.MANAGE_DEVICE_ADMINS);
-        mContext.callerPermissions.add(permission.MANAGE_PROFILE_AND_DEVICE_OWNERS);
-
-        // PO needs to be an DA.
-        dpm.setActiveAdmin(admin, /* replace =*/ false);
-
-        // Fire!
-        assertTrue(dpm.setProfileOwner(admin, "owner-name", DpmMockContext.CALLER_USER_HANDLE));
-
-        // Check
-        assertEquals(admin, dpm.getProfileOwnerAsUser(DpmMockContext.CALLER_USER_HANDLE));
-    }
-
-    public void testHasNoFeature() throws Exception {
-        when(mContext.packageManager.hasSystemFeature(eq(PackageManager.FEATURE_DEVICE_ADMIN)))
-                .thenReturn(false);
-
-        LocalServices.removeServiceForTest(DevicePolicyManagerInternal.class);
-        new DevicePolicyManagerServiceTestable(mContext, dataDir);
-
-        // If the device has no DPMS feature, it shouldn't register the local service.
-        assertNull(LocalServices.getService(DevicePolicyManagerInternal.class));
-    }
-
-    /**
-     * Caller doesn't have proper permissions.
-     */
-    public void testSetActiveAdmin_SecurityException() {
-        // 1. Failure cases.
-
-        // Caller doesn't have MANAGE_DEVICE_ADMINS.
-        try {
-            dpm.setActiveAdmin(admin1, false);
-            fail("Didn't throw SecurityException");
-        } catch (SecurityException expected) {
-        }
-
-        // Caller has MANAGE_DEVICE_ADMINS, but for different user.
-        mContext.callerPermissions.add(android.Manifest.permission.MANAGE_DEVICE_ADMINS);
-        try {
-            dpm.setActiveAdmin(admin1, false, DpmMockContext.CALLER_USER_HANDLE + 1);
-            fail("Didn't throw SecurityException");
-        } catch (SecurityException expected) {
-        }
-    }
-
-    /**
-     * Test for:
-     * {@link DevicePolicyManager#setActiveAdmin}
-     * with replace=false and replace=true
-     * {@link DevicePolicyManager#isAdminActive}
-     * {@link DevicePolicyManager#isAdminActiveAsUser}
-     * {@link DevicePolicyManager#getActiveAdmins}
-     * {@link DevicePolicyManager#getActiveAdminsAsUser}
-     */
-    public void testSetActiveAdmin() throws Exception {
-        // 1. Make sure the caller has proper permissions.
-        mContext.callerPermissions.add(android.Manifest.permission.MANAGE_DEVICE_ADMINS);
-
-        // 2. Call the API.
-        dpm.setActiveAdmin(admin1, /* replace =*/ false);
-
-        // 3. Verify internal calls.
-
-        // Check if the boradcast is sent.
-        verify(mContext.spiedContext).sendBroadcastAsUser(
-                MockUtils.checkIntentAction(
-                        DevicePolicyManager.ACTION_DEVICE_POLICY_MANAGER_STATE_CHANGED),
-                MockUtils.checkUserHandle(DpmMockContext.CALLER_USER_HANDLE));
-        verify(mContext.spiedContext).sendBroadcastAsUser(
-                MockUtils.checkIntentAction(
-                        DeviceAdminReceiver.ACTION_DEVICE_ADMIN_ENABLED),
-                MockUtils.checkUserHandle(DpmMockContext.CALLER_USER_HANDLE));
-
-        verify(mContext.ipackageManager, times(1)).setApplicationEnabledSetting(
-                eq(admin1.getPackageName()),
-                eq(PackageManager.COMPONENT_ENABLED_STATE_DEFAULT),
-                eq(PackageManager.DONT_KILL_APP),
-                eq(DpmMockContext.CALLER_USER_HANDLE),
-                anyString());
-
-        // TODO Verify other calls too.
-
-        // Make sure it's active admin1.
-        assertTrue(dpm.isAdminActive(admin1));
-        assertFalse(dpm.isAdminActive(admin2));
-        assertFalse(dpm.isAdminActive(admin3));
-
-        // But not admin1 for a different user.
-
-        // For this to work, caller needs android.permission.INTERACT_ACROSS_USERS_FULL.
-        // (Because we're checking a different user's status from CALLER_USER_HANDLE.)
-        mContext.callerPermissions.add("android.permission.INTERACT_ACROSS_USERS_FULL");
-
-        assertFalse(dpm.isAdminActiveAsUser(admin1, DpmMockContext.CALLER_USER_HANDLE + 1));
-        assertFalse(dpm.isAdminActiveAsUser(admin2, DpmMockContext.CALLER_USER_HANDLE + 1));
-
-        mContext.callerPermissions.remove("android.permission.INTERACT_ACROSS_USERS_FULL");
-
-        // Next, add one more admin.
-        // Before doing so, update the application info, now it's enabled.
-        setUpPackageManagerForAdmin(admin2, DpmMockContext.CALLER_UID,
-                PackageManager.COMPONENT_ENABLED_STATE_ENABLED);
-
-        dpm.setActiveAdmin(admin2, /* replace =*/ false);
-
-        // Now we have two admins.
-        assertTrue(dpm.isAdminActive(admin1));
-        assertTrue(dpm.isAdminActive(admin2));
-        assertFalse(dpm.isAdminActive(admin3));
-
-        // Admin2 was already enabled, so setApplicationEnabledSetting() shouldn't have called
-        // again.  (times(1) because it was previously called for admin1)
-        verify(mContext.ipackageManager, times(1)).setApplicationEnabledSetting(
-                eq(admin1.getPackageName()),
-                eq(PackageManager.COMPONENT_ENABLED_STATE_DEFAULT),
-                eq(PackageManager.DONT_KILL_APP),
-                eq(DpmMockContext.CALLER_USER_HANDLE),
-                anyString());
-
-        // 4. Add the same admin1 again without replace, which should throw.
-        try {
-            dpm.setActiveAdmin(admin1, /* replace =*/ false);
-            fail("Didn't throw");
-        } catch (IllegalArgumentException expected) {
-        }
-
-        // 5. Add the same admin1 again with replace, which should succeed.
-        dpm.setActiveAdmin(admin1, /* replace =*/ true);
-
-        // TODO make sure it's replaced.
-
-        // 6. Test getActiveAdmins()
-        List<ComponentName> admins = dpm.getActiveAdmins();
-        assertEquals(2, admins.size());
-        assertEquals(admin1, admins.get(0));
-        assertEquals(admin2, admins.get(1));
-
-        // Another user has no admins.
-        mContext.callerPermissions.add("android.permission.INTERACT_ACROSS_USERS_FULL");
-
-        assertEquals(0, DpmTestUtils.getListSizeAllowingNull(
-                dpm.getActiveAdminsAsUser(DpmMockContext.CALLER_USER_HANDLE + 1)));
-
-        mContext.callerPermissions.remove("android.permission.INTERACT_ACROSS_USERS_FULL");
-    }
-
-    public void testSetActiveAdmin_multiUsers() throws Exception {
-
-        final int ANOTHER_USER_ID = 100;
-        final int ANOTHER_ADMIN_UID = UserHandle.getUid(ANOTHER_USER_ID, 20456);
-
-        mMockContext.addUser(ANOTHER_USER_ID, 0); // Add one more user.
-
-        // Set up pacakge manager for the other user.
-        setUpPackageManagerForAdmin(admin2, ANOTHER_ADMIN_UID);
-
-        mContext.callerPermissions.add(android.Manifest.permission.MANAGE_DEVICE_ADMINS);
-
-        dpm.setActiveAdmin(admin1, /* replace =*/ false);
-
-        mMockContext.binder.callingUid = ANOTHER_ADMIN_UID;
-        dpm.setActiveAdmin(admin2, /* replace =*/ false);
-
-
-        mMockContext.binder.callingUid = DpmMockContext.CALLER_UID;
-        assertTrue(dpm.isAdminActive(admin1));
-        assertFalse(dpm.isAdminActive(admin2));
-
-        mMockContext.binder.callingUid = ANOTHER_ADMIN_UID;
-        assertFalse(dpm.isAdminActive(admin1));
-        assertTrue(dpm.isAdminActive(admin2));
-    }
-
-    /**
-     * Test for:
-     * {@link DevicePolicyManager#setActiveAdmin}
-     * with replace=false
-     */
-    public void testSetActiveAdmin_twiceWithoutReplace() throws Exception {
-        // 1. Make sure the caller has proper permissions.
-        mContext.callerPermissions.add(android.Manifest.permission.MANAGE_DEVICE_ADMINS);
-
-        dpm.setActiveAdmin(admin1, /* replace =*/ false);
-        assertTrue(dpm.isAdminActive(admin1));
-
-        // Add the same admin1 again without replace, which should throw.
-        try {
-            dpm.setActiveAdmin(admin1, /* replace =*/ false);
-            fail("Didn't throw");
-        } catch (IllegalArgumentException expected) {
-        }
-    }
-
-    /**
-     * Test for:
-     * {@link DevicePolicyManager#setActiveAdmin} when the admin isn't protected with
-     * BIND_DEVICE_ADMIN.
-     */
-    public void testSetActiveAdmin_permissionCheck() throws Exception {
-        // 1. Make sure the caller has proper permissions.
-        mContext.callerPermissions.add(android.Manifest.permission.MANAGE_DEVICE_ADMINS);
-
-        try {
-            dpm.setActiveAdmin(adminNoPerm, /* replace =*/ false);
-            fail();
-        } catch (IllegalArgumentException expected) {
-            assertTrue(expected.getMessage().contains(permission.BIND_DEVICE_ADMIN));
-        }
-        assertFalse(dpm.isAdminActive(adminNoPerm));
-
-        // Change the target API level to MNC.  Now it can be set as DA.
-        setUpPackageManagerForAdmin(adminNoPerm, DpmMockContext.CALLER_UID, null,
-                VERSION_CODES.M);
-        dpm.setActiveAdmin(adminNoPerm, /* replace =*/ false);
-        assertTrue(dpm.isAdminActive(adminNoPerm));
-
-        // TODO Test the "load from the file" case where DA will still be loaded even without
-        // BIND_DEVICE_ADMIN and target API is N.
-    }
-
-    /**
-     * Test for:
-     * {@link DevicePolicyManager#removeActiveAdmin}
-     */
-    public void testRemoveActiveAdmin_SecurityException() {
-        mContext.callerPermissions.add(android.Manifest.permission.MANAGE_DEVICE_ADMINS);
-
-        // Add admin.
-
-        dpm.setActiveAdmin(admin1, /* replace =*/ false);
-
-        assertTrue(dpm.isAdminActive(admin1));
-
-        assertFalse(dpm.isRemovingAdmin(admin1, DpmMockContext.CALLER_USER_HANDLE));
-
-        // Directly call the DPMS method with a different userid, which should fail.
-        try {
-            dpms.removeActiveAdmin(admin1, DpmMockContext.CALLER_USER_HANDLE + 1);
-            fail("Didn't throw SecurityException");
-        } catch (SecurityException expected) {
-        }
-
-        // Try to remove active admin with a different caller userid should fail too, without
-        // having MANAGE_DEVICE_ADMINS.
-        mContext.callerPermissions.clear();
-
-        // Change the caller, and call into DPMS directly with a different user-id.
-
-        mContext.binder.callingUid = 1234567;
-        try {
-            dpms.removeActiveAdmin(admin1, DpmMockContext.CALLER_USER_HANDLE);
-            fail("Didn't throw SecurityException");
-        } catch (SecurityException expected) {
-        }
-    }
-
-    /**
-     * {@link DevicePolicyManager#removeActiveAdmin} should fail with the user is not unlocked
-     * (because we can't send the remove broadcast).
-     */
-    public void testRemoveActiveAdmin_userNotRunningOrLocked() {
-        mContext.callerPermissions.add(android.Manifest.permission.MANAGE_DEVICE_ADMINS);
-
-        mContext.binder.callingUid = DpmMockContext.CALLER_UID;
-
-        // Add admin.
-
-        dpm.setActiveAdmin(admin1, /* replace =*/ false);
-
-        assertTrue(dpm.isAdminActive(admin1));
-
-        assertFalse(dpm.isRemovingAdmin(admin1, DpmMockContext.CALLER_USER_HANDLE));
-
-        // 1. User not unlocked.
-        when(mContext.userManager.isUserUnlocked(eq(DpmMockContext.CALLER_USER_HANDLE)))
-                .thenReturn(false);
-        try {
-            dpm.removeActiveAdmin(admin1);
-            fail("Didn't throw IllegalStateException");
-        } catch (IllegalStateException expected) {
-            MoreAsserts.assertContainsRegex(
-                    "User must be running and unlocked", expected.getMessage());
-        }
-
-        assertFalse(dpm.isRemovingAdmin(admin1, DpmMockContext.CALLER_USER_HANDLE));
-
-        // 2. User unlocked.
-        when(mContext.userManager.isUserUnlocked(eq(DpmMockContext.CALLER_USER_HANDLE)))
-                .thenReturn(true);
-
-        dpm.removeActiveAdmin(admin1);
-        assertFalse(dpm.isAdminActiveAsUser(admin1, DpmMockContext.CALLER_USER_HANDLE));
-    }
-
-    /**
-     * Test for:
-     * {@link DevicePolicyManager#removeActiveAdmin}
-     */
-    public void testRemoveActiveAdmin_fromDifferentUserWithINTERACT_ACROSS_USERS_FULL() {
-        mContext.callerPermissions.add(android.Manifest.permission.MANAGE_DEVICE_ADMINS);
-
-        // Add admin1.
-
-        dpm.setActiveAdmin(admin1, /* replace =*/ false);
-
-        assertTrue(dpm.isAdminActive(admin1));
-        assertFalse(dpm.isRemovingAdmin(admin1, DpmMockContext.CALLER_USER_HANDLE));
-
-        // Different user, but should work, because caller has proper permissions.
-        mContext.callerPermissions.add(permission.INTERACT_ACROSS_USERS_FULL);
-
-        // Change the caller, and call into DPMS directly with a different user-id.
-        mContext.binder.callingUid = 1234567;
-
-        dpms.removeActiveAdmin(admin1, DpmMockContext.CALLER_USER_HANDLE);
-        assertFalse(dpm.isAdminActiveAsUser(admin1, DpmMockContext.CALLER_USER_HANDLE));
-
-        // TODO DO Still can't be removed in this case.
-    }
-
-    /**
-     * Test for:
-     * {@link DevicePolicyManager#removeActiveAdmin}
-     */
-    public void testRemoveActiveAdmin_sameUserNoMANAGE_DEVICE_ADMINS() {
-        // Need MANAGE_DEVICE_ADMINS for setActiveAdmin.  We'll remove it later.
-        mContext.callerPermissions.add(android.Manifest.permission.MANAGE_DEVICE_ADMINS);
-
-        // Add admin1.
-
-        dpm.setActiveAdmin(admin1, /* replace =*/ false);
-
-        assertTrue(dpm.isAdminActive(admin1));
-        assertFalse(dpm.isRemovingAdmin(admin1, DpmMockContext.CALLER_USER_HANDLE));
-
-        // Broadcast from saveSettingsLocked().
-        verify(mContext.spiedContext, times(1)).sendBroadcastAsUser(
-                MockUtils.checkIntentAction(
-                        DevicePolicyManager.ACTION_DEVICE_POLICY_MANAGER_STATE_CHANGED),
-                MockUtils.checkUserHandle(DpmMockContext.CALLER_USER_HANDLE));
-
-        // Remove.  No permissions, but same user, so it'll work.
-        mContext.callerPermissions.clear();
-        dpm.removeActiveAdmin(admin1);
-
-        verify(mContext.spiedContext).sendOrderedBroadcastAsUser(
-                MockUtils.checkIntentAction(
-                        DeviceAdminReceiver.ACTION_DEVICE_ADMIN_DISABLED),
-                MockUtils.checkUserHandle(DpmMockContext.CALLER_USER_HANDLE),
-                isNull(String.class),
-                any(BroadcastReceiver.class),
-                eq(dpms.mHandler),
-                eq(Activity.RESULT_OK),
-                isNull(String.class),
-                isNull(Bundle.class));
-
-        assertFalse(dpm.isAdminActiveAsUser(admin1, DpmMockContext.CALLER_USER_HANDLE));
-
-        // Again broadcast from saveSettingsLocked().
-        verify(mContext.spiedContext, times(2)).sendBroadcastAsUser(
-                MockUtils.checkIntentAction(
-                        DevicePolicyManager.ACTION_DEVICE_POLICY_MANAGER_STATE_CHANGED),
-                MockUtils.checkUserHandle(DpmMockContext.CALLER_USER_HANDLE));
-
-        // TODO Check other internal calls.
-    }
-
-    /**
-     * Test for: {@link DevicePolicyManager#setDeviceOwner} DO on system user installs successfully.
-     */
-    public void testSetDeviceOwner() throws Exception {
-        setDeviceOwner();
-
-        // Try to set a profile owner on the same user, which should fail.
-        setUpPackageManagerForAdmin(admin2, DpmMockContext.CALLER_SYSTEM_USER_UID);
-        dpm.setActiveAdmin(admin2, /* refreshing= */ true, UserHandle.USER_SYSTEM);
-        try {
-            dpm.setProfileOwner(admin2, "owner-name", UserHandle.USER_SYSTEM);
-            fail("IllegalStateException not thrown");
-        } catch (IllegalStateException expected) {
-            assertTrue("Message was: " + expected.getMessage(),
-                    expected.getMessage().contains("already has a device owner"));
-        }
-
-        // DO admin can't be deactivated.
-        dpm.removeActiveAdmin(admin1);
-        assertTrue(dpm.isAdminActive(admin1));
-
-        // TODO Test getDeviceOwnerName() too. To do so, we need to change
-        // DPMS.getApplicationLabel() because Context.createPackageContextAsUser() is not mockable.
-    }
-
-    private void setDeviceOwner() throws Exception {
-        mContext.callerPermissions.add(permission.MANAGE_DEVICE_ADMINS);
-        mContext.callerPermissions.add(permission.MANAGE_USERS);
-        mContext.callerPermissions.add(permission.MANAGE_PROFILE_AND_DEVICE_OWNERS);
-        mContext.callerPermissions.add(permission.INTERACT_ACROSS_USERS_FULL);
-
-        // In this test, change the caller user to "system".
-        mContext.binder.callingUid = DpmMockContext.CALLER_SYSTEM_USER_UID;
-
-        // Make sure admin1 is installed on system user.
-        setUpPackageManagerForAdmin(admin1, DpmMockContext.CALLER_SYSTEM_USER_UID);
-
-        // Check various get APIs.
-        checkGetDeviceOwnerInfoApi(dpm, /* hasDeviceOwner =*/ false);
-
-        // DO needs to be an DA.
-        dpm.setActiveAdmin(admin1, /* replace =*/ false);
-
-        // Fire!
-        assertTrue(dpm.setDeviceOwner(admin1, "owner-name"));
-
-        // getDeviceOwnerComponent should return the admin1 component.
-        assertEquals(admin1, dpm.getDeviceOwnerComponentOnCallingUser());
-        assertEquals(admin1, dpm.getDeviceOwnerComponentOnAnyUser());
-
-        // Check various get APIs.
-        checkGetDeviceOwnerInfoApi(dpm, /* hasDeviceOwner =*/ true);
-
-        // getDeviceOwnerComponent should *NOT* return the admin1 component for other users.
-        mContext.binder.callingUid = DpmMockContext.CALLER_UID;
-        assertEquals(null, dpm.getDeviceOwnerComponentOnCallingUser());
-        assertEquals(admin1, dpm.getDeviceOwnerComponentOnAnyUser());
-
-        mContext.binder.callingUid = DpmMockContext.CALLER_SYSTEM_USER_UID;
-
-        // Verify internal calls.
-        verify(mContext.iactivityManager, times(1)).updateDeviceOwner(
-                eq(admin1.getPackageName()));
-
-        // TODO We should check if the caller has called clearCallerIdentity().
-        verify(mContext.ibackupManager, times(1)).setBackupServiceActive(
-                eq(UserHandle.USER_SYSTEM), eq(false));
-
-        verify(mContext.spiedContext, times(1)).sendBroadcastAsUser(
-                MockUtils.checkIntentAction(DevicePolicyManager.ACTION_DEVICE_OWNER_CHANGED),
-                MockUtils.checkUserHandle(UserHandle.USER_SYSTEM));
-
-        assertEquals(admin1, dpm.getDeviceOwnerComponentOnAnyUser());
-    }
-
-    private void checkGetDeviceOwnerInfoApi(DevicePolicyManager dpm, boolean hasDeviceOwner) {
-        final int origCallingUser = mContext.binder.callingUid;
-        final List origPermissions = new ArrayList(mContext.callerPermissions);
-        mContext.callerPermissions.clear();
-
-        mContext.callerPermissions.add(permission.MANAGE_USERS);
-
-        mContext.binder.callingUid = Process.SYSTEM_UID;
-
-        // TODO Test getDeviceOwnerName() too.  To do so, we need to change
-        // DPMS.getApplicationLabel() because Context.createPackageContextAsUser() is not mockable.
-        if (hasDeviceOwner) {
-            assertTrue(dpm.isDeviceOwnerApp(admin1.getPackageName()));
-            assertTrue(dpm.isDeviceOwnerAppOnCallingUser(admin1.getPackageName()));
-            assertEquals(admin1, dpm.getDeviceOwnerComponentOnCallingUser());
-
-            assertTrue(dpm.isDeviceOwnerAppOnAnyUser(admin1.getPackageName()));
-            assertEquals(admin1, dpm.getDeviceOwnerComponentOnAnyUser());
-            assertEquals(UserHandle.USER_SYSTEM, dpm.getDeviceOwnerUserId());
-        } else {
-            assertFalse(dpm.isDeviceOwnerApp(admin1.getPackageName()));
-            assertFalse(dpm.isDeviceOwnerAppOnCallingUser(admin1.getPackageName()));
-            assertEquals(null, dpm.getDeviceOwnerComponentOnCallingUser());
-
-            assertFalse(dpm.isDeviceOwnerAppOnAnyUser(admin1.getPackageName()));
-            assertEquals(null, dpm.getDeviceOwnerComponentOnAnyUser());
-            assertEquals(UserHandle.USER_NULL, dpm.getDeviceOwnerUserId());
-        }
-
-        mContext.binder.callingUid = DpmMockContext.CALLER_SYSTEM_USER_UID;
-        if (hasDeviceOwner) {
-            assertTrue(dpm.isDeviceOwnerApp(admin1.getPackageName()));
-            assertTrue(dpm.isDeviceOwnerAppOnCallingUser(admin1.getPackageName()));
-            assertEquals(admin1, dpm.getDeviceOwnerComponentOnCallingUser());
-
-            assertTrue(dpm.isDeviceOwnerAppOnAnyUser(admin1.getPackageName()));
-            assertEquals(admin1, dpm.getDeviceOwnerComponentOnAnyUser());
-            assertEquals(UserHandle.USER_SYSTEM, dpm.getDeviceOwnerUserId());
-        } else {
-            assertFalse(dpm.isDeviceOwnerApp(admin1.getPackageName()));
-            assertFalse(dpm.isDeviceOwnerAppOnCallingUser(admin1.getPackageName()));
-            assertEquals(null, dpm.getDeviceOwnerComponentOnCallingUser());
-
-            assertFalse(dpm.isDeviceOwnerAppOnAnyUser(admin1.getPackageName()));
-            assertEquals(null, dpm.getDeviceOwnerComponentOnAnyUser());
-            assertEquals(UserHandle.USER_NULL, dpm.getDeviceOwnerUserId());
-        }
-
-        mContext.binder.callingUid = DpmMockContext.CALLER_UID;
-        // Still with MANAGE_USERS.
-        assertFalse(dpm.isDeviceOwnerApp(admin1.getPackageName()));
-        assertFalse(dpm.isDeviceOwnerAppOnCallingUser(admin1.getPackageName()));
-        assertEquals(null, dpm.getDeviceOwnerComponentOnCallingUser());
-
-        if (hasDeviceOwner) {
-            assertTrue(dpm.isDeviceOwnerAppOnAnyUser(admin1.getPackageName()));
-            assertEquals(admin1, dpm.getDeviceOwnerComponentOnAnyUser());
-            assertEquals(UserHandle.USER_SYSTEM, dpm.getDeviceOwnerUserId());
-        } else {
-            assertFalse(dpm.isDeviceOwnerAppOnAnyUser(admin1.getPackageName()));
-            assertEquals(null, dpm.getDeviceOwnerComponentOnAnyUser());
-            assertEquals(UserHandle.USER_NULL, dpm.getDeviceOwnerUserId());
-        }
-
-        mContext.binder.callingUid = Process.SYSTEM_UID;
-        mContext.callerPermissions.remove(permission.MANAGE_USERS);
-        // System can still call "OnAnyUser" without MANAGE_USERS.
-        if (hasDeviceOwner) {
-            assertTrue(dpm.isDeviceOwnerApp(admin1.getPackageName()));
-            assertTrue(dpm.isDeviceOwnerAppOnCallingUser(admin1.getPackageName()));
-            assertEquals(admin1, dpm.getDeviceOwnerComponentOnCallingUser());
-
-            assertTrue(dpm.isDeviceOwnerAppOnAnyUser(admin1.getPackageName()));
-            assertEquals(admin1, dpm.getDeviceOwnerComponentOnAnyUser());
-            assertEquals(UserHandle.USER_SYSTEM, dpm.getDeviceOwnerUserId());
-        } else {
-            assertFalse(dpm.isDeviceOwnerApp(admin1.getPackageName()));
-            assertFalse(dpm.isDeviceOwnerAppOnCallingUser(admin1.getPackageName()));
-            assertEquals(null, dpm.getDeviceOwnerComponentOnCallingUser());
-
-            assertFalse(dpm.isDeviceOwnerAppOnAnyUser(admin1.getPackageName()));
-            assertEquals(null, dpm.getDeviceOwnerComponentOnAnyUser());
-            assertEquals(UserHandle.USER_NULL, dpm.getDeviceOwnerUserId());
-        }
-
-        mContext.binder.callingUid = DpmMockContext.CALLER_SYSTEM_USER_UID;
-        // Still no MANAGE_USERS.
-        if (hasDeviceOwner) {
-            assertTrue(dpm.isDeviceOwnerApp(admin1.getPackageName()));
-            assertTrue(dpm.isDeviceOwnerAppOnCallingUser(admin1.getPackageName()));
-            assertEquals(admin1, dpm.getDeviceOwnerComponentOnCallingUser());
-        } else {
-            assertFalse(dpm.isDeviceOwnerApp(admin1.getPackageName()));
-            assertFalse(dpm.isDeviceOwnerAppOnCallingUser(admin1.getPackageName()));
-            assertEquals(null, dpm.getDeviceOwnerComponentOnCallingUser());
-        }
-
-        try {
-            dpm.isDeviceOwnerAppOnAnyUser(admin1.getPackageName());
-            fail();
-        } catch (SecurityException expected) {
-        }
-        try {
-            dpm.getDeviceOwnerComponentOnAnyUser();
-            fail();
-        } catch (SecurityException expected) {
-        }
-        try {
-            dpm.getDeviceOwnerUserId();
-            fail();
-        } catch (SecurityException expected) {
-        }
-        try {
-            dpm.getDeviceOwnerNameOnAnyUser();
-            fail();
-        } catch (SecurityException expected) {
-        }
-
-        mContext.binder.callingUid = DpmMockContext.CALLER_UID;
-        // Still no MANAGE_USERS.
-        assertFalse(dpm.isDeviceOwnerApp(admin1.getPackageName()));
-        assertFalse(dpm.isDeviceOwnerAppOnCallingUser(admin1.getPackageName()));
-        assertEquals(null, dpm.getDeviceOwnerComponentOnCallingUser());
-
-        try {
-            dpm.isDeviceOwnerAppOnAnyUser(admin1.getPackageName());
-            fail();
-        } catch (SecurityException expected) {
-        }
-        try {
-            dpm.getDeviceOwnerComponentOnAnyUser();
-            fail();
-        } catch (SecurityException expected) {
-        }
-        try {
-            dpm.getDeviceOwnerUserId();
-            fail();
-        } catch (SecurityException expected) {
-        }
-        try {
-            dpm.getDeviceOwnerNameOnAnyUser();
-            fail();
-        } catch (SecurityException expected) {
-        }
-
-        // Restore.
-        mContext.binder.callingUid = origCallingUser;
-        mContext.callerPermissions.addAll(origPermissions);
-    }
-
-
-    /**
-     * Test for: {@link DevicePolicyManager#setDeviceOwner} Package doesn't exist.
-     */
-    public void testSetDeviceOwner_noSuchPackage() {
-        mContext.callerPermissions.add(permission.MANAGE_DEVICE_ADMINS);
-        mContext.callerPermissions.add(permission.MANAGE_USERS);
-        mContext.callerPermissions.add(permission.MANAGE_PROFILE_AND_DEVICE_OWNERS);
-        mContext.callerPermissions.add(permission.INTERACT_ACROSS_USERS_FULL);
-
-        // Call from a process on the system user.
-        mContext.binder.callingUid = DpmMockContext.CALLER_SYSTEM_USER_UID;
-
-        try {
-            dpm.setDeviceOwner(new ComponentName("a.b.c", ".def"));
-            fail("Didn't throw IllegalArgumentException");
-        } catch (IllegalArgumentException expected) {
-            assertTrue("Message was: " + expected.getMessage(),
-                    expected.getMessage().contains("Invalid component"));
-        }
-    }
-
-    public void testSetDeviceOwner_failures() throws Exception {
-        // TODO Test more failure cases.  Basically test all chacks in enforceCanSetDeviceOwner().
-    }
-
-    public void testClearDeviceOwner() throws Exception {
-        mContext.callerPermissions.add(permission.MANAGE_DEVICE_ADMINS);
-        mContext.callerPermissions.add(permission.MANAGE_USERS);
-        mContext.callerPermissions.add(permission.MANAGE_PROFILE_AND_DEVICE_OWNERS);
-        mContext.callerPermissions.add(permission.INTERACT_ACROSS_USERS_FULL);
-
-        // Set admin1 as a DA to the secondary user.
-        setUpPackageManagerForAdmin(admin1, DpmMockContext.CALLER_UID);
-
-        dpm.setActiveAdmin(admin1, /* replace =*/ false);
-
-        // Set admin 1 as the DO to the system user.
-
-        mContext.binder.callingUid = DpmMockContext.CALLER_SYSTEM_USER_UID;
-        setUpPackageManagerForAdmin(admin1, DpmMockContext.CALLER_SYSTEM_USER_UID);
-        dpm.setActiveAdmin(admin1, /* replace =*/ false);
-        assertTrue(dpm.setDeviceOwner(admin1, "owner-name"));
-
-        // Verify internal calls.
-        verify(mContext.iactivityManager, times(1)).updateDeviceOwner(
-                eq(admin1.getPackageName()));
-
-        assertEquals(admin1, dpm.getDeviceOwnerComponentOnAnyUser());
-
-        dpm.addUserRestriction(admin1, UserManager.DISALLOW_ADD_USER);
-
-        assertTrue(dpm.isAdminActive(admin1));
-        assertFalse(dpm.isRemovingAdmin(admin1, UserHandle.USER_SYSTEM));
-
-        // Set up other mocks.
-        when(mContext.userManager.getUserRestrictions()).thenReturn(new Bundle());
-
-        // Now call clear.
-        doReturn(DpmMockContext.CALLER_SYSTEM_USER_UID).when(mContext.packageManager).getPackageUidAsUser(
-                eq(admin1.getPackageName()),
-                anyInt());
-
-        // But first pretend the user is locked.  Then it should fail.
-        when(mContext.userManager.isUserUnlocked(anyInt())).thenReturn(false);
-        try {
-            dpm.clearDeviceOwnerApp(admin1.getPackageName());
-            fail("Didn't throw IllegalStateException");
-        } catch (IllegalStateException expected) {
-            MoreAsserts.assertContainsRegex(
-                    "User must be running and unlocked", expected.getMessage());
-        }
-
-        when(mContext.userManager.isUserUnlocked(anyInt())).thenReturn(true);
-        reset(mContext.userManagerInternal);
-        dpm.clearDeviceOwnerApp(admin1.getPackageName());
-
-        // Now DO shouldn't be set.
-        assertNull(dpm.getDeviceOwnerComponentOnAnyUser());
-
-        verify(mContext.userManagerInternal).setDevicePolicyUserRestrictions(
-                eq(UserHandle.USER_SYSTEM),
-                MockUtils.checkUserRestrictions(),
-                MockUtils.checkUserRestrictions()
-        );
-
-        assertFalse(dpm.isAdminActiveAsUser(admin1, UserHandle.USER_SYSTEM));
-        // TODO Check other calls.
-    }
-
-    public void testClearDeviceOwner_fromDifferentUser() throws Exception {
-        mContext.callerPermissions.add(permission.MANAGE_DEVICE_ADMINS);
-        mContext.callerPermissions.add(permission.MANAGE_USERS);
-        mContext.callerPermissions.add(permission.MANAGE_PROFILE_AND_DEVICE_OWNERS);
-        mContext.callerPermissions.add(permission.INTERACT_ACROSS_USERS_FULL);
-
-        // Set admin1 as a DA to the secondary user.
-        setUpPackageManagerForAdmin(admin1, DpmMockContext.CALLER_UID);
-
-        dpm.setActiveAdmin(admin1, /* replace =*/ false);
-
-        // Set admin 1 as the DO to the system user.
-
-        mContext.binder.callingUid = DpmMockContext.CALLER_SYSTEM_USER_UID;
-        setUpPackageManagerForAdmin(admin1, DpmMockContext.CALLER_SYSTEM_USER_UID);
-        dpm.setActiveAdmin(admin1, /* replace =*/ false);
-        assertTrue(dpm.setDeviceOwner(admin1, "owner-name"));
-
-        // Verify internal calls.
-        verify(mContext.iactivityManager, times(1)).updateDeviceOwner(
-                eq(admin1.getPackageName()));
-
-        assertEquals(admin1, dpm.getDeviceOwnerComponentOnAnyUser());
-
-        // Now call clear from the secondary user, which should throw.
-        mContext.binder.callingUid = DpmMockContext.CALLER_UID;
-
-        // Now call clear.
-        doReturn(DpmMockContext.CALLER_UID).when(mContext.packageManager).getPackageUidAsUser(
-                eq(admin1.getPackageName()),
-                anyInt());
-        try {
-            dpm.clearDeviceOwnerApp(admin1.getPackageName());
-            fail("Didn't throw");
-        } catch (SecurityException e) {
-            assertEquals("clearDeviceOwner can only be called by the device owner", e.getMessage());
-        }
-
-        // DO shouldn't be removed.
-        assertTrue(dpm.isDeviceManaged());
-    }
-
-    public void testSetProfileOwner() throws Exception {
-        setAsProfileOwner(admin1);
-
-        // PO admin can't be deactivated.
-        dpm.removeActiveAdmin(admin1);
-        assertTrue(dpm.isAdminActive(admin1));
-
-        // Try setting DO on the same user, which should fail.
-        setUpPackageManagerForAdmin(admin2, DpmMockContext.CALLER_UID);
-        dpm.setActiveAdmin(admin2, /* refreshing= */ true, DpmMockContext.CALLER_USER_HANDLE);
-        try {
-            dpm.setDeviceOwner(admin2, "owner-name", DpmMockContext.CALLER_USER_HANDLE);
-            fail("IllegalStateException not thrown");
-        } catch (IllegalStateException expected) {
-            assertTrue("Message was: " + expected.getMessage(),
-                    expected.getMessage().contains("already has a profile owner"));
-        }
-    }
-
-    public void testClearProfileOwner() throws Exception {
-        setAsProfileOwner(admin1);
-
-        mContext.binder.callingUid = DpmMockContext.CALLER_UID;
-
-        assertTrue(dpm.isProfileOwnerApp(admin1.getPackageName()));
-        assertFalse(dpm.isRemovingAdmin(admin1, DpmMockContext.CALLER_USER_HANDLE));
-
-        // First try when the user is locked, which should fail.
-        when(mContext.userManager.isUserUnlocked(anyInt()))
-                .thenReturn(false);
-        try {
-            dpm.clearProfileOwner(admin1);
-            fail("Didn't throw IllegalStateException");
-        } catch (IllegalStateException expected) {
-            MoreAsserts.assertContainsRegex(
-                    "User must be running and unlocked", expected.getMessage());
-        }
-        // Clear, really.
-        when(mContext.userManager.isUserUnlocked(anyInt()))
-                .thenReturn(true);
-        dpm.clearProfileOwner(admin1);
-
-        // Check
-        assertFalse(dpm.isProfileOwnerApp(admin1.getPackageName()));
-        assertFalse(dpm.isAdminActiveAsUser(admin1, DpmMockContext.CALLER_USER_HANDLE));
-    }
-
-    public void testSetProfileOwner_failures() throws Exception {
-        // TODO Test more failure cases.  Basically test all chacks in enforceCanSetProfileOwner().
-    }
-
-    public void testGetDeviceOwnerAdminLocked() throws Exception {
-        checkDeviceOwnerWithMultipleDeviceAdmins();
-    }
-
-    private void checkDeviceOwnerWithMultipleDeviceAdmins() throws Exception {
-        // In ths test, we use 3 users (system + 2 secondary users), set some device admins to them,
-        // set admin2 on CALLER_USER_HANDLE as DO, then call getDeviceOwnerAdminLocked() to
-        // make sure it gets the right component from the right user.
-
-        final int ANOTHER_USER_ID = 100;
-        final int ANOTHER_ADMIN_UID = UserHandle.getUid(ANOTHER_USER_ID, 456);
-
-        mMockContext.addUser(ANOTHER_USER_ID, 0); // Add one more user.
-
-        mContext.callerPermissions.add(permission.MANAGE_DEVICE_ADMINS);
-        mContext.callerPermissions.add(permission.MANAGE_USERS);
-        mContext.callerPermissions.add(permission.MANAGE_PROFILE_AND_DEVICE_OWNERS);
-        mContext.callerPermissions.add(permission.INTERACT_ACROSS_USERS_FULL);
-
-        mContext.binder.callingUid = DpmMockContext.CALLER_SYSTEM_USER_UID;
-
-        when(mContext.userManagerForMock.isSplitSystemUser()).thenReturn(true);
-
-        // Make sure the admin packge is installed to each user.
-        setUpPackageManagerForAdmin(admin1, DpmMockContext.CALLER_SYSTEM_USER_UID);
-        setUpPackageManagerForAdmin(admin3, DpmMockContext.CALLER_SYSTEM_USER_UID);
-
-        setUpPackageManagerForAdmin(admin1, DpmMockContext.CALLER_UID);
-        setUpPackageManagerForAdmin(admin2, DpmMockContext.CALLER_UID);
-
-        setUpPackageManagerForAdmin(admin2, ANOTHER_ADMIN_UID);
-
-
-        // Set active admins to the users.
-        dpm.setActiveAdmin(admin1, /* replace =*/ false);
-        dpm.setActiveAdmin(admin3, /* replace =*/ false);
-
-        dpm.setActiveAdmin(admin1, /* replace =*/ false, DpmMockContext.CALLER_USER_HANDLE);
-        dpm.setActiveAdmin(admin2, /* replace =*/ false, DpmMockContext.CALLER_USER_HANDLE);
-
-        dpm.setActiveAdmin(admin2, /* replace =*/ false, ANOTHER_USER_ID);
-
-        // Set DO on the first non-system user.
-        mContext.setUserRunning(DpmMockContext.CALLER_USER_HANDLE, true);
-        assertTrue(dpm.setDeviceOwner(admin2, "owner-name", DpmMockContext.CALLER_USER_HANDLE));
-
-        assertEquals(admin2, dpms.getDeviceOwnerComponent(/* callingUserOnly =*/ false));
-
-        // Then check getDeviceOwnerAdminLocked().
-        assertEquals(admin2, dpms.getDeviceOwnerAdminLocked().info.getComponent());
-        assertEquals(DpmMockContext.CALLER_UID, dpms.getDeviceOwnerAdminLocked().getUid());
-    }
-
-    /**
-     * This essentially tests
-     * {@code DevicePolicyManagerService.findOwnerComponentIfNecessaryLocked()}. (which is
-     * private.)
-     *
-     * We didn't use to persist the DO component class name, but now we do, and the above method
-     * finds the right component from a package name upon migration.
-     */
-    public void testDeviceOwnerMigration() throws Exception {
-        when(mContext.userManagerForMock.isSplitSystemUser()).thenReturn(true);
-        checkDeviceOwnerWithMultipleDeviceAdmins();
-
-        // Overwrite the device owner setting and clears the clas name.
-        dpms.mOwners.setDeviceOwner(
-                new ComponentName(admin2.getPackageName(), ""),
-                "owner-name", DpmMockContext.CALLER_USER_HANDLE);
-        dpms.mOwners.writeDeviceOwner();
-
-        // Make sure the DO component name doesn't have a class name.
-        assertEquals("", dpms.getDeviceOwnerComponent(/* callingUserOnly =*/ false).getClassName());
-
-        // Then create a new DPMS to have it load the settings from files.
-        when(mContext.userManager.getUserRestrictions(any(UserHandle.class)))
-                .thenReturn(new Bundle());
-        initializeDpms();
-
-        // Now the DO component name is a full name.
-        // *BUT* because both admin1 and admin2 belong to the same package, we think admin1 is the
-        // DO.
-        assertEquals(admin1, dpms.getDeviceOwnerComponent(/* callingUserOnly =*/ false));
-    }
-
-    public void testSetGetApplicationRestriction() {
-        setAsProfileOwner(admin1);
-
-        {
-            Bundle rest = new Bundle();
-            rest.putString("KEY_STRING", "Foo1");
-            dpm.setApplicationRestrictions(admin1, "pkg1", rest);
-        }
-
-        {
-            Bundle rest = new Bundle();
-            rest.putString("KEY_STRING", "Foo2");
-            dpm.setApplicationRestrictions(admin1, "pkg2", rest);
-        }
-
-        {
-            Bundle returned = dpm.getApplicationRestrictions(admin1, "pkg1");
-            assertNotNull(returned);
-            assertEquals(returned.size(), 1);
-            assertEquals(returned.get("KEY_STRING"), "Foo1");
-        }
-
-        {
-            Bundle returned = dpm.getApplicationRestrictions(admin1, "pkg2");
-            assertNotNull(returned);
-            assertEquals(returned.size(), 1);
-            assertEquals(returned.get("KEY_STRING"), "Foo2");
-        }
-
-        dpm.setApplicationRestrictions(admin1, "pkg2", new Bundle());
-        assertEquals(0, dpm.getApplicationRestrictions(admin1, "pkg2").size());
-    }
-
-    public void testApplicationRestrictionsManagingApp() throws Exception {
-        setAsProfileOwner(admin1);
-
-        final String nonExistAppRestrictionsManagerPackage = "com.google.app.restrictions.manager2";
-        final String appRestrictionsManagerPackage = "com.google.app.restrictions.manager";
-        final int appRestrictionsManagerAppId = 20987;
-        final int appRestrictionsManagerUid = UserHandle.getUid(
-                DpmMockContext.CALLER_USER_HANDLE, appRestrictionsManagerAppId);
-        doReturn(appRestrictionsManagerUid).when(mContext.packageManager).getPackageUidAsUser(
-                eq(appRestrictionsManagerPackage),
-                eq(DpmMockContext.CALLER_USER_HANDLE));
-        mContext.binder.callingUid = appRestrictionsManagerUid;
-
-        final PackageInfo pi = new PackageInfo();
-        pi.applicationInfo = new ApplicationInfo();
-        pi.applicationInfo.flags = ApplicationInfo.FLAG_HAS_CODE;
-        doReturn(pi).when(mContext.ipackageManager).getPackageInfo(
-                eq(appRestrictionsManagerPackage),
-                anyInt(),
-                eq(DpmMockContext.CALLER_USER_HANDLE));
-
-        // appRestrictionsManager package shouldn't be able to manage restrictions as the PO hasn't
-        // delegated that permission yet.
-        assertFalse(dpm.isCallerApplicationRestrictionsManagingPackage());
-        Bundle rest = new Bundle();
-        rest.putString("KEY_STRING", "Foo1");
-        try {
-            dpm.setApplicationRestrictions(null, "pkg1", rest);
-            fail("Didn't throw expected SecurityException");
-        } catch (SecurityException expected) {
-            MoreAsserts.assertContainsRegex(
-                    "caller cannot manage application restrictions", expected.getMessage());
-        }
-        try {
-            dpm.getApplicationRestrictions(null, "pkg1");
-            fail("Didn't throw expected SecurityException");
-        } catch (SecurityException expected) {
-            MoreAsserts.assertContainsRegex(
-                    "caller cannot manage application restrictions", expected.getMessage());
-        }
-
-        // Check via the profile owner that no restrictions were set.
-        mContext.binder.callingUid = DpmMockContext.CALLER_UID;
-        assertEquals(0, dpm.getApplicationRestrictions(admin1, "pkg1").size());
-
-        // Check the API does not allow setting a non-existent package
-        try {
-            dpm.setApplicationRestrictionsManagingPackage(admin1,
-                    nonExistAppRestrictionsManagerPackage);
-            fail("Non-existent app set as app restriction manager.");
-        } catch (PackageManager.NameNotFoundException expected) {
-            MoreAsserts.assertContainsRegex(
-                    nonExistAppRestrictionsManagerPackage, expected.getMessage());
-        }
-
-        // Let appRestrictionsManagerPackage manage app restrictions
-        dpm.setApplicationRestrictionsManagingPackage(admin1, appRestrictionsManagerPackage);
-        assertEquals(appRestrictionsManagerPackage,
-                dpm.getApplicationRestrictionsManagingPackage(admin1));
-
-        // Now that package should be able to set and retrieve app restrictions.
-        mContext.binder.callingUid = appRestrictionsManagerUid;
-        assertTrue(dpm.isCallerApplicationRestrictionsManagingPackage());
-        dpm.setApplicationRestrictions(null, "pkg1", rest);
-        Bundle returned = dpm.getApplicationRestrictions(null, "pkg1");
-        assertEquals(1, returned.size(), 1);
-        assertEquals("Foo1", returned.get("KEY_STRING"));
-
-        // The same app running on a separate user shouldn't be able to manage app restrictions.
-        mContext.binder.callingUid = UserHandle.getUid(
-                UserHandle.USER_SYSTEM, appRestrictionsManagerAppId);
-        assertFalse(dpm.isCallerApplicationRestrictionsManagingPackage());
-        try {
-            dpm.setApplicationRestrictions(null, "pkg1", rest);
-            fail("Didn't throw expected SecurityException");
-        } catch (SecurityException expected) {
-            MoreAsserts.assertContainsRegex(
-                    "caller cannot manage application restrictions", expected.getMessage());
-        }
-
-        // The DPM is still able to manage app restrictions, even if it allowed another app to do it
-        // too.
-        mContext.binder.callingUid = DpmMockContext.CALLER_UID;
-        assertEquals(returned, dpm.getApplicationRestrictions(admin1, "pkg1"));
-        dpm.setApplicationRestrictions(admin1, "pkg1", null);
-        assertEquals(0, dpm.getApplicationRestrictions(admin1, "pkg1").size());
-
-        // Removing the ability for the package to manage app restrictions.
-        dpm.setApplicationRestrictionsManagingPackage(admin1, null);
-        assertNull(dpm.getApplicationRestrictionsManagingPackage(admin1));
-        mContext.binder.callingUid = appRestrictionsManagerUid;
-        assertFalse(dpm.isCallerApplicationRestrictionsManagingPackage());
-        try {
-            dpm.setApplicationRestrictions(null, "pkg1", null);
-            fail("Didn't throw expected SecurityException");
-        } catch (SecurityException expected) {
-            MoreAsserts.assertContainsRegex(
-                    "caller cannot manage application restrictions", expected.getMessage());
-        }
-    }
-
-    public void testSetUserRestriction_asDo() throws Exception {
-        mContext.callerPermissions.add(permission.MANAGE_DEVICE_ADMINS);
-        mContext.callerPermissions.add(permission.MANAGE_USERS);
-        mContext.callerPermissions.add(permission.MANAGE_PROFILE_AND_DEVICE_OWNERS);
-        mContext.callerPermissions.add(permission.INTERACT_ACROSS_USERS_FULL);
-
-        // First, set DO.
-
-        // Call from a process on the system user.
-        mContext.binder.callingUid = DpmMockContext.CALLER_SYSTEM_USER_UID;
-
-        // Make sure admin1 is installed on system user.
-        setUpPackageManagerForAdmin(admin1, DpmMockContext.CALLER_SYSTEM_USER_UID);
-
-        // Call.
-        dpm.setActiveAdmin(admin1, /* replace =*/ false, UserHandle.USER_SYSTEM);
-        assertTrue(dpm.setDeviceOwner(admin1, "owner-name",
-                UserHandle.USER_SYSTEM));
-
-        DpmTestUtils.assertRestrictions(
-                DpmTestUtils.newRestrictions(),
-                dpms.getDeviceOwnerAdminLocked().ensureUserRestrictions()
-        );
-        DpmTestUtils.assertRestrictions(
-                DpmTestUtils.newRestrictions(),
-                dpm.getUserRestrictions(admin1)
-        );
-
-        reset(mContext.userManagerInternal);
-
-        dpm.addUserRestriction(admin1, UserManager.DISALLOW_ADD_USER);
-        verify(mContext.userManagerInternal).setDevicePolicyUserRestrictions(
-                eq(UserHandle.USER_SYSTEM),
-                MockUtils.checkUserRestrictions(),
-                MockUtils.checkUserRestrictions(UserManager.DISALLOW_ADD_USER)
-        );
-        reset(mContext.userManagerInternal);
-
-        dpm.addUserRestriction(admin1, UserManager.DISALLOW_OUTGOING_CALLS);
-        verify(mContext.userManagerInternal).setDevicePolicyUserRestrictions(
-                eq(UserHandle.USER_SYSTEM),
-                MockUtils.checkUserRestrictions(UserManager.DISALLOW_OUTGOING_CALLS),
-                MockUtils.checkUserRestrictions(UserManager.DISALLOW_ADD_USER)
-        );
-        reset(mContext.userManagerInternal);
-
-        DpmTestUtils.assertRestrictions(
-                DpmTestUtils.newRestrictions(
-                        UserManager.DISALLOW_ADD_USER, UserManager.DISALLOW_OUTGOING_CALLS),
-                dpms.getDeviceOwnerAdminLocked().ensureUserRestrictions()
-        );
-        DpmTestUtils.assertRestrictions(
-                DpmTestUtils.newRestrictions(
-                        UserManager.DISALLOW_ADD_USER, UserManager.DISALLOW_OUTGOING_CALLS),
-                dpm.getUserRestrictions(admin1)
-        );
-
-        dpm.clearUserRestriction(admin1, UserManager.DISALLOW_ADD_USER);
-        verify(mContext.userManagerInternal).setDevicePolicyUserRestrictions(
-                eq(UserHandle.USER_SYSTEM),
-                MockUtils.checkUserRestrictions(UserManager.DISALLOW_OUTGOING_CALLS),
-                MockUtils.checkUserRestrictions()
-        );
-        reset(mContext.userManagerInternal);
-
-        DpmTestUtils.assertRestrictions(
-                DpmTestUtils.newRestrictions(UserManager.DISALLOW_OUTGOING_CALLS),
-                dpms.getDeviceOwnerAdminLocked().ensureUserRestrictions()
-        );
-        DpmTestUtils.assertRestrictions(
-                DpmTestUtils.newRestrictions(UserManager.DISALLOW_OUTGOING_CALLS),
-                dpm.getUserRestrictions(admin1)
-        );
-
-        dpm.clearUserRestriction(admin1, UserManager.DISALLOW_OUTGOING_CALLS);
-        verify(mContext.userManagerInternal).setDevicePolicyUserRestrictions(
-                eq(UserHandle.USER_SYSTEM),
-                MockUtils.checkUserRestrictions(),
-                MockUtils.checkUserRestrictions()
-        );
-        reset(mContext.userManagerInternal);
-
-        DpmTestUtils.assertRestrictions(
-                DpmTestUtils.newRestrictions(),
-                dpms.getDeviceOwnerAdminLocked().ensureUserRestrictions()
-        );
-        DpmTestUtils.assertRestrictions(
-                DpmTestUtils.newRestrictions(),
-                dpm.getUserRestrictions(admin1)
-        );
-
-        // DISALLOW_ADJUST_VOLUME and DISALLOW_UNMUTE_MICROPHONE are PO restrictions, but when
-        // DO sets them, the scope is global.
-        dpm.addUserRestriction(admin1, UserManager.DISALLOW_ADJUST_VOLUME);
-        reset(mContext.userManagerInternal);
-        dpm.addUserRestriction(admin1, UserManager.DISALLOW_UNMUTE_MICROPHONE);
-        verify(mContext.userManagerInternal).setDevicePolicyUserRestrictions(
-                eq(UserHandle.USER_SYSTEM),
-                MockUtils.checkUserRestrictions(),
-                MockUtils.checkUserRestrictions(UserManager.DISALLOW_ADJUST_VOLUME,
-                        UserManager.DISALLOW_UNMUTE_MICROPHONE)
-        );
-        reset(mContext.userManagerInternal);
-
-        dpm.clearUserRestriction(admin1, UserManager.DISALLOW_ADJUST_VOLUME);
-        dpm.clearUserRestriction(admin1, UserManager.DISALLOW_UNMUTE_MICROPHONE);
-
-
-        // More tests.
-        dpm.addUserRestriction(admin1, UserManager.DISALLOW_ADD_USER);
-        verify(mContext.userManagerInternal).setDevicePolicyUserRestrictions(
-                eq(UserHandle.USER_SYSTEM),
-                MockUtils.checkUserRestrictions(),
-                MockUtils.checkUserRestrictions(UserManager.DISALLOW_ADD_USER)
-        );
-        reset(mContext.userManagerInternal);
-
-        dpm.addUserRestriction(admin1, UserManager.DISALLOW_FUN);
-        verify(mContext.userManagerInternal).setDevicePolicyUserRestrictions(
-                eq(UserHandle.USER_SYSTEM),
-                MockUtils.checkUserRestrictions(),
-                MockUtils.checkUserRestrictions(UserManager.DISALLOW_FUN,
-                        UserManager.DISALLOW_ADD_USER)
-        );
-        reset(mContext.userManagerInternal);
-
-        dpm.setCameraDisabled(admin1, true);
-        verify(mContext.userManagerInternal).setDevicePolicyUserRestrictions(
-                eq(UserHandle.USER_SYSTEM),
-                // DISALLOW_CAMERA will be applied to both local and global.
-                MockUtils.checkUserRestrictions(UserManager.DISALLOW_CAMERA),
-                MockUtils.checkUserRestrictions(UserManager.DISALLOW_FUN,
-                        UserManager.DISALLOW_CAMERA, UserManager.DISALLOW_ADD_USER)
-        );
-        reset(mContext.userManagerInternal);
-
-        // Set up another DA and let it disable camera.  Now DISALLOW_CAMERA will only be applied
-        // locally.
-        dpm.setCameraDisabled(admin1, false);
-        reset(mContext.userManagerInternal);
-
-        setUpPackageManagerForAdmin(admin2, DpmMockContext.CALLER_SYSTEM_USER_UID);
-        dpm.setActiveAdmin(admin2, /* replace =*/ false, UserHandle.USER_SYSTEM);
-        dpm.setCameraDisabled(admin2, true);
-
-        verify(mContext.userManagerInternal).setDevicePolicyUserRestrictions(
-                eq(UserHandle.USER_SYSTEM),
-                // DISALLOW_CAMERA will be applied to both local and global.
-                MockUtils.checkUserRestrictions(UserManager.DISALLOW_CAMERA),
-                MockUtils.checkUserRestrictions(UserManager.DISALLOW_FUN,
-                        UserManager.DISALLOW_ADD_USER)
-        );
-        reset(mContext.userManagerInternal);
-        // TODO Make sure restrictions are written to the file.
-    }
-
-    public void testSetUserRestriction_asPo() {
-        setAsProfileOwner(admin1);
-
-        DpmTestUtils.assertRestrictions(
-                DpmTestUtils.newRestrictions(),
-                dpms.getProfileOwnerAdminLocked(DpmMockContext.CALLER_USER_HANDLE)
-                        .ensureUserRestrictions()
-        );
-
-        dpm.addUserRestriction(admin1, UserManager.DISALLOW_INSTALL_UNKNOWN_SOURCES);
-        verify(mContext.userManagerInternal).setDevicePolicyUserRestrictions(
-                eq(DpmMockContext.CALLER_USER_HANDLE),
-                MockUtils.checkUserRestrictions(UserManager.DISALLOW_INSTALL_UNKNOWN_SOURCES),
-                isNull(Bundle.class)
-        );
-        reset(mContext.userManagerInternal);
-
-        dpm.addUserRestriction(admin1, UserManager.DISALLOW_OUTGOING_CALLS);
-        verify(mContext.userManagerInternal).setDevicePolicyUserRestrictions(
-                eq(DpmMockContext.CALLER_USER_HANDLE),
-                MockUtils.checkUserRestrictions(UserManager.DISALLOW_INSTALL_UNKNOWN_SOURCES,
-                        UserManager.DISALLOW_OUTGOING_CALLS),
-                isNull(Bundle.class)
-        );
-        reset(mContext.userManagerInternal);
-
-        DpmTestUtils.assertRestrictions(
-                DpmTestUtils.newRestrictions(
-                        UserManager.DISALLOW_INSTALL_UNKNOWN_SOURCES,
-                        UserManager.DISALLOW_OUTGOING_CALLS
-                ),
-                dpms.getProfileOwnerAdminLocked(DpmMockContext.CALLER_USER_HANDLE)
-                        .ensureUserRestrictions()
-        );
-        DpmTestUtils.assertRestrictions(
-                DpmTestUtils.newRestrictions(
-                        UserManager.DISALLOW_INSTALL_UNKNOWN_SOURCES,
-                        UserManager.DISALLOW_OUTGOING_CALLS
-                ),
-                dpm.getUserRestrictions(admin1)
-        );
-
-        dpm.clearUserRestriction(admin1, UserManager.DISALLOW_INSTALL_UNKNOWN_SOURCES);
-        verify(mContext.userManagerInternal).setDevicePolicyUserRestrictions(
-                eq(DpmMockContext.CALLER_USER_HANDLE),
-                MockUtils.checkUserRestrictions(UserManager.DISALLOW_OUTGOING_CALLS),
-                isNull(Bundle.class)
-        );
-        reset(mContext.userManagerInternal);
-
-        DpmTestUtils.assertRestrictions(
-                DpmTestUtils.newRestrictions(
-                        UserManager.DISALLOW_OUTGOING_CALLS
-                ),
-                dpms.getProfileOwnerAdminLocked(DpmMockContext.CALLER_USER_HANDLE)
-                        .ensureUserRestrictions()
-        );
-        DpmTestUtils.assertRestrictions(
-                DpmTestUtils.newRestrictions(
-                        UserManager.DISALLOW_OUTGOING_CALLS
-                ),
-                dpm.getUserRestrictions(admin1)
-        );
-
-        dpm.clearUserRestriction(admin1, UserManager.DISALLOW_OUTGOING_CALLS);
-        verify(mContext.userManagerInternal).setDevicePolicyUserRestrictions(
-                eq(DpmMockContext.CALLER_USER_HANDLE),
-                MockUtils.checkUserRestrictions(),
-                isNull(Bundle.class)
-        );
-        reset(mContext.userManagerInternal);
-
-        DpmTestUtils.assertRestrictions(
-                DpmTestUtils.newRestrictions(),
-                dpms.getProfileOwnerAdminLocked(DpmMockContext.CALLER_USER_HANDLE)
-                        .ensureUserRestrictions()
-        );
-        DpmTestUtils.assertRestrictions(
-                DpmTestUtils.newRestrictions(),
-                dpm.getUserRestrictions(admin1)
-        );
-
-        // DISALLOW_ADJUST_VOLUME and DISALLOW_UNMUTE_MICROPHONE can be set by PO too, even
-        // though when DO sets them they'll be applied globally.
-        dpm.addUserRestriction(admin1, UserManager.DISALLOW_ADJUST_VOLUME);
-        reset(mContext.userManagerInternal);
-        dpm.addUserRestriction(admin1, UserManager.DISALLOW_UNMUTE_MICROPHONE);
-        verify(mContext.userManagerInternal).setDevicePolicyUserRestrictions(
-                eq(DpmMockContext.CALLER_USER_HANDLE),
-                MockUtils.checkUserRestrictions(UserManager.DISALLOW_ADJUST_VOLUME,
-                        UserManager.DISALLOW_UNMUTE_MICROPHONE),
-                isNull(Bundle.class)
-        );
-        reset(mContext.userManagerInternal);
-
-        dpm.setCameraDisabled(admin1, true);
-        verify(mContext.userManagerInternal).setDevicePolicyUserRestrictions(
-                eq(DpmMockContext.CALLER_USER_HANDLE),
-                MockUtils.checkUserRestrictions(UserManager.DISALLOW_CAMERA,
-                        UserManager.DISALLOW_ADJUST_VOLUME,
-                        UserManager.DISALLOW_UNMUTE_MICROPHONE),
-                isNull(Bundle.class)
-        );
-        reset(mContext.userManagerInternal);
-
-        // TODO Make sure restrictions are written to the file.
-    }
-
-    public void testGetMacAddress() throws Exception {
-        mContext.callerPermissions.add(permission.MANAGE_DEVICE_ADMINS);
-        mContext.callerPermissions.add(permission.MANAGE_PROFILE_AND_DEVICE_OWNERS);
-        mContext.callerPermissions.add(permission.INTERACT_ACROSS_USERS_FULL);
-
-        // In this test, change the caller user to "system".
-        mContext.binder.callingUid = DpmMockContext.CALLER_SYSTEM_USER_UID;
-
-        // Make sure admin1 is installed on system user.
-        setUpPackageManagerForAdmin(admin1, DpmMockContext.CALLER_SYSTEM_USER_UID);
-
-        // Test 1. Caller doesn't have DO or DA.
-        try {
-            dpm.getWifiMacAddress(admin1);
-            fail();
-        } catch (SecurityException e) {
-            MoreAsserts.assertContainsRegex("No active admin", e.getMessage());
-        }
-
-        // DO needs to be an DA.
-        dpm.setActiveAdmin(admin1, /* replace =*/ false);
-        assertTrue(dpm.isAdminActive(admin1));
-
-        // Test 2. Caller has DA, but not DO.
-        try {
-            dpm.getWifiMacAddress(admin1);
-            fail();
-        } catch (SecurityException e) {
-            MoreAsserts.assertContainsRegex("does not own the device", e.getMessage());
-        }
-
-        // Test 3. Caller has PO, but not DO.
-        assertTrue(dpm.setProfileOwner(admin1, null, UserHandle.USER_SYSTEM));
-        try {
-            dpm.getWifiMacAddress(admin1);
-            fail();
-        } catch (SecurityException e) {
-            MoreAsserts.assertContainsRegex("does not own the device", e.getMessage());
-        }
-
-        // Remove PO.
-        dpm.clearProfileOwner(admin1);
-        dpm.setActiveAdmin(admin1, false);
-        // Test 4, Caller is DO now.
-        assertTrue(dpm.setDeviceOwner(admin1, null, UserHandle.USER_SYSTEM));
-
-        // 4-1.  But no WifiInfo.
-        assertNull(dpm.getWifiMacAddress(admin1));
-
-        // 4-2.  Returns WifiInfo, but with the default MAC.
-        when(mContext.wifiManager.getConnectionInfo()).thenReturn(new WifiInfo());
-        assertNull(dpm.getWifiMacAddress(admin1));
-
-        // 4-3. With a real MAC address.
-        final WifiInfo wi = new WifiInfo();
-        wi.setMacAddress("11:22:33:44:55:66");
-        when(mContext.wifiManager.getConnectionInfo()).thenReturn(wi);
-        assertEquals("11:22:33:44:55:66", dpm.getWifiMacAddress(admin1));
-    }
-
-    public void testReboot() throws Exception {
-        mContext.callerPermissions.add(permission.MANAGE_DEVICE_ADMINS);
-        mContext.callerPermissions.add(permission.MANAGE_PROFILE_AND_DEVICE_OWNERS);
-
-        // In this test, change the caller user to "system".
-        mContext.binder.callingUid = DpmMockContext.CALLER_SYSTEM_USER_UID;
-
-        // Make sure admin1 is installed on system user.
-        setUpPackageManagerForAdmin(admin1, DpmMockContext.CALLER_SYSTEM_USER_UID);
-
-        // Set admin1 as DA.
-        dpm.setActiveAdmin(admin1, false);
-        assertTrue(dpm.isAdminActive(admin1));
-        try {
-            dpm.reboot(admin1);
-            fail("DA calls DPM.reboot(), did not throw expected SecurityException");
-        } catch (SecurityException expected) {
-            MoreAsserts.assertContainsRegex("does not own the device", expected.getMessage());
-        }
-
-        // Set admin1 as PO.
-        assertTrue(dpm.setProfileOwner(admin1, null, UserHandle.USER_SYSTEM));
-        try {
-            dpm.reboot(admin1);
-            fail("PO calls DPM.reboot(), did not throw expected SecurityException");
-        } catch (SecurityException expected) {
-            MoreAsserts.assertContainsRegex("does not own the device", expected.getMessage());
-        }
-
-        // Remove PO and add DO.
-        dpm.clearProfileOwner(admin1);
-        dpm.setActiveAdmin(admin1, false);
-        assertTrue(dpm.setDeviceOwner(admin1, null, UserHandle.USER_SYSTEM));
-
-        // admin1 is DO.
-        // Set current call state of device to ringing.
-        when(mContext.telephonyManager.getCallState())
-                .thenReturn(TelephonyManager.CALL_STATE_RINGING);
-        try {
-            dpm.reboot(admin1);
-            fail("DPM.reboot() called when receiveing a call, should thrown IllegalStateException");
-        } catch (IllegalStateException expected) {
-            MoreAsserts.assertContainsRegex("ongoing call on the device", expected.getMessage());
-        }
-
-        // Set current call state of device to dialing/active.
-        when(mContext.telephonyManager.getCallState())
-                .thenReturn(TelephonyManager.CALL_STATE_OFFHOOK);
-        try {
-            dpm.reboot(admin1);
-            fail("DPM.reboot() called when dialing, should thrown IllegalStateException");
-        } catch (IllegalStateException expected) {
-            MoreAsserts.assertContainsRegex("ongoing call on the device", expected.getMessage());
-        }
-
-        // Set current call state of device to idle.
-        when(mContext.telephonyManager.getCallState()).thenReturn(TelephonyManager.CALL_STATE_IDLE);
-        dpm.reboot(admin1);
-    }
-
-    public void testSetGetSupportText() {
-        mContext.callerPermissions.add(permission.MANAGE_DEVICE_ADMINS);
-        dpm.setActiveAdmin(admin1, true);
-        dpm.setActiveAdmin(admin2, true);
-        mContext.callerPermissions.remove(permission.MANAGE_DEVICE_ADMINS);
-
-        // Null default support messages.
-        {
-            assertNull(dpm.getLongSupportMessage(admin1));
-            assertNull(dpm.getShortSupportMessage(admin1));
-            mContext.binder.callingUid = DpmMockContext.SYSTEM_UID;
-            assertNull(dpm.getShortSupportMessageForUser(admin1,
-                    DpmMockContext.CALLER_USER_HANDLE));
-            assertNull(dpm.getLongSupportMessageForUser(admin1,
-                    DpmMockContext.CALLER_USER_HANDLE));
-            mMockContext.binder.callingUid = DpmMockContext.CALLER_UID;
-        }
-
-        // Only system can call the per user versions.
-        {
-            try {
-                dpm.getShortSupportMessageForUser(admin1,
-                        DpmMockContext.CALLER_USER_HANDLE);
-                fail("Only system should be able to call getXXXForUser versions");
-            } catch (SecurityException expected) {
-                MoreAsserts.assertContainsRegex("message for user", expected.getMessage());
-            }
-            try {
-                dpm.getLongSupportMessageForUser(admin1,
-                        DpmMockContext.CALLER_USER_HANDLE);
-                fail("Only system should be able to call getXXXForUser versions");
-            } catch (SecurityException expected) {
-                MoreAsserts.assertContainsRegex("message for user", expected.getMessage());
-            }
-        }
-
-        // Can't set message for admin in another uid.
-        {
-            mContext.binder.callingUid = DpmMockContext.CALLER_UID + 1;
-            try {
-                dpm.setShortSupportMessage(admin1, "Some text");
-                fail("Admins should only be able to change their own support text.");
-            } catch (SecurityException expected) {
-                MoreAsserts.assertContainsRegex("is not owned by uid", expected.getMessage());
-            }
-            mContext.binder.callingUid = DpmMockContext.CALLER_UID;
-        }
-
-        // Set/Get short returns what it sets and other admins text isn't changed.
-        {
-            final String supportText = "Some text to test with.";
-            dpm.setShortSupportMessage(admin1, supportText);
-            assertEquals(supportText, dpm.getShortSupportMessage(admin1));
-            assertNull(dpm.getLongSupportMessage(admin1));
-            assertNull(dpm.getShortSupportMessage(admin2));
-
-            mContext.binder.callingUid = DpmMockContext.SYSTEM_UID;
-            assertEquals(supportText, dpm.getShortSupportMessageForUser(admin1,
-                    DpmMockContext.CALLER_USER_HANDLE));
-            assertNull(dpm.getShortSupportMessageForUser(admin2,
-                    DpmMockContext.CALLER_USER_HANDLE));
-            assertNull(dpm.getLongSupportMessageForUser(admin1,
-                    DpmMockContext.CALLER_USER_HANDLE));
-            mMockContext.binder.callingUid = DpmMockContext.CALLER_UID;
-
-            dpm.setShortSupportMessage(admin1, null);
-            assertNull(dpm.getShortSupportMessage(admin1));
-        }
-
-        // Set/Get long returns what it sets and other admins text isn't changed.
-        {
-            final String supportText = "Some text to test with.\nWith more text.";
-            dpm.setLongSupportMessage(admin1, supportText);
-            assertEquals(supportText, dpm.getLongSupportMessage(admin1));
-            assertNull(dpm.getShortSupportMessage(admin1));
-            assertNull(dpm.getLongSupportMessage(admin2));
-
-            mContext.binder.callingUid = DpmMockContext.SYSTEM_UID;
-            assertEquals(supportText, dpm.getLongSupportMessageForUser(admin1,
-                    DpmMockContext.CALLER_USER_HANDLE));
-            assertNull(dpm.getLongSupportMessageForUser(admin2,
-                    DpmMockContext.CALLER_USER_HANDLE));
-            assertNull(dpm.getShortSupportMessageForUser(admin1,
-                    DpmMockContext.CALLER_USER_HANDLE));
-            mMockContext.binder.callingUid = DpmMockContext.CALLER_UID;
-
-            dpm.setLongSupportMessage(admin1, null);
-            assertNull(dpm.getLongSupportMessage(admin1));
-        }
-    }
-
-    /**
-     * Test for:
-     * {@link DevicePolicyManager#setAffiliationIds}
-     * {@link DevicePolicyManager#isAffiliatedUser}
-     */
-    public void testUserAffiliation() throws Exception {
-        mContext.callerPermissions.add(permission.MANAGE_DEVICE_ADMINS);
-        mContext.callerPermissions.add(permission.MANAGE_PROFILE_AND_DEVICE_OWNERS);
-        mContext.callerPermissions.add(permission.INTERACT_ACROSS_USERS_FULL);
-
-        // Check that the system user is unaffiliated.
-        mContext.binder.callingUid = DpmMockContext.CALLER_SYSTEM_USER_UID;
-        assertFalse(dpm.isAffiliatedUser());
-
-        // Set a device owner on the system user. Check that the system user becomes affiliated.
-        setUpPackageManagerForAdmin(admin1, DpmMockContext.CALLER_SYSTEM_USER_UID);
-        dpm.setActiveAdmin(admin1, /* replace =*/ false);
-        assertTrue(dpm.setDeviceOwner(admin1, "owner-name"));
-        assertTrue(dpm.isAffiliatedUser());
-
-        // Install a profile owner whose package name matches the device owner on a test user. Check
-        // that the test user is unaffiliated.
-        mContext.binder.callingUid = DpmMockContext.CALLER_UID;
-        setAsProfileOwner(admin2);
-        assertFalse(dpm.isAffiliatedUser());
-
-        // Have the profile owner specify a set of affiliation ids. Check that the test user remains
-        // unaffiliated.
-        final Set<String> userAffiliationIds = new ArraySet<>();
-        userAffiliationIds.add("red");
-        userAffiliationIds.add("green");
-        userAffiliationIds.add("blue");
-        dpm.setAffiliationIds(admin2, userAffiliationIds);
-        assertFalse(dpm.isAffiliatedUser());
-
-        // Have the device owner specify a set of affiliation ids that do not intersect with those
-        // specified by the profile owner. Check that the test user remains unaffiliated.
-        final Set<String> deviceAffiliationIds = new ArraySet<>();
-        deviceAffiliationIds.add("cyan");
-        deviceAffiliationIds.add("yellow");
-        deviceAffiliationIds.add("magenta");
-        mContext.binder.callingUid = DpmMockContext.CALLER_SYSTEM_USER_UID;
-        dpm.setAffiliationIds(admin1, deviceAffiliationIds);
-        mContext.binder.callingUid = DpmMockContext.CALLER_UID;
-        assertFalse(dpm.isAffiliatedUser());
-
-        // Have the profile owner specify a set of affiliation ids that intersect with those
-        // specified by the device owner. Check that the test user becomes affiliated.
-        userAffiliationIds.add("yellow");
-        dpm.setAffiliationIds(admin2, userAffiliationIds);
-        assertTrue(dpm.isAffiliatedUser());
-
-        // Change the profile owner to one whose package name does not match the device owner. Check
-        // that the test user is not affiliated anymore.
-        dpm.clearProfileOwner(admin2);
-        final ComponentName admin = new ComponentName("test", "test");
-
-        setUpPackageManagerForFakeAdmin(admin, DpmMockContext.CALLER_UID,
-                /* enabledSetting =*/ PackageManager.COMPONENT_ENABLED_STATE_ENABLED,
-                /* appTargetSdk = */ null, admin2);
-
-        dpm.setActiveAdmin(admin, /* refreshing =*/ true, DpmMockContext.CALLER_USER_HANDLE);
-        assertTrue(dpm.setProfileOwner(admin, "owner-name", DpmMockContext.CALLER_USER_HANDLE));
-        assertFalse(dpm.isAffiliatedUser());
-
-        // Check that the system user remains affiliated.
-        mContext.binder.callingUid = DpmMockContext.CALLER_SYSTEM_USER_UID;
-        assertTrue(dpm.isAffiliatedUser());
-    }
-
-    public void testGetUserProvisioningState_defaultResult() {
-        assertEquals(DevicePolicyManager.STATE_USER_UNMANAGED, dpm.getUserProvisioningState());
-    }
-
-    public void testSetUserProvisioningState_permission() throws Exception {
-        setupProfileOwner();
-        mContext.callerPermissions.add(permission.MANAGE_PROFILE_AND_DEVICE_OWNERS);
-
-        exerciseUserProvisioningTransitions(DpmMockContext.CALLER_USER_HANDLE,
-                DevicePolicyManager.STATE_USER_SETUP_FINALIZED);
-    }
-
-    public void testSetUserProvisioningState_unprivileged() throws Exception {
-        setupProfileOwner();
-        try {
-            dpm.setUserProvisioningState(DevicePolicyManager.STATE_USER_SETUP_FINALIZED,
-                    DpmMockContext.CALLER_USER_HANDLE);
-            fail("Expected SecurityException");
-        } catch (SecurityException expected) {
-        }
-    }
-
-    public void testSetUserProvisioningState_noManagement() {
-        mContext.callerPermissions.add(permission.MANAGE_PROFILE_AND_DEVICE_OWNERS);
-        try {
-            dpm.setUserProvisioningState(DevicePolicyManager.STATE_USER_SETUP_FINALIZED,
-                    DpmMockContext.CALLER_USER_HANDLE);
-            fail("IllegalStateException expected");
-        } catch (IllegalStateException e) {
-            MoreAsserts.assertContainsRegex("change provisioning state unless a .* owner is set",
-                    e.getMessage());
-        }
-        assertEquals(DevicePolicyManager.STATE_USER_UNMANAGED, dpm.getUserProvisioningState());
-    }
-
-    public void testSetUserProvisioningState_deviceOwnerFromSetupWizard() throws Exception {
-        mContext.binder.callingUid = DpmMockContext.CALLER_SYSTEM_USER_UID;
-        setupDeviceOwner();
-        mContext.callerPermissions.add(permission.MANAGE_PROFILE_AND_DEVICE_OWNERS);
-
-        exerciseUserProvisioningTransitions(UserHandle.USER_SYSTEM,
-                DevicePolicyManager.STATE_USER_SETUP_COMPLETE,
-                DevicePolicyManager.STATE_USER_SETUP_FINALIZED);
-    }
-
-    public void testSetUserProvisioningState_deviceOwnerFromSetupWizardAlternative()
-            throws Exception {
-        mContext.binder.callingUid = DpmMockContext.CALLER_SYSTEM_USER_UID;
-        setupDeviceOwner();
-        mContext.callerPermissions.add(permission.MANAGE_PROFILE_AND_DEVICE_OWNERS);
-
-        exerciseUserProvisioningTransitions(UserHandle.USER_SYSTEM,
-                DevicePolicyManager.STATE_USER_SETUP_INCOMPLETE,
-                DevicePolicyManager.STATE_USER_SETUP_FINALIZED);
-    }
-
-    public void testSetUserProvisioningState_deviceOwnerWithoutSetupWizard() throws Exception {
-        mContext.binder.callingUid = DpmMockContext.CALLER_SYSTEM_USER_UID;
-        setupDeviceOwner();
-        mContext.callerPermissions.add(permission.MANAGE_PROFILE_AND_DEVICE_OWNERS);
-
-        exerciseUserProvisioningTransitions(UserHandle.USER_SYSTEM,
-                DevicePolicyManager.STATE_USER_SETUP_FINALIZED);
-    }
-
-    public void testSetUserProvisioningState_managedProfileFromSetupWizard_primaryUser()
-            throws Exception {
-        setupProfileOwner();
-        mContext.callerPermissions.add(permission.MANAGE_PROFILE_AND_DEVICE_OWNERS);
-
-        exerciseUserProvisioningTransitions(DpmMockContext.CALLER_USER_HANDLE,
-                DevicePolicyManager.STATE_USER_PROFILE_COMPLETE,
-                DevicePolicyManager.STATE_USER_UNMANAGED);
-    }
-
-    public void testSetUserProvisioningState_managedProfileFromSetupWizard_managedProfile()
-            throws Exception {
-        setupProfileOwner();
-        mContext.callerPermissions.add(permission.MANAGE_PROFILE_AND_DEVICE_OWNERS);
-
-        exerciseUserProvisioningTransitions(DpmMockContext.CALLER_USER_HANDLE,
-                DevicePolicyManager.STATE_USER_SETUP_COMPLETE,
-                DevicePolicyManager.STATE_USER_SETUP_FINALIZED);
-    }
-
-    public void testSetUserProvisioningState_managedProfileWithoutSetupWizard() throws Exception {
-        setupProfileOwner();
-        mContext.callerPermissions.add(permission.MANAGE_PROFILE_AND_DEVICE_OWNERS);
-
-        exerciseUserProvisioningTransitions(DpmMockContext.CALLER_USER_HANDLE,
-                DevicePolicyManager.STATE_USER_SETUP_FINALIZED);
-    }
-
-    public void testSetUserProvisioningState_illegalTransitionOutOfFinalized1() throws Exception {
-        setupProfileOwner();
-        mContext.callerPermissions.add(permission.MANAGE_PROFILE_AND_DEVICE_OWNERS);
-
-        try {
-            exerciseUserProvisioningTransitions(DpmMockContext.CALLER_USER_HANDLE,
-                    DevicePolicyManager.STATE_USER_SETUP_FINALIZED,
-                    DevicePolicyManager.STATE_USER_UNMANAGED);
-            fail("Expected IllegalStateException");
-        } catch (IllegalStateException e) {
-            MoreAsserts.assertContainsRegex("Cannot move to user provisioning state",
-                    e.getMessage());
-        }
-    }
-
-    public void testSetUserProvisioningState_illegalTransitionToAnotherInProgressState()
-            throws Exception {
-        setupProfileOwner();
-        mContext.callerPermissions.add(permission.MANAGE_PROFILE_AND_DEVICE_OWNERS);
-
-        try {
-            exerciseUserProvisioningTransitions(DpmMockContext.CALLER_USER_HANDLE,
-                    DevicePolicyManager.STATE_USER_SETUP_INCOMPLETE,
-                    DevicePolicyManager.STATE_USER_SETUP_COMPLETE);
-            fail("Expected IllegalStateException");
-        } catch (IllegalStateException e) {
-            MoreAsserts.assertContainsRegex("Cannot move to user provisioning state",
-                    e.getMessage());
-        }
-    }
-
-    private void exerciseUserProvisioningTransitions(int userId, int... states) {
-        assertEquals(DevicePolicyManager.STATE_USER_UNMANAGED, dpm.getUserProvisioningState());
-        for (int state : states) {
-            dpm.setUserProvisioningState(state, userId);
-            assertEquals(state, dpm.getUserProvisioningState());
-        }
-    }
-
-    private void setupProfileOwner() throws Exception {
-        mContext.callerPermissions.addAll(OWNER_SETUP_PERMISSIONS);
-
-        setUpPackageManagerForAdmin(admin1, DpmMockContext.CALLER_UID);
-        dpm.setActiveAdmin(admin1, false);
-        assertTrue(dpm.setProfileOwner(admin1, null, DpmMockContext.CALLER_USER_HANDLE));
-
-        mContext.callerPermissions.removeAll(OWNER_SETUP_PERMISSIONS);
-    }
-
-    private void setupDeviceOwner() throws Exception {
-        mContext.callerPermissions.addAll(OWNER_SETUP_PERMISSIONS);
-
-        setUpPackageManagerForAdmin(admin1, DpmMockContext.CALLER_SYSTEM_USER_UID);
-        dpm.setActiveAdmin(admin1, false);
-        assertTrue(dpm.setDeviceOwner(admin1, null, UserHandle.USER_SYSTEM));
-
-        mContext.callerPermissions.removeAll(OWNER_SETUP_PERMISSIONS);
-    }
-
-    public void testSetMaximumTimeToLock() {
-        mContext.callerPermissions.add(android.Manifest.permission.MANAGE_DEVICE_ADMINS);
-
-        dpm.setActiveAdmin(admin1, /* replace =*/ false);
-        dpm.setActiveAdmin(admin2, /* replace =*/ false);
-
-        reset(mMockContext.powerManagerInternal);
-        reset(mMockContext.settings);
-
-        dpm.setMaximumTimeToLock(admin1, 0);
-        verifyScreenTimeoutCall(null, false);
-        reset(mMockContext.powerManagerInternal);
-        reset(mMockContext.settings);
-
-        dpm.setMaximumTimeToLock(admin1, 1);
-        verifyScreenTimeoutCall(1, true);
-        reset(mMockContext.powerManagerInternal);
-        reset(mMockContext.settings);
-
-        dpm.setMaximumTimeToLock(admin2, 10);
-        verifyScreenTimeoutCall(null, false);
-        reset(mMockContext.powerManagerInternal);
-        reset(mMockContext.settings);
-
-        dpm.setMaximumTimeToLock(admin1, 5);
-        verifyScreenTimeoutCall(5, true);
-        reset(mMockContext.powerManagerInternal);
-        reset(mMockContext.settings);
-
-        dpm.setMaximumTimeToLock(admin2, 4);
-        verifyScreenTimeoutCall(4, true);
-        reset(mMockContext.powerManagerInternal);
-        reset(mMockContext.settings);
-
-        dpm.setMaximumTimeToLock(admin1, 0);
-        reset(mMockContext.powerManagerInternal);
-        reset(mMockContext.settings);
-
-        dpm.setMaximumTimeToLock(admin2, Integer.MAX_VALUE);
-        verifyScreenTimeoutCall(Integer.MAX_VALUE, true);
-        reset(mMockContext.powerManagerInternal);
-        reset(mMockContext.settings);
-
-        dpm.setMaximumTimeToLock(admin2, Integer.MAX_VALUE + 1);
-        verifyScreenTimeoutCall(Integer.MAX_VALUE, true);
-        reset(mMockContext.powerManagerInternal);
-        reset(mMockContext.settings);
-
-        dpm.setMaximumTimeToLock(admin2, 10);
-        verifyScreenTimeoutCall(10, true);
-        reset(mMockContext.powerManagerInternal);
-        reset(mMockContext.settings);
-
-        // There's no restriction; shold be set to MAX.
-        dpm.setMaximumTimeToLock(admin2, 0);
-        verifyScreenTimeoutCall(Integer.MAX_VALUE, false);
-    }
-
-    public void testSetRequiredStrongAuthTimeout_DeviceOwner() throws Exception {
-        mContext.binder.callingUid = DpmMockContext.CALLER_SYSTEM_USER_UID;
-        setupDeviceOwner();
-        mContext.callerPermissions.add(permission.MANAGE_PROFILE_AND_DEVICE_OWNERS);
-
-        final long MINIMUM_STRONG_AUTH_TIMEOUT_MS = 1 * 60 * 60 * 1000; // 1h
-        final long ONE_MINUTE = 60 * 1000;
-
-        // aggregation should be the default if unset by any admin
-        assertEquals(dpm.getRequiredStrongAuthTimeout(null),
-                DevicePolicyManager.DEFAULT_STRONG_AUTH_TIMEOUT_MS);
-
-        // admin not participating by default
-        assertEquals(dpm.getRequiredStrongAuthTimeout(admin1), 0);
-
-        //clamping from the top
-        dpm.setRequiredStrongAuthTimeout(admin1,
-                DevicePolicyManager.DEFAULT_STRONG_AUTH_TIMEOUT_MS + ONE_MINUTE);
-        assertEquals(dpm.getRequiredStrongAuthTimeout(admin1),
-                DevicePolicyManager.DEFAULT_STRONG_AUTH_TIMEOUT_MS);
-        assertEquals(dpm.getRequiredStrongAuthTimeout(null),
-                DevicePolicyManager.DEFAULT_STRONG_AUTH_TIMEOUT_MS);
-
-        // 0 means default
-        dpm.setRequiredStrongAuthTimeout(admin1, 0);
-        assertEquals(dpm.getRequiredStrongAuthTimeout(admin1), 0);
-        assertEquals(dpm.getRequiredStrongAuthTimeout(null),
-                DevicePolicyManager.DEFAULT_STRONG_AUTH_TIMEOUT_MS);
-
-        // clamping from the bottom
-        dpm.setRequiredStrongAuthTimeout(admin1, MINIMUM_STRONG_AUTH_TIMEOUT_MS - ONE_MINUTE);
-        assertEquals(dpm.getRequiredStrongAuthTimeout(admin1), MINIMUM_STRONG_AUTH_TIMEOUT_MS);
-        assertEquals(dpm.getRequiredStrongAuthTimeout(null), MINIMUM_STRONG_AUTH_TIMEOUT_MS);
-
-        // value within range
-        dpm.setRequiredStrongAuthTimeout(admin1, MINIMUM_STRONG_AUTH_TIMEOUT_MS + ONE_MINUTE);
-        assertEquals(dpm.getRequiredStrongAuthTimeout(admin1), MINIMUM_STRONG_AUTH_TIMEOUT_MS
-                + ONE_MINUTE);
-        assertEquals(dpm.getRequiredStrongAuthTimeout(null), MINIMUM_STRONG_AUTH_TIMEOUT_MS
-                + ONE_MINUTE);
-
-        // reset to default
-        dpm.setRequiredStrongAuthTimeout(admin1, 0);
-        assertEquals(dpm.getRequiredStrongAuthTimeout(admin1), 0);
-        assertEquals(dpm.getRequiredStrongAuthTimeout(null),
-                DevicePolicyManager.DEFAULT_STRONG_AUTH_TIMEOUT_MS);
-
-        // negative value
-        try {
-            dpm.setRequiredStrongAuthTimeout(admin1, -ONE_MINUTE);
-            fail("Didn't throw IllegalArgumentException");
-        } catch (IllegalArgumentException iae) {
-        }
-    }
-
-    private void verifyScreenTimeoutCall(Integer expectedTimeout,
-            boolean shouldStayOnWhilePluggedInBeCleared) {
-        if (expectedTimeout == null) {
-            verify(mMockContext.powerManagerInternal, times(0))
-                    .setMaximumScreenOffTimeoutFromDeviceAdmin(anyInt());
-        } else {
-            verify(mMockContext.powerManagerInternal, times(1))
-                    .setMaximumScreenOffTimeoutFromDeviceAdmin(eq(expectedTimeout));
-        }
-        // TODO Verify calls to settingsGlobalPutInt.  Tried but somehow mockito threw
-        // UnfinishedVerificationException.
-    }
-
-    public void testIsProvisioningAllowed_DeviceAdminFeatureOff() throws Exception {
-        when(mContext.packageManager.hasSystemFeature(PackageManager.FEATURE_DEVICE_ADMIN))
-                .thenReturn(false);
-        when(mContext.ipackageManager.hasSystemFeature(PackageManager.FEATURE_MANAGED_USERS, 0))
-                .thenReturn(false);
-        initializeDpms();
-        when(mContext.userManagerForMock.isSplitSystemUser()).thenReturn(false);
-        when(mContext.userManager.canAddMoreManagedProfiles(UserHandle.USER_SYSTEM, true))
-                .thenReturn(true);
-        setUserSetupCompleteForUser(false, UserHandle.USER_SYSTEM);
-
-        mContext.binder.callingUid = DpmMockContext.CALLER_SYSTEM_USER_UID;
-
-        assertProvisioningAllowed(DevicePolicyManager.ACTION_PROVISION_MANAGED_DEVICE, false);
-        assertProvisioningAllowed(DevicePolicyManager.ACTION_PROVISION_MANAGED_PROFILE, false);
-        assertProvisioningAllowed(DevicePolicyManager.ACTION_PROVISION_MANAGED_SHAREABLE_DEVICE,
-                false);
-        assertProvisioningAllowed(DevicePolicyManager.ACTION_PROVISION_MANAGED_USER, false);
-    }
-
-    public void testIsProvisioningAllowed_ManagedProfileFeatureOff() throws Exception {
-        when(mContext.ipackageManager.hasSystemFeature(PackageManager.FEATURE_MANAGED_USERS, 0))
-                .thenReturn(false);
-        initializeDpms();
-        when(mContext.userManagerForMock.isSplitSystemUser()).thenReturn(false);
-        when(mContext.userManager.canAddMoreManagedProfiles(UserHandle.USER_SYSTEM, true))
-                .thenReturn(true);
-        setUserSetupCompleteForUser(false, UserHandle.USER_SYSTEM);
-
-        mContext.binder.callingUid = DpmMockContext.CALLER_SYSTEM_USER_UID;
-
-        assertProvisioningAllowed(DevicePolicyManager.ACTION_PROVISION_MANAGED_DEVICE, true);
-        assertProvisioningAllowed(DevicePolicyManager.ACTION_PROVISION_MANAGED_PROFILE, false);
-        assertProvisioningAllowed(DevicePolicyManager.ACTION_PROVISION_MANAGED_SHAREABLE_DEVICE,
-                false);
-        assertProvisioningAllowed(DevicePolicyManager.ACTION_PROVISION_MANAGED_USER, false);
-
-        // Test again when split user is on
-        when(mContext.userManagerForMock.isSplitSystemUser()).thenReturn(true);
-        assertProvisioningAllowed(DevicePolicyManager.ACTION_PROVISION_MANAGED_DEVICE, true);
-        assertProvisioningAllowed(DevicePolicyManager.ACTION_PROVISION_MANAGED_PROFILE, false);
-        assertProvisioningAllowed(DevicePolicyManager.ACTION_PROVISION_MANAGED_SHAREABLE_DEVICE,
-                true);
-        assertProvisioningAllowed(DevicePolicyManager.ACTION_PROVISION_MANAGED_USER, false);
-    }
-
-    public void testIsProvisioningAllowed_nonSplitUser_firstBoot_primaryUser() throws Exception {
-        when(mContext.ipackageManager.hasSystemFeature(PackageManager.FEATURE_MANAGED_USERS, 0))
-                .thenReturn(true);
-        when(mContext.userManagerForMock.isSplitSystemUser()).thenReturn(false);
-        when(mContext.userManager.canAddMoreManagedProfiles(UserHandle.USER_SYSTEM, true))
-                .thenReturn(true);
-        setUserSetupCompleteForUser(false, UserHandle.USER_SYSTEM);
-
-        mContext.binder.callingUid = DpmMockContext.CALLER_SYSTEM_USER_UID;
-
-        assertProvisioningAllowed(DevicePolicyManager.ACTION_PROVISION_MANAGED_DEVICE, true);
-        assertProvisioningAllowed(DevicePolicyManager.ACTION_PROVISION_MANAGED_PROFILE, true);
-        assertProvisioningAllowed(DevicePolicyManager.ACTION_PROVISION_MANAGED_SHAREABLE_DEVICE,
-                false /* because of non-split user */);
-        assertProvisioningAllowed(DevicePolicyManager.ACTION_PROVISION_MANAGED_USER,
-                false /* because of non-split user */);
-    }
-
-    public void testIsProvisioningAllowed_nonSplitUser_afterDeviceSetup_primaryUser()
-            throws Exception {
-        when(mContext.ipackageManager.hasSystemFeature(PackageManager.FEATURE_MANAGED_USERS, 0))
-                .thenReturn(true);
-        when(mContext.userManagerForMock.isSplitSystemUser()).thenReturn(false);
-        when(mContext.userManager.canAddMoreManagedProfiles(UserHandle.USER_SYSTEM, true))
-                .thenReturn(true);
-        setUserSetupCompleteForUser(true, UserHandle.USER_SYSTEM);
-
-        mContext.binder.callingUid = DpmMockContext.CALLER_SYSTEM_USER_UID;
-
-        assertProvisioningAllowed(DevicePolicyManager.ACTION_PROVISION_MANAGED_DEVICE,
-                false/* because of completed device setup */);
-        assertProvisioningAllowed(DevicePolicyManager.ACTION_PROVISION_MANAGED_PROFILE, true);
-        assertProvisioningAllowed(DevicePolicyManager.ACTION_PROVISION_MANAGED_SHAREABLE_DEVICE,
-                false/* because of non-split user */);
-        assertProvisioningAllowed(DevicePolicyManager.ACTION_PROVISION_MANAGED_USER,
-                false/* because of non-split user */);
-    }
-
-    public void testIsProvisioningAllowed_splitUser_firstBoot_systemUser() throws Exception {
-        when(mContext.ipackageManager.hasSystemFeature(PackageManager.FEATURE_MANAGED_USERS, 0))
-                .thenReturn(true);
-        when(mContext.userManagerForMock.isSplitSystemUser()).thenReturn(true);
-        when(mContext.userManager.canAddMoreManagedProfiles(UserHandle.USER_SYSTEM, true))
-                .thenReturn(false);
-        setUserSetupCompleteForUser(false, UserHandle.USER_SYSTEM);
-
-        mContext.binder.callingUid = DpmMockContext.CALLER_SYSTEM_USER_UID;
-
-        assertProvisioningAllowed(DevicePolicyManager.ACTION_PROVISION_MANAGED_DEVICE, true);
-        assertProvisioningAllowed(DevicePolicyManager.ACTION_PROVISION_MANAGED_PROFILE,
-                false /* because canAddMoreManagedProfiles returns false */);
-        assertProvisioningAllowed(DevicePolicyManager.ACTION_PROVISION_MANAGED_SHAREABLE_DEVICE,
-                true);
-        assertProvisioningAllowed(DevicePolicyManager.ACTION_PROVISION_MANAGED_USER,
-                false/* because calling uid is system user */);
-
-    }
-
-    public void testIsProvisioningAllowed_splitUser_afterDeviceSetup_systemUser() throws Exception {
-        when(mContext.ipackageManager.hasSystemFeature(PackageManager.FEATURE_MANAGED_USERS, 0))
-                .thenReturn(true);
-        when(mContext.userManagerForMock.isSplitSystemUser()).thenReturn(true);
-        when(mContext.userManager.canAddMoreManagedProfiles(UserHandle.USER_SYSTEM, true))
-                .thenReturn(false);
-        setUserSetupCompleteForUser(true, UserHandle.USER_SYSTEM);
-
-        mContext.binder.callingUid = DpmMockContext.CALLER_SYSTEM_USER_UID;
-
-        assertProvisioningAllowed(DevicePolicyManager.ACTION_PROVISION_MANAGED_DEVICE,
-                true/* it's undefined behavior. Can be changed into false in the future */);
-        assertProvisioningAllowed(DevicePolicyManager.ACTION_PROVISION_MANAGED_PROFILE,
-                false /* because canAddMoreManagedProfiles returns false */);
-        assertProvisioningAllowed(DevicePolicyManager.ACTION_PROVISION_MANAGED_SHAREABLE_DEVICE,
-                true/* it's undefined behavior. Can be changed into false in the future */);
-        assertProvisioningAllowed(DevicePolicyManager.ACTION_PROVISION_MANAGED_USER,
-                false/* because calling uid is system user */);
-    }
-
-    public void testIsProvisioningAllowed_splitUser_firstBoot_primaryUser() throws Exception {
-        when(mContext.ipackageManager.hasSystemFeature(PackageManager.FEATURE_MANAGED_USERS, 0))
-                .thenReturn(true);
-        when(mContext.userManagerForMock.isSplitSystemUser()).thenReturn(true);
-        when(mContext.userManager.canAddMoreManagedProfiles(DpmMockContext.CALLER_USER_HANDLE,
-                true)).thenReturn(true);
-        setUserSetupCompleteForUser(false, DpmMockContext.CALLER_USER_HANDLE);
-
-        mContext.binder.callingUid = DpmMockContext.CALLER_UID;
-
-        assertProvisioningAllowed(DevicePolicyManager.ACTION_PROVISION_MANAGED_DEVICE, true);
-        assertProvisioningAllowed(DevicePolicyManager.ACTION_PROVISION_MANAGED_PROFILE, true);
-        assertProvisioningAllowed(DevicePolicyManager.ACTION_PROVISION_MANAGED_SHAREABLE_DEVICE,
-                true);
-        assertProvisioningAllowed(DevicePolicyManager.ACTION_PROVISION_MANAGED_USER, true);
-
-    }
-
-    public void testIsProvisioningAllowed_splitUser_afterDeviceSetup_primaryUser()
-            throws Exception {
-        when(mContext.ipackageManager.hasSystemFeature(PackageManager.FEATURE_MANAGED_USERS, 0))
-                .thenReturn(true);
-        when(mContext.userManagerForMock.isSplitSystemUser()).thenReturn(true);
-        when(mContext.userManager.canAddMoreManagedProfiles(DpmMockContext.CALLER_USER_HANDLE,
-                true)).thenReturn(true);
-        setUserSetupCompleteForUser(true, DpmMockContext.CALLER_USER_HANDLE);
-
-        mContext.binder.callingUid = DpmMockContext.CALLER_UID;
-
-        assertProvisioningAllowed(DevicePolicyManager.ACTION_PROVISION_MANAGED_DEVICE,
-                true/* it's undefined behavior. Can be changed into false in the future */);
-        assertProvisioningAllowed(DevicePolicyManager.ACTION_PROVISION_MANAGED_PROFILE, true);
-        assertProvisioningAllowed(DevicePolicyManager.ACTION_PROVISION_MANAGED_SHAREABLE_DEVICE,
-                true/* it's undefined behavior. Can be changed into false in the future */);
-        assertProvisioningAllowed(DevicePolicyManager.ACTION_PROVISION_MANAGED_USER,
-                false/* because user setup completed */);
-    }
-
-    public void testIsProvisioningAllowed_provisionManagedProfileWithDeviceOwner_systemUser()
-            throws Exception {
-        setDeviceOwner();
-
-        when(mContext.ipackageManager.hasSystemFeature(PackageManager.FEATURE_MANAGED_USERS, 0))
-                .thenReturn(true);
-        when(mContext.userManagerForMock.isSplitSystemUser()).thenReturn(true);
-        when(mContext.userManager.canAddMoreManagedProfiles(UserHandle.USER_SYSTEM, true))
-                .thenReturn(false);
-        setUserSetupCompleteForUser(true, UserHandle.USER_SYSTEM);
-
-        mContext.binder.callingUid = DpmMockContext.CALLER_SYSTEM_USER_UID;
-
-        assertProvisioningAllowed(DevicePolicyManager.ACTION_PROVISION_MANAGED_PROFILE,
-                false /* can't provision managed profile on system user */);
-    }
-
-    public void testIsProvisioningAllowed_provisionManagedProfileWithDeviceOwner_primaryUser()
-            throws Exception {
-        setDeviceOwner();
-
-        when(mContext.ipackageManager.hasSystemFeature(PackageManager.FEATURE_MANAGED_USERS, 0))
-                .thenReturn(true);
-        when(mContext.userManagerForMock.isSplitSystemUser()).thenReturn(true);
-        when(mContext.userManager.canAddMoreManagedProfiles(DpmMockContext.CALLER_USER_HANDLE,
-                true)).thenReturn(true);
-        setUserSetupCompleteForUser(false, DpmMockContext.CALLER_USER_HANDLE);
-
-        mContext.binder.callingUid = DpmMockContext.CALLER_UID;
-
-        assertProvisioningAllowed(DevicePolicyManager.ACTION_PROVISION_MANAGED_PROFILE, true);
-    }
-
-    private void setUserSetupCompleteForUser(boolean isUserSetupComplete, int userhandle) {
-        when(mContext.settings.settingsSecureGetIntForUser(Settings.Secure.USER_SETUP_COMPLETE, 0,
-                userhandle)).thenReturn(isUserSetupComplete ? 1 : 0);
-        dpms.notifyChangeToContentObserver(
-                Settings.Secure.getUriFor(Settings.Secure.USER_SETUP_COMPLETE), userhandle);
-    }
-
-    private void assertProvisioningAllowed(String action, boolean expected) {
-        assertEquals("isProvisioningAllowed(" + action + ") returning unexpected result", expected,
-                dpm.isProvisioningAllowed(action));
-    }
-}
diff --git a/services/tests/servicestests/src/com/android/server/devicepolicy/DevicePolicyManagerTestable.java b/services/tests/servicestests/src/com/android/server/devicepolicy/DevicePolicyManagerTestable.java
deleted file mode 100644
index 3da61d69c74..00000000000
--- a/services/tests/servicestests/src/com/android/server/devicepolicy/DevicePolicyManagerTestable.java
+++ /dev/null
@@ -1,37 +0,0 @@
-/*
- * Copyright (C) 2015 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.android.server.devicepolicy;
-
-import android.app.admin.DevicePolicyManager;
-import android.os.UserHandle;
-
-/**
- * Overrides {@link #DevicePolicyManager} for dependency injection.
- */
-public class DevicePolicyManagerTestable extends DevicePolicyManager {
-    public final DevicePolicyManagerServiceTestable dpms;
-
-    public DevicePolicyManagerTestable(DpmMockContext context,
-            DevicePolicyManagerServiceTestable dpms) {
-        super(context, dpms, /* parentInstance = */ false);
-        this.dpms = dpms;
-    }
-
-    @Override
-    public int myUserId() {
-        return UserHandle.getUserId(dpms.context.binder.callingUid);
-    }
-}
diff --git a/services/tests/servicestests/src/com/android/server/devicepolicy/DpmMockContext.java b/services/tests/servicestests/src/com/android/server/devicepolicy/DpmMockContext.java
deleted file mode 100644
index 956d83a2caf..00000000000
--- a/services/tests/servicestests/src/com/android/server/devicepolicy/DpmMockContext.java
+++ /dev/null
@@ -1,619 +0,0 @@
-/*
- * Copyright (C) 2015 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.android.server.devicepolicy;
-
-import static org.mockito.Matchers.anyBoolean;
-import static org.mockito.Matchers.anyInt;
-import static org.mockito.Matchers.eq;
-import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.spy;
-import static org.mockito.Mockito.when;
-
-import android.accounts.Account;
-import android.accounts.AccountManager;
-import android.app.IActivityManager;
-import android.app.NotificationManager;
-import android.app.backup.IBackupManager;
-import android.content.BroadcastReceiver;
-import android.content.ContentResolver;
-import android.content.Context;
-import android.content.Intent;
-import android.content.IntentFilter;
-import android.content.pm.IPackageManager;
-import android.content.pm.PackageManager;
-import android.content.pm.PackageManagerInternal;
-import android.content.pm.UserInfo;
-import android.media.IAudioService;
-import android.net.wifi.WifiManager;
-import android.os.Bundle;
-import android.os.Handler;
-import android.os.PowerManager.WakeLock;
-import android.os.PowerManagerInternal;
-import android.os.UserHandle;
-import android.os.UserManager;
-import android.os.UserManagerInternal;
-import android.telephony.TelephonyManager;
-import android.test.mock.MockContentResolver;
-import android.test.mock.MockContext;
-import android.view.IWindowManager;
-
-import com.android.internal.widget.LockPatternUtils;
-
-import org.junit.Assert;
-import org.mockito.invocation.InvocationOnMock;
-import org.mockito.stubbing.Answer;
-
-import java.io.File;
-import java.util.ArrayList;
-import java.util.List;
-
-/**
- * Context used throughout DPMS tests.
- */
-public class DpmMockContext extends MockContext {
-    /**
-     * User-id of a non-system user we use throughout unit tests.
-     */
-    public static final int CALLER_USER_HANDLE = 20;
-
-    /**
-     * UID corresponding to {@link #CALLER_USER_HANDLE}.
-     */
-    public static final int CALLER_UID = UserHandle.getUid(CALLER_USER_HANDLE, 20123);
-
-    /**
-     * UID used when a caller is on the system user.
-     */
-    public static final int CALLER_SYSTEM_USER_UID = 20321;
-
-    /**
-     * PID of the caller.
-     */
-    public static final int CALLER_PID = 22222;
-
-    /**
-     * UID of the system server.
-     */
-    public static final int SYSTEM_UID = android.os.Process.SYSTEM_UID;
-
-    /**
-     * PID of the system server.
-     */
-    public static final int SYSTEM_PID = 11111;
-
-    public static class MockBinder {
-        public int callingUid = CALLER_UID;
-        public int callingPid = CALLER_PID;
-
-        public long clearCallingIdentity() {
-            final long token = (((long) callingUid) << 32) | (callingPid);
-            callingUid = SYSTEM_UID;
-            callingPid = SYSTEM_PID;
-            return token;
-        }
-
-        public void restoreCallingIdentity(long token) {
-            callingUid = (int) (token >> 32);
-            callingPid = (int) token;
-        }
-
-        public int getCallingUid() {
-            return callingUid;
-        }
-
-        public int getCallingPid() {
-            return callingPid;
-        }
-
-        public UserHandle getCallingUserHandle() {
-            return new UserHandle(UserHandle.getUserId(getCallingUid()));
-        }
-
-        public boolean isCallerUidMyUid() {
-            return callingUid == SYSTEM_UID;
-        }
-    }
-
-    public static class EnvironmentForMock {
-        public File getUserSystemDirectory(int userId) {
-            return null;
-        }
-    }
-
-    public static class PowerManagerForMock {
-        public WakeLock newWakeLock(int levelAndFlags, String tag) {
-            return null;
-        }
-
-        public void goToSleep(long time, int reason, int flags) {
-        }
-
-        public void reboot(String reason) {
-        }
-    }
-
-    public static class SystemPropertiesForMock {
-        public boolean getBoolean(String key, boolean def) {
-            return false;
-        }
-
-        public long getLong(String key, long def) {
-            return 0;
-        }
-
-        public String get(String key, String def) {
-            return null;
-        }
-
-        public String get(String key) {
-            return null;
-        }
-
-        public void set(String key, String value) {
-        }
-    }
-
-    public static class UserManagerForMock {
-        public boolean isSplitSystemUser() {
-            return false;
-        }
-    }
-
-    public static class SettingsForMock {
-        public int settingsSecureGetIntForUser(String name, int def, int userHandle) {
-            return 0;
-        }
-
-        public void settingsSecurePutIntForUser(String name, int value, int userHandle) {
-        }
-
-        public void settingsSecurePutStringForUser(String name, String value, int userHandle) {
-        }
-
-        public void settingsGlobalPutStringForUser(String name, String value, int userHandle) {
-        }
-
-        public void settingsSecurePutInt(String name, int value) {
-        }
-
-        public void settingsGlobalPutInt(String name, int value) {
-        }
-
-        public void settingsSecurePutString(String name, String value) {
-        }
-
-        public void settingsGlobalPutString(String name, String value) {
-        }
-
-        public int settingsGlobalGetInt(String name, int value) {
-            return 0;
-        }
-
-        public void securityLogSetLoggingEnabledProperty(boolean enabled) {
-        }
-
-        public boolean securityLogGetLoggingEnabledProperty() {
-            return false;
-        }
-
-        public boolean securityLogIsLoggingEnabled() {
-            return false;
-        }
-    }
-
-    public static class StorageManagerForMock {
-        public boolean isFileBasedEncryptionEnabled() {
-            return false;
-        }
-
-        public boolean isNonDefaultBlockEncrypted() {
-            return false;
-        }
-
-        public boolean isEncrypted() {
-            return false;
-        }
-
-        public boolean isEncryptable() {
-            return false;
-        }
-    }
-
-    public final Context realTestContext;
-
-    /**
-     * Use this instance to verify unimplemented methods such as {@link #sendBroadcast}.
-     * (Spying on {@code this} instance will confuse mockito somehow and I got weired "wrong number
-     * of arguments" exceptions.)
-     */
-    public final Context spiedContext;
-
-    public final File dataDir;
-    public final File systemUserDataDir;
-
-    public final MockBinder binder;
-    public final EnvironmentForMock environment;
-    public final SystemPropertiesForMock systemProperties;
-    public final UserManager userManager;
-    public final UserManagerInternal userManagerInternal;
-    public final PackageManagerInternal packageManagerInternal;
-    public final UserManagerForMock userManagerForMock;
-    public final PowerManagerForMock powerManager;
-    public final PowerManagerInternal powerManagerInternal;
-    public final NotificationManager notificationManager;
-    public final IWindowManager iwindowManager;
-    public final IActivityManager iactivityManager;
-    public final IPackageManager ipackageManager;
-    public final IBackupManager ibackupManager;
-    public final IAudioService iaudioService;
-    public final LockPatternUtils lockPatternUtils;
-    public final StorageManagerForMock storageManager;
-    public final WifiManager wifiManager;
-    public final SettingsForMock settings;
-    public final MockContentResolver contentResolver;
-    public final TelephonyManager telephonyManager;
-    public final AccountManager accountManager;
-
-    /** Note this is a partial mock, not a real mock. */
-    public final PackageManager packageManager;
-
-    public final List<String> callerPermissions = new ArrayList<>();
-
-    private final ArrayList<UserInfo> mUserInfos = new ArrayList<>();
-
-    public DpmMockContext(Context context, File dataDir) {
-        realTestContext = context;
-
-        this.dataDir = dataDir;
-        DpmTestUtils.clearDir(dataDir);
-
-        binder = new MockBinder();
-        environment = mock(EnvironmentForMock.class);
-        systemProperties= mock(SystemPropertiesForMock.class);
-        userManager = mock(UserManager.class);
-        userManagerInternal = mock(UserManagerInternal.class);
-        userManagerForMock = mock(UserManagerForMock.class);
-        packageManagerInternal = mock(PackageManagerInternal.class);
-        powerManager = mock(PowerManagerForMock.class);
-        powerManagerInternal = mock(PowerManagerInternal.class);
-        notificationManager = mock(NotificationManager.class);
-        iwindowManager = mock(IWindowManager.class);
-        iactivityManager = mock(IActivityManager.class);
-        ipackageManager = mock(IPackageManager.class);
-        ibackupManager = mock(IBackupManager.class);
-        iaudioService = mock(IAudioService.class);
-        lockPatternUtils = mock(LockPatternUtils.class);
-        storageManager = mock(StorageManagerForMock.class);
-        wifiManager = mock(WifiManager.class);
-        settings = mock(SettingsForMock.class);
-        telephonyManager = mock(TelephonyManager.class);
-        accountManager = mock(AccountManager.class);
-
-        // Package manager is huge, so we use a partial mock instead.
-        packageManager = spy(context.getPackageManager());
-
-        spiedContext = mock(Context.class);
-
-        contentResolver = new MockContentResolver();
-
-        // Add the system user
-        systemUserDataDir = addUser(UserHandle.USER_SYSTEM, UserInfo.FLAG_PRIMARY);
-
-        // System user is always running.
-        setUserRunning(UserHandle.USER_SYSTEM, true);
-    }
-
-    public File addUser(int userId, int flags) {
-
-        // Set up (default) UserInfo for CALLER_USER_HANDLE.
-        final UserInfo uh = new UserInfo(userId, "user" + userId, flags);
-        when(userManager.getUserInfo(eq(userId))).thenReturn(uh);
-
-        mUserInfos.add(uh);
-        when(userManager.getUsers()).thenReturn(mUserInfos);
-        when(userManager.getUsers(anyBoolean())).thenReturn(mUserInfos);
-        when(userManager.isUserRunning(eq(new UserHandle(userId)))).thenReturn(true);
-        when(userManager.getUserInfo(anyInt())).thenAnswer(
-                new Answer<UserInfo>() {
-                    @Override
-                    public UserInfo answer(InvocationOnMock invocation) throws Throwable {
-                        final int userId = (int) invocation.getArguments()[0];
-                        for (UserInfo ui : mUserInfos) {
-                            if (ui.id == userId) {
-                                return ui;
-                            }
-                        }
-                        return null;
-                    }
-                }
-        );
-        when(userManager.getProfiles(anyInt())).thenAnswer(
-                new Answer<List<UserInfo>>() {
-                    @Override
-                    public List<UserInfo> answer(InvocationOnMock invocation) throws Throwable {
-                        final int userId = (int) invocation.getArguments()[0];
-                        return getProfiles(userId);
-                    }
-                }
-        );
-        when(userManager.getProfileIdsWithDisabled(anyInt())).thenAnswer(
-                new Answer<int[]>() {
-                    @Override
-                    public int[] answer(InvocationOnMock invocation) throws Throwable {
-                        final int userId = (int) invocation.getArguments()[0];
-                        List<UserInfo> profiles = getProfiles(userId);
-                        int[] results = new int[profiles.size()];
-                        for (int i = 0; i < results.length; i++) {
-                            results[i] = profiles.get(i).id;
-                        }
-                        return results;
-                    }
-                }
-        );
-        when(accountManager.getAccountsAsUser(anyInt())).thenReturn(new Account[0]);
-
-
-        // Create a data directory.
-        final File dir = new File(dataDir, "user" + userId);
-        DpmTestUtils.clearDir(dir);
-
-        when(environment.getUserSystemDirectory(eq(userId))).thenReturn(dir);
-        return dir;
-    }
-
-    private List<UserInfo> getProfiles(int userId) {
-        final ArrayList<UserInfo> ret = new ArrayList<UserInfo>();
-        UserInfo parent = null;
-        for (UserInfo ui : mUserInfos) {
-            if (ui.id == userId) {
-                parent = ui;
-                break;
-            }
-        }
-        if (parent == null) {
-            return ret;
-        }
-        ret.add(parent);
-        for (UserInfo ui : mUserInfos) {
-            if (ui.id == userId) {
-                continue;
-            }
-            if (ui.profileGroupId != UserInfo.NO_PROFILE_GROUP_ID
-                    && ui.profileGroupId == parent.profileGroupId) {
-                ret.add(ui);
-            }
-        }
-        return ret;
-    }
-
-    /**
-     * Add multiple users at once.  They'll all have flag 0.
-     */
-    public void addUsers(int... userIds) {
-        for (int userId : userIds) {
-            addUser(userId, 0);
-        }
-    }
-
-    public void setUserRunning(int userId, boolean isRunning) {
-        when(userManager.isUserRunning(MockUtils.checkUserHandle(userId)))
-                .thenReturn(isRunning);
-    }
-
-    @Override
-    public Object getSystemService(String name) {
-        switch (name) {
-            case Context.USER_SERVICE:
-                return userManager;
-            case Context.POWER_SERVICE:
-                return powerManager;
-            case Context.WIFI_SERVICE:
-                return wifiManager;
-            case Context.ACCOUNT_SERVICE:
-                return accountManager;
-        }
-        throw new UnsupportedOperationException();
-    }
-
-    @Override
-    public String getSystemServiceName(Class<?> serviceClass) {
-        return realTestContext.getSystemServiceName(serviceClass);
-    }
-
-    @Override
-    public PackageManager getPackageManager() {
-        return packageManager;
-    }
-
-    @Override
-    public void enforceCallingOrSelfPermission(String permission, String message) {
-        if (binder.getCallingUid() == SYSTEM_UID) {
-            return; // Assume system has all permissions.
-        }
-        if (!callerPermissions.contains(permission)) {
-            throw new SecurityException("Caller doesn't have " + permission + " : " + message);
-        }
-    }
-
-    @Override
-    public void sendBroadcast(Intent intent) {
-        spiedContext.sendBroadcast(intent);
-    }
-
-    @Override
-    public void sendBroadcast(Intent intent, String receiverPermission) {
-        spiedContext.sendBroadcast(intent, receiverPermission);
-    }
-
-    @Override
-    public void sendBroadcastMultiplePermissions(Intent intent, String[] receiverPermissions) {
-        spiedContext.sendBroadcastMultiplePermissions(intent, receiverPermissions);
-    }
-
-    @Override
-    public void sendBroadcast(Intent intent, String receiverPermission, Bundle options) {
-        spiedContext.sendBroadcast(intent, receiverPermission, options);
-    }
-
-    @Override
-    public void sendBroadcast(Intent intent, String receiverPermission, int appOp) {
-        spiedContext.sendBroadcast(intent, receiverPermission, appOp);
-    }
-
-    @Override
-    public void sendOrderedBroadcast(Intent intent, String receiverPermission) {
-        spiedContext.sendOrderedBroadcast(intent, receiverPermission);
-    }
-
-    @Override
-    public void sendOrderedBroadcast(Intent intent, String receiverPermission,
-            BroadcastReceiver resultReceiver, Handler scheduler, int initialCode,
-            String initialData, Bundle initialExtras) {
-        spiedContext.sendOrderedBroadcast(intent, receiverPermission, resultReceiver, scheduler,
-                initialCode, initialData, initialExtras);
-    }
-
-    @Override
-    public void sendOrderedBroadcast(Intent intent, String receiverPermission, Bundle options,
-            BroadcastReceiver resultReceiver, Handler scheduler, int initialCode,
-            String initialData, Bundle initialExtras) {
-        spiedContext.sendOrderedBroadcast(intent, receiverPermission, options, resultReceiver,
-                scheduler,
-                initialCode, initialData, initialExtras);
-    }
-
-    @Override
-    public void sendOrderedBroadcast(Intent intent, String receiverPermission, int appOp,
-            BroadcastReceiver resultReceiver, Handler scheduler, int initialCode,
-            String initialData, Bundle initialExtras) {
-        spiedContext.sendOrderedBroadcast(intent, receiverPermission, appOp, resultReceiver,
-                scheduler,
-                initialCode, initialData, initialExtras);
-    }
-
-    @Override
-    public void sendBroadcastAsUser(Intent intent, UserHandle user) {
-        if (binder.callingPid != SYSTEM_PID) {
-            // Unless called as the system process, can only call if the target user is the
-            // calling user.
-            // (The actual check is more complex; we may need to change it later.)
-            Assert.assertEquals(UserHandle.getUserId(binder.getCallingUid()), user.getIdentifier());
-        }
-
-        spiedContext.sendBroadcastAsUser(intent, user);
-    }
-
-    @Override
-    public void sendBroadcastAsUser(Intent intent, UserHandle user, String receiverPermission) {
-        spiedContext.sendBroadcastAsUser(intent, user, receiverPermission);
-    }
-
-    @Override
-    public void sendBroadcastAsUser(Intent intent, UserHandle user, String receiverPermission,
-            int appOp) {
-        spiedContext.sendBroadcastAsUser(intent, user, receiverPermission, appOp);
-    }
-
-    @Override
-    public void sendOrderedBroadcastAsUser(Intent intent, UserHandle user,
-            String receiverPermission, BroadcastReceiver resultReceiver, Handler scheduler,
-            int initialCode, String initialData, Bundle initialExtras) {
-        spiedContext.sendOrderedBroadcastAsUser(intent, user, receiverPermission, resultReceiver,
-                scheduler, initialCode, initialData, initialExtras);
-        resultReceiver.onReceive(spiedContext, intent);
-    }
-
-    @Override
-    public void sendOrderedBroadcastAsUser(Intent intent, UserHandle user,
-            String receiverPermission, int appOp, BroadcastReceiver resultReceiver,
-            Handler scheduler, int initialCode, String initialData, Bundle initialExtras) {
-        spiedContext.sendOrderedBroadcastAsUser(intent, user, receiverPermission, appOp,
-                resultReceiver,
-                scheduler, initialCode, initialData, initialExtras);
-    }
-
-    @Override
-    public void sendOrderedBroadcastAsUser(Intent intent, UserHandle user,
-            String receiverPermission, int appOp, Bundle options, BroadcastReceiver resultReceiver,
-            Handler scheduler, int initialCode, String initialData, Bundle initialExtras) {
-        spiedContext.sendOrderedBroadcastAsUser(intent, user, receiverPermission, appOp, options,
-                resultReceiver, scheduler, initialCode, initialData, initialExtras);
-    }
-
-    @Override
-    public void sendStickyBroadcast(Intent intent) {
-        spiedContext.sendStickyBroadcast(intent);
-    }
-
-    @Override
-    public void sendStickyOrderedBroadcast(Intent intent, BroadcastReceiver resultReceiver,
-            Handler scheduler, int initialCode, String initialData, Bundle initialExtras) {
-        spiedContext.sendStickyOrderedBroadcast(intent, resultReceiver, scheduler, initialCode,
-                initialData, initialExtras);
-    }
-
-    @Override
-    public void removeStickyBroadcast(Intent intent) {
-        spiedContext.removeStickyBroadcast(intent);
-    }
-
-    @Override
-    public void sendStickyBroadcastAsUser(Intent intent, UserHandle user) {
-        spiedContext.sendStickyBroadcastAsUser(intent, user);
-    }
-
-    @Override
-    public void sendStickyOrderedBroadcastAsUser(Intent intent, UserHandle user,
-            BroadcastReceiver resultReceiver, Handler scheduler, int initialCode,
-            String initialData, Bundle initialExtras) {
-        spiedContext.sendStickyOrderedBroadcastAsUser(intent, user, resultReceiver, scheduler, initialCode,
-                initialData, initialExtras);
-    }
-
-    @Override
-    public void removeStickyBroadcastAsUser(Intent intent, UserHandle user) {
-        spiedContext.removeStickyBroadcastAsUser(intent, user);
-    }
-
-    @Override
-    public Intent registerReceiver(BroadcastReceiver receiver, IntentFilter filter) {
-        return spiedContext.registerReceiver(receiver, filter);
-    }
-
-    @Override
-    public Intent registerReceiver(BroadcastReceiver receiver, IntentFilter filter,
-            String broadcastPermission, Handler scheduler) {
-        return spiedContext.registerReceiver(receiver, filter, broadcastPermission, scheduler);
-    }
-
-    @Override
-    public Intent registerReceiverAsUser(BroadcastReceiver receiver, UserHandle user,
-            IntentFilter filter, String broadcastPermission, Handler scheduler) {
-        return spiedContext.registerReceiverAsUser(receiver, user, filter, broadcastPermission,
-                scheduler);
-    }
-
-    @Override
-    public void unregisterReceiver(BroadcastReceiver receiver) {
-        spiedContext.unregisterReceiver(receiver);
-    }
-
-    @Override
-    public ContentResolver getContentResolver() {
-        return contentResolver;
-    }
-}
diff --git a/services/tests/servicestests/src/com/android/server/devicepolicy/DpmTestBase.java b/services/tests/servicestests/src/com/android/server/devicepolicy/DpmTestBase.java
deleted file mode 100644
index b4b74b3ec10..00000000000
--- a/services/tests/servicestests/src/com/android/server/devicepolicy/DpmTestBase.java
+++ /dev/null
@@ -1,167 +0,0 @@
-/*
- * Copyright (C) 2015 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.android.server.devicepolicy;
-
-import android.content.ComponentName;
-import android.content.Context;
-import android.content.Intent;
-import android.content.pm.ActivityInfo;
-import android.content.pm.ApplicationInfo;
-import android.content.pm.PackageInfo;
-import android.content.pm.PackageManager;
-import android.content.pm.ResolveInfo;
-import android.os.UserHandle;
-import android.test.AndroidTestCase;
-
-import java.io.File;
-import java.util.List;
-
-import static org.mockito.Matchers.anyInt;
-import static org.mockito.Matchers.eq;
-import static org.mockito.Mockito.doReturn;
-
-public abstract class DpmTestBase extends AndroidTestCase {
-    public static final String TAG = "DpmTest";
-
-    protected Context mRealTestContext;
-    protected DpmMockContext mMockContext;
-
-    public File dataDir;
-
-    public ComponentName admin1;
-    public ComponentName admin2;
-    public ComponentName admin3;
-    public ComponentName adminNoPerm;
-
-    @Override
-    protected void setUp() throws Exception {
-        super.setUp();
-
-        mRealTestContext = super.getContext();
-
-        mMockContext = new DpmMockContext(
-                mRealTestContext, new File(mRealTestContext.getCacheDir(), "test-data"));
-
-        admin1 = new ComponentName(mRealTestContext, DummyDeviceAdmins.Admin1.class);
-        admin2 = new ComponentName(mRealTestContext, DummyDeviceAdmins.Admin2.class);
-        admin3 = new ComponentName(mRealTestContext, DummyDeviceAdmins.Admin3.class);
-        adminNoPerm = new ComponentName(mRealTestContext, DummyDeviceAdmins.AdminNoPerm.class);
-    }
-
-    @Override
-    public DpmMockContext getContext() {
-        return mMockContext;
-    }
-
-    protected void markPackageAsInstalled(String packageName, ApplicationInfo ai, int userId)
-            throws Exception {
-        final PackageInfo pi = DpmTestUtils.cloneParcelable(
-                mRealTestContext.getPackageManager().getPackageInfo(
-                        mRealTestContext.getPackageName(), 0));
-        assertTrue(pi.applicationInfo.flags != 0);
-
-        if (ai != null) {
-            pi.applicationInfo = ai;
-        }
-
-        doReturn(pi).when(mMockContext.ipackageManager).getPackageInfo(
-                eq(packageName),
-                eq(0),
-                eq(userId));
-    }
-
-    protected void setUpPackageManagerForAdmin(ComponentName admin, int packageUid)
-            throws Exception {
-        setUpPackageManagerForAdmin(admin, packageUid,
-                /* enabledSetting =*/ null, /* appTargetSdk = */ null);
-    }
-
-    protected void setUpPackageManagerForAdmin(ComponentName admin, int packageUid,
-            int enabledSetting) throws Exception {
-        setUpPackageManagerForAdmin(admin, packageUid, enabledSetting, /* appTargetSdk = */ null);
-    }
-
-    protected void setUpPackageManagerForAdmin(ComponentName admin, int packageUid,
-            Integer enabledSetting, Integer appTargetSdk) throws Exception {
-        setUpPackageManagerForFakeAdmin(admin, packageUid, enabledSetting, appTargetSdk,
-                admin);
-    }
-
-    /**
-     * Set up a component in the mock package manager to be an active admin.
-     *
-     * @param admin ComponentName that's visible to the test code, which doesn't have to exist.
-     * @param copyFromAdmin package information for {@code admin} will be built based on this
-     *    component's information.
-     */
-    protected void setUpPackageManagerForFakeAdmin(ComponentName admin, int packageUid,
-            Integer enabledSetting, Integer appTargetSdk, ComponentName copyFromAdmin)
-            throws Exception {
-
-        // Set up getApplicationInfo().
-
-        final ApplicationInfo ai = DpmTestUtils.cloneParcelable(
-                mRealTestContext.getPackageManager().getApplicationInfo(
-                        copyFromAdmin.getPackageName(),
-                        PackageManager.GET_DISABLED_UNTIL_USED_COMPONENTS));
-
-        ai.enabledSetting = enabledSetting == null
-                ? PackageManager.COMPONENT_ENABLED_STATE_DISABLED_UNTIL_USED
-                : enabledSetting;
-        if (appTargetSdk != null) {
-            ai.targetSdkVersion = appTargetSdk;
-        }
-        ai.uid = packageUid;
-        ai.packageName = admin.getPackageName();
-        ai.name = admin.getClassName();
-
-        doReturn(ai).when(mMockContext.ipackageManager).getApplicationInfo(
-                eq(admin.getPackageName()),
-                anyInt(),
-                eq(UserHandle.getUserId(packageUid)));
-
-        // Set up queryBroadcastReceivers().
-
-        final Intent resolveIntent = new Intent();
-        resolveIntent.setComponent(copyFromAdmin);
-        final List<ResolveInfo> realResolveInfo =
-                mRealTestContext.getPackageManager().queryBroadcastReceivers(
-                        resolveIntent,
-                        PackageManager.GET_META_DATA);
-        assertNotNull(realResolveInfo);
-        assertEquals(1, realResolveInfo.size());
-
-        // We need to change AI, so set a clone.
-        realResolveInfo.set(0, DpmTestUtils.cloneParcelable(realResolveInfo.get(0)));
-
-        // We need to rewrite the UID in the activity info.
-        final ActivityInfo aci = realResolveInfo.get(0).activityInfo;
-        aci.applicationInfo = ai;
-        aci.packageName = admin.getPackageName();
-        aci.name = admin.getClassName();
-
-        // Note we don't set up queryBroadcastReceivers.  We don't use it in DPMS.
-
-        doReturn(aci).when(mMockContext.ipackageManager).getReceiverInfo(
-                eq(admin),
-                anyInt(),
-                eq(UserHandle.getUserId(packageUid)));
-
-        // Set up getPackageInfo().
-        markPackageAsInstalled(admin.getPackageName(), ai, UserHandle.getUserId(packageUid));
-    }
-}
diff --git a/services/tests/servicestests/src/com/android/server/devicepolicy/DpmTestUtils.java b/services/tests/servicestests/src/com/android/server/devicepolicy/DpmTestUtils.java
deleted file mode 100644
index cceb2d2761f..00000000000
--- a/services/tests/servicestests/src/com/android/server/devicepolicy/DpmTestUtils.java
+++ /dev/null
@@ -1,166 +0,0 @@
-/*
- * Copyright (C) 2015 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.android.server.devicepolicy;
-
-import com.google.android.collect.Lists;
-import com.google.android.collect.Sets;
-
-import android.content.Context;
-import android.os.Bundle;
-import android.os.FileUtils;
-import android.os.Parcel;
-import android.os.Parcelable;
-import android.test.AndroidTestCase;
-import android.util.Log;
-import android.util.Printer;
-
-import org.junit.Assert;
-
-import java.io.BufferedReader;
-import java.io.File;
-import java.io.FileWriter;
-import java.io.IOException;
-import java.io.InputStreamReader;
-import java.io.PrintWriter;
-import java.util.ArrayList;
-import java.util.Collections;
-import java.util.List;
-import java.util.Objects;
-import java.util.Set;
-
-import junit.framework.AssertionFailedError;
-
-public class DpmTestUtils extends AndroidTestCase {
-    public static void clearDir(File dir) {
-        if (dir.exists()) {
-            Assert.assertTrue("failed to delete dir", FileUtils.deleteContents(dir));
-        }
-        dir.mkdirs();
-        Log.i(DpmTestBase.TAG, "Created " + dir);
-    }
-
-    public static int getListSizeAllowingNull(List<?> list) {
-        return list == null ? 0 : list.size();
-    }
-
-    public static Bundle newRestrictions(String... restrictions) {
-        final Bundle ret = new Bundle();
-        for (String restriction : restrictions) {
-            ret.putBoolean(restriction, true);
-        }
-        return ret;
-    }
-
-    public static void assertRestrictions(Bundle expected, Bundle actual) {
-        final ArrayList<String> elist;
-        if (expected == null) {
-            elist = null;
-        } else {
-            elist = Lists.newArrayList();
-            for (String key : expected.keySet()) {
-                if (expected.getBoolean(key)) {
-                    elist.add(key);
-                }
-            }
-            Collections.sort(elist);
-        }
-
-        final ArrayList<String> alist;
-        if (actual == null) {
-            alist = null;
-        } else {
-            alist = Lists.newArrayList();
-            for (String key : actual.keySet()) {
-                if (actual.getBoolean(key)) {
-                    alist.add(key);
-                }
-            }
-            Collections.sort(alist);
-        }
-
-        assertEquals(elist, alist);
-    }
-
-    public static <T extends Parcelable> T cloneParcelable(T source) {
-        Parcel p = Parcel.obtain();
-        p.writeParcelable(source, 0);
-        p.setDataPosition(0);
-        final T clone = p.readParcelable(DpmTestUtils.class.getClassLoader());
-        p.recycle();
-        return clone;
-    }
-
-    public static Printer LOG_PRINTER = new Printer() {
-        @Override
-        public void println(String x) {
-            Log.i(DpmTestBase.TAG, x);
-        }
-    };
-
-    public static String readAsset(Context context, String assetPath) throws IOException {
-        final StringBuilder sb = new StringBuilder();
-        try (BufferedReader br = new BufferedReader(
-                new InputStreamReader(
-                        context.getResources().getAssets().open(assetPath)))) {
-            String line;
-            while ((line = br.readLine()) != null) {
-                sb.append(line);
-                sb.append(System.lineSeparator());
-            }
-        }
-        return sb.toString();
-    }
-
-    public static void writeToFile(File path, String content)
-            throws IOException {
-        path.getParentFile().mkdirs();
-
-        try (FileWriter writer = new FileWriter(path)) {
-            Log.i(DpmTestBase.TAG, "Writing to " + path);
-            Log.i(DpmTestBase.TAG, content);
-            writer.write(content);
-        }
-    }
-
-    private static boolean checkAssertRestrictions(Bundle a, Bundle b) {
-        try {
-            assertRestrictions(a, b);
-            return true;
-        } catch (AssertionFailedError e) {
-            return false;
-        }
-    }
-
-    public void testAssertRestrictions() {
-        final Bundle a = newRestrictions();
-        final Bundle b = newRestrictions("a");
-        final Bundle c = newRestrictions("a");
-        final Bundle d = newRestrictions("b", "c");
-        final Bundle e = newRestrictions("b", "c");
-
-        assertTrue(checkAssertRestrictions(null, null));
-        assertFalse(checkAssertRestrictions(null, a));
-        assertFalse(checkAssertRestrictions(a, null));
-        assertTrue(checkAssertRestrictions(a, a));
-
-        assertFalse(checkAssertRestrictions(a, b));
-        assertTrue(checkAssertRestrictions(b, c));
-
-        assertFalse(checkAssertRestrictions(c, d));
-        assertTrue(checkAssertRestrictions(d, e));
-    }
-}
diff --git a/services/tests/servicestests/src/com/android/server/devicepolicy/DummyDeviceAdmins.java b/services/tests/servicestests/src/com/android/server/devicepolicy/DummyDeviceAdmins.java
deleted file mode 100644
index a0f4d97de1d..00000000000
--- a/services/tests/servicestests/src/com/android/server/devicepolicy/DummyDeviceAdmins.java
+++ /dev/null
@@ -1,29 +0,0 @@
-/*
- * Copyright (C) 2015 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.android.server.devicepolicy;
-
-import android.app.admin.DeviceAdminReceiver;
-
-public class DummyDeviceAdmins {
-    public static class Admin1 extends DeviceAdminReceiver {
-    }
-    public static class Admin2 extends DeviceAdminReceiver {
-    }
-    public static class Admin3 extends DeviceAdminReceiver {
-    }
-    public static class AdminNoPerm extends DeviceAdminReceiver {
-    }
-}
diff --git a/services/tests/servicestests/src/com/android/server/devicepolicy/MockUtils.java b/services/tests/servicestests/src/com/android/server/devicepolicy/MockUtils.java
deleted file mode 100644
index 58db192f117..00000000000
--- a/services/tests/servicestests/src/com/android/server/devicepolicy/MockUtils.java
+++ /dev/null
@@ -1,117 +0,0 @@
-/*
- * Copyright (C) 2015 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.android.server.devicepolicy;
-
-import com.google.common.base.Objects;
-
-import com.android.internal.util.Preconditions;
-import com.android.server.pm.UserRestrictionsUtils;
-
-import android.content.ComponentName;
-import android.content.Intent;
-import android.os.Bundle;
-import android.os.UserHandle;
-
-import org.hamcrest.BaseMatcher;
-import org.hamcrest.Description;
-import org.hamcrest.Matcher;
-import org.mockito.Mockito;
-
-public class MockUtils {
-    private MockUtils() {
-    }
-
-    public static UserHandle checkUserHandle(final int userId) {
-        final Matcher<UserHandle> m = new BaseMatcher<UserHandle>() {
-            @Override
-            public boolean matches(Object item) {
-                if (item == null) return false;
-                return Objects.equal(((UserHandle) item).getIdentifier(), userId);
-            }
-
-            @Override
-            public void describeTo(Description description) {
-                description.appendText("UserHandle: user-id= \"" + userId + "\"");
-            }
-        };
-        return Mockito.argThat(m);
-    }
-
-    public static Intent checkIntentComponent(final ComponentName component) {
-        final Matcher<Intent> m = new BaseMatcher<Intent>() {
-            @Override
-            public boolean matches(Object item) {
-                if (item == null) return false;
-                return Objects.equal(((Intent) item).getComponent(), component);
-            }
-
-            @Override
-            public void describeTo(Description description) {
-                description.appendText("Intent: component=\"" + component + "\"");
-            }
-        };
-        return Mockito.argThat(m);
-    }
-
-    public static Intent checkIntentAction(final String action) {
-        final Matcher<Intent> m = new BaseMatcher<Intent>() {
-            @Override
-            public boolean matches(Object item) {
-                if (item == null) return false;
-                return Objects.equal(((Intent) item).getAction(), action);
-            }
-
-            @Override
-            public void describeTo(Description description) {
-                description.appendText("Intent: action=\"" + action + "\"");
-            }
-        };
-        return Mockito.argThat(m);
-    }
-
-    public static Bundle checkUserRestrictions(String... keys) {
-        final Bundle expected = DpmTestUtils.newRestrictions(Preconditions.checkNotNull(keys));
-        final Matcher<Bundle> m = new BaseMatcher<Bundle>() {
-            @Override
-            public boolean matches(Object item) {
-                if (item == null) return false;
-                return UserRestrictionsUtils.areEqual((Bundle) item, expected);
-            }
-
-            @Override
-            public void describeTo(Description description) {
-                description.appendText("User restrictions=" + getRestrictionsAsString(expected));
-            }
-        };
-        return Mockito.argThat(m);
-    }
-
-    private static String getRestrictionsAsString(Bundle b) {
-        final StringBuilder sb = new StringBuilder();
-        sb.append("[");
-
-        if (b != null) {
-            String sep = "";
-            for (String key : b.keySet()) {
-                sb.append(sep);
-                sep = ",";
-                sb.append(key);
-            }
-        }
-        sb.append("]");
-        return sb.toString();
-    }
-}
diff --git a/services/tests/servicestests/src/com/android/server/devicepolicy/OwnersTest.java b/services/tests/servicestests/src/com/android/server/devicepolicy/OwnersTest.java
deleted file mode 100644
index 423c4d5431a..00000000000
--- a/services/tests/servicestests/src/com/android/server/devicepolicy/OwnersTest.java
+++ /dev/null
@@ -1,480 +0,0 @@
-/*
- * Copyright (C) 2014 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.android.server.devicepolicy;
-
-import com.android.server.devicepolicy.DevicePolicyManagerServiceTestable.OwnersTestable;
-
-import android.content.ComponentName;
-import android.os.UserHandle;
-
-/**
- * Tests for the DeviceOwner object that saves & loads device and policy owner information.
- * run this test with:
- m FrameworksServicesTests &&
- adb install \
-   -r out/target/product/hammerhead/data/app/FrameworksServicesTests/FrameworksServicesTests.apk &&
- adb shell am instrument -e class com.android.server.devicepolicy.OwnersTest \
-   -w com.android.frameworks.servicestests/android.support.test.runner.AndroidJUnitRunner
-
- (mmma frameworks/base/services/tests/servicestests/ for non-ninja build)
- */
-public class OwnersTest extends DpmTestBase {
-    public void testUpgrade01() throws Exception {
-        getContext().addUsers(10, 11, 20, 21);
-
-        // First, migrate.
-        {
-            final OwnersTestable owners = new OwnersTestable(getContext());
-
-            DpmTestUtils.writeToFile(owners.getLegacyConfigFileWithTestOverride(),
-                    DpmTestUtils.readAsset(mRealTestContext, "OwnersTest/test01/input.xml"));
-
-            owners.load();
-
-            // The legacy file should be removed.
-            assertFalse(owners.getLegacyConfigFileWithTestOverride().exists());
-
-            // File was empty, so no new files should be created.
-            assertFalse(owners.getDeviceOwnerFileWithTestOverride().exists());
-
-            assertFalse(owners.getProfileOwnerFileWithTestOverride(10).exists());
-            assertFalse(owners.getProfileOwnerFileWithTestOverride(11).exists());
-            assertFalse(owners.getProfileOwnerFileWithTestOverride(20).exists());
-            assertFalse(owners.getProfileOwnerFileWithTestOverride(21).exists());
-
-            assertFalse(owners.hasDeviceOwner());
-            assertEquals(UserHandle.USER_NULL, owners.getDeviceOwnerUserId());
-            assertNull(owners.getSystemUpdatePolicy());
-            assertEquals(0, owners.getProfileOwnerKeys().size());
-
-            assertFalse(owners.getDeviceOwnerUserRestrictionsNeedsMigration());
-            assertFalse(owners.getProfileOwnerUserRestrictionsNeedsMigration(10));
-            assertFalse(owners.getProfileOwnerUserRestrictionsNeedsMigration(11));
-            assertFalse(owners.getProfileOwnerUserRestrictionsNeedsMigration(20));
-            assertFalse(owners.getProfileOwnerUserRestrictionsNeedsMigration(21));
-        }
-
-        // Then re-read and check.
-        {
-            final OwnersTestable owners = new OwnersTestable(getContext());
-            owners.load();
-
-            assertFalse(owners.hasDeviceOwner());
-            assertEquals(UserHandle.USER_NULL, owners.getDeviceOwnerUserId());
-            assertNull(owners.getSystemUpdatePolicy());
-            assertEquals(0, owners.getProfileOwnerKeys().size());
-
-            assertFalse(owners.getDeviceOwnerUserRestrictionsNeedsMigration());
-            assertFalse(owners.getProfileOwnerUserRestrictionsNeedsMigration(10));
-            assertFalse(owners.getProfileOwnerUserRestrictionsNeedsMigration(11));
-            assertFalse(owners.getProfileOwnerUserRestrictionsNeedsMigration(20));
-            assertFalse(owners.getProfileOwnerUserRestrictionsNeedsMigration(21));
-        }
-    }
-
-    public void testUpgrade02() throws Exception {
-        getContext().addUsers(10, 11, 20, 21);
-
-        // First, migrate.
-        {
-            final OwnersTestable owners = new OwnersTestable(getContext());
-
-            DpmTestUtils.writeToFile(owners.getLegacyConfigFileWithTestOverride(),
-                    DpmTestUtils.readAsset(mRealTestContext, "OwnersTest/test02/input.xml"));
-
-            owners.load();
-
-            // The legacy file should be removed.
-            assertFalse(owners.getLegacyConfigFileWithTestOverride().exists());
-
-            assertTrue(owners.getDeviceOwnerFileWithTestOverride().exists()); // TODO Check content
-
-            assertFalse(owners.getProfileOwnerFileWithTestOverride(10).exists());
-            assertFalse(owners.getProfileOwnerFileWithTestOverride(11).exists());
-            assertFalse(owners.getProfileOwnerFileWithTestOverride(20).exists());
-            assertFalse(owners.getProfileOwnerFileWithTestOverride(21).exists());
-
-            assertTrue(owners.hasDeviceOwner());
-            assertEquals(null, owners.getDeviceOwnerName());
-            assertEquals("com.google.android.testdpc", owners.getDeviceOwnerPackageName());
-            assertEquals(UserHandle.USER_SYSTEM, owners.getDeviceOwnerUserId());
-
-            assertNull(owners.getSystemUpdatePolicy());
-            assertEquals(0, owners.getProfileOwnerKeys().size());
-
-            assertTrue(owners.getDeviceOwnerUserRestrictionsNeedsMigration());
-            assertFalse(owners.getProfileOwnerUserRestrictionsNeedsMigration(10));
-            assertFalse(owners.getProfileOwnerUserRestrictionsNeedsMigration(11));
-            assertFalse(owners.getProfileOwnerUserRestrictionsNeedsMigration(20));
-            assertFalse(owners.getProfileOwnerUserRestrictionsNeedsMigration(21));
-        }
-
-        // Then re-read and check.
-        {
-            final OwnersTestable owners = new OwnersTestable(getContext());
-            owners.load();
-
-            assertTrue(owners.hasDeviceOwner());
-            assertEquals(null, owners.getDeviceOwnerName());
-            assertEquals("com.google.android.testdpc", owners.getDeviceOwnerPackageName());
-            assertEquals(UserHandle.USER_SYSTEM, owners.getDeviceOwnerUserId());
-
-            assertNull(owners.getSystemUpdatePolicy());
-            assertEquals(0, owners.getProfileOwnerKeys().size());
-
-            assertTrue(owners.getDeviceOwnerUserRestrictionsNeedsMigration());
-            assertFalse(owners.getProfileOwnerUserRestrictionsNeedsMigration(10));
-            assertFalse(owners.getProfileOwnerUserRestrictionsNeedsMigration(11));
-            assertFalse(owners.getProfileOwnerUserRestrictionsNeedsMigration(20));
-            assertFalse(owners.getProfileOwnerUserRestrictionsNeedsMigration(21));
-        }
-    }
-
-    public void testUpgrade03() throws Exception {
-        getContext().addUsers(10, 11, 20, 21);
-
-        // First, migrate.
-        {
-            final OwnersTestable owners = new OwnersTestable(getContext());
-
-            DpmTestUtils.writeToFile(owners.getLegacyConfigFileWithTestOverride(),
-                    DpmTestUtils.readAsset(mRealTestContext, "OwnersTest/test03/input.xml"));
-
-            owners.load();
-
-            // The legacy file should be removed.
-            assertFalse(owners.getLegacyConfigFileWithTestOverride().exists());
-
-            assertFalse(owners.getDeviceOwnerFileWithTestOverride().exists());
-
-            assertTrue(owners.getProfileOwnerFileWithTestOverride(10).exists());
-            assertTrue(owners.getProfileOwnerFileWithTestOverride(11).exists());
-            assertFalse(owners.getProfileOwnerFileWithTestOverride(20).exists());
-            assertFalse(owners.getProfileOwnerFileWithTestOverride(21).exists());
-
-            assertFalse(owners.hasDeviceOwner());
-            assertEquals(UserHandle.USER_NULL, owners.getDeviceOwnerUserId());
-            assertNull(owners.getSystemUpdatePolicy());
-
-            assertEquals(2, owners.getProfileOwnerKeys().size());
-            assertEquals(new ComponentName("com.google.android.testdpc",
-                            "com.google.android.testdpc.DeviceAdminReceiver0"),
-                    owners.getProfileOwnerComponent(10));
-            assertEquals("0", owners.getProfileOwnerName(10));
-            assertEquals("com.google.android.testdpc", owners.getProfileOwnerPackage(10));
-
-            assertEquals(new ComponentName("com.google.android.testdpc1", ""),
-                    owners.getProfileOwnerComponent(11));
-            assertEquals("1", owners.getProfileOwnerName(11));
-            assertEquals("com.google.android.testdpc1", owners.getProfileOwnerPackage(11));
-
-            assertFalse(owners.getDeviceOwnerUserRestrictionsNeedsMigration());
-            assertTrue(owners.getProfileOwnerUserRestrictionsNeedsMigration(10));
-            assertTrue(owners.getProfileOwnerUserRestrictionsNeedsMigration(11));
-            assertFalse(owners.getProfileOwnerUserRestrictionsNeedsMigration(20));
-            assertFalse(owners.getProfileOwnerUserRestrictionsNeedsMigration(21));
-        }
-
-        // Then re-read and check.
-        {
-            final OwnersTestable owners = new OwnersTestable(getContext());
-            owners.load();
-
-            assertFalse(owners.hasDeviceOwner());
-            assertEquals(UserHandle.USER_NULL, owners.getDeviceOwnerUserId());
-            assertNull(owners.getSystemUpdatePolicy());
-
-            assertEquals(2, owners.getProfileOwnerKeys().size());
-            assertEquals(new ComponentName("com.google.android.testdpc",
-                            "com.google.android.testdpc.DeviceAdminReceiver0"),
-                    owners.getProfileOwnerComponent(10));
-            assertEquals("0", owners.getProfileOwnerName(10));
-            assertEquals("com.google.android.testdpc", owners.getProfileOwnerPackage(10));
-
-            assertEquals(new ComponentName("com.google.android.testdpc1", ""),
-                    owners.getProfileOwnerComponent(11));
-            assertEquals("1", owners.getProfileOwnerName(11));
-            assertEquals("com.google.android.testdpc1", owners.getProfileOwnerPackage(11));
-
-            assertFalse(owners.getDeviceOwnerUserRestrictionsNeedsMigration());
-            assertTrue(owners.getProfileOwnerUserRestrictionsNeedsMigration(10));
-            assertTrue(owners.getProfileOwnerUserRestrictionsNeedsMigration(11));
-            assertFalse(owners.getProfileOwnerUserRestrictionsNeedsMigration(20));
-            assertFalse(owners.getProfileOwnerUserRestrictionsNeedsMigration(21));
-        }
-    }
-
-    /**
-     * Note this also tests {@link Owners#setDeviceOwnerUserRestrictionsMigrated()}
-     * and {@link  Owners#setProfileOwnerUserRestrictionsMigrated(int)}.
-     */
-    public void testUpgrade04() throws Exception {
-        getContext().addUsers(10, 11, 20, 21);
-
-        // First, migrate.
-        {
-            final OwnersTestable owners = new OwnersTestable(getContext());
-
-            DpmTestUtils.writeToFile(owners.getLegacyConfigFileWithTestOverride(),
-                    DpmTestUtils.readAsset(mRealTestContext, "OwnersTest/test04/input.xml"));
-
-            owners.load();
-
-            // The legacy file should be removed.
-            assertFalse(owners.getLegacyConfigFileWithTestOverride().exists());
-
-            assertTrue(owners.getDeviceOwnerFileWithTestOverride().exists());
-
-            assertTrue(owners.getProfileOwnerFileWithTestOverride(10).exists());
-            assertTrue(owners.getProfileOwnerFileWithTestOverride(11).exists());
-            assertFalse(owners.getProfileOwnerFileWithTestOverride(20).exists());
-            assertFalse(owners.getProfileOwnerFileWithTestOverride(21).exists());
-
-            assertTrue(owners.hasDeviceOwner());
-            assertEquals(null, owners.getDeviceOwnerName());
-            assertEquals("com.google.android.testdpc", owners.getDeviceOwnerPackageName());
-            assertEquals(UserHandle.USER_SYSTEM, owners.getDeviceOwnerUserId());
-
-            assertNotNull(owners.getSystemUpdatePolicy());
-            assertEquals(5, owners.getSystemUpdatePolicy().getPolicyType());
-
-            assertEquals(2, owners.getProfileOwnerKeys().size());
-            assertEquals(new ComponentName("com.google.android.testdpc",
-                            "com.google.android.testdpc.DeviceAdminReceiver0"),
-                    owners.getProfileOwnerComponent(10));
-            assertEquals("0", owners.getProfileOwnerName(10));
-            assertEquals("com.google.android.testdpc", owners.getProfileOwnerPackage(10));
-
-            assertEquals(new ComponentName("com.google.android.testdpc1", ""),
-                    owners.getProfileOwnerComponent(11));
-            assertEquals("1", owners.getProfileOwnerName(11));
-            assertEquals("com.google.android.testdpc1", owners.getProfileOwnerPackage(11));
-
-            assertTrue(owners.getDeviceOwnerUserRestrictionsNeedsMigration());
-            assertTrue(owners.getProfileOwnerUserRestrictionsNeedsMigration(10));
-            assertTrue(owners.getProfileOwnerUserRestrictionsNeedsMigration(11));
-            assertFalse(owners.getProfileOwnerUserRestrictionsNeedsMigration(20));
-            assertFalse(owners.getProfileOwnerUserRestrictionsNeedsMigration(21));
-        }
-
-        // Then re-read and check.
-        {
-            final OwnersTestable owners = new OwnersTestable(getContext());
-            owners.load();
-
-            assertTrue(owners.hasDeviceOwner());
-            assertEquals(null, owners.getDeviceOwnerName());
-            assertEquals("com.google.android.testdpc", owners.getDeviceOwnerPackageName());
-            assertEquals(UserHandle.USER_SYSTEM, owners.getDeviceOwnerUserId());
-
-            assertNotNull(owners.getSystemUpdatePolicy());
-            assertEquals(5, owners.getSystemUpdatePolicy().getPolicyType());
-
-            assertEquals(2, owners.getProfileOwnerKeys().size());
-            assertEquals(new ComponentName("com.google.android.testdpc",
-                            "com.google.android.testdpc.DeviceAdminReceiver0"),
-                    owners.getProfileOwnerComponent(10));
-            assertEquals("0", owners.getProfileOwnerName(10));
-            assertEquals("com.google.android.testdpc", owners.getProfileOwnerPackage(10));
-
-            assertEquals(new ComponentName("com.google.android.testdpc1", ""),
-                    owners.getProfileOwnerComponent(11));
-            assertEquals("1", owners.getProfileOwnerName(11));
-            assertEquals("com.google.android.testdpc1", owners.getProfileOwnerPackage(11));
-
-            assertTrue(owners.getDeviceOwnerUserRestrictionsNeedsMigration());
-            assertTrue(owners.getProfileOwnerUserRestrictionsNeedsMigration(10));
-            assertTrue(owners.getProfileOwnerUserRestrictionsNeedsMigration(11));
-            assertFalse(owners.getProfileOwnerUserRestrictionsNeedsMigration(20));
-            assertFalse(owners.getProfileOwnerUserRestrictionsNeedsMigration(21));
-
-            owners.setDeviceOwnerUserRestrictionsMigrated();
-        }
-
-        {
-            final OwnersTestable owners = new OwnersTestable(getContext());
-            owners.load();
-
-            assertFalse(owners.getDeviceOwnerUserRestrictionsNeedsMigration());
-            assertTrue(owners.getProfileOwnerUserRestrictionsNeedsMigration(10));
-            assertTrue(owners.getProfileOwnerUserRestrictionsNeedsMigration(11));
-            assertFalse(owners.getProfileOwnerUserRestrictionsNeedsMigration(20));
-            assertFalse(owners.getProfileOwnerUserRestrictionsNeedsMigration(21));
-
-            owners.setProfileOwnerUserRestrictionsMigrated(11);
-        }
-
-        {
-            final OwnersTestable owners = new OwnersTestable(getContext());
-            owners.load();
-
-            assertFalse(owners.getDeviceOwnerUserRestrictionsNeedsMigration());
-            assertTrue(owners.getProfileOwnerUserRestrictionsNeedsMigration(10));
-            assertFalse(owners.getProfileOwnerUserRestrictionsNeedsMigration(11));
-            assertFalse(owners.getProfileOwnerUserRestrictionsNeedsMigration(20));
-            assertFalse(owners.getProfileOwnerUserRestrictionsNeedsMigration(21));
-
-            owners.setProfileOwnerUserRestrictionsMigrated(11);
-        }
-    }
-
-    public void testUpgrade05() throws Exception {
-        getContext().addUsers(10, 11, 20, 21);
-
-        // First, migrate.
-        {
-            final OwnersTestable owners = new OwnersTestable(getContext());
-
-            DpmTestUtils.writeToFile(owners.getLegacyConfigFileWithTestOverride(),
-                    DpmTestUtils.readAsset(mRealTestContext, "OwnersTest/test05/input.xml"));
-
-            owners.load();
-
-            // The legacy file should be removed.
-            assertFalse(owners.getLegacyConfigFileWithTestOverride().exists());
-
-            // Note device initializer is no longer supported.  No need to write the DO file.
-            assertFalse(owners.getDeviceOwnerFileWithTestOverride().exists());
-
-            assertFalse(owners.getProfileOwnerFileWithTestOverride(10).exists());
-            assertFalse(owners.getProfileOwnerFileWithTestOverride(11).exists());
-            assertFalse(owners.getProfileOwnerFileWithTestOverride(20).exists());
-
-            assertFalse(owners.hasDeviceOwner());
-            assertEquals(UserHandle.USER_NULL, owners.getDeviceOwnerUserId());
-
-
-            assertNull(owners.getSystemUpdatePolicy());
-            assertEquals(0, owners.getProfileOwnerKeys().size());
-
-            assertFalse(owners.getDeviceOwnerUserRestrictionsNeedsMigration());
-            assertFalse(owners.getProfileOwnerUserRestrictionsNeedsMigration(10));
-            assertFalse(owners.getProfileOwnerUserRestrictionsNeedsMigration(11));
-            assertFalse(owners.getProfileOwnerUserRestrictionsNeedsMigration(20));
-            assertFalse(owners.getProfileOwnerUserRestrictionsNeedsMigration(21));
-        }
-
-        // Then re-read and check.
-        {
-            final OwnersTestable owners = new OwnersTestable(getContext());
-            owners.load();
-
-            assertFalse(owners.hasDeviceOwner());
-            assertEquals(UserHandle.USER_NULL, owners.getDeviceOwnerUserId());
-
-
-            assertNull(owners.getSystemUpdatePolicy());
-            assertEquals(0, owners.getProfileOwnerKeys().size());
-
-            assertFalse(owners.getDeviceOwnerUserRestrictionsNeedsMigration());
-            assertFalse(owners.getProfileOwnerUserRestrictionsNeedsMigration(10));
-            assertFalse(owners.getProfileOwnerUserRestrictionsNeedsMigration(11));
-            assertFalse(owners.getProfileOwnerUserRestrictionsNeedsMigration(20));
-            assertFalse(owners.getProfileOwnerUserRestrictionsNeedsMigration(21));
-        }
-    }
-
-    public void testUpgrade06() throws Exception {
-        getContext().addUsers(10, 11, 20, 21);
-
-        // First, migrate.
-        {
-            final OwnersTestable owners = new OwnersTestable(getContext());
-
-            DpmTestUtils.writeToFile(owners.getLegacyConfigFileWithTestOverride(),
-                    DpmTestUtils.readAsset(mRealTestContext, "OwnersTest/test06/input.xml"));
-
-            owners.load();
-
-            // The legacy file should be removed.
-            assertFalse(owners.getLegacyConfigFileWithTestOverride().exists());
-
-            assertTrue(owners.getDeviceOwnerFileWithTestOverride().exists());
-
-            assertFalse(owners.getProfileOwnerFileWithTestOverride(10).exists());
-            assertFalse(owners.getProfileOwnerFileWithTestOverride(11).exists());
-            assertFalse(owners.getProfileOwnerFileWithTestOverride(20).exists());
-
-            assertFalse(owners.hasDeviceOwner());
-            assertEquals(UserHandle.USER_NULL, owners.getDeviceOwnerUserId());
-            assertEquals(0, owners.getProfileOwnerKeys().size());
-
-            assertNotNull(owners.getSystemUpdatePolicy());
-            assertEquals(5, owners.getSystemUpdatePolicy().getPolicyType());
-
-            assertFalse(owners.getDeviceOwnerUserRestrictionsNeedsMigration());
-            assertFalse(owners.getProfileOwnerUserRestrictionsNeedsMigration(10));
-            assertFalse(owners.getProfileOwnerUserRestrictionsNeedsMigration(11));
-            assertFalse(owners.getProfileOwnerUserRestrictionsNeedsMigration(20));
-            assertFalse(owners.getProfileOwnerUserRestrictionsNeedsMigration(21));
-        }
-
-        // Then re-read and check.
-        {
-            final OwnersTestable owners = new OwnersTestable(getContext());
-            owners.load();
-
-            assertFalse(owners.hasDeviceOwner());
-            assertEquals(UserHandle.USER_NULL, owners.getDeviceOwnerUserId());
-            assertEquals(0, owners.getProfileOwnerKeys().size());
-
-            assertNotNull(owners.getSystemUpdatePolicy());
-            assertEquals(5, owners.getSystemUpdatePolicy().getPolicyType());
-
-            assertFalse(owners.getDeviceOwnerUserRestrictionsNeedsMigration());
-            assertFalse(owners.getProfileOwnerUserRestrictionsNeedsMigration(10));
-            assertFalse(owners.getProfileOwnerUserRestrictionsNeedsMigration(11));
-            assertFalse(owners.getProfileOwnerUserRestrictionsNeedsMigration(20));
-            assertFalse(owners.getProfileOwnerUserRestrictionsNeedsMigration(21));
-        }
-    }
-
-    public void testRemoveExistingFiles() throws Exception {
-        getContext().addUsers(10, 11, 20, 21);
-
-        final OwnersTestable owners = new OwnersTestable(getContext());
-
-        // First, migrate to create new-style config files.
-        DpmTestUtils.writeToFile(owners.getLegacyConfigFileWithTestOverride(),
-                DpmTestUtils.readAsset(mRealTestContext, "OwnersTest/test04/input.xml"));
-
-        owners.load();
-
-        assertFalse(owners.getLegacyConfigFileWithTestOverride().exists());
-
-        assertTrue(owners.getDeviceOwnerFileWithTestOverride().exists());
-        assertTrue(owners.getProfileOwnerFileWithTestOverride(10).exists());
-        assertTrue(owners.getProfileOwnerFileWithTestOverride(11).exists());
-
-        // Then clear all information and save.
-        owners.clearDeviceOwner();
-        owners.clearSystemUpdatePolicy();
-        owners.removeProfileOwner(10);
-        owners.removeProfileOwner(11);
-
-        owners.writeDeviceOwner();
-        owners.writeProfileOwner(10);
-        owners.writeProfileOwner(11);
-        owners.writeProfileOwner(20);
-        owners.writeProfileOwner(21);
-
-        // Now all files should be removed.
-        assertFalse(owners.getDeviceOwnerFileWithTestOverride().exists());
-        assertFalse(owners.getProfileOwnerFileWithTestOverride(10).exists());
-        assertFalse(owners.getProfileOwnerFileWithTestOverride(11).exists());
-    }
-}
diff --git a/services/tests/servicestests/src/com/android/server/job/JobStoreTest.java b/services/tests/servicestests/src/com/android/server/job/JobStoreTest.java
deleted file mode 100644
index edbff83736a..00000000000
--- a/services/tests/servicestests/src/com/android/server/job/JobStoreTest.java
+++ /dev/null
@@ -1,312 +0,0 @@
-package com.android.server.job;
-
-
-import android.content.ComponentName;
-import android.content.Context;
-import android.app.job.JobInfo;
-import android.app.job.JobInfo.Builder;
-import android.os.PersistableBundle;
-import android.os.SystemClock;
-import android.test.AndroidTestCase;
-import android.test.RenamingDelegatingContext;
-import android.util.Log;
-import android.util.ArraySet;
-
-import com.android.server.job.JobStore.JobSet;
-import com.android.server.job.controllers.JobStatus;
-
-import java.util.Iterator;
-
-/**
- * Test reading and writing correctly from file.
- */
-public class JobStoreTest extends AndroidTestCase {
-    private static final String TAG = "TaskStoreTest";
-    private static final String TEST_PREFIX = "_test_";
-
-    private static final int SOME_UID = 34234;
-    private ComponentName mComponent;
-    private static final long IO_WAIT = 1000L;
-
-    JobStore mTaskStoreUnderTest;
-    Context mTestContext;
-
-    @Override
-    public void setUp() throws Exception {
-        mTestContext = new RenamingDelegatingContext(getContext(), TEST_PREFIX);
-        Log.d(TAG, "Saving tasks to '" + mTestContext.getFilesDir() + "'");
-        mTaskStoreUnderTest =
-                JobStore.initAndGetForTesting(mTestContext, mTestContext.getFilesDir());
-        mComponent = new ComponentName(getContext().getPackageName(), StubClass.class.getName());
-    }
-
-    @Override
-    public void tearDown() throws Exception {
-        mTaskStoreUnderTest.clear();
-    }
-
-    public void testMaybeWriteStatusToDisk() throws Exception {
-        int taskId = 5;
-        long runByMillis = 20000L; // 20s
-        long runFromMillis = 2000L; // 2s
-        long initialBackoff = 10000L; // 10s
-
-        final JobInfo task = new Builder(taskId, mComponent)
-                .setRequiresCharging(true)
-                .setRequiredNetworkType(JobInfo.NETWORK_TYPE_ANY)
-                .setBackoffCriteria(initialBackoff, JobInfo.BACKOFF_POLICY_EXPONENTIAL)
-                .setOverrideDeadline(runByMillis)
-                .setMinimumLatency(runFromMillis)
-                .setPersisted(true)
-                .build();
-        final JobStatus ts = JobStatus.createFromJobInfo(task, SOME_UID, null, -1, null);
-        mTaskStoreUnderTest.add(ts);
-        Thread.sleep(IO_WAIT);
-        // Manually load tasks from xml file.
-        final JobSet jobStatusSet = new JobSet();
-        mTaskStoreUnderTest.readJobMapFromDisk(jobStatusSet);
-
-        assertEquals("Didn't get expected number of persisted tasks.", 1, jobStatusSet.size());
-        final JobStatus loadedTaskStatus = jobStatusSet.getAllJobs().get(0);
-        assertTasksEqual(task, loadedTaskStatus.getJob());
-        assertTrue("JobStore#contains invalid.", mTaskStoreUnderTest.containsJob(ts));
-        assertEquals("Different uids.", SOME_UID, loadedTaskStatus.getUid());
-        compareTimestampsSubjectToIoLatency("Early run-times not the same after read.",
-                ts.getEarliestRunTime(), loadedTaskStatus.getEarliestRunTime());
-        compareTimestampsSubjectToIoLatency("Late run-times not the same after read.",
-                ts.getLatestRunTimeElapsed(), loadedTaskStatus.getLatestRunTimeElapsed());
-
-    }
-
-    public void testWritingTwoFilesToDisk() throws Exception {
-        final JobInfo task1 = new Builder(8, mComponent)
-                .setRequiresDeviceIdle(true)
-                .setPeriodic(10000L)
-                .setRequiresCharging(true)
-                .setPersisted(true)
-                .build();
-        final JobInfo task2 = new Builder(12, mComponent)
-                .setMinimumLatency(5000L)
-                .setBackoffCriteria(15000L, JobInfo.BACKOFF_POLICY_LINEAR)
-                .setOverrideDeadline(30000L)
-                .setRequiredNetworkType(JobInfo.NETWORK_TYPE_UNMETERED)
-                .setPersisted(true)
-                .build();
-        final JobStatus taskStatus1 = JobStatus.createFromJobInfo(task1, SOME_UID, null, -1, null);
-        final JobStatus taskStatus2 = JobStatus.createFromJobInfo(task2, SOME_UID, null, -1, null);
-        mTaskStoreUnderTest.add(taskStatus1);
-        mTaskStoreUnderTest.add(taskStatus2);
-        Thread.sleep(IO_WAIT);
-
-        final JobSet jobStatusSet = new JobSet();
-        mTaskStoreUnderTest.readJobMapFromDisk(jobStatusSet);
-        assertEquals("Incorrect # of persisted tasks.", 2, jobStatusSet.size());
-        Iterator<JobStatus> it = jobStatusSet.getAllJobs().iterator();
-        JobStatus loaded1 = it.next();
-        JobStatus loaded2 = it.next();
-
-        // Reverse them so we know which comparison to make.
-        if (loaded1.getJobId() != 8) {
-            JobStatus tmp = loaded1;
-            loaded1 = loaded2;
-            loaded2 = tmp;
-        }
-
-        assertTasksEqual(task1, loaded1.getJob());
-        assertTasksEqual(task2, loaded2.getJob());
-        assertTrue("JobStore#contains invalid.", mTaskStoreUnderTest.containsJob(taskStatus1));
-        assertTrue("JobStore#contains invalid.", mTaskStoreUnderTest.containsJob(taskStatus2));
-        // Check that the loaded task has the correct runtimes.
-        compareTimestampsSubjectToIoLatency("Early run-times not the same after read.",
-                taskStatus1.getEarliestRunTime(), loaded1.getEarliestRunTime());
-        compareTimestampsSubjectToIoLatency("Late run-times not the same after read.",
-                taskStatus1.getLatestRunTimeElapsed(), loaded1.getLatestRunTimeElapsed());
-        compareTimestampsSubjectToIoLatency("Early run-times not the same after read.",
-                taskStatus2.getEarliestRunTime(), loaded2.getEarliestRunTime());
-        compareTimestampsSubjectToIoLatency("Late run-times not the same after read.",
-                taskStatus2.getLatestRunTimeElapsed(), loaded2.getLatestRunTimeElapsed());
-
-    }
-
-    public void testWritingTaskWithExtras() throws Exception {
-        JobInfo.Builder b = new Builder(8, mComponent)
-                .setRequiresDeviceIdle(true)
-                .setPeriodic(10000L)
-                .setRequiresCharging(true)
-                .setPersisted(true);
-
-        PersistableBundle extras = new PersistableBundle();
-        extras.putDouble("hello", 3.2);
-        extras.putString("hi", "there");
-        extras.putInt("into", 3);
-        b.setExtras(extras);
-        final JobInfo task = b.build();
-        JobStatus taskStatus = JobStatus.createFromJobInfo(task, SOME_UID, null, -1, null);
-
-        mTaskStoreUnderTest.add(taskStatus);
-        Thread.sleep(IO_WAIT);
-
-        final JobSet jobStatusSet = new JobSet();
-        mTaskStoreUnderTest.readJobMapFromDisk(jobStatusSet);
-        assertEquals("Incorrect # of persisted tasks.", 1, jobStatusSet.size());
-        JobStatus loaded = jobStatusSet.getAllJobs().iterator().next();
-        assertTasksEqual(task, loaded.getJob());
-    }
-    public void testWritingTaskWithSourcePackage() throws Exception {
-        JobInfo.Builder b = new Builder(8, mComponent)
-                .setRequiresDeviceIdle(true)
-                .setPeriodic(10000L)
-                .setRequiresCharging(true)
-                .setPersisted(true);
-        JobStatus taskStatus = JobStatus.createFromJobInfo(b.build(), SOME_UID,
-                "com.google.android.gms", 0, null);
-
-        mTaskStoreUnderTest.add(taskStatus);
-        Thread.sleep(IO_WAIT);
-
-        final JobSet jobStatusSet = new JobSet();
-        mTaskStoreUnderTest.readJobMapFromDisk(jobStatusSet);
-        assertEquals("Incorrect # of persisted tasks.", 1, jobStatusSet.size());
-        JobStatus loaded = jobStatusSet.getAllJobs().iterator().next();
-        assertEquals("Source package not equal.", loaded.getSourcePackageName(),
-                taskStatus.getSourcePackageName());
-        assertEquals("Source user not equal.", loaded.getSourceUserId(),
-                taskStatus.getSourceUserId());
-    }
-
-    public void testWritingTaskWithFlex() throws Exception {
-        JobInfo.Builder b = new Builder(8, mComponent)
-                .setRequiresDeviceIdle(true)
-                .setPeriodic(5*60*60*1000, 1*60*60*1000)
-                .setRequiresCharging(true)
-                .setPersisted(true);
-        JobStatus taskStatus = JobStatus.createFromJobInfo(b.build(), SOME_UID, null, -1, null);
-
-        mTaskStoreUnderTest.add(taskStatus);
-        Thread.sleep(IO_WAIT);
-
-        final JobSet jobStatusSet = new JobSet();
-        mTaskStoreUnderTest.readJobMapFromDisk(jobStatusSet);
-        assertEquals("Incorrect # of persisted tasks.", 1, jobStatusSet.size());
-        JobStatus loaded = jobStatusSet.getAllJobs().iterator().next();
-        assertEquals("Period not equal.", loaded.getJob().getIntervalMillis(),
-                taskStatus.getJob().getIntervalMillis());
-        assertEquals("Flex not equal.", loaded.getJob().getFlexMillis(),
-                taskStatus.getJob().getFlexMillis());
-    }
-
-    public void testMassivePeriodClampedOnRead() throws Exception {
-        final long ONE_HOUR = 60*60*1000L; // flex
-        final long TWO_HOURS = 2 * ONE_HOUR; // period
-        JobInfo.Builder b = new Builder(8, mComponent)
-                .setPeriodic(TWO_HOURS, ONE_HOUR)
-                .setPersisted(true);
-        final long invalidLateRuntimeElapsedMillis =
-                SystemClock.elapsedRealtime() + (TWO_HOURS * ONE_HOUR) + TWO_HOURS;  // > period+flex
-        final long invalidEarlyRuntimeElapsedMillis =
-                invalidLateRuntimeElapsedMillis - TWO_HOURS;  // Early is (late - period).
-        final JobStatus js = new JobStatus(b.build(), SOME_UID, "somePackage",
-                0 /* sourceUserId */, "someTag",
-                invalidEarlyRuntimeElapsedMillis, invalidLateRuntimeElapsedMillis);
-
-        mTaskStoreUnderTest.add(js);
-        Thread.sleep(IO_WAIT);
-
-        final JobSet jobStatusSet = new JobSet();
-        mTaskStoreUnderTest.readJobMapFromDisk(jobStatusSet);
-        assertEquals("Incorrect # of persisted tasks.", 1, jobStatusSet.size());
-        JobStatus loaded = jobStatusSet.getAllJobs().iterator().next();
-
-        // Assert early runtime was clamped to be under now + period. We can do <= here b/c we'll
-        // call SystemClock.elapsedRealtime after doing the disk i/o.
-        final long newNowElapsed = SystemClock.elapsedRealtime();
-        assertTrue("Early runtime wasn't correctly clamped.",
-                loaded.getEarliestRunTime() <= newNowElapsed + TWO_HOURS);
-        // Assert late runtime was clamped to be now + period + flex.
-        assertTrue("Early runtime wasn't correctly clamped.",
-                loaded.getEarliestRunTime() <= newNowElapsed + TWO_HOURS + ONE_HOUR);
-    }
-
-    public void testPriorityPersisted() throws Exception {
-        JobInfo.Builder b = new Builder(92, mComponent)
-                .setOverrideDeadline(5000)
-                .setPriority(42)
-                .setPersisted(true);
-        final JobStatus js = JobStatus.createFromJobInfo(b.build(), SOME_UID, null, -1, null);
-        mTaskStoreUnderTest.add(js);
-        Thread.sleep(IO_WAIT);
-        final JobSet jobStatusSet = new JobSet();
-        mTaskStoreUnderTest.readJobMapFromDisk(jobStatusSet);
-        JobStatus loaded = jobStatusSet.getAllJobs().iterator().next();
-        assertEquals("Priority not correctly persisted.", 42, loaded.getPriority());
-    }
-
-    /**
-     * Test that non persisted job is not written to disk.
-     */
-    public void testNonPersistedTaskIsNotPersisted() throws Exception {
-        JobInfo.Builder b = new Builder(42, mComponent)
-                .setOverrideDeadline(10000)
-                .setPersisted(false);
-        JobStatus jsNonPersisted = JobStatus.createFromJobInfo(b.build(), SOME_UID, null, -1, null);
-        mTaskStoreUnderTest.add(jsNonPersisted);
-        b = new Builder(43, mComponent)
-                .setOverrideDeadline(10000)
-                .setPersisted(true);
-        JobStatus jsPersisted = JobStatus.createFromJobInfo(b.build(), SOME_UID, null, -1, null);
-        mTaskStoreUnderTest.add(jsPersisted);
-        Thread.sleep(IO_WAIT);
-        final JobSet jobStatusSet = new JobSet();
-        mTaskStoreUnderTest.readJobMapFromDisk(jobStatusSet);
-        assertEquals("Job count is incorrect.", 1, jobStatusSet.size());
-        JobStatus jobStatus = jobStatusSet.getAllJobs().iterator().next();
-        assertEquals("Wrong job persisted.", 43, jobStatus.getJobId());
-    }
-
-    /**
-     * Helper function to throw an error if the provided task and TaskStatus objects are not equal.
-     */
-    private void assertTasksEqual(JobInfo first, JobInfo second) {
-        assertEquals("Different task ids.", first.getId(), second.getId());
-        assertEquals("Different components.", first.getService(), second.getService());
-        assertEquals("Different periodic status.", first.isPeriodic(), second.isPeriodic());
-        assertEquals("Different period.", first.getIntervalMillis(), second.getIntervalMillis());
-        assertEquals("Different inital backoff.", first.getInitialBackoffMillis(),
-                second.getInitialBackoffMillis());
-        assertEquals("Different backoff policy.", first.getBackoffPolicy(),
-                second.getBackoffPolicy());
-
-        assertEquals("Invalid charging constraint.", first.isRequireCharging(),
-                second.isRequireCharging());
-        assertEquals("Invalid idle constraint.", first.isRequireDeviceIdle(),
-                second.isRequireDeviceIdle());
-        assertEquals("Invalid unmetered constraint.",
-                first.getNetworkType() == JobInfo.NETWORK_TYPE_UNMETERED,
-                second.getNetworkType() == JobInfo.NETWORK_TYPE_UNMETERED);
-        assertEquals("Invalid connectivity constraint.",
-                first.getNetworkType() == JobInfo.NETWORK_TYPE_ANY,
-                second.getNetworkType() == JobInfo.NETWORK_TYPE_ANY);
-        assertEquals("Invalid deadline constraint.",
-                first.hasLateConstraint(),
-                second.hasLateConstraint());
-        assertEquals("Invalid delay constraint.",
-                first.hasEarlyConstraint(),
-                second.hasEarlyConstraint());
-        assertEquals("Extras don't match",
-                first.getExtras().toString(), second.getExtras().toString());
-    }
-
-    /**
-     * When comparing timestamps before and after DB read/writes (to make sure we're saving/loading
-     * the correct values), there is some latency involved that terrorises a naive assertEquals().
-     * We define a <code>DELTA_MILLIS</code> as a function variable here to make this comparision
-     * more reasonable.
-     */
-    private void compareTimestampsSubjectToIoLatency(String error, long ts1, long ts2) {
-        final long DELTA_MILLIS = 700L;  // We allow up to 700ms of latency for IO read/writes.
-        assertTrue(error, Math.abs(ts1 - ts2) < DELTA_MILLIS + IO_WAIT);
-    }
-
-    private static class StubClass {}
-
-}
diff --git a/services/tests/servicestests/src/com/android/server/job/MockPriorityJobService.java b/services/tests/servicestests/src/com/android/server/job/MockPriorityJobService.java
deleted file mode 100644
index 3ea86f2e9ac..00000000000
--- a/services/tests/servicestests/src/com/android/server/job/MockPriorityJobService.java
+++ /dev/null
@@ -1,106 +0,0 @@
-/*
- * Copyright (C) 2015 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License
- */
-
-package com.android.server.job;
-
-import android.annotation.TargetApi;
-import android.app.job.JobParameters;
-import android.app.job.JobService;
-import android.util.Log;
-
-import java.util.ArrayList;
-
-@TargetApi(24)
-public class MockPriorityJobService extends JobService {
-    private static final String TAG = "MockPriorityJobService";
-
-    @Override
-    public void onCreate() {
-        super.onCreate();
-        Log.e(TAG, "Created test service.");
-    }
-
-    @Override
-    public boolean onStartJob(JobParameters params) {
-        Log.i(TAG, "Test job executing: " + params.getJobId());
-        TestEnvironment.getTestEnvironment().executedEvents.add(
-                new TestEnvironment.Event(TestEnvironment.EVENT_START_JOB, params.getJobId()));
-        return true;  // Job not finished
-    }
-
-    @Override
-    public boolean onStopJob(JobParameters params) {
-        Log.i(TAG, "Test job stop executing: " + params.getJobId());
-        int reason = params.getStopReason();
-        int event = TestEnvironment.EVENT_STOP_JOB;
-        Log.d(TAG, "stop reason: " + String.valueOf(reason));
-        if (reason == JobParameters.REASON_PREEMPT) {
-            event = TestEnvironment.EVENT_PREEMPT_JOB;
-            Log.d(TAG, "preempted " + String.valueOf(params.getJobId()));
-        }
-        TestEnvironment.getTestEnvironment().executedEvents
-                .add(new TestEnvironment.Event(event, params.getJobId()));
-        return false;  // Do not reschedule
-    }
-
-    public static class TestEnvironment {
-
-        public static final int EVENT_START_JOB = 0;
-        public static final int EVENT_PREEMPT_JOB = 1;
-        public static final int EVENT_STOP_JOB = 2;
-
-        private static TestEnvironment kTestEnvironment;
-
-        private ArrayList<Event> executedEvents = new ArrayList<Event>();
-
-        public static TestEnvironment getTestEnvironment() {
-            if (kTestEnvironment == null) {
-                kTestEnvironment = new TestEnvironment();
-            }
-            return kTestEnvironment;
-        }
-
-        public static class Event {
-            public int event;
-            public int jobId;
-
-            public Event() {
-            }
-
-            public Event(int event, int jobId) {
-                this.event = event;
-                this.jobId = jobId;
-            }
-
-            @Override
-            public boolean equals(Object other) {
-                if (other instanceof Event) {
-                    Event otherEvent = (Event) other;
-                    return otherEvent.event == event && otherEvent.jobId == jobId;
-                }
-                return false;
-            }
-        }
-
-        public void setUp() {
-            executedEvents.clear();
-        }
-
-        public ArrayList<Event> getExecutedEvents() {
-            return executedEvents;
-        }
-    }
-}
diff --git a/services/tests/servicestests/src/com/android/server/job/PrioritySchedulingTest.java b/services/tests/servicestests/src/com/android/server/job/PrioritySchedulingTest.java
deleted file mode 100644
index 63bccfa0141..00000000000
--- a/services/tests/servicestests/src/com/android/server/job/PrioritySchedulingTest.java
+++ /dev/null
@@ -1,119 +0,0 @@
-/*
- * Copyright (C) 2015 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License
- */
-
-package com.android.server.job;
-
-import android.annotation.TargetApi;
-import android.app.job.JobInfo;
-import android.app.job.JobScheduler;
-import android.content.ComponentName;
-import android.content.Context;
-import android.test.AndroidTestCase;
-import com.android.server.job.MockPriorityJobService.TestEnvironment;
-import com.android.server.job.MockPriorityJobService.TestEnvironment.Event;
-
-import java.util.ArrayList;
-
-@TargetApi(24)
-public class PrioritySchedulingTest extends AndroidTestCase {
-    /** Environment that notifies of JobScheduler callbacks. */
-    static TestEnvironment kTestEnvironment = TestEnvironment.getTestEnvironment();
-    /** Handle for the service which receives the execution callbacks from the JobScheduler. */
-    static ComponentName kJobServiceComponent;
-    JobScheduler mJobScheduler;
-
-    @Override
-    public void setUp() throws Exception {
-        super.setUp();
-        kTestEnvironment.setUp();
-        kJobServiceComponent = new ComponentName(getContext(), MockPriorityJobService.class);
-        mJobScheduler = (JobScheduler) getContext().getSystemService(Context.JOB_SCHEDULER_SERVICE);
-        mJobScheduler.cancelAll();
-    }
-
-    @Override
-    public void tearDown() throws Exception {
-        mJobScheduler.cancelAll();
-        super.tearDown();
-    }
-
-    public void testLowerPriorityJobPreempted() throws Exception {
-        JobInfo job1 = new JobInfo.Builder(111, kJobServiceComponent)
-                .setPriority(1)
-                .setOverrideDeadline(7000L)
-                .build();
-        JobInfo job2 = new JobInfo.Builder(222, kJobServiceComponent)
-                .setPriority(1)
-                .setOverrideDeadline(7000L)
-                .build();
-        JobInfo job3 = new JobInfo.Builder(333, kJobServiceComponent)
-                .setPriority(1)
-                .setOverrideDeadline(7000L)
-                .build();
-        JobInfo job4 = new JobInfo.Builder(444, kJobServiceComponent)
-                .setPriority(2)
-                .setMinimumLatency(2000L)
-                .setOverrideDeadline(7000L)
-                .build();
-        mJobScheduler.schedule(job1);
-        mJobScheduler.schedule(job2);
-        mJobScheduler.schedule(job3);
-        mJobScheduler.schedule(job4);
-        Thread.sleep(10000);  // Wait for job 4 to preempt one of the lower priority jobs
-
-        Event job4Execution = new Event(TestEnvironment.EVENT_START_JOB, 444);
-        ArrayList<Event> executedEvents = kTestEnvironment.getExecutedEvents();
-        boolean wasJob4Executed = executedEvents.contains(job4Execution);
-        boolean wasSomeJobPreempted = false;
-        for (Event event: executedEvents) {
-            if (event.event == TestEnvironment.EVENT_PREEMPT_JOB) {
-                wasSomeJobPreempted = true;
-                break;
-            }
-        }
-        assertTrue("No job was preempted.", wasSomeJobPreempted);
-        assertTrue("Lower priority jobs were not preempted.",  wasJob4Executed);
-    }
-
-    public void testHigherPriorityJobNotPreempted() throws Exception {
-        JobInfo job1 = new JobInfo.Builder(111, kJobServiceComponent)
-                .setPriority(2)
-                .setOverrideDeadline(7000L)
-                .build();
-        JobInfo job2 = new JobInfo.Builder(222, kJobServiceComponent)
-                .setPriority(2)
-                .setOverrideDeadline(7000L)
-                .build();
-        JobInfo job3 = new JobInfo.Builder(333, kJobServiceComponent)
-                .setPriority(2)
-                .setOverrideDeadline(7000L)
-                .build();
-        JobInfo job4 = new JobInfo.Builder(444, kJobServiceComponent)
-                .setPriority(1)
-                .setMinimumLatency(2000L)
-                .setOverrideDeadline(7000L)
-                .build();
-        mJobScheduler.schedule(job1);
-        mJobScheduler.schedule(job2);
-        mJobScheduler.schedule(job3);
-        mJobScheduler.schedule(job4);
-        Thread.sleep(10000);  // Wait for job 4 to preempt one of the higher priority jobs
-
-        Event job4Execution = new Event(TestEnvironment.EVENT_START_JOB, 444);
-        boolean wasJob4Executed = kTestEnvironment.getExecutedEvents().contains(job4Execution);
-        assertFalse("Higher priority job was preempted.", wasJob4Executed);
-    }
-}
diff --git a/services/tests/servicestests/src/com/android/server/location/ComprehensiveCountryDetectorTest.java b/services/tests/servicestests/src/com/android/server/location/ComprehensiveCountryDetectorTest.java
deleted file mode 100644
index 98966c032d1..00000000000
--- a/services/tests/servicestests/src/com/android/server/location/ComprehensiveCountryDetectorTest.java
+++ /dev/null
@@ -1,299 +0,0 @@
-/*
- * Copyright (C) 2010 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License
- */
-
-package com.android.server.location;
-
-import android.location.Country;
-import android.location.CountryListener;
-import android.test.AndroidTestCase;
-
-public class ComprehensiveCountryDetectorTest extends AndroidTestCase {
-    private class TestCountryDetector extends ComprehensiveCountryDetector {
-        public final static String COUNTRY_ISO = "us";
-        private boolean mLocationBasedDetectorStarted;
-        private boolean mLocationBasedDetectorStopped;
-        protected boolean mNotified;
-        private boolean listenerAdded = false;
-
-        private Country mNotifiedCountry;
-        public TestCountryDetector() {
-            super(getContext());
-        }
-
-        public void notifyLocationBasedListener(Country country) {
-            mNotified = true;
-            mNotifiedCountry = country;
-            mLocationBasedCountryDetector.notifyListener(country);
-        }
-
-        public boolean locationBasedDetectorStarted() {
-            return mLocationBasedCountryDetector != null && mLocationBasedDetectorStarted;
-        }
-
-        public boolean locationBasedDetectorStopped() {
-            return mLocationBasedCountryDetector == null && mLocationBasedDetectorStopped;
-        }
-
-        public boolean locationRefreshStarted() {
-            return mLocationRefreshTimer != null;
-        }
-
-        public boolean locationRefreshCancelled() {
-            return mLocationRefreshTimer == null;
-        }
-
-        @Override
-        protected CountryDetectorBase createLocationBasedCountryDetector() {
-            return new CountryDetectorBase(mContext) {
-                @Override
-                public Country detectCountry() {
-                    mLocationBasedDetectorStarted = true;
-                    return null;
-                }
-
-                @Override
-                public void stop() {
-                    mLocationBasedDetectorStopped = true;
-                }
-            };
-        }
-
-        @Override
-        protected Country getNetworkBasedCountry() {
-            return null;
-        }
-
-        @Override
-        protected Country getLastKnownLocationBasedCountry() {
-            return mNotifiedCountry;
-        }
-
-        @Override
-        protected Country getSimBasedCountry() {
-            return null;
-        }
-
-        @Override
-        protected Country getLocaleCountry() {
-            return null;
-        }
-
-        @Override
-        protected void runAfterDetectionAsync(final Country country, final Country detectedCountry,
-                final boolean notifyChange, final boolean startLocationBasedDetection) {
-            runAfterDetection(country, detectedCountry, notifyChange, startLocationBasedDetection);
-        };
-
-        @Override
-        protected boolean isAirplaneModeOff() {
-            return true;
-        }
-
-        @Override
-        protected synchronized void addPhoneStateListener() {
-            listenerAdded = true;
-        }
-
-        @Override
-        protected synchronized void removePhoneStateListener() {
-            listenerAdded = false;
-        }
-
-        @Override
-        protected boolean isGeoCoderImplemented() {
-            return true;
-        }
-
-        public boolean isPhoneStateListenerAdded() {
-            return listenerAdded;
-        }
-    }
-
-    private class CountryListenerImpl implements CountryListener {
-        private boolean mNotified;
-        private Country mCountry;
-
-        public void onCountryDetected(Country country) {
-            mNotified = true;
-            mCountry = country;
-        }
-
-        public boolean notified() {
-            return mNotified;
-        }
-
-        public Country getCountry() {
-            return mCountry;
-        }
-    }
-
-    public void testDetectNetworkBasedCountry() {
-        final Country resultCountry = new Country(
-                TestCountryDetector.COUNTRY_ISO, Country.COUNTRY_SOURCE_NETWORK);
-        TestCountryDetector countryDetector = new TestCountryDetector() {
-            @Override
-            protected Country getNetworkBasedCountry() {
-                return resultCountry;
-            }
-        };
-        CountryListenerImpl listener = new CountryListenerImpl();
-        countryDetector.setCountryListener(listener);
-        Country country = countryDetector.detectCountry();
-        assertTrue(sameCountry(country, resultCountry));
-        assertFalse(listener.notified());
-        assertFalse(countryDetector.locationBasedDetectorStarted());
-        assertFalse(countryDetector.locationRefreshStarted());
-        countryDetector.stop();
-    }
-
-    public void testDetectLocationBasedCountry() {
-        final Country resultCountry = new Country(
-                TestCountryDetector.COUNTRY_ISO, Country.COUNTRY_SOURCE_SIM);
-        final Country locationBasedCountry = new Country(
-                TestCountryDetector.COUNTRY_ISO, Country.COUNTRY_SOURCE_LOCATION);
-        TestCountryDetector countryDetector = new TestCountryDetector() {
-            @Override
-            protected Country getSimBasedCountry() {
-                return resultCountry;
-            }
-        };
-        CountryListenerImpl listener = new CountryListenerImpl();
-        countryDetector.setCountryListener(listener);
-        Country country = countryDetector.detectCountry();
-        assertTrue(sameCountry(country, resultCountry));
-        assertTrue(countryDetector.locationBasedDetectorStarted());
-        countryDetector.notifyLocationBasedListener(locationBasedCountry);
-        assertTrue(listener.notified());
-        assertTrue(sameCountry(listener.getCountry(), locationBasedCountry));
-        assertTrue(countryDetector.locationBasedDetectorStopped());
-        assertTrue(countryDetector.locationRefreshStarted());
-        countryDetector.stop();
-        assertTrue(countryDetector.locationRefreshCancelled());
-    }
-
-    public void testLocaleBasedCountry() {
-        final Country resultCountry = new Country(
-                TestCountryDetector.COUNTRY_ISO, Country.COUNTRY_SOURCE_LOCALE);
-        TestCountryDetector countryDetector = new TestCountryDetector() {
-            @Override
-            protected Country getLocaleCountry() {
-                return resultCountry;
-            }
-        };
-        CountryListenerImpl listener = new CountryListenerImpl();
-        countryDetector.setCountryListener(listener);
-        Country country = countryDetector.detectCountry();
-        assertTrue(sameCountry(country, resultCountry));
-        assertFalse(listener.notified());
-        assertTrue(countryDetector.locationBasedDetectorStarted());
-        assertTrue(countryDetector.locationRefreshStarted());
-        countryDetector.stop();
-        assertTrue(countryDetector.locationRefreshCancelled());
-    }
-
-    public void testStoppingDetector() {
-        // Test stopping detector when LocationBasedCountryDetector was started
-        final Country resultCountry = new Country(
-                TestCountryDetector.COUNTRY_ISO, Country.COUNTRY_SOURCE_SIM);
-        TestCountryDetector countryDetector = new TestCountryDetector() {
-            @Override
-            protected Country getSimBasedCountry() {
-                return resultCountry;
-            }
-        };
-        CountryListenerImpl listener = new CountryListenerImpl();
-        countryDetector.setCountryListener(listener);
-        Country country = countryDetector.detectCountry();
-        assertTrue(sameCountry(country, resultCountry));
-        assertTrue(countryDetector.locationBasedDetectorStarted());
-        countryDetector.stop();
-        // The LocationBasedDetector should be stopped.
-        assertTrue(countryDetector.locationBasedDetectorStopped());
-        // The location refresh should not running.
-        assertTrue(countryDetector.locationRefreshCancelled());
-    }
-
-    public void testLocationBasedCountryNotFound() {
-        final Country resultCountry = new Country(
-                TestCountryDetector.COUNTRY_ISO, Country.COUNTRY_SOURCE_SIM);
-        TestCountryDetector countryDetector = new TestCountryDetector() {
-            @Override
-            protected Country getSimBasedCountry() {
-                return resultCountry;
-            }
-        };
-        CountryListenerImpl listener = new CountryListenerImpl();
-        countryDetector.setCountryListener(listener);
-        Country country = countryDetector.detectCountry();
-        assertTrue(sameCountry(country, resultCountry));
-        assertTrue(countryDetector.locationBasedDetectorStarted());
-        countryDetector.notifyLocationBasedListener(null);
-        assertFalse(listener.notified());
-        assertTrue(sameCountry(listener.getCountry(), null));
-        assertTrue(countryDetector.locationBasedDetectorStopped());
-        assertTrue(countryDetector.locationRefreshStarted());
-        countryDetector.stop();
-        assertTrue(countryDetector.locationRefreshCancelled());
-    }
-
-    public void testNoCountryFound() {
-        TestCountryDetector countryDetector = new TestCountryDetector();
-        CountryListenerImpl listener = new CountryListenerImpl();
-        countryDetector.setCountryListener(listener);
-        Country country = countryDetector.detectCountry();
-        assertTrue(sameCountry(country, null));
-        assertTrue(countryDetector.locationBasedDetectorStarted());
-        countryDetector.notifyLocationBasedListener(null);
-        assertFalse(listener.notified());
-        assertTrue(sameCountry(listener.getCountry(), null));
-        assertTrue(countryDetector.locationBasedDetectorStopped());
-        assertTrue(countryDetector.locationRefreshStarted());
-        countryDetector.stop();
-        assertTrue(countryDetector.locationRefreshCancelled());
-    }
-
-    public void testAddRemoveListener() {
-        TestCountryDetector countryDetector = new TestCountryDetector();
-        CountryListenerImpl listener = new CountryListenerImpl();
-        countryDetector.setCountryListener(listener);
-        assertTrue(countryDetector.isPhoneStateListenerAdded());
-        assertTrue(countryDetector.locationBasedDetectorStarted());
-        countryDetector.setCountryListener(null);
-        assertFalse(countryDetector.isPhoneStateListenerAdded());
-        assertTrue(countryDetector.locationBasedDetectorStopped());
-    }
-
-    public void testGeocoderNotImplemented() {
-        TestCountryDetector countryDetector = new TestCountryDetector() {
-            @Override
-            protected boolean isGeoCoderImplemented() {
-                return false;
-            }
-        };
-        CountryListenerImpl listener = new CountryListenerImpl();
-        countryDetector.setCountryListener(listener);
-        assertTrue(countryDetector.isPhoneStateListenerAdded());
-        assertFalse(countryDetector.locationBasedDetectorStarted());
-        countryDetector.setCountryListener(null);
-        assertFalse(countryDetector.isPhoneStateListenerAdded());
-    }
-
-    private boolean sameCountry(Country country1, Country country2) {
-        return country1 == null && country2 == null || country1 != null && country2 != null &&
-        country1.getCountryIso().equalsIgnoreCase(country2.getCountryIso()) &&
-        country1.getSource() == country2.getSource();
-    }
-}
diff --git a/services/tests/servicestests/src/com/android/server/location/LocationBasedCountryDetectorTest.java b/services/tests/servicestests/src/com/android/server/location/LocationBasedCountryDetectorTest.java
deleted file mode 100644
index 5f5d6684f38..00000000000
--- a/services/tests/servicestests/src/com/android/server/location/LocationBasedCountryDetectorTest.java
+++ /dev/null
@@ -1,379 +0,0 @@
-/*
- * Copyright (C) 2010 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License
- */
-package com.android.server.location;
-
-import android.location.Country;
-import android.location.CountryListener;
-import android.location.Location;
-import android.location.LocationListener;
-import android.location.LocationManager;
-import android.test.AndroidTestCase;
-
-import java.util.Arrays;
-import java.util.HashMap;
-import java.util.HashSet;
-import java.util.List;
-import java.util.Map;
-import java.util.Map.Entry;
-import java.util.Set;
-import java.util.Timer;
-
-public class LocationBasedCountryDetectorTest extends AndroidTestCase {
-    private static final List<String> sEnabledProviders = Arrays.asList(
-            LocationManager.GPS_PROVIDER, LocationManager.PASSIVE_PROVIDER);
-    private class TestCountryDetector extends LocationBasedCountryDetector {
-        public static final int TOTAL_PROVIDERS = 2;
-        protected Object countryFoundLocker = new Object();
-        protected boolean notifyCountry = false;
-        private final Location mLocation;
-        private final String mCountry;
-        private final long mQueryLocationTimeout;
-        private Map<String, LocationListener> mListeners;
-
-        public TestCountryDetector(String country, String provider) {
-            this(country, provider, 1000 * 60 * 5);
-        }
-
-        public TestCountryDetector(String country, String provider, long queryLocationTimeout) {
-            super(getContext());
-            mCountry = country;
-            mLocation = new Location(provider);
-            mQueryLocationTimeout = queryLocationTimeout;
-            mListeners = new HashMap<String, LocationListener>();
-        }
-
-        @Override
-        protected String getCountryFromLocation(Location location) {
-            synchronized (countryFoundLocker) {
-                if (!notifyCountry) {
-                    try {
-                        countryFoundLocker.wait();
-                    } catch (InterruptedException e) {
-                    }
-                }
-            }
-            if (mLocation.getProvider().endsWith(location.getProvider())) {
-                return mCountry;
-            } else {
-                return null;
-            }
-        }
-
-        @Override
-        protected Location getLastKnownLocation() {
-            return mLocation;
-        }
-
-        private Set<String> mAcceptableProviders;
-
-        public void setAcceptableProvider(Set<String> acceptableProviders) {
-            mAcceptableProviders = acceptableProviders;
-        }
-
-        @Override
-        protected boolean isAcceptableProvider(String provider) {
-            if (mAcceptableProviders != null) {
-                return mAcceptableProviders.contains(provider);
-            } else {
-                return true;
-            }
-        }
-
-        @Override
-        protected void registerListener(String provider, LocationListener listener) {
-            assertNotNull(provider);
-            mListeners.put(provider, listener);
-        }
-
-        @Override
-        protected void unregisterListener(LocationListener listener) {
-            for (Entry<String, LocationListener> entry : mListeners.entrySet()) {
-                if (entry.getValue().equals(listener)) {
-                    mListeners.remove(entry.getKey());
-                    return;
-                }
-            }
-            fail("Not registered");
-        }
-
-        public Map<String, LocationListener> getListeners() {
-            return mListeners;
-        }
-
-        @Override
-        protected long getQueryLocationTimeout() {
-            return mQueryLocationTimeout;
-        }
-
-        @Override
-        protected List<String> getEnabledProviders() {
-            return sEnabledProviders;
-        }
-
-        public void notifyLocationFound() {
-            // Listener could be removed in the notification.
-            LocationListener[] listeners = new LocationListener[mListeners.size()];
-            mLocationListeners.toArray(listeners);
-            for (LocationListener listener :listeners) {
-                listener.onLocationChanged(mLocation);
-            }
-        }
-
-        public int getListenersCount() {
-            return mListeners.size();
-        }
-
-        public void notifyCountryFound() {
-            synchronized (countryFoundLocker) {
-                notifyCountry = true;
-                countryFoundLocker.notify();
-            }
-        }
-
-        public Timer getTimer() {
-            return mTimer;
-        }
-
-        public Thread getQueryThread() {
-            return mQueryThread;
-        }
-    }
-
-    private class CountryListenerImpl implements CountryListener {
-        private boolean mNotified;
-        private String mCountryCode;
-        public void onCountryDetected(Country country) {
-            mNotified = true;
-            if (country != null) {
-                mCountryCode = country.getCountryIso();
-            }
-        }
-
-        public boolean notified() {
-            return mNotified;
-        }
-
-        public String getCountry() {
-            return mCountryCode;
-        }
-    }
-
-    public void testFindingCountry() {
-        testFindingCountryCommon(null);
-    }
-
-    public void testFindingCountryWithAcceptableProvider() {
-        testFindingCountryCommon(new HashSet<String>(Arrays.asList("passive")));
-    }
-
-    private void testFindingCountryCommon(Set<String> acceptableProviders) {
-        final String country = "us";
-        final String provider = "Good";
-        CountryListenerImpl countryListener = new CountryListenerImpl();
-        TestCountryDetector detector = new TestCountryDetector(country, provider);
-
-        if (acceptableProviders != null) {
-            detector.setAcceptableProvider(acceptableProviders);
-        }
-
-        detector.setCountryListener(countryListener);
-        detector.detectCountry();
-
-        if (acceptableProviders != null) {
-            assertEquals(acceptableProviders.size(), detector.getListenersCount());
-            Map<String, LocationListener> listeners = detector.getListeners();
-            for (String acceptableProvider : acceptableProviders) {
-                assertTrue(listeners.containsKey(acceptableProvider));
-            }
-        } else {
-            assertEquals(TestCountryDetector.TOTAL_PROVIDERS, detector.getListenersCount());
-        }
-
-        detector.notifyLocationFound();
-        // All listeners should be unregistered
-        assertEquals(0, detector.getListenersCount());
-        assertNull(detector.getTimer());
-        Thread queryThread = waitForQueryThreadLaunched(detector);
-        detector.notifyCountryFound();
-        // Wait for query thread ending
-        waitForThreadEnding(queryThread);
-        // QueryThread should be set to NULL
-        assertNull(detector.getQueryThread());
-        assertTrue(countryListener.notified());
-        assertEquals("us", countryListener.getCountry().toLowerCase());
-    }
-
-    public void testFindingCountryCancelled() {
-        final String country = "us";
-        final String provider = "Good";
-        CountryListenerImpl countryListener = new CountryListenerImpl();
-        TestCountryDetector detector = new TestCountryDetector(country, provider);
-        detector.setCountryListener(countryListener);
-        detector.detectCountry();
-        assertEquals(TestCountryDetector.TOTAL_PROVIDERS, detector.getListenersCount());
-        detector.notifyLocationFound();
-        // All listeners should be unregistered
-        assertEquals(0, detector.getListenersCount());
-        // The time should be stopped
-        assertNull(detector.getTimer());
-        Thread queryThread = waitForQueryThreadLaunched(detector);
-        detector.stop();
-        // There is no way to stop the thread, let's test it could be stopped, after get country
-        detector.notifyCountryFound();
-        // Wait for query thread ending
-        waitForThreadEnding(queryThread);
-        // QueryThread should be set to NULL
-        assertNull(detector.getQueryThread());
-        assertTrue(countryListener.notified());
-        assertEquals("us", countryListener.getCountry().toLowerCase());
-    }
-
-    public void testFindingLocationCancelled() {
-        final String country = "us";
-        final String provider = "Good";
-        CountryListenerImpl countryListener = new CountryListenerImpl();
-        TestCountryDetector detector = new TestCountryDetector(country, provider);
-        detector.setCountryListener(countryListener);
-        detector.detectCountry();
-        assertEquals(TestCountryDetector.TOTAL_PROVIDERS, detector.getListenersCount());
-        detector.stop();
-        // All listeners should be unregistered
-        assertEquals(0, detector.getListenersCount());
-        // The time should be stopped
-        assertNull(detector.getTimer());
-        // QueryThread should still be NULL
-        assertNull(detector.getQueryThread());
-        assertFalse(countryListener.notified());
-    }
-
-    public void testFindingLocationFailed() {
-        final String country = "us";
-        final String provider = "Good";
-        long timeout = 1000;
-        TestCountryDetector detector = new TestCountryDetector(country, provider, timeout) {
-            @Override
-            protected Location getLastKnownLocation() {
-                return null;
-            }
-        };
-        CountryListenerImpl countryListener = new CountryListenerImpl();
-        detector.setCountryListener(countryListener);
-        detector.detectCountry();
-        assertEquals(TestCountryDetector.TOTAL_PROVIDERS, detector.getListenersCount());
-        waitForTimerReset(detector);
-        // All listeners should be unregistered
-        assertEquals(0, detector.getListenersCount());
-        // QueryThread should still be NULL
-        assertNull(detector.getQueryThread());
-        assertTrue(countryListener.notified());
-        assertNull(countryListener.getCountry());
-    }
-
-    public void testFindingCountryFailed() {
-        final String country = "us";
-        final String provider = "Good";
-        TestCountryDetector detector = new TestCountryDetector(country, provider) {
-            @Override
-            protected String getCountryFromLocation(Location location) {
-                synchronized (countryFoundLocker) {
-                    if (! notifyCountry) {
-                        try {
-                            countryFoundLocker.wait();
-                        } catch (InterruptedException e) {
-                        }
-                    }
-                }
-                // We didn't find country.
-                return null;
-            }
-        };
-        CountryListenerImpl countryListener = new CountryListenerImpl();
-        detector.setCountryListener(countryListener);
-        detector.detectCountry();
-        assertEquals(TestCountryDetector.TOTAL_PROVIDERS, detector.getListenersCount());
-        detector.notifyLocationFound();
-        // All listeners should be unregistered
-        assertEquals(0, detector.getListenersCount());
-        assertNull(detector.getTimer());
-        Thread queryThread = waitForQueryThreadLaunched(detector);
-        detector.notifyCountryFound();
-        // Wait for query thread ending
-        waitForThreadEnding(queryThread);
-        // QueryThread should be set to NULL
-        assertNull(detector.getQueryThread());
-        // CountryListener should be notified
-        assertTrue(countryListener.notified());
-        assertNull(countryListener.getCountry());
-    }
-
-    public void testFindingCountryWithLastKnownLocation() {
-        final String country = "us";
-        final String provider = "Good";
-        long timeout = 1000;
-        TestCountryDetector detector = new TestCountryDetector(country, provider, timeout);
-        CountryListenerImpl countryListener = new CountryListenerImpl();
-        detector.setCountryListener(countryListener);
-        detector.detectCountry();
-        assertEquals(TestCountryDetector.TOTAL_PROVIDERS, detector.getListenersCount());
-        waitForTimerReset(detector);
-        // All listeners should be unregistered
-        assertEquals(0, detector.getListenersCount());
-        Thread queryThread = waitForQueryThreadLaunched(detector);
-        detector.notifyCountryFound();
-        // Wait for query thread ending
-        waitForThreadEnding(queryThread);
-        // QueryThread should be set to NULL
-        assertNull(detector.getQueryThread());
-        // CountryListener should be notified
-        assertTrue(countryListener.notified());
-        assertEquals("us", countryListener.getCountry().toLowerCase());
-    }
-
-    private void waitForTimerReset(TestCountryDetector detector) {
-        int count = 5;
-        long interval = 1000;
-        try {
-            while (count-- > 0 && detector.getTimer() != null) {
-                Thread.sleep(interval);
-            }
-        } catch (InterruptedException e) {
-        }
-        Timer timer = detector.getTimer();
-        assertTrue(timer == null);
-    }
-
-    private void waitForThreadEnding(Thread thread) {
-        try {
-            thread.join(5000);
-        } catch (InterruptedException e) {
-            e.printStackTrace();
-        }
-    }
-
-    private Thread waitForQueryThreadLaunched(TestCountryDetector detector) {
-        int count = 5;
-        long interval = 1000;
-        try {
-            while (count-- > 0 && detector.getQueryThread() == null) {
-                Thread.sleep(interval);
-            }
-        } catch (InterruptedException e) {
-        }
-        Thread thread = detector.getQueryThread();
-        assertTrue(thread != null);
-        return thread;
-    }
-}
diff --git a/services/tests/servicestests/src/com/android/server/location/LocationRequestStatisticsTest.java b/services/tests/servicestests/src/com/android/server/location/LocationRequestStatisticsTest.java
deleted file mode 100644
index 33f604d9914..00000000000
--- a/services/tests/servicestests/src/com/android/server/location/LocationRequestStatisticsTest.java
+++ /dev/null
@@ -1,175 +0,0 @@
-package com.android.server.location;
-
-import com.android.server.location.LocationRequestStatistics.PackageProviderKey;
-import com.android.server.location.LocationRequestStatistics.PackageStatistics;
-
-import android.os.SystemClock;
-import android.test.AndroidTestCase;
-
-/**
- * Unit tests for {@link LocationRequestStatistics}.
- */
-public class LocationRequestStatisticsTest extends AndroidTestCase {
-    private static final String PACKAGE1 = "package1";
-    private static final String PACKAGE2 = "package2";
-    private static final String PROVIDER1 = "provider1";
-    private static final String PROVIDER2 = "provider2";
-    private static final long INTERVAL1 = 5000;
-    private static final long INTERVAL2 = 100000;
-
-    private LocationRequestStatistics mStatistics;
-    private long mStartElapsedRealtimeMs;
-
-    @Override
-    public void setUp() {
-        mStatistics = new LocationRequestStatistics();
-        mStartElapsedRealtimeMs = SystemClock.elapsedRealtime();
-    }
-
-    /**
-     * Tests that adding a single package works correctly.
-     */
-    public void testSinglePackage() {
-        mStatistics.startRequesting(PACKAGE1, PROVIDER1, INTERVAL1);
-
-        assertEquals(1, mStatistics.statistics.size());
-        PackageProviderKey key = mStatistics.statistics.keySet().iterator().next();
-        assertEquals(PACKAGE1, key.packageName);
-        assertEquals(PROVIDER1, key.providerName);
-        PackageStatistics stats = mStatistics.statistics.values().iterator().next();
-        verifyStatisticsTimes(stats);
-        assertEquals(INTERVAL1, stats.getFastestIntervalMs());
-        assertEquals(INTERVAL1, stats.getSlowestIntervalMs());
-        assertTrue(stats.isActive());
-    }
-
-    /**
-     * Tests that adding a single package works correctly when it is stopped and restarted.
-     */
-    public void testSinglePackage_stopAndRestart() {
-        mStatistics.startRequesting(PACKAGE1, PROVIDER1, INTERVAL1);
-        mStatistics.stopRequesting(PACKAGE1, PROVIDER1);
-        mStatistics.startRequesting(PACKAGE1, PROVIDER1, INTERVAL1);
-
-        assertEquals(1, mStatistics.statistics.size());
-        PackageProviderKey key = mStatistics.statistics.keySet().iterator().next();
-        assertEquals(PACKAGE1, key.packageName);
-        assertEquals(PROVIDER1, key.providerName);
-        PackageStatistics stats = mStatistics.statistics.values().iterator().next();
-        verifyStatisticsTimes(stats);
-        assertEquals(INTERVAL1, stats.getFastestIntervalMs());
-        assertEquals(INTERVAL1, stats.getSlowestIntervalMs());
-        assertTrue(stats.isActive());
-
-        mStatistics.stopRequesting(PACKAGE1, PROVIDER1);
-        assertFalse(stats.isActive());
-    }
-
-    /**
-     * Tests that adding a single package works correctly when multiple intervals are used.
-     */
-    public void testSinglePackage_multipleIntervals() {
-        mStatistics.startRequesting(PACKAGE1, PROVIDER1, INTERVAL1);
-        mStatistics.startRequesting(PACKAGE1, PROVIDER1, INTERVAL2);
-
-        assertEquals(1, mStatistics.statistics.size());
-        PackageProviderKey key = mStatistics.statistics.keySet().iterator().next();
-        assertEquals(PACKAGE1, key.packageName);
-        assertEquals(PROVIDER1, key.providerName);
-        PackageStatistics stats = mStatistics.statistics.values().iterator().next();
-        verifyStatisticsTimes(stats);
-        assertEquals(INTERVAL1, stats.getFastestIntervalMs());
-        assertTrue(stats.isActive());
-
-        mStatistics.stopRequesting(PACKAGE1, PROVIDER1);
-        assertTrue(stats.isActive());
-        mStatistics.stopRequesting(PACKAGE1, PROVIDER1);
-        assertFalse(stats.isActive());
-    }
-
-    /**
-     * Tests that adding a single package works correctly when multiple providers are used.
-     */
-    public void testSinglePackage_multipleProviders() {
-        mStatistics.startRequesting(PACKAGE1, PROVIDER1, INTERVAL1);
-        mStatistics.startRequesting(PACKAGE1, PROVIDER2, INTERVAL2);
-
-        assertEquals(2, mStatistics.statistics.size());
-        PackageProviderKey key1 = new PackageProviderKey(PACKAGE1, PROVIDER1);
-        PackageStatistics stats1 = mStatistics.statistics.get(key1);
-        verifyStatisticsTimes(stats1);
-        assertEquals(INTERVAL1, stats1.getSlowestIntervalMs());
-        assertEquals(INTERVAL1, stats1.getFastestIntervalMs());
-        assertTrue(stats1.isActive());
-        PackageProviderKey key2 = new PackageProviderKey(PACKAGE1, PROVIDER2);
-        PackageStatistics stats2 = mStatistics.statistics.get(key2);
-        verifyStatisticsTimes(stats2);
-        assertEquals(INTERVAL2, stats2.getSlowestIntervalMs());
-        assertEquals(INTERVAL2, stats2.getFastestIntervalMs());
-        assertTrue(stats2.isActive());
-
-        mStatistics.stopRequesting(PACKAGE1, PROVIDER1);
-        assertFalse(stats1.isActive());
-        assertTrue(stats2.isActive());
-        mStatistics.stopRequesting(PACKAGE1, PROVIDER2);
-        assertFalse(stats1.isActive());
-        assertFalse(stats2.isActive());
-    }
-
-    /**
-     * Tests that adding multiple packages works correctly.
-     */
-    public void testMultiplePackages() {
-        mStatistics.startRequesting(PACKAGE1, PROVIDER1, INTERVAL1);
-        mStatistics.startRequesting(PACKAGE1, PROVIDER2, INTERVAL1);
-        mStatistics.startRequesting(PACKAGE1, PROVIDER2, INTERVAL2);
-        mStatistics.startRequesting(PACKAGE2, PROVIDER1, INTERVAL1);
-
-        assertEquals(3, mStatistics.statistics.size());
-        PackageProviderKey key1 = new PackageProviderKey(PACKAGE1, PROVIDER1);
-        PackageStatistics stats1 = mStatistics.statistics.get(key1);
-        verifyStatisticsTimes(stats1);
-        assertEquals(INTERVAL1, stats1.getSlowestIntervalMs());
-        assertEquals(INTERVAL1, stats1.getFastestIntervalMs());
-        assertTrue(stats1.isActive());
-
-        PackageProviderKey key2 = new PackageProviderKey(PACKAGE1, PROVIDER2);
-        PackageStatistics stats2 = mStatistics.statistics.get(key2);
-        verifyStatisticsTimes(stats2);
-        assertEquals(INTERVAL2, stats2.getSlowestIntervalMs());
-        assertEquals(INTERVAL1, stats2.getFastestIntervalMs());
-        assertTrue(stats2.isActive());
-
-        PackageProviderKey key3 = new PackageProviderKey(PACKAGE2, PROVIDER1);
-        PackageStatistics stats3 = mStatistics.statistics.get(key3);
-        verifyStatisticsTimes(stats3);
-        assertEquals(INTERVAL1, stats3.getSlowestIntervalMs());
-        assertEquals(INTERVAL1, stats3.getFastestIntervalMs());
-        assertTrue(stats3.isActive());
-
-        mStatistics.stopRequesting(PACKAGE1, PROVIDER1);
-        assertFalse(stats1.isActive());
-        assertTrue(stats2.isActive());
-        assertTrue(stats3.isActive());
-
-        mStatistics.stopRequesting(PACKAGE1, PROVIDER2);
-        assertFalse(stats1.isActive());
-        assertTrue(stats2.isActive());
-        assertTrue(stats3.isActive());
-        mStatistics.stopRequesting(PACKAGE1, PROVIDER2);
-        assertFalse(stats2.isActive());
-
-        mStatistics.stopRequesting(PACKAGE2, PROVIDER1);
-        assertFalse(stats1.isActive());
-        assertFalse(stats2.isActive());
-        assertFalse(stats3.isActive());
-    }
-
-    private void verifyStatisticsTimes(PackageStatistics stats) {
-        long durationMs = stats.getDurationMs();
-        long timeSinceFirstRequestMs = stats.getTimeSinceFirstRequestMs();
-        long maxDeltaMs = SystemClock.elapsedRealtime() - mStartElapsedRealtimeMs;
-        assertTrue("Duration is too large", durationMs <= maxDeltaMs);
-        assertTrue("Time since first request is too large", timeSinceFirstRequestMs <= maxDeltaMs);
-    }
-}
diff --git a/services/tests/servicestests/src/com/android/server/net/NetworkStatsAccessTest.java b/services/tests/servicestests/src/com/android/server/net/NetworkStatsAccessTest.java
deleted file mode 100644
index bb8f9d1a7b1..00000000000
--- a/services/tests/servicestests/src/com/android/server/net/NetworkStatsAccessTest.java
+++ /dev/null
@@ -1,178 +0,0 @@
-/*
- * Copyright (C) 2015 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License
- */
-
-package com.android.server.net;
-
-import static org.mockito.Mockito.when;
-
-import android.Manifest;
-import android.Manifest.permission;
-import android.app.AppOpsManager;
-import android.app.admin.DeviceAdminInfo;
-import android.app.admin.DevicePolicyManagerInternal;
-import android.content.Context;
-import android.content.pm.PackageManager;
-import android.telephony.TelephonyManager;
-
-import com.android.server.LocalServices;
-
-import junit.framework.TestCase;
-
-import org.mockito.Mock;
-import org.mockito.MockitoAnnotations;
-
-public class NetworkStatsAccessTest extends TestCase {
-    private static final String TEST_PKG = "com.example.test";
-    private static final int TEST_UID = 12345;
-
-    @Mock private Context mContext;
-    @Mock private DevicePolicyManagerInternal mDpmi;
-    @Mock private TelephonyManager mTm;
-    @Mock private AppOpsManager mAppOps;
-
-    // Hold the real service so we can restore it when tearing down the test.
-    private DevicePolicyManagerInternal mSystemDpmi;
-
-    @Override
-    public void setUp() throws Exception {
-        super.setUp();
-        MockitoAnnotations.initMocks(this);
-
-        mSystemDpmi = LocalServices.getService(DevicePolicyManagerInternal.class);
-        LocalServices.removeServiceForTest(DevicePolicyManagerInternal.class);
-        LocalServices.addService(DevicePolicyManagerInternal.class, mDpmi);
-
-        when(mContext.getSystemService(Context.TELEPHONY_SERVICE)).thenReturn(mTm);
-        when(mContext.getSystemService(Context.APP_OPS_SERVICE)).thenReturn(mAppOps);
-    }
-
-    @Override
-    public void tearDown() throws Exception {
-        LocalServices.removeServiceForTest(DevicePolicyManagerInternal.class);
-        LocalServices.addService(DevicePolicyManagerInternal.class, mSystemDpmi);
-        super.tearDown();
-    }
-
-    public void testCheckAccessLevel_hasCarrierPrivileges() throws Exception {
-        setHasCarrierPrivileges(true);
-        setIsDeviceOwner(false);
-        setIsProfileOwner(false);
-        setHasAppOpsPermission(AppOpsManager.MODE_DEFAULT, false);
-        setHasReadHistoryPermission(false);
-        assertEquals(NetworkStatsAccess.Level.DEVICE,
-                NetworkStatsAccess.checkAccessLevel(mContext, TEST_UID, TEST_PKG));
-    }
-
-    public void testCheckAccessLevel_isDeviceOwner() throws Exception {
-        setHasCarrierPrivileges(false);
-        setIsDeviceOwner(true);
-        setIsProfileOwner(false);
-        setHasAppOpsPermission(AppOpsManager.MODE_DEFAULT, false);
-        setHasReadHistoryPermission(false);
-        assertEquals(NetworkStatsAccess.Level.DEVICE,
-                NetworkStatsAccess.checkAccessLevel(mContext, TEST_UID, TEST_PKG));
-    }
-
-    public void testCheckAccessLevel_isProfileOwner() throws Exception {
-        setHasCarrierPrivileges(false);
-        setIsDeviceOwner(false);
-        setIsProfileOwner(true);
-        setHasAppOpsPermission(AppOpsManager.MODE_DEFAULT, false);
-        setHasReadHistoryPermission(false);
-        assertEquals(NetworkStatsAccess.Level.USER,
-                NetworkStatsAccess.checkAccessLevel(mContext, TEST_UID, TEST_PKG));
-    }
-
-    public void testCheckAccessLevel_hasAppOpsBitAllowed() throws Exception {
-        setHasCarrierPrivileges(false);
-        setIsDeviceOwner(false);
-        setIsProfileOwner(true);
-        setHasAppOpsPermission(AppOpsManager.MODE_ALLOWED, false);
-        setHasReadHistoryPermission(false);
-        assertEquals(NetworkStatsAccess.Level.USER,
-                NetworkStatsAccess.checkAccessLevel(mContext, TEST_UID, TEST_PKG));
-    }
-
-    public void testCheckAccessLevel_hasAppOpsBitDefault_grantedPermission() throws Exception {
-        setHasCarrierPrivileges(false);
-        setIsDeviceOwner(false);
-        setIsProfileOwner(true);
-        setHasAppOpsPermission(AppOpsManager.MODE_DEFAULT, true);
-        setHasReadHistoryPermission(false);
-        assertEquals(NetworkStatsAccess.Level.USER,
-                NetworkStatsAccess.checkAccessLevel(mContext, TEST_UID, TEST_PKG));
-    }
-
-    public void testCheckAccessLevel_hasReadHistoryPermission() throws Exception {
-        setHasCarrierPrivileges(false);
-        setIsDeviceOwner(false);
-        setIsProfileOwner(true);
-        setHasAppOpsPermission(AppOpsManager.MODE_DEFAULT, false);
-        setHasReadHistoryPermission(true);
-        assertEquals(NetworkStatsAccess.Level.USER,
-                NetworkStatsAccess.checkAccessLevel(mContext, TEST_UID, TEST_PKG));
-    }
-
-    public void testCheckAccessLevel_deniedAppOpsBit() throws Exception {
-        setHasCarrierPrivileges(false);
-        setIsDeviceOwner(false);
-        setIsProfileOwner(false);
-        setHasAppOpsPermission(AppOpsManager.MODE_ERRORED, true);
-        setHasReadHistoryPermission(false);
-        assertEquals(NetworkStatsAccess.Level.DEFAULT,
-                NetworkStatsAccess.checkAccessLevel(mContext, TEST_UID, TEST_PKG));
-    }
-
-    public void testCheckAccessLevel_deniedAppOpsBit_deniedPermission() throws Exception {
-        setHasCarrierPrivileges(false);
-        setIsDeviceOwner(false);
-        setIsProfileOwner(false);
-        setHasAppOpsPermission(AppOpsManager.MODE_DEFAULT, false);
-        setHasReadHistoryPermission(false);
-        assertEquals(NetworkStatsAccess.Level.DEFAULT,
-                NetworkStatsAccess.checkAccessLevel(mContext, TEST_UID, TEST_PKG));
-    }
-
-    private void setHasCarrierPrivileges(boolean hasPrivileges) {
-        when(mTm.checkCarrierPrivilegesForPackage(TEST_PKG)).thenReturn(
-                hasPrivileges ? TelephonyManager.CARRIER_PRIVILEGE_STATUS_HAS_ACCESS
-                        : TelephonyManager.CARRIER_PRIVILEGE_STATUS_NO_ACCESS);
-    }
-
-    private void setIsDeviceOwner(boolean isOwner) {
-        when(mDpmi.isActiveAdminWithPolicy(TEST_UID, DeviceAdminInfo.USES_POLICY_DEVICE_OWNER))
-                .thenReturn(isOwner);
-    }
-
-    private void setIsProfileOwner(boolean isOwner) {
-        when(mDpmi.isActiveAdminWithPolicy(TEST_UID, DeviceAdminInfo.USES_POLICY_PROFILE_OWNER))
-                .thenReturn(isOwner);
-    }
-
-    private void setHasAppOpsPermission(int appOpsMode, boolean hasPermission) {
-        when(mAppOps.checkOp(AppOpsManager.OP_GET_USAGE_STATS, TEST_UID, TEST_PKG))
-                .thenReturn(appOpsMode);
-        when(mContext.checkCallingPermission(Manifest.permission.PACKAGE_USAGE_STATS)).thenReturn(
-                hasPermission ? PackageManager.PERMISSION_GRANTED
-                        : PackageManager.PERMISSION_DENIED);
-    }
-
-    private void setHasReadHistoryPermission(boolean hasPermission) {
-        when(mContext.checkCallingOrSelfPermission(permission.READ_NETWORK_USAGE_HISTORY))
-                .thenReturn(hasPermission ? PackageManager.PERMISSION_GRANTED
-                        : PackageManager.PERMISSION_DENIED);
-    }
-}
diff --git a/services/tests/servicestests/src/com/android/server/net/NetworkStatsCollectionTest.java b/services/tests/servicestests/src/com/android/server/net/NetworkStatsCollectionTest.java
deleted file mode 100644
index 9f53c87834e..00000000000
--- a/services/tests/servicestests/src/com/android/server/net/NetworkStatsCollectionTest.java
+++ /dev/null
@@ -1,262 +0,0 @@
-/*
- * Copyright (C) 2012 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.android.server.net;
-
-import static android.net.ConnectivityManager.TYPE_MOBILE;
-import static android.net.NetworkStats.SET_DEFAULT;
-import static android.net.NetworkStats.TAG_NONE;
-import static android.net.NetworkStats.UID_ALL;
-import static android.net.NetworkTemplate.buildTemplateMobileAll;
-import static android.text.format.DateUtils.HOUR_IN_MILLIS;
-import static android.text.format.DateUtils.MINUTE_IN_MILLIS;
-
-import android.content.res.Resources;
-import android.net.NetworkIdentity;
-import android.net.NetworkStats;
-import android.net.NetworkTemplate;
-import android.os.Process;
-import android.os.UserHandle;
-import android.telephony.TelephonyManager;
-import android.test.AndroidTestCase;
-import android.test.MoreAsserts;
-import android.test.suitebuilder.annotation.MediumTest;
-
-import com.android.frameworks.servicestests.R;
-
-import java.io.ByteArrayInputStream;
-import java.io.ByteArrayOutputStream;
-import java.io.DataOutputStream;
-import java.io.File;
-import java.io.FileOutputStream;
-import java.io.InputStream;
-import java.io.OutputStream;
-
-import libcore.io.IoUtils;
-import libcore.io.Streams;
-
-/**
- * Tests for {@link NetworkStatsCollection}.
- */
-@MediumTest
-public class NetworkStatsCollectionTest extends AndroidTestCase {
-
-    private static final String TEST_FILE = "test.bin";
-    private static final String TEST_IMSI = "310260000000000";
-
-    @Override
-    public void setUp() throws Exception {
-        super.setUp();
-
-        // ignore any device overlay while testing
-        NetworkTemplate.forceAllNetworkTypes();
-    }
-
-    public void testReadLegacyNetwork() throws Exception {
-        final File testFile = new File(getContext().getFilesDir(), TEST_FILE);
-        stageFile(R.raw.netstats_v1, testFile);
-
-        final NetworkStatsCollection collection = new NetworkStatsCollection(30 * MINUTE_IN_MILLIS);
-        collection.readLegacyNetwork(testFile);
-
-        // verify that history read correctly
-        assertSummaryTotal(collection, buildTemplateMobileAll(TEST_IMSI),
-                636016770L, 709306L, 88038768L, 518836L, NetworkStatsAccess.Level.DEVICE);
-
-        // now export into a unified format
-        final ByteArrayOutputStream bos = new ByteArrayOutputStream();
-        collection.write(new DataOutputStream(bos));
-
-        // clear structure completely
-        collection.reset();
-        assertSummaryTotal(collection, buildTemplateMobileAll(TEST_IMSI),
-                0L, 0L, 0L, 0L, NetworkStatsAccess.Level.DEVICE);
-
-        // and read back into structure, verifying that totals are same
-        collection.read(new ByteArrayInputStream(bos.toByteArray()));
-        assertSummaryTotal(collection, buildTemplateMobileAll(TEST_IMSI),
-                636016770L, 709306L, 88038768L, 518836L, NetworkStatsAccess.Level.DEVICE);
-    }
-
-    public void testReadLegacyUid() throws Exception {
-        final File testFile = new File(getContext().getFilesDir(), TEST_FILE);
-        stageFile(R.raw.netstats_uid_v4, testFile);
-
-        final NetworkStatsCollection collection = new NetworkStatsCollection(30 * MINUTE_IN_MILLIS);
-        collection.readLegacyUid(testFile, false);
-
-        // verify that history read correctly
-        assertSummaryTotal(collection, buildTemplateMobileAll(TEST_IMSI),
-                637076152L, 711413L, 88343717L, 521022L, NetworkStatsAccess.Level.DEVICE);
-
-        // now export into a unified format
-        final ByteArrayOutputStream bos = new ByteArrayOutputStream();
-        collection.write(new DataOutputStream(bos));
-
-        // clear structure completely
-        collection.reset();
-        assertSummaryTotal(collection, buildTemplateMobileAll(TEST_IMSI),
-                0L, 0L, 0L, 0L, NetworkStatsAccess.Level.DEVICE);
-
-        // and read back into structure, verifying that totals are same
-        collection.read(new ByteArrayInputStream(bos.toByteArray()));
-        assertSummaryTotal(collection, buildTemplateMobileAll(TEST_IMSI),
-                637076152L, 711413L, 88343717L, 521022L, NetworkStatsAccess.Level.DEVICE);
-    }
-
-    public void testReadLegacyUidTags() throws Exception {
-        final File testFile = new File(getContext().getFilesDir(), TEST_FILE);
-        stageFile(R.raw.netstats_uid_v4, testFile);
-
-        final NetworkStatsCollection collection = new NetworkStatsCollection(30 * MINUTE_IN_MILLIS);
-        collection.readLegacyUid(testFile, true);
-
-        // verify that history read correctly
-        assertSummaryTotalIncludingTags(collection, buildTemplateMobileAll(TEST_IMSI),
-                77017831L, 100995L, 35436758L, 92344L);
-
-        // now export into a unified format
-        final ByteArrayOutputStream bos = new ByteArrayOutputStream();
-        collection.write(new DataOutputStream(bos));
-
-        // clear structure completely
-        collection.reset();
-        assertSummaryTotalIncludingTags(collection, buildTemplateMobileAll(TEST_IMSI),
-                0L, 0L, 0L, 0L);
-
-        // and read back into structure, verifying that totals are same
-        collection.read(new ByteArrayInputStream(bos.toByteArray()));
-        assertSummaryTotalIncludingTags(collection, buildTemplateMobileAll(TEST_IMSI),
-                77017831L, 100995L, 35436758L, 92344L);
-    }
-
-    public void testStartEndAtomicBuckets() throws Exception {
-        final NetworkStatsCollection collection = new NetworkStatsCollection(HOUR_IN_MILLIS);
-
-        // record empty data straddling between buckets
-        final NetworkStats.Entry entry = new NetworkStats.Entry();
-        entry.rxBytes = 32;
-        collection.recordData(null, UID_ALL, SET_DEFAULT, TAG_NONE, 30 * MINUTE_IN_MILLIS,
-                90 * MINUTE_IN_MILLIS, entry);
-
-        // assert that we report boundary in atomic buckets
-        assertEquals(0, collection.getStartMillis());
-        assertEquals(2 * HOUR_IN_MILLIS, collection.getEndMillis());
-    }
-
-    public void testAccessLevels() throws Exception {
-        final NetworkStatsCollection collection = new NetworkStatsCollection(HOUR_IN_MILLIS);
-        final NetworkStats.Entry entry = new NetworkStats.Entry();
-        final NetworkIdentitySet identSet = new NetworkIdentitySet();
-        identSet.add(new NetworkIdentity(TYPE_MOBILE, TelephonyManager.NETWORK_TYPE_UNKNOWN,
-                TEST_IMSI, null, false, true));
-
-        int myUid = Process.myUid();
-        int otherUidInSameUser = Process.myUid() + 1;
-        int uidInDifferentUser = Process.myUid() + UserHandle.PER_USER_RANGE;
-
-        // Record one entry for the current UID.
-        entry.rxBytes = 32;
-        collection.recordData(identSet, myUid, SET_DEFAULT, TAG_NONE, 0, 60 * MINUTE_IN_MILLIS,
-                entry);
-
-        // Record one entry for another UID in this user.
-        entry.rxBytes = 64;
-        collection.recordData(identSet, otherUidInSameUser, SET_DEFAULT, TAG_NONE, 0,
-                60 * MINUTE_IN_MILLIS, entry);
-
-        // Record one entry for the system UID.
-        entry.rxBytes = 128;
-        collection.recordData(identSet, Process.SYSTEM_UID, SET_DEFAULT, TAG_NONE, 0,
-                60 * MINUTE_IN_MILLIS, entry);
-
-        // Record one entry for a UID in a different user.
-        entry.rxBytes = 256;
-        collection.recordData(identSet, uidInDifferentUser, SET_DEFAULT, TAG_NONE, 0,
-                60 * MINUTE_IN_MILLIS, entry);
-
-        // Verify the set of relevant UIDs for each access level.
-        MoreAsserts.assertEquals(new int[] { myUid },
-                collection.getRelevantUids(NetworkStatsAccess.Level.DEFAULT));
-        MoreAsserts.assertEquals(new int[] { Process.SYSTEM_UID, myUid, otherUidInSameUser },
-                collection.getRelevantUids(NetworkStatsAccess.Level.USER));
-        MoreAsserts.assertEquals(
-                new int[] { Process.SYSTEM_UID, myUid, otherUidInSameUser, uidInDifferentUser },
-                collection.getRelevantUids(NetworkStatsAccess.Level.DEVICE));
-
-        // Verify security check in getHistory.
-        assertNotNull(collection.getHistory(buildTemplateMobileAll(TEST_IMSI), myUid, SET_DEFAULT,
-                TAG_NONE, 0, NetworkStatsAccess.Level.DEFAULT));
-        try {
-            collection.getHistory(buildTemplateMobileAll(TEST_IMSI), otherUidInSameUser,
-                    SET_DEFAULT, TAG_NONE, 0, NetworkStatsAccess.Level.DEFAULT);
-            fail("Should have thrown SecurityException for accessing different UID");
-        } catch (SecurityException e) {
-            // expected
-        }
-
-        // Verify appropriate aggregation in getSummary.
-        assertSummaryTotal(collection, buildTemplateMobileAll(TEST_IMSI), 32, 0, 0, 0,
-                NetworkStatsAccess.Level.DEFAULT);
-        assertSummaryTotal(collection, buildTemplateMobileAll(TEST_IMSI), 32 + 64 + 128, 0, 0, 0,
-                NetworkStatsAccess.Level.USER);
-        assertSummaryTotal(collection, buildTemplateMobileAll(TEST_IMSI), 32 + 64 + 128 + 256, 0, 0,
-                0, NetworkStatsAccess.Level.DEVICE);
-    }
-
-    /**
-     * Copy a {@link Resources#openRawResource(int)} into {@link File} for
-     * testing purposes.
-     */
-    private void stageFile(int rawId, File file) throws Exception {
-        new File(file.getParent()).mkdirs();
-        InputStream in = null;
-        OutputStream out = null;
-        try {
-            in = getContext().getResources().openRawResource(rawId);
-            out = new FileOutputStream(file);
-            Streams.copy(in, out);
-        } finally {
-            IoUtils.closeQuietly(in);
-            IoUtils.closeQuietly(out);
-        }
-    }
-
-    private static void assertSummaryTotal(NetworkStatsCollection collection,
-            NetworkTemplate template, long rxBytes, long rxPackets, long txBytes, long txPackets,
-            @NetworkStatsAccess.Level int accessLevel) {
-        final NetworkStats.Entry entry = collection.getSummary(
-                template, Long.MIN_VALUE, Long.MAX_VALUE, accessLevel)
-                .getTotal(null);
-        assertEntry(entry, rxBytes, rxPackets, txBytes, txPackets);
-    }
-
-    private static void assertSummaryTotalIncludingTags(NetworkStatsCollection collection,
-            NetworkTemplate template, long rxBytes, long rxPackets, long txBytes, long txPackets) {
-        final NetworkStats.Entry entry = collection.getSummary(
-                template, Long.MIN_VALUE, Long.MAX_VALUE, NetworkStatsAccess.Level.DEVICE)
-                .getTotalIncludingTags(null);
-        assertEntry(entry, rxBytes, rxPackets, txBytes, txPackets);
-    }
-
-    private static void assertEntry(
-            NetworkStats.Entry entry, long rxBytes, long rxPackets, long txBytes, long txPackets) {
-        assertEquals("unexpected rxBytes", rxBytes, entry.rxBytes);
-        assertEquals("unexpected rxPackets", rxPackets, entry.rxPackets);
-        assertEquals("unexpected txBytes", txBytes, entry.txBytes);
-        assertEquals("unexpected txPackets", txPackets, entry.txPackets);
-    }
-}
diff --git a/services/tests/servicestests/src/com/android/server/net/NetworkStatsObserversTest.java b/services/tests/servicestests/src/com/android/server/net/NetworkStatsObserversTest.java
deleted file mode 100644
index 21560acbf3b..00000000000
--- a/services/tests/servicestests/src/com/android/server/net/NetworkStatsObserversTest.java
+++ /dev/null
@@ -1,477 +0,0 @@
-/*
- * Copyright (C) 2016 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.android.server.net;
-
-import static android.net.ConnectivityManager.TYPE_MOBILE;
-import static android.net.ConnectivityManager.TYPE_WIFI;
-import static android.text.format.DateUtils.MINUTE_IN_MILLIS;
-import static org.mockito.Matchers.any;
-import static org.mockito.Matchers.anyInt;
-import static org.mockito.Matchers.isA;
-import static org.mockito.Mockito.when;
-
-import static android.net.NetworkStats.SET_DEFAULT;
-import static android.net.NetworkStats.ROAMING_NO;
-import static android.net.NetworkStats.TAG_NONE;
-import static android.net.NetworkTemplate.buildTemplateMobileAll;
-import static android.net.NetworkTemplate.buildTemplateWifiWildcard;
-import static android.net.TrafficStats.MB_IN_BYTES;
-import static android.text.format.DateUtils.MINUTE_IN_MILLIS;
-
-import android.app.usage.NetworkStatsManager;
-import android.net.DataUsageRequest;
-import android.net.NetworkIdentity;
-import android.net.NetworkStats;
-import android.net.NetworkTemplate;
-import android.os.Handler;
-import android.os.HandlerThread;
-import android.os.IBinder;
-import android.os.Process;
-
-import android.os.ConditionVariable;
-import android.os.Looper;
-import android.os.Messenger;
-import android.os.Message;
-import android.os.UserHandle;
-import android.telephony.TelephonyManager;
-import android.util.ArrayMap;
-
-import com.android.internal.net.VpnInfo;
-import com.android.server.net.NetworkStatsService;
-import com.android.server.net.NetworkStatsServiceTest.IdleableHandlerThread;
-import com.android.server.net.NetworkStatsServiceTest.LatchedHandler;
-
-import java.util.ArrayList;
-import java.util.Objects;
-import java.util.List;
-
-import junit.framework.TestCase;
-
-import org.mockito.Mock;
-import org.mockito.Mockito;
-import org.mockito.MockitoAnnotations;
-
-/**
- * Tests for {@link NetworkStatsObservers}.
- */
-public class NetworkStatsObserversTest extends TestCase {
-    private static final String TEST_IFACE = "test0";
-    private static final String TEST_IFACE2 = "test1";
-    private static final long TEST_START = 1194220800000L;
-
-    private static final String IMSI_1 = "310004";
-    private static final String IMSI_2 = "310260";
-    private static final String TEST_SSID = "AndroidAP";
-
-    private static NetworkTemplate sTemplateWifi = buildTemplateWifiWildcard();
-    private static NetworkTemplate sTemplateImsi1 = buildTemplateMobileAll(IMSI_1);
-    private static NetworkTemplate sTemplateImsi2 = buildTemplateMobileAll(IMSI_2);
-
-    private static final int UID_RED = UserHandle.PER_USER_RANGE + 1;
-    private static final int UID_BLUE = UserHandle.PER_USER_RANGE + 2;
-    private static final int UID_GREEN = UserHandle.PER_USER_RANGE + 3;
-    private static final int UID_ANOTHER_USER = 2 * UserHandle.PER_USER_RANGE + 4;
-
-    private static final long WAIT_TIMEOUT = 500;  // 1/2 sec
-    private static final long THRESHOLD_BYTES = 2 * MB_IN_BYTES;
-    private static final long BASE_BYTES = 7 * MB_IN_BYTES;
-    private static final int INVALID_TYPE = -1;
-
-    private static final VpnInfo[] VPN_INFO = new VpnInfo[0];
-
-    private long mElapsedRealtime;
-
-    private IdleableHandlerThread mObserverHandlerThread;
-    private Handler mObserverNoopHandler;
-
-    private LatchedHandler mHandler;
-    private ConditionVariable mCv;
-
-    private NetworkStatsObservers mStatsObservers;
-    private Messenger mMessenger;
-    private ArrayMap<String, NetworkIdentitySet> mActiveIfaces;
-    private ArrayMap<String, NetworkIdentitySet> mActiveUidIfaces;
-
-    @Mock private IBinder mockBinder;
-
-    @Override
-    public void setUp() throws Exception {
-        super.setUp();
-        MockitoAnnotations.initMocks(this);
-
-        mObserverHandlerThread = new IdleableHandlerThread("HandlerThread");
-        mObserverHandlerThread.start();
-        final Looper observerLooper = mObserverHandlerThread.getLooper();
-        mStatsObservers = new NetworkStatsObservers() {
-            @Override
-            protected Looper getHandlerLooperLocked() {
-                return observerLooper;
-            }
-        };
-
-        mCv = new ConditionVariable();
-        mHandler = new LatchedHandler(Looper.getMainLooper(), mCv);
-        mMessenger = new Messenger(mHandler);
-
-        mActiveIfaces = new ArrayMap<>();
-        mActiveUidIfaces = new ArrayMap<>();
-    }
-
-    public void testRegister_thresholdTooLow_setsDefaultThreshold() throws Exception {
-        long thresholdTooLowBytes = 1L;
-        DataUsageRequest inputRequest = new DataUsageRequest(
-                DataUsageRequest.REQUEST_ID_UNSET, sTemplateWifi, thresholdTooLowBytes);
-
-        DataUsageRequest request = mStatsObservers.register(inputRequest, mMessenger, mockBinder,
-                Process.SYSTEM_UID, NetworkStatsAccess.Level.DEVICE);
-        assertTrue(request.requestId > 0);
-        assertTrue(Objects.equals(sTemplateWifi, request.template));
-        assertEquals(THRESHOLD_BYTES, request.thresholdInBytes);
-    }
-
-    public void testRegister_highThreshold_accepted() throws Exception {
-        long highThresholdBytes = 2 * THRESHOLD_BYTES;
-        DataUsageRequest inputRequest = new DataUsageRequest(
-                DataUsageRequest.REQUEST_ID_UNSET, sTemplateWifi, highThresholdBytes);
-
-        DataUsageRequest request = mStatsObservers.register(inputRequest, mMessenger, mockBinder,
-                Process.SYSTEM_UID, NetworkStatsAccess.Level.DEVICE);
-        assertTrue(request.requestId > 0);
-        assertTrue(Objects.equals(sTemplateWifi, request.template));
-        assertEquals(highThresholdBytes, request.thresholdInBytes);
-    }
-
-    public void testRegister_twoRequests_twoIds() throws Exception {
-        DataUsageRequest inputRequest = new DataUsageRequest(
-                DataUsageRequest.REQUEST_ID_UNSET, sTemplateWifi, THRESHOLD_BYTES);
-
-        DataUsageRequest request1 = mStatsObservers.register(inputRequest, mMessenger, mockBinder,
-                Process.SYSTEM_UID, NetworkStatsAccess.Level.DEVICE);
-        assertTrue(request1.requestId > 0);
-        assertTrue(Objects.equals(sTemplateWifi, request1.template));
-        assertEquals(THRESHOLD_BYTES, request1.thresholdInBytes);
-
-        DataUsageRequest request2 = mStatsObservers.register(inputRequest, mMessenger, mockBinder,
-                Process.SYSTEM_UID, NetworkStatsAccess.Level.DEVICE);
-        assertTrue(request2.requestId > request1.requestId);
-        assertTrue(Objects.equals(sTemplateWifi, request2.template));
-        assertEquals(THRESHOLD_BYTES, request2.thresholdInBytes);
-    }
-
-    public void testUnregister_unknownRequest_noop() throws Exception {
-        DataUsageRequest unknownRequest = new DataUsageRequest(
-                123456 /* id */, sTemplateWifi, THRESHOLD_BYTES);
-
-        mStatsObservers.unregister(unknownRequest, UID_RED);
-    }
-
-    public void testUnregister_knownRequest_releasesCaller() throws Exception {
-        DataUsageRequest inputRequest = new DataUsageRequest(
-                DataUsageRequest.REQUEST_ID_UNSET, sTemplateImsi1, THRESHOLD_BYTES);
-
-        DataUsageRequest request = mStatsObservers.register(inputRequest, mMessenger, mockBinder,
-                Process.SYSTEM_UID, NetworkStatsAccess.Level.DEVICE);
-        assertTrue(request.requestId > 0);
-        assertTrue(Objects.equals(sTemplateImsi1, request.template));
-        assertEquals(THRESHOLD_BYTES, request.thresholdInBytes);
-        Mockito.verify(mockBinder).linkToDeath(any(IBinder.DeathRecipient.class), anyInt());
-
-        mStatsObservers.unregister(request, Process.SYSTEM_UID);
-        waitForObserverToIdle();
-
-        Mockito.verify(mockBinder).unlinkToDeath(any(IBinder.DeathRecipient.class), anyInt());
-    }
-
-    public void testUnregister_knownRequest_invalidUid_doesNotUnregister() throws Exception {
-        DataUsageRequest inputRequest = new DataUsageRequest(
-                DataUsageRequest.REQUEST_ID_UNSET, sTemplateImsi1, THRESHOLD_BYTES);
-
-        DataUsageRequest request = mStatsObservers.register(inputRequest, mMessenger, mockBinder,
-                UID_RED, NetworkStatsAccess.Level.DEVICE);
-        assertTrue(request.requestId > 0);
-        assertTrue(Objects.equals(sTemplateImsi1, request.template));
-        assertEquals(THRESHOLD_BYTES, request.thresholdInBytes);
-        Mockito.verify(mockBinder).linkToDeath(any(IBinder.DeathRecipient.class), anyInt());
-
-        mStatsObservers.unregister(request, UID_BLUE);
-        waitForObserverToIdle();
-
-        Mockito.verifyZeroInteractions(mockBinder);
-    }
-
-    public void testUpdateStats_initialSample_doesNotNotify() throws Exception {
-        DataUsageRequest inputRequest = new DataUsageRequest(
-                DataUsageRequest.REQUEST_ID_UNSET, sTemplateImsi1, THRESHOLD_BYTES);
-
-        DataUsageRequest request = mStatsObservers.register(inputRequest, mMessenger, mockBinder,
-                Process.SYSTEM_UID, NetworkStatsAccess.Level.DEVICE);
-        assertTrue(request.requestId > 0);
-        assertTrue(Objects.equals(sTemplateImsi1, request.template));
-        assertEquals(THRESHOLD_BYTES, request.thresholdInBytes);
-
-        NetworkIdentitySet identSet = new NetworkIdentitySet();
-        identSet.add(new NetworkIdentity(
-                TYPE_MOBILE, TelephonyManager.NETWORK_TYPE_UNKNOWN,
-                IMSI_1, null /* networkId */, false /* roaming */, true /* metered */));
-        mActiveIfaces.put(TEST_IFACE, identSet);
-
-        // Baseline
-        NetworkStats xtSnapshot = new NetworkStats(TEST_START, 1 /* initialSize */)
-                .addIfaceValues(TEST_IFACE, BASE_BYTES, 8L, BASE_BYTES, 16L);
-        NetworkStats uidSnapshot = null;
-
-        mStatsObservers.updateStats(
-                xtSnapshot, uidSnapshot, mActiveIfaces, mActiveUidIfaces,
-                VPN_INFO, TEST_START);
-        waitForObserverToIdle();
-
-        assertTrue(mCv.block(WAIT_TIMEOUT));
-        assertEquals(INVALID_TYPE, mHandler.mLastMessageType);
-    }
-
-    public void testUpdateStats_belowThreshold_doesNotNotify() throws Exception {
-        DataUsageRequest inputRequest = new DataUsageRequest(
-                DataUsageRequest.REQUEST_ID_UNSET, sTemplateImsi1, THRESHOLD_BYTES);
-
-        DataUsageRequest request = mStatsObservers.register(inputRequest, mMessenger, mockBinder,
-                Process.SYSTEM_UID, NetworkStatsAccess.Level.DEVICE);
-        assertTrue(request.requestId > 0);
-        assertTrue(Objects.equals(sTemplateImsi1, request.template));
-        assertEquals(THRESHOLD_BYTES, request.thresholdInBytes);
-
-        NetworkIdentitySet identSet = new NetworkIdentitySet();
-        identSet.add(new NetworkIdentity(
-                TYPE_MOBILE, TelephonyManager.NETWORK_TYPE_UNKNOWN,
-                IMSI_1, null /* networkId */, false /* roaming */, true /* metered */));
-        mActiveIfaces.put(TEST_IFACE, identSet);
-
-        // Baseline
-        NetworkStats xtSnapshot = new NetworkStats(TEST_START, 1 /* initialSize */)
-                .addIfaceValues(TEST_IFACE, BASE_BYTES, 8L, BASE_BYTES, 16L);
-        NetworkStats uidSnapshot = null;
-        mStatsObservers.updateStats(
-                xtSnapshot, uidSnapshot, mActiveIfaces, mActiveUidIfaces,
-                VPN_INFO, TEST_START);
-
-        // Delta
-        xtSnapshot = new NetworkStats(TEST_START, 1 /* initialSize */)
-                .addIfaceValues(TEST_IFACE, BASE_BYTES + 1024L, 10L, BASE_BYTES + 2048L, 20L);
-        mStatsObservers.updateStats(
-                xtSnapshot, uidSnapshot, mActiveIfaces, mActiveUidIfaces,
-                VPN_INFO, TEST_START);
-        waitForObserverToIdle();
-
-        assertTrue(mCv.block(WAIT_TIMEOUT));
-        mCv.block(WAIT_TIMEOUT);
-        assertEquals(INVALID_TYPE, mHandler.mLastMessageType);
-    }
-
-    public void testUpdateStats_deviceAccess_notifies() throws Exception {
-        DataUsageRequest inputRequest = new DataUsageRequest(
-                DataUsageRequest.REQUEST_ID_UNSET, sTemplateImsi1, THRESHOLD_BYTES);
-
-        DataUsageRequest request = mStatsObservers.register(inputRequest, mMessenger, mockBinder,
-                Process.SYSTEM_UID, NetworkStatsAccess.Level.DEVICE);
-        assertTrue(request.requestId > 0);
-        assertTrue(Objects.equals(sTemplateImsi1, request.template));
-        assertEquals(THRESHOLD_BYTES, request.thresholdInBytes);
-
-        NetworkIdentitySet identSet = new NetworkIdentitySet();
-        identSet.add(new NetworkIdentity(
-                TYPE_MOBILE, TelephonyManager.NETWORK_TYPE_UNKNOWN,
-                IMSI_1, null /* networkId */, false /* roaming */, true /* metered */));
-        mActiveIfaces.put(TEST_IFACE, identSet);
-
-        // Baseline
-        NetworkStats xtSnapshot = new NetworkStats(TEST_START, 1 /* initialSize */)
-                .addIfaceValues(TEST_IFACE, BASE_BYTES, 8L, BASE_BYTES, 16L);
-        NetworkStats uidSnapshot = null;
-        mStatsObservers.updateStats(
-                xtSnapshot, uidSnapshot, mActiveIfaces, mActiveUidIfaces,
-                VPN_INFO, TEST_START);
-
-        // Delta
-        xtSnapshot = new NetworkStats(TEST_START + MINUTE_IN_MILLIS, 1 /* initialSize */)
-                .addIfaceValues(TEST_IFACE, BASE_BYTES + THRESHOLD_BYTES, 12L,
-                        BASE_BYTES + THRESHOLD_BYTES, 22L);
-        mStatsObservers.updateStats(
-                xtSnapshot, uidSnapshot, mActiveIfaces, mActiveUidIfaces,
-                VPN_INFO, TEST_START);
-        waitForObserverToIdle();
-
-        assertTrue(mCv.block(WAIT_TIMEOUT));
-        assertEquals(NetworkStatsManager.CALLBACK_LIMIT_REACHED, mHandler.mLastMessageType);
-    }
-
-    public void testUpdateStats_defaultAccess_notifiesSameUid() throws Exception {
-        DataUsageRequest inputRequest = new DataUsageRequest(
-                DataUsageRequest.REQUEST_ID_UNSET, sTemplateImsi1, THRESHOLD_BYTES);
-
-        DataUsageRequest request = mStatsObservers.register(inputRequest, mMessenger, mockBinder,
-                UID_RED, NetworkStatsAccess.Level.DEFAULT);
-        assertTrue(request.requestId > 0);
-        assertTrue(Objects.equals(sTemplateImsi1, request.template));
-        assertEquals(THRESHOLD_BYTES, request.thresholdInBytes);
-
-        NetworkIdentitySet identSet = new NetworkIdentitySet();
-        identSet.add(new NetworkIdentity(
-                TYPE_MOBILE, TelephonyManager.NETWORK_TYPE_UNKNOWN,
-                IMSI_1, null /* networkId */, false /* roaming */, true /* metered */));
-        mActiveUidIfaces.put(TEST_IFACE, identSet);
-
-        // Baseline
-        NetworkStats xtSnapshot = null;
-        NetworkStats uidSnapshot = new NetworkStats(TEST_START, 2 /* initialSize */)
-                .addValues(TEST_IFACE, UID_RED, SET_DEFAULT, TAG_NONE, ROAMING_NO,
-                        BASE_BYTES, 2L, BASE_BYTES, 2L, 0L);
-        mStatsObservers.updateStats(
-                xtSnapshot, uidSnapshot, mActiveIfaces, mActiveUidIfaces,
-                VPN_INFO, TEST_START);
-
-        // Delta
-        uidSnapshot = new NetworkStats(TEST_START + 2 * MINUTE_IN_MILLIS, 2 /* initialSize */)
-                .addValues(TEST_IFACE, UID_RED, SET_DEFAULT, TAG_NONE, ROAMING_NO,
-                        BASE_BYTES + THRESHOLD_BYTES, 2L, BASE_BYTES + THRESHOLD_BYTES, 2L, 0L);
-        mStatsObservers.updateStats(
-                xtSnapshot, uidSnapshot, mActiveIfaces, mActiveUidIfaces,
-                VPN_INFO, TEST_START);
-        waitForObserverToIdle();
-
-        assertTrue(mCv.block(WAIT_TIMEOUT));
-        assertEquals(NetworkStatsManager.CALLBACK_LIMIT_REACHED, mHandler.mLastMessageType);
-    }
-
-    public void testUpdateStats_defaultAccess_usageOtherUid_doesNotNotify() throws Exception {
-        DataUsageRequest inputRequest = new DataUsageRequest(
-                DataUsageRequest.REQUEST_ID_UNSET, sTemplateImsi1, THRESHOLD_BYTES);
-
-        DataUsageRequest request = mStatsObservers.register(inputRequest, mMessenger, mockBinder,
-                UID_BLUE, NetworkStatsAccess.Level.DEFAULT);
-        assertTrue(request.requestId > 0);
-        assertTrue(Objects.equals(sTemplateImsi1, request.template));
-        assertEquals(THRESHOLD_BYTES, request.thresholdInBytes);
-
-        NetworkIdentitySet identSet = new NetworkIdentitySet();
-        identSet.add(new NetworkIdentity(
-                TYPE_MOBILE, TelephonyManager.NETWORK_TYPE_UNKNOWN,
-                IMSI_1, null /* networkId */, false /* roaming */, true /* metered */));
-        mActiveUidIfaces.put(TEST_IFACE, identSet);
-
-        // Baseline
-        NetworkStats xtSnapshot = null;
-        NetworkStats uidSnapshot = new NetworkStats(TEST_START, 2 /* initialSize */)
-                .addValues(TEST_IFACE, UID_RED, SET_DEFAULT, TAG_NONE, ROAMING_NO,
-                        BASE_BYTES, 2L, BASE_BYTES, 2L, 0L);
-        mStatsObservers.updateStats(
-                xtSnapshot, uidSnapshot, mActiveIfaces, mActiveUidIfaces,
-                VPN_INFO, TEST_START);
-
-        // Delta
-        uidSnapshot = new NetworkStats(TEST_START + 2 * MINUTE_IN_MILLIS, 2 /* initialSize */)
-                .addValues(TEST_IFACE, UID_RED, SET_DEFAULT, TAG_NONE, ROAMING_NO,
-                        BASE_BYTES + THRESHOLD_BYTES, 2L, BASE_BYTES + THRESHOLD_BYTES, 2L, 0L);
-        mStatsObservers.updateStats(
-                xtSnapshot, uidSnapshot, mActiveIfaces, mActiveUidIfaces,
-                VPN_INFO, TEST_START);
-        waitForObserverToIdle();
-
-        assertTrue(mCv.block(WAIT_TIMEOUT));
-        assertEquals(INVALID_TYPE, mHandler.mLastMessageType);
-    }
-
-    public void testUpdateStats_userAccess_usageSameUser_notifies() throws Exception {
-        DataUsageRequest inputRequest = new DataUsageRequest(
-                DataUsageRequest.REQUEST_ID_UNSET, sTemplateImsi1, THRESHOLD_BYTES);
-
-        DataUsageRequest request = mStatsObservers.register(inputRequest, mMessenger, mockBinder,
-                UID_BLUE, NetworkStatsAccess.Level.USER);
-        assertTrue(request.requestId > 0);
-        assertTrue(Objects.equals(sTemplateImsi1, request.template));
-        assertEquals(THRESHOLD_BYTES, request.thresholdInBytes);
-
-        NetworkIdentitySet identSet = new NetworkIdentitySet();
-        identSet.add(new NetworkIdentity(
-                TYPE_MOBILE, TelephonyManager.NETWORK_TYPE_UNKNOWN,
-                IMSI_1, null /* networkId */, false /* roaming */, true /* metered */));
-        mActiveUidIfaces.put(TEST_IFACE, identSet);
-
-        // Baseline
-        NetworkStats xtSnapshot = null;
-        NetworkStats uidSnapshot = new NetworkStats(TEST_START, 2 /* initialSize */)
-                .addValues(TEST_IFACE, UID_RED, SET_DEFAULT, TAG_NONE, ROAMING_NO,
-                        BASE_BYTES, 2L, BASE_BYTES, 2L, 0L);
-        mStatsObservers.updateStats(
-                xtSnapshot, uidSnapshot, mActiveIfaces, mActiveUidIfaces,
-                VPN_INFO, TEST_START);
-
-        // Delta
-        uidSnapshot = new NetworkStats(TEST_START + 2 * MINUTE_IN_MILLIS, 2 /* initialSize */)
-                .addValues(TEST_IFACE, UID_RED, SET_DEFAULT, TAG_NONE, ROAMING_NO,
-                        BASE_BYTES + THRESHOLD_BYTES, 2L, BASE_BYTES + THRESHOLD_BYTES, 2L, 0L);
-        mStatsObservers.updateStats(
-                xtSnapshot, uidSnapshot, mActiveIfaces, mActiveUidIfaces,
-                VPN_INFO, TEST_START);
-        waitForObserverToIdle();
-
-        assertTrue(mCv.block(WAIT_TIMEOUT));
-        assertEquals(NetworkStatsManager.CALLBACK_LIMIT_REACHED, mHandler.mLastMessageType);
-    }
-
-    public void testUpdateStats_userAccess_usageAnotherUser_doesNotNotify() throws Exception {
-        DataUsageRequest inputRequest = new DataUsageRequest(
-                DataUsageRequest.REQUEST_ID_UNSET, sTemplateImsi1, THRESHOLD_BYTES);
-
-        DataUsageRequest request = mStatsObservers.register(inputRequest, mMessenger, mockBinder,
-                UID_RED, NetworkStatsAccess.Level.USER);
-        assertTrue(request.requestId > 0);
-        assertTrue(Objects.equals(sTemplateImsi1, request.template));
-        assertEquals(THRESHOLD_BYTES, request.thresholdInBytes);
-
-        NetworkIdentitySet identSet = new NetworkIdentitySet();
-        identSet.add(new NetworkIdentity(
-                TYPE_MOBILE, TelephonyManager.NETWORK_TYPE_UNKNOWN,
-                IMSI_1, null /* networkId */, false /* roaming */, true /* metered */));
-        mActiveUidIfaces.put(TEST_IFACE, identSet);
-
-        // Baseline
-        NetworkStats xtSnapshot = null;
-        NetworkStats uidSnapshot = new NetworkStats(TEST_START, 2 /* initialSize */)
-                .addValues(TEST_IFACE, UID_ANOTHER_USER, SET_DEFAULT, TAG_NONE, ROAMING_NO,
-                        BASE_BYTES, 2L, BASE_BYTES, 2L, 0L);
-        mStatsObservers.updateStats(
-                xtSnapshot, uidSnapshot, mActiveIfaces, mActiveUidIfaces,
-                VPN_INFO, TEST_START);
-
-        // Delta
-        uidSnapshot = new NetworkStats(TEST_START + 2 * MINUTE_IN_MILLIS, 2 /* initialSize */)
-                .addValues(TEST_IFACE, UID_ANOTHER_USER, SET_DEFAULT, TAG_NONE, ROAMING_NO,
-                        BASE_BYTES + THRESHOLD_BYTES, 2L, BASE_BYTES + THRESHOLD_BYTES, 2L, 0L);
-        mStatsObservers.updateStats(
-                xtSnapshot, uidSnapshot, mActiveIfaces, mActiveUidIfaces,
-                VPN_INFO, TEST_START);
-        waitForObserverToIdle();
-
-        assertTrue(mCv.block(WAIT_TIMEOUT));
-        assertEquals(INVALID_TYPE, mHandler.mLastMessageType);
-    }
-
-    private void waitForObserverToIdle() {
-        // Send dummy message to make sure that any previous message has been handled
-        mHandler.sendMessage(mHandler.obtainMessage(-1));
-        mObserverHandlerThread.waitForIdle(WAIT_TIMEOUT);
-    }
-}
diff --git a/services/tests/servicestests/src/com/android/server/net/NetworkStatsServiceTest.java b/services/tests/servicestests/src/com/android/server/net/NetworkStatsServiceTest.java
deleted file mode 100644
index 94c6711da9a..00000000000
--- a/services/tests/servicestests/src/com/android/server/net/NetworkStatsServiceTest.java
+++ /dev/null
@@ -1,1324 +0,0 @@
-/*
- * Copyright (C) 2011 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.android.server.net;
-
-import static android.content.Intent.ACTION_UID_REMOVED;
-import static android.content.Intent.EXTRA_UID;
-import static android.net.ConnectivityManager.TYPE_MOBILE;
-import static android.net.ConnectivityManager.TYPE_WIFI;
-import static android.net.ConnectivityManager.TYPE_WIMAX;
-import static android.net.NetworkStats.IFACE_ALL;
-import static android.net.NetworkStats.ROAMING_ALL;
-import static android.net.NetworkStats.ROAMING_NO;
-import static android.net.NetworkStats.ROAMING_YES;
-import static android.net.NetworkStats.SET_ALL;
-import static android.net.NetworkStats.SET_DEFAULT;
-import static android.net.NetworkStats.SET_FOREGROUND;
-import static android.net.NetworkStats.TAG_NONE;
-import static android.net.NetworkStats.UID_ALL;
-import static android.net.NetworkStatsHistory.FIELD_ALL;
-import static android.net.NetworkTemplate.buildTemplateMobileAll;
-import static android.net.NetworkTemplate.buildTemplateWifiWildcard;
-import static android.net.TrafficStats.MB_IN_BYTES;
-import static android.net.TrafficStats.UID_REMOVED;
-import static android.net.TrafficStats.UID_TETHERING;
-import static android.text.format.DateUtils.DAY_IN_MILLIS;
-import static android.text.format.DateUtils.HOUR_IN_MILLIS;
-import static android.text.format.DateUtils.MINUTE_IN_MILLIS;
-import static android.text.format.DateUtils.WEEK_IN_MILLIS;
-import static com.android.server.net.NetworkStatsService.ACTION_NETWORK_STATS_POLL;
-import static org.easymock.EasyMock.anyInt;
-import static org.easymock.EasyMock.anyLong;
-import static org.easymock.EasyMock.anyObject;
-import static org.easymock.EasyMock.capture;
-import static org.easymock.EasyMock.createMock;
-import static org.easymock.EasyMock.eq;
-import static org.easymock.EasyMock.expect;
-import static org.easymock.EasyMock.expectLastCall;
-import static org.easymock.EasyMock.isA;
-
-import android.app.AlarmManager;
-import android.app.IAlarmListener;
-import android.app.IAlarmManager;
-import android.app.PendingIntent;
-import android.app.usage.NetworkStatsManager;
-import android.content.Context;
-import android.content.Intent;
-import android.net.DataUsageRequest;
-import android.net.IConnectivityManager;
-import android.net.INetworkManagementEventObserver;
-import android.net.INetworkStatsSession;
-import android.net.LinkProperties;
-import android.net.NetworkInfo;
-import android.net.NetworkInfo.DetailedState;
-import android.net.NetworkState;
-import android.net.NetworkStats;
-import android.net.NetworkStatsHistory;
-import android.net.NetworkTemplate;
-import android.os.ConditionVariable;
-import android.os.Handler;
-import android.os.HandlerThread;
-import android.os.INetworkManagementService;
-import android.os.IBinder;
-import android.os.Looper;
-import android.os.Messenger;
-import android.os.MessageQueue;
-import android.os.MessageQueue.IdleHandler;
-import android.os.Message;
-import android.os.PowerManager;
-import android.os.WorkSource;
-import android.telephony.TelephonyManager;
-import android.test.AndroidTestCase;
-import android.test.suitebuilder.annotation.LargeTest;
-import android.test.suitebuilder.annotation.Suppress;
-import android.util.TrustedTime;
-
-import com.android.internal.net.VpnInfo;
-import com.android.server.BroadcastInterceptingContext;
-import com.android.server.net.NetworkStatsService;
-import com.android.server.net.NetworkStatsService.NetworkStatsSettings;
-import com.android.server.net.NetworkStatsService.NetworkStatsSettings.Config;
-
-import libcore.io.IoUtils;
-
-import org.easymock.Capture;
-import org.easymock.EasyMock;
-
-import java.io.File;
-import java.util.ArrayList;
-import java.util.Objects;
-import java.util.List;
-
-/**
- * Tests for {@link NetworkStatsService}.
- *
- * TODO: This test is really brittle, largely due to overly-strict use of Easymock.
- * Rewrite w/ Mockito.
- */
-@LargeTest
-public class NetworkStatsServiceTest extends AndroidTestCase {
-    private static final String TAG = "NetworkStatsServiceTest";
-
-    private static final String TEST_IFACE = "test0";
-    private static final String TEST_IFACE2 = "test1";
-    private static final long TEST_START = 1194220800000L;
-
-    private static final String IMSI_1 = "310004";
-    private static final String IMSI_2 = "310260";
-    private static final String TEST_SSID = "AndroidAP";
-
-    private static NetworkTemplate sTemplateWifi = buildTemplateWifiWildcard();
-    private static NetworkTemplate sTemplateImsi1 = buildTemplateMobileAll(IMSI_1);
-    private static NetworkTemplate sTemplateImsi2 = buildTemplateMobileAll(IMSI_2);
-
-    private static final int UID_RED = 1001;
-    private static final int UID_BLUE = 1002;
-    private static final int UID_GREEN = 1003;
-
-    private static final long WAIT_TIMEOUT = 2 * 1000;  // 2 secs
-    private static final int INVALID_TYPE = -1;
-
-    private long mElapsedRealtime;
-
-    private BroadcastInterceptingContext mServiceContext;
-    private File mStatsDir;
-
-    private INetworkManagementService mNetManager;
-    private TrustedTime mTime;
-    private NetworkStatsSettings mSettings;
-    private IConnectivityManager mConnManager;
-    private IdleableHandlerThread mHandlerThread;
-    private Handler mHandler;
-
-    private NetworkStatsService mService;
-    private INetworkStatsSession mSession;
-    private INetworkManagementEventObserver mNetworkObserver;
-
-    @Override
-    public void setUp() throws Exception {
-        super.setUp();
-
-        mServiceContext = new BroadcastInterceptingContext(getContext());
-        mStatsDir = getContext().getFilesDir();
-        if (mStatsDir.exists()) {
-            IoUtils.deleteContents(mStatsDir);
-        }
-
-        mNetManager = createMock(INetworkManagementService.class);
-
-        // TODO: Mock AlarmManager when migrating this test to Mockito.
-        AlarmManager alarmManager = (AlarmManager) mServiceContext
-                .getSystemService(Context.ALARM_SERVICE);
-        mTime = createMock(TrustedTime.class);
-        mSettings = createMock(NetworkStatsSettings.class);
-        mConnManager = createMock(IConnectivityManager.class);
-
-        PowerManager powerManager = (PowerManager) mServiceContext.getSystemService(
-                Context.POWER_SERVICE);
-        PowerManager.WakeLock wakeLock =
-                powerManager.newWakeLock(PowerManager.PARTIAL_WAKE_LOCK, TAG);
-
-        mService = new NetworkStatsService(
-                mServiceContext, mNetManager, alarmManager, wakeLock, mTime,
-                TelephonyManager.getDefault(), mSettings, new NetworkStatsObservers(),
-                mStatsDir, getBaseDir(mStatsDir));
-        mHandlerThread = new IdleableHandlerThread("HandlerThread");
-        mHandlerThread.start();
-        Handler.Callback callback = new NetworkStatsService.HandlerCallback(mService);
-        mHandler = new Handler(mHandlerThread.getLooper(), callback);
-        mService.setHandler(mHandler, callback);
-        mService.bindConnectivityManager(mConnManager);
-
-        mElapsedRealtime = 0L;
-
-        expectCurrentTime();
-        expectDefaultSettings();
-        expectNetworkStatsUidDetail(buildEmptyStats());
-        expectSystemReady();
-
-        // catch INetworkManagementEventObserver during systemReady()
-        final Capture<INetworkManagementEventObserver> networkObserver = new Capture<
-                INetworkManagementEventObserver>();
-        mNetManager.registerObserver(capture(networkObserver));
-        expectLastCall().atLeastOnce();
-
-        replay();
-        mService.systemReady();
-        mSession = mService.openSession();
-        verifyAndReset();
-
-        mNetworkObserver = networkObserver.getValue();
-
-    }
-
-    @Override
-    public void tearDown() throws Exception {
-        IoUtils.deleteContents(mStatsDir);
-
-        mServiceContext = null;
-        mStatsDir = null;
-
-        mNetManager = null;
-        mTime = null;
-        mSettings = null;
-        mConnManager = null;
-
-        mSession.close();
-        mService = null;
-
-        super.tearDown();
-    }
-
-    public void testNetworkStatsWifi() throws Exception {
-        // pretend that wifi network comes online; service should ask about full
-        // network state, and poll any existing interfaces before updating.
-        expectCurrentTime();
-        expectDefaultSettings();
-        expectNetworkState(buildWifiState());
-        expectNetworkStatsSummary(buildEmptyStats());
-        expectNetworkStatsUidDetail(buildEmptyStats());
-        expectNetworkStatsPoll();
-        expectBandwidthControlCheck();
-
-        replay();
-        mService.forceUpdateIfaces();
-
-        // verify service has empty history for wifi
-        assertNetworkTotal(sTemplateWifi, 0L, 0L, 0L, 0L, 0);
-        verifyAndReset();
-
-        // modify some number on wifi, and trigger poll event
-        incrementCurrentTime(HOUR_IN_MILLIS);
-        expectCurrentTime();
-        expectDefaultSettings();
-        expectNetworkStatsSummary(new NetworkStats(getElapsedRealtime(), 1)
-                .addIfaceValues(TEST_IFACE, 1024L, 1L, 2048L, 2L));
-        expectNetworkStatsUidDetail(buildEmptyStats());
-        expectNetworkStatsPoll();
-
-        replay();
-        forcePollAndWaitForIdle();
-
-        // verify service recorded history
-        assertNetworkTotal(sTemplateWifi, 1024L, 1L, 2048L, 2L, 0);
-        verifyAndReset();
-
-        // and bump forward again, with counters going higher. this is
-        // important, since polling should correctly subtract last snapshot.
-        incrementCurrentTime(DAY_IN_MILLIS);
-        expectCurrentTime();
-        expectDefaultSettings();
-        expectNetworkStatsSummary(new NetworkStats(getElapsedRealtime(), 1)
-                .addIfaceValues(TEST_IFACE, 4096L, 4L, 8192L, 8L));
-        expectNetworkStatsUidDetail(buildEmptyStats());
-        expectNetworkStatsPoll();
-
-        replay();
-        forcePollAndWaitForIdle();
-
-        // verify service recorded history
-        assertNetworkTotal(sTemplateWifi, 4096L, 4L, 8192L, 8L, 0);
-        verifyAndReset();
-
-    }
-
-    public void testStatsRebootPersist() throws Exception {
-        assertStatsFilesExist(false);
-
-        // pretend that wifi network comes online; service should ask about full
-        // network state, and poll any existing interfaces before updating.
-        expectCurrentTime();
-        expectDefaultSettings();
-        expectNetworkState(buildWifiState());
-        expectNetworkStatsSummary(buildEmptyStats());
-        expectNetworkStatsUidDetail(buildEmptyStats());
-        expectNetworkStatsPoll();
-        expectBandwidthControlCheck();
-
-        replay();
-        mService.forceUpdateIfaces();
-
-        // verify service has empty history for wifi
-        assertNetworkTotal(sTemplateWifi, 0L, 0L, 0L, 0L, 0);
-        verifyAndReset();
-
-        // modify some number on wifi, and trigger poll event
-        incrementCurrentTime(HOUR_IN_MILLIS);
-        expectCurrentTime();
-        expectDefaultSettings();
-        expectNetworkStatsSummary(new NetworkStats(getElapsedRealtime(), 1)
-                .addIfaceValues(TEST_IFACE, 1024L, 8L, 2048L, 16L));
-        expectNetworkStatsUidDetail(new NetworkStats(getElapsedRealtime(), 2)
-                .addValues(TEST_IFACE, UID_RED, SET_DEFAULT, TAG_NONE, 512L, 4L, 256L, 2L, 0L)
-                .addValues(TEST_IFACE, UID_RED, SET_DEFAULT, 0xFAAD, 256L, 2L, 128L, 1L, 0L)
-                .addValues(TEST_IFACE, UID_RED, SET_FOREGROUND, TAG_NONE, 512L, 4L, 256L, 2L, 0L)
-                .addValues(TEST_IFACE, UID_RED, SET_FOREGROUND, 0xFAAD, 256L, 2L, 128L, 1L, 0L)
-                .addValues(TEST_IFACE, UID_BLUE, SET_DEFAULT, TAG_NONE, 128L, 1L, 128L, 1L, 0L));
-        expectNetworkStatsPoll();
-
-        mService.setUidForeground(UID_RED, false);
-        mService.incrementOperationCount(UID_RED, 0xFAAD, 4);
-        mService.setUidForeground(UID_RED, true);
-        mService.incrementOperationCount(UID_RED, 0xFAAD, 6);
-
-        replay();
-        forcePollAndWaitForIdle();
-
-        // verify service recorded history
-        assertNetworkTotal(sTemplateWifi, 1024L, 8L, 2048L, 16L, 0);
-        assertUidTotal(sTemplateWifi, UID_RED, 1024L, 8L, 512L, 4L, 10);
-        assertUidTotal(sTemplateWifi, UID_RED, SET_DEFAULT, ROAMING_NO, 512L, 4L, 256L, 2L, 4);
-        assertUidTotal(sTemplateWifi, UID_RED, SET_FOREGROUND, ROAMING_NO, 512L, 4L, 256L, 2L,
-                6);
-        assertUidTotal(sTemplateWifi, UID_BLUE, 128L, 1L, 128L, 1L, 0);
-        verifyAndReset();
-
-        // graceful shutdown system, which should trigger persist of stats, and
-        // clear any values in memory.
-        expectCurrentTime();
-        expectDefaultSettings();
-        replay();
-        mServiceContext.sendBroadcast(new Intent(Intent.ACTION_SHUTDOWN));
-        verifyAndReset();
-
-        assertStatsFilesExist(true);
-
-        // boot through serviceReady() again
-        expectCurrentTime();
-        expectDefaultSettings();
-        expectNetworkStatsUidDetail(buildEmptyStats());
-        expectSystemReady();
-
-        // catch INetworkManagementEventObserver during systemReady()
-        final Capture<INetworkManagementEventObserver> networkObserver = new Capture<
-                INetworkManagementEventObserver>();
-        mNetManager.registerObserver(capture(networkObserver));
-        expectLastCall().atLeastOnce();
-
-        replay();
-        mService.systemReady();
-
-        mNetworkObserver = networkObserver.getValue();
-
-        // after systemReady(), we should have historical stats loaded again
-        assertNetworkTotal(sTemplateWifi, 1024L, 8L, 2048L, 16L, 0);
-        assertUidTotal(sTemplateWifi, UID_RED, 1024L, 8L, 512L, 4L, 10);
-        assertUidTotal(sTemplateWifi, UID_RED, SET_DEFAULT, ROAMING_NO, 512L, 4L, 256L, 2L, 4);
-        assertUidTotal(sTemplateWifi, UID_RED, SET_FOREGROUND, ROAMING_NO, 512L, 4L, 256L, 2L,
-                6);
-        assertUidTotal(sTemplateWifi, UID_BLUE, 128L, 1L, 128L, 1L, 0);
-        verifyAndReset();
-
-    }
-
-    // TODO: simulate reboot to test bucket resize
-    @Suppress
-    public void testStatsBucketResize() throws Exception {
-        NetworkStatsHistory history = null;
-
-        assertStatsFilesExist(false);
-
-        // pretend that wifi network comes online; service should ask about full
-        // network state, and poll any existing interfaces before updating.
-        expectCurrentTime();
-        expectSettings(0L, HOUR_IN_MILLIS, WEEK_IN_MILLIS);
-        expectNetworkState(buildWifiState());
-        expectNetworkStatsSummary(buildEmptyStats());
-        expectNetworkStatsUidDetail(buildEmptyStats());
-        expectNetworkStatsPoll();
-        expectBandwidthControlCheck();
-
-        replay();
-        mService.forceUpdateIfaces();
-        verifyAndReset();
-
-        // modify some number on wifi, and trigger poll event
-        incrementCurrentTime(2 * HOUR_IN_MILLIS);
-        expectCurrentTime();
-        expectSettings(0L, HOUR_IN_MILLIS, WEEK_IN_MILLIS);
-        expectNetworkStatsSummary(new NetworkStats(getElapsedRealtime(), 1)
-                .addIfaceValues(TEST_IFACE, 512L, 4L, 512L, 4L));
-        expectNetworkStatsUidDetail(buildEmptyStats());
-        expectNetworkStatsPoll();
-
-        replay();
-        forcePollAndWaitForIdle();
-
-        // verify service recorded history
-        history = mSession.getHistoryForNetwork(sTemplateWifi, FIELD_ALL);
-        assertValues(history, Long.MIN_VALUE, Long.MAX_VALUE, 512L, 4L, 512L, 4L, 0);
-        assertEquals(HOUR_IN_MILLIS, history.getBucketDuration());
-        assertEquals(2, history.size());
-        verifyAndReset();
-
-        // now change bucket duration setting and trigger another poll with
-        // exact same values, which should resize existing buckets.
-        expectCurrentTime();
-        expectSettings(0L, 30 * MINUTE_IN_MILLIS, WEEK_IN_MILLIS);
-        expectNetworkStatsSummary(buildEmptyStats());
-        expectNetworkStatsUidDetail(buildEmptyStats());
-        expectNetworkStatsPoll();
-
-        replay();
-        forcePollAndWaitForIdle();
-
-        // verify identical stats, but spread across 4 buckets now
-        history = mSession.getHistoryForNetwork(sTemplateWifi, FIELD_ALL);
-        assertValues(history, Long.MIN_VALUE, Long.MAX_VALUE, 512L, 4L, 512L, 4L, 0);
-        assertEquals(30 * MINUTE_IN_MILLIS, history.getBucketDuration());
-        assertEquals(4, history.size());
-        verifyAndReset();
-
-    }
-
-    public void testUidStatsAcrossNetworks() throws Exception {
-        // pretend first mobile network comes online
-        expectCurrentTime();
-        expectDefaultSettings();
-        expectNetworkState(buildMobile3gState(IMSI_1));
-        expectNetworkStatsSummary(buildEmptyStats());
-        expectNetworkStatsUidDetail(buildEmptyStats());
-        expectNetworkStatsPoll();
-        expectBandwidthControlCheck();
-
-        replay();
-        mService.forceUpdateIfaces();
-        verifyAndReset();
-
-        // create some traffic on first network
-        incrementCurrentTime(HOUR_IN_MILLIS);
-        expectCurrentTime();
-        expectDefaultSettings();
-        expectNetworkStatsSummary(new NetworkStats(getElapsedRealtime(), 1)
-                .addIfaceValues(TEST_IFACE, 2048L, 16L, 512L, 4L));
-        expectNetworkStatsUidDetail(new NetworkStats(getElapsedRealtime(), 3)
-                .addValues(TEST_IFACE, UID_RED, SET_DEFAULT, TAG_NONE, 1536L, 12L, 512L, 4L, 0L)
-                .addValues(TEST_IFACE, UID_RED, SET_DEFAULT, 0xF00D, 512L, 4L, 512L, 4L, 0L)
-                .addValues(TEST_IFACE, UID_BLUE, SET_DEFAULT, TAG_NONE, 512L, 4L, 0L, 0L, 0L));
-        expectNetworkStatsPoll();
-
-        mService.incrementOperationCount(UID_RED, 0xF00D, 10);
-
-        replay();
-        forcePollAndWaitForIdle();
-
-        // verify service recorded history
-        assertNetworkTotal(sTemplateImsi1, 2048L, 16L, 512L, 4L, 0);
-        assertNetworkTotal(sTemplateWifi, 0L, 0L, 0L, 0L, 0);
-        assertUidTotal(sTemplateImsi1, UID_RED, 1536L, 12L, 512L, 4L, 10);
-        assertUidTotal(sTemplateImsi1, UID_BLUE, 512L, 4L, 0L, 0L, 0);
-        verifyAndReset();
-
-        // now switch networks; this also tests that we're okay with interfaces
-        // disappearing, to verify we don't count backwards.
-        incrementCurrentTime(HOUR_IN_MILLIS);
-        expectCurrentTime();
-        expectDefaultSettings();
-        expectNetworkState(buildMobile3gState(IMSI_2));
-        expectNetworkStatsSummary(new NetworkStats(getElapsedRealtime(), 1)
-                .addIfaceValues(TEST_IFACE, 2048L, 16L, 512L, 4L));
-        expectNetworkStatsUidDetail(new NetworkStats(getElapsedRealtime(), 3)
-                .addValues(TEST_IFACE, UID_RED, SET_DEFAULT, TAG_NONE, 1536L, 12L, 512L, 4L, 0L)
-                .addValues(TEST_IFACE, UID_RED, SET_DEFAULT, 0xF00D, 512L, 4L, 512L, 4L, 0L)
-                .addValues(TEST_IFACE, UID_BLUE, SET_DEFAULT, TAG_NONE, 512L, 4L, 0L, 0L, 0L));
-        expectNetworkStatsPoll();
-        expectBandwidthControlCheck();
-
-        replay();
-        mService.forceUpdateIfaces();
-        forcePollAndWaitForIdle();
-        verifyAndReset();
-
-        // create traffic on second network
-        incrementCurrentTime(HOUR_IN_MILLIS);
-        expectCurrentTime();
-        expectDefaultSettings();
-        expectNetworkStatsSummary(new NetworkStats(getElapsedRealtime(), 1)
-                .addIfaceValues(TEST_IFACE, 2176L, 17L, 1536L, 12L));
-        expectNetworkStatsUidDetail(new NetworkStats(getElapsedRealtime(), 1)
-                .addValues(TEST_IFACE, UID_RED, SET_DEFAULT, TAG_NONE, 1536L, 12L, 512L, 4L, 0L)
-                .addValues(TEST_IFACE, UID_RED, SET_DEFAULT, 0xF00D, 512L, 4L, 512L, 4L, 0L)
-                .addValues(TEST_IFACE, UID_BLUE, SET_DEFAULT, TAG_NONE, 640L, 5L, 1024L, 8L, 0L)
-                .addValues(TEST_IFACE, UID_BLUE, SET_DEFAULT, 0xFAAD, 128L, 1L, 1024L, 8L, 0L));
-        expectNetworkStatsPoll();
-
-        mService.incrementOperationCount(UID_BLUE, 0xFAAD, 10);
-
-        replay();
-        forcePollAndWaitForIdle();
-
-        // verify original history still intact
-        assertNetworkTotal(sTemplateImsi1, 2048L, 16L, 512L, 4L, 0);
-        assertUidTotal(sTemplateImsi1, UID_RED, 1536L, 12L, 512L, 4L, 10);
-        assertUidTotal(sTemplateImsi1, UID_BLUE, 512L, 4L, 0L, 0L, 0);
-
-        // and verify new history also recorded under different template, which
-        // verifies that we didn't cross the streams.
-        assertNetworkTotal(sTemplateImsi2, 128L, 1L, 1024L, 8L, 0);
-        assertNetworkTotal(sTemplateWifi, 0L, 0L, 0L, 0L, 0);
-        assertUidTotal(sTemplateImsi2, UID_BLUE, 128L, 1L, 1024L, 8L, 10);
-        verifyAndReset();
-
-    }
-
-    public void testUidRemovedIsMoved() throws Exception {
-        // pretend that network comes online
-        expectCurrentTime();
-        expectDefaultSettings();
-        expectNetworkState(buildWifiState());
-        expectNetworkStatsSummary(buildEmptyStats());
-        expectNetworkStatsUidDetail(buildEmptyStats());
-        expectNetworkStatsPoll();
-        expectBandwidthControlCheck();
-
-        replay();
-        mService.forceUpdateIfaces();
-        verifyAndReset();
-
-        // create some traffic
-        incrementCurrentTime(HOUR_IN_MILLIS);
-        expectCurrentTime();
-        expectDefaultSettings();
-        expectNetworkStatsSummary(new NetworkStats(getElapsedRealtime(), 1)
-                .addIfaceValues(TEST_IFACE, 4128L, 258L, 544L, 34L));
-        expectNetworkStatsUidDetail(new NetworkStats(getElapsedRealtime(), 1)
-                .addValues(TEST_IFACE, UID_RED, SET_DEFAULT, TAG_NONE, 16L, 1L, 16L, 1L, 0L)
-                .addValues(TEST_IFACE, UID_RED, SET_DEFAULT, 0xFAAD, 16L, 1L, 16L, 1L, 0L)
-                .addValues(TEST_IFACE, UID_BLUE, SET_DEFAULT, TAG_NONE, 4096L, 258L, 512L, 32L, 0L)
-                .addValues(TEST_IFACE, UID_GREEN, SET_DEFAULT, TAG_NONE, 16L, 1L, 16L, 1L, 0L));
-        expectNetworkStatsPoll();
-
-        mService.incrementOperationCount(UID_RED, 0xFAAD, 10);
-
-        replay();
-        forcePollAndWaitForIdle();
-
-        // verify service recorded history
-        assertNetworkTotal(sTemplateWifi, 4128L, 258L, 544L, 34L, 0);
-        assertUidTotal(sTemplateWifi, UID_RED, 16L, 1L, 16L, 1L, 10);
-        assertUidTotal(sTemplateWifi, UID_BLUE, 4096L, 258L, 512L, 32L, 0);
-        assertUidTotal(sTemplateWifi, UID_GREEN, 16L, 1L, 16L, 1L, 0);
-        verifyAndReset();
-
-        // now pretend two UIDs are uninstalled, which should migrate stats to
-        // special "removed" bucket.
-        expectCurrentTime();
-        expectDefaultSettings();
-        expectNetworkStatsSummary(new NetworkStats(getElapsedRealtime(), 1)
-                .addIfaceValues(TEST_IFACE, 4128L, 258L, 544L, 34L));
-        expectNetworkStatsUidDetail(new NetworkStats(getElapsedRealtime(), 1)
-                .addValues(TEST_IFACE, UID_RED, SET_DEFAULT, TAG_NONE, 16L, 1L, 16L, 1L, 0L)
-                .addValues(TEST_IFACE, UID_RED, SET_DEFAULT, 0xFAAD, 16L, 1L, 16L, 1L, 0L)
-                .addValues(TEST_IFACE, UID_BLUE, SET_DEFAULT, TAG_NONE, 4096L, 258L, 512L, 32L, 0L)
-                .addValues(TEST_IFACE, UID_GREEN, SET_DEFAULT, TAG_NONE, 16L, 1L, 16L, 1L, 0L));
-        expectNetworkStatsPoll();
-
-        replay();
-        final Intent intent = new Intent(ACTION_UID_REMOVED);
-        intent.putExtra(EXTRA_UID, UID_BLUE);
-        mServiceContext.sendBroadcast(intent);
-        intent.putExtra(EXTRA_UID, UID_RED);
-        mServiceContext.sendBroadcast(intent);
-
-        // existing uid and total should remain unchanged; but removed UID
-        // should be gone completely.
-        assertNetworkTotal(sTemplateWifi, 4128L, 258L, 544L, 34L, 0);
-        assertUidTotal(sTemplateWifi, UID_RED, 0L, 0L, 0L, 0L, 0);
-        assertUidTotal(sTemplateWifi, UID_BLUE, 0L, 0L, 0L, 0L, 0);
-        assertUidTotal(sTemplateWifi, UID_GREEN, 16L, 1L, 16L, 1L, 0);
-        assertUidTotal(sTemplateWifi, UID_REMOVED, 4112L, 259L, 528L, 33L, 10);
-        verifyAndReset();
-
-    }
-
-    public void testUid3g4gCombinedByTemplate() throws Exception {
-        // pretend that network comes online
-        expectCurrentTime();
-        expectDefaultSettings();
-        expectNetworkState(buildMobile3gState(IMSI_1));
-        expectNetworkStatsSummary(buildEmptyStats());
-        expectNetworkStatsUidDetail(buildEmptyStats());
-        expectNetworkStatsPoll();
-        expectBandwidthControlCheck();
-
-        replay();
-        mService.forceUpdateIfaces();
-        verifyAndReset();
-
-        // create some traffic
-        incrementCurrentTime(HOUR_IN_MILLIS);
-        expectCurrentTime();
-        expectDefaultSettings();
-        expectNetworkStatsSummary(buildEmptyStats());
-        expectNetworkStatsUidDetail(new NetworkStats(getElapsedRealtime(), 1)
-                .addValues(TEST_IFACE, UID_RED, SET_DEFAULT, TAG_NONE, 1024L, 8L, 1024L, 8L, 0L)
-                .addValues(TEST_IFACE, UID_RED, SET_DEFAULT, 0xF00D, 512L, 4L, 512L, 4L, 0L));
-        expectNetworkStatsPoll();
-
-        mService.incrementOperationCount(UID_RED, 0xF00D, 5);
-
-        replay();
-        forcePollAndWaitForIdle();
-
-        // verify service recorded history
-        assertUidTotal(sTemplateImsi1, UID_RED, 1024L, 8L, 1024L, 8L, 5);
-        verifyAndReset();
-
-        // now switch over to 4g network
-        incrementCurrentTime(HOUR_IN_MILLIS);
-        expectCurrentTime();
-        expectDefaultSettings();
-        expectNetworkState(buildMobile4gState(TEST_IFACE2));
-        expectNetworkStatsSummary(buildEmptyStats());
-        expectNetworkStatsUidDetail(new NetworkStats(getElapsedRealtime(), 1)
-                .addValues(TEST_IFACE, UID_RED, SET_DEFAULT, TAG_NONE, 1024L, 8L, 1024L, 8L, 0L)
-                .addValues(TEST_IFACE, UID_RED, SET_DEFAULT, 0xF00D, 512L, 4L, 512L, 4L, 0L));
-        expectNetworkStatsPoll();
-        expectBandwidthControlCheck();
-
-        replay();
-        mService.forceUpdateIfaces();
-        forcePollAndWaitForIdle();
-        verifyAndReset();
-
-        // create traffic on second network
-        incrementCurrentTime(HOUR_IN_MILLIS);
-        expectCurrentTime();
-        expectDefaultSettings();
-        expectNetworkStatsSummary(buildEmptyStats());
-        expectNetworkStatsUidDetail(new NetworkStats(getElapsedRealtime(), 1)
-                .addValues(TEST_IFACE, UID_RED, SET_DEFAULT, TAG_NONE, 1024L, 8L, 1024L, 8L, 0L)
-                .addValues(TEST_IFACE, UID_RED, SET_DEFAULT, 0xF00D, 512L, 4L, 512L, 4L, 0L)
-                .addValues(TEST_IFACE2, UID_RED, SET_DEFAULT, TAG_NONE, 512L, 4L, 256L, 2L, 0L)
-                .addValues(TEST_IFACE2, UID_RED, SET_DEFAULT, 0xFAAD, 512L, 4L, 256L, 2L, 0L));
-        expectNetworkStatsPoll();
-
-        mService.incrementOperationCount(UID_RED, 0xFAAD, 5);
-
-        replay();
-        forcePollAndWaitForIdle();
-
-        // verify that ALL_MOBILE template combines both
-        assertUidTotal(sTemplateImsi1, UID_RED, 1536L, 12L, 1280L, 10L, 10);
-
-        verifyAndReset();
-    }
-
-    public void testSummaryForAllUid() throws Exception {
-        // pretend that network comes online
-        expectCurrentTime();
-        expectDefaultSettings();
-        expectNetworkState(buildWifiState());
-        expectNetworkStatsSummary(buildEmptyStats());
-        expectNetworkStatsUidDetail(buildEmptyStats());
-        expectNetworkStatsPoll();
-        expectBandwidthControlCheck();
-
-        replay();
-        mService.forceUpdateIfaces();
-        verifyAndReset();
-
-        // create some traffic for two apps
-        incrementCurrentTime(HOUR_IN_MILLIS);
-        expectCurrentTime();
-        expectDefaultSettings();
-        expectNetworkStatsSummary(buildEmptyStats());
-        expectNetworkStatsUidDetail(new NetworkStats(getElapsedRealtime(), 1)
-                .addValues(TEST_IFACE, UID_RED, SET_DEFAULT, TAG_NONE, 50L, 5L, 50L, 5L, 0L)
-                .addValues(TEST_IFACE, UID_RED, SET_DEFAULT, 0xF00D, 10L, 1L, 10L, 1L, 0L)
-                .addValues(TEST_IFACE, UID_BLUE, SET_DEFAULT, TAG_NONE, 1024L, 8L, 512L, 4L, 0L));
-        expectNetworkStatsPoll();
-
-        mService.incrementOperationCount(UID_RED, 0xF00D, 1);
-
-        replay();
-        forcePollAndWaitForIdle();
-
-        // verify service recorded history
-        assertUidTotal(sTemplateWifi, UID_RED, 50L, 5L, 50L, 5L, 1);
-        assertUidTotal(sTemplateWifi, UID_BLUE, 1024L, 8L, 512L, 4L, 0);
-        verifyAndReset();
-
-        // now create more traffic in next hour, but only for one app
-        incrementCurrentTime(HOUR_IN_MILLIS);
-        expectCurrentTime();
-        expectDefaultSettings();
-        expectNetworkStatsSummary(buildEmptyStats());
-        expectNetworkStatsUidDetail(new NetworkStats(getElapsedRealtime(), 1)
-                .addValues(TEST_IFACE, UID_RED, SET_DEFAULT, TAG_NONE, 50L, 5L, 50L, 5L, 0L)
-                .addValues(TEST_IFACE, UID_RED, SET_DEFAULT, 0xF00D, 10L, 1L, 10L, 1L, 0L)
-                .addValues(TEST_IFACE, UID_BLUE, SET_DEFAULT, TAG_NONE, 2048L, 16L, 1024L, 8L, 0L));
-        expectNetworkStatsPoll();
-
-        replay();
-        forcePollAndWaitForIdle();
-
-        // first verify entire history present
-        NetworkStats stats = mSession.getSummaryForAllUid(
-                sTemplateWifi, Long.MIN_VALUE, Long.MAX_VALUE, true);
-        assertEquals(3, stats.size());
-        assertValues(stats, IFACE_ALL, UID_RED, SET_DEFAULT, TAG_NONE, ROAMING_NO, 50L, 5L,
-                50L, 5L, 1);
-        assertValues(stats, IFACE_ALL, UID_RED, SET_DEFAULT, 0xF00D, ROAMING_NO, 10L, 1L, 10L,
-                1L, 1);
-        assertValues(stats, IFACE_ALL, UID_BLUE, SET_DEFAULT, TAG_NONE, ROAMING_NO, 2048L, 16L,
-                1024L, 8L, 0);
-
-        // now verify that recent history only contains one uid
-        final long currentTime = currentTimeMillis();
-        stats = mSession.getSummaryForAllUid(
-                sTemplateWifi, currentTime - HOUR_IN_MILLIS, currentTime, true);
-        assertEquals(1, stats.size());
-        assertValues(stats, IFACE_ALL, UID_BLUE, SET_DEFAULT, TAG_NONE, ROAMING_NO, 1024L, 8L,
-                512L, 4L, 0);
-
-        verifyAndReset();
-    }
-
-    public void testForegroundBackground() throws Exception {
-        // pretend that network comes online
-        expectCurrentTime();
-        expectDefaultSettings();
-        expectNetworkState(buildWifiState());
-        expectNetworkStatsSummary(buildEmptyStats());
-        expectNetworkStatsUidDetail(buildEmptyStats());
-        expectNetworkStatsPoll();
-        expectBandwidthControlCheck();
-
-        replay();
-        mService.forceUpdateIfaces();
-        verifyAndReset();
-
-        // create some initial traffic
-        incrementCurrentTime(HOUR_IN_MILLIS);
-        expectCurrentTime();
-        expectDefaultSettings();
-        expectNetworkStatsSummary(buildEmptyStats());
-        expectNetworkStatsUidDetail(new NetworkStats(getElapsedRealtime(), 1)
-                .addValues(TEST_IFACE, UID_RED, SET_DEFAULT, TAG_NONE, 128L, 2L, 128L, 2L, 0L)
-                .addValues(TEST_IFACE, UID_RED, SET_DEFAULT, 0xF00D, 64L, 1L, 64L, 1L, 0L));
-        expectNetworkStatsPoll();
-
-        mService.incrementOperationCount(UID_RED, 0xF00D, 1);
-
-        replay();
-        forcePollAndWaitForIdle();
-
-        // verify service recorded history
-        assertUidTotal(sTemplateWifi, UID_RED, 128L, 2L, 128L, 2L, 1);
-        verifyAndReset();
-
-        // now switch to foreground
-        incrementCurrentTime(HOUR_IN_MILLIS);
-        expectCurrentTime();
-        expectDefaultSettings();
-        expectNetworkStatsSummary(buildEmptyStats());
-        expectNetworkStatsUidDetail(new NetworkStats(getElapsedRealtime(), 1)
-                .addValues(TEST_IFACE, UID_RED, SET_DEFAULT, TAG_NONE, 128L, 2L, 128L, 2L, 0L)
-                .addValues(TEST_IFACE, UID_RED, SET_DEFAULT, 0xF00D, 64L, 1L, 64L, 1L, 0L)
-                .addValues(TEST_IFACE, UID_RED, SET_FOREGROUND, TAG_NONE, 32L, 2L, 32L, 2L, 0L)
-                .addValues(TEST_IFACE, UID_RED, SET_FOREGROUND, 0xFAAD, 1L, 1L, 1L, 1L, 0L));
-        expectNetworkStatsPoll();
-
-        mService.setUidForeground(UID_RED, true);
-        mService.incrementOperationCount(UID_RED, 0xFAAD, 1);
-
-        replay();
-        forcePollAndWaitForIdle();
-
-        // test that we combined correctly
-        assertUidTotal(sTemplateWifi, UID_RED, 160L, 4L, 160L, 4L, 2);
-
-        // verify entire history present
-        final NetworkStats stats = mSession.getSummaryForAllUid(
-                sTemplateWifi, Long.MIN_VALUE, Long.MAX_VALUE, true);
-        assertEquals(4, stats.size());
-        assertValues(stats, IFACE_ALL, UID_RED, SET_DEFAULT, TAG_NONE, ROAMING_NO, 128L, 2L,
-                128L, 2L, 1);
-        assertValues(stats, IFACE_ALL, UID_RED, SET_DEFAULT, 0xF00D, ROAMING_NO, 64L, 1L, 64L,
-                1L, 1);
-        assertValues(stats, IFACE_ALL, UID_RED, SET_FOREGROUND, TAG_NONE, ROAMING_NO, 32L, 2L,
-                32L, 2L, 1);
-        assertValues(stats, IFACE_ALL, UID_RED, SET_FOREGROUND, 0xFAAD, ROAMING_NO, 1L, 1L, 1L,
-                1L, 1);
-
-        verifyAndReset();
-    }
-
-    public void testRoaming() throws Exception {
-        // pretend that network comes online
-        expectCurrentTime();
-        expectDefaultSettings();
-        expectNetworkState(buildMobile3gState(IMSI_1, true /* isRoaming */));
-        expectNetworkStatsSummary(buildEmptyStats());
-        expectNetworkStatsUidDetail(buildEmptyStats());
-        expectNetworkStatsPoll();
-        expectBandwidthControlCheck();
-
-        replay();
-        mService.forceUpdateIfaces();
-        verifyAndReset();
-
-        // Create some traffic
-        incrementCurrentTime(HOUR_IN_MILLIS);
-        expectCurrentTime();
-        expectDefaultSettings();
-        expectNetworkStatsSummary(buildEmptyStats());
-        // Note that all traffic from NetworkManagementService is tagged as ROAMING_NO, because
-        // roaming isn't tracked at that layer. We layer it on top by inspecting the iface
-        // properties.
-        expectNetworkStatsUidDetail(new NetworkStats(getElapsedRealtime(), 1)
-                .addValues(TEST_IFACE, UID_RED, SET_DEFAULT, TAG_NONE, ROAMING_NO, 128L, 2L,
-                        128L, 2L, 0L)
-                .addValues(TEST_IFACE, UID_RED, SET_DEFAULT, 0xF00D, ROAMING_NO, 64L, 1L, 64L,
-                        1L, 0L));
-        expectNetworkStatsPoll();
-
-        replay();
-        forcePollAndWaitForIdle();
-
-        // verify service recorded history
-        assertUidTotal(sTemplateImsi1, UID_RED, 128L, 2L, 128L, 2L, 0);
-
-        // verify entire history present
-        final NetworkStats stats = mSession.getSummaryForAllUid(
-                sTemplateImsi1, Long.MIN_VALUE, Long.MAX_VALUE, true);
-        assertEquals(2, stats.size());
-        assertValues(stats, IFACE_ALL, UID_RED, SET_DEFAULT, TAG_NONE, ROAMING_YES, 128L, 2L,
-                128L, 2L, 0);
-        assertValues(stats, IFACE_ALL, UID_RED, SET_DEFAULT, 0xF00D, ROAMING_YES, 64L, 1L, 64L,
-                1L, 0);
-
-        verifyAndReset();
-    }
-
-    public void testTethering() throws Exception {
-        // pretend first mobile network comes online
-        expectCurrentTime();
-        expectDefaultSettings();
-        expectNetworkState(buildMobile3gState(IMSI_1));
-        expectNetworkStatsSummary(buildEmptyStats());
-        expectNetworkStatsUidDetail(buildEmptyStats());
-        expectNetworkStatsPoll();
-        expectBandwidthControlCheck();
-
-        replay();
-        mService.forceUpdateIfaces();
-        verifyAndReset();
-
-        // create some tethering traffic
-        incrementCurrentTime(HOUR_IN_MILLIS);
-        expectCurrentTime();
-        expectDefaultSettings();
-        expectNetworkStatsSummary(new NetworkStats(getElapsedRealtime(), 1)
-                .addIfaceValues(TEST_IFACE, 2048L, 16L, 512L, 4L));
-
-        final NetworkStats uidStats = new NetworkStats(getElapsedRealtime(), 1)
-                .addValues(TEST_IFACE, UID_RED, SET_DEFAULT, TAG_NONE, 128L, 2L, 128L, 2L, 0L);
-        final String[] tetherIfacePairs = new String[] { TEST_IFACE, "wlan0" };
-        final NetworkStats tetherStats = new NetworkStats(getElapsedRealtime(), 1)
-                .addValues(TEST_IFACE, UID_TETHERING, SET_DEFAULT, TAG_NONE, 1920L, 14L, 384L, 2L, 0L);
-
-        expectNetworkStatsUidDetail(uidStats, tetherIfacePairs, tetherStats);
-        expectNetworkStatsPoll();
-
-        replay();
-        forcePollAndWaitForIdle();
-
-        // verify service recorded history
-        assertNetworkTotal(sTemplateImsi1, 2048L, 16L, 512L, 4L, 0);
-        assertUidTotal(sTemplateImsi1, UID_RED, 128L, 2L, 128L, 2L, 0);
-        assertUidTotal(sTemplateImsi1, UID_TETHERING, 1920L, 14L, 384L, 2L, 0);
-        verifyAndReset();
-
-    }
-
-    public void testRegisterUsageCallback() throws Exception {
-        // pretend that wifi network comes online; service should ask about full
-        // network state, and poll any existing interfaces before updating.
-        expectCurrentTime();
-        expectDefaultSettings();
-        expectNetworkState(buildWifiState());
-        expectNetworkStatsSummary(buildEmptyStats());
-        expectNetworkStatsUidDetail(buildEmptyStats());
-        expectNetworkStatsPoll();
-        expectBandwidthControlCheck();
-
-        replay();
-        mService.forceUpdateIfaces();
-
-        // verify service has empty history for wifi
-        assertNetworkTotal(sTemplateWifi, 0L, 0L, 0L, 0L, 0);
-        verifyAndReset();
-
-        String callingPackage = "the.calling.package";
-        long thresholdInBytes = 1L;  // very small; should be overriden by framework
-        DataUsageRequest inputRequest = new DataUsageRequest(
-                DataUsageRequest.REQUEST_ID_UNSET, sTemplateWifi, thresholdInBytes);
-
-        // Create a messenger that waits for callback activity
-        ConditionVariable cv = new ConditionVariable(false);
-        LatchedHandler latchedHandler = new LatchedHandler(Looper.getMainLooper(), cv);
-        Messenger messenger = new Messenger(latchedHandler);
-
-        // Allow binder to connect
-        IBinder mockBinder = createMock(IBinder.class);
-        mockBinder.linkToDeath((IBinder.DeathRecipient) anyObject(), anyInt());
-        EasyMock.replay(mockBinder);
-
-        // Force poll
-        expectCurrentTime();
-        expectDefaultSettings();
-        expectNetworkStatsSummary(buildEmptyStats());
-        expectNetworkStatsUidDetail(buildEmptyStats());
-        expectNetworkStatsPoll();
-        replay();
-
-        // Register and verify request and that binder was called
-        DataUsageRequest request =
-                mService.registerUsageCallback(callingPackage, inputRequest,
-                        messenger, mockBinder);
-        assertTrue(request.requestId > 0);
-        assertTrue(Objects.equals(sTemplateWifi, request.template));
-        long minThresholdInBytes = 2 * 1024 * 1024; // 2 MB
-        assertEquals(minThresholdInBytes, request.thresholdInBytes);
-
-        // Send dummy message to make sure that any previous message has been handled
-        mHandler.sendMessage(mHandler.obtainMessage(-1));
-        mHandlerThread.waitForIdle(WAIT_TIMEOUT);
-
-        verifyAndReset();
-
-        // Make sure that the caller binder gets connected
-        EasyMock.verify(mockBinder);
-        EasyMock.reset(mockBinder);
-
-        // modify some number on wifi, and trigger poll event
-        // not enough traffic to call data usage callback
-        incrementCurrentTime(HOUR_IN_MILLIS);
-        expectCurrentTime();
-        expectDefaultSettings();
-        expectNetworkStatsSummary(new NetworkStats(getElapsedRealtime(), 1)
-                .addIfaceValues(TEST_IFACE, 1024L, 1L, 2048L, 2L));
-        expectNetworkStatsUidDetail(buildEmptyStats());
-        expectNetworkStatsPoll();
-
-        replay();
-        forcePollAndWaitForIdle();
-
-        // verify service recorded history
-        verifyAndReset();
-        assertNetworkTotal(sTemplateWifi, 1024L, 1L, 2048L, 2L, 0);
-
-        // make sure callback has not being called
-        assertEquals(INVALID_TYPE, latchedHandler.mLastMessageType);
-
-        // and bump forward again, with counters going higher. this is
-        // important, since it will trigger the data usage callback
-        incrementCurrentTime(DAY_IN_MILLIS);
-        expectCurrentTime();
-        expectDefaultSettings();
-        expectNetworkStatsSummary(new NetworkStats(getElapsedRealtime(), 1)
-                .addIfaceValues(TEST_IFACE, 4096000L, 4L, 8192000L, 8L));
-        expectNetworkStatsUidDetail(buildEmptyStats());
-        expectNetworkStatsPoll();
-
-        replay();
-        forcePollAndWaitForIdle();
-
-        // verify service recorded history
-        assertNetworkTotal(sTemplateWifi, 4096000L, 4L, 8192000L, 8L, 0);
-        verifyAndReset();
-
-        // Wait for the caller to ack receipt of CALLBACK_LIMIT_REACHED
-        assertTrue(cv.block(WAIT_TIMEOUT));
-        assertEquals(NetworkStatsManager.CALLBACK_LIMIT_REACHED, latchedHandler.mLastMessageType);
-        cv.close();
-
-        // Allow binder to disconnect
-        expect(mockBinder.unlinkToDeath((IBinder.DeathRecipient) anyObject(), anyInt()))
-                .andReturn(true);
-        EasyMock.replay(mockBinder);
-
-        // Unregister request
-        mService.unregisterUsageRequest(request);
-
-        // Wait for the caller to ack receipt of CALLBACK_RELEASED
-        assertTrue(cv.block(WAIT_TIMEOUT));
-        assertEquals(NetworkStatsManager.CALLBACK_RELEASED, latchedHandler.mLastMessageType);
-
-        // Make sure that the caller binder gets disconnected
-        EasyMock.verify(mockBinder);
-    }
-
-    public void testUnregisterUsageCallback_unknown_noop() throws Exception {
-        String callingPackage = "the.calling.package";
-        long thresholdInBytes = 10 * 1024 * 1024;  // 10 MB
-        DataUsageRequest unknownRequest = new DataUsageRequest(
-                2 /* requestId */, sTemplateImsi1, thresholdInBytes);
-
-        mService.unregisterUsageRequest(unknownRequest);
-    }
-
-    private static File getBaseDir(File statsDir) {
-        File baseDir = new File(statsDir, "netstats");
-        baseDir.mkdirs();
-        return baseDir;
-    }
-
-    private void assertNetworkTotal(NetworkTemplate template, long rxBytes, long rxPackets,
-            long txBytes, long txPackets, int operations) throws Exception {
-        assertNetworkTotal(template, Long.MIN_VALUE, Long.MAX_VALUE, rxBytes, rxPackets, txBytes,
-                txPackets, operations);
-    }
-
-    private void assertNetworkTotal(NetworkTemplate template, long start, long end, long rxBytes,
-            long rxPackets, long txBytes, long txPackets, int operations) throws Exception {
-        // verify history API
-        final NetworkStatsHistory history = mSession.getHistoryForNetwork(template, FIELD_ALL);
-        assertValues(history, start, end, rxBytes, rxPackets, txBytes, txPackets, operations);
-
-        // verify summary API
-        final NetworkStats stats = mSession.getSummaryForNetwork(template, start, end);
-        assertValues(stats, IFACE_ALL, UID_ALL, SET_DEFAULT, TAG_NONE, ROAMING_NO, rxBytes,
-                rxPackets, txBytes, txPackets, operations);
-    }
-
-    private void assertUidTotal(NetworkTemplate template, int uid, long rxBytes, long rxPackets,
-            long txBytes, long txPackets, int operations) throws Exception {
-        assertUidTotal(template, uid, SET_ALL, ROAMING_ALL, rxBytes, rxPackets, txBytes, txPackets,
-                operations);
-    }
-
-    private void assertUidTotal(NetworkTemplate template, int uid, int set, int roaming,
-            long rxBytes, long rxPackets, long txBytes, long txPackets, int operations)
-            throws Exception {
-        // verify history API
-        final NetworkStatsHistory history = mSession.getHistoryForUid(
-                template, uid, set, TAG_NONE, FIELD_ALL);
-        assertValues(history, Long.MIN_VALUE, Long.MAX_VALUE, rxBytes, rxPackets, txBytes,
-                txPackets, operations);
-
-        // verify summary API
-        final NetworkStats stats = mSession.getSummaryForAllUid(
-                template, Long.MIN_VALUE, Long.MAX_VALUE, false);
-        assertValues(stats, IFACE_ALL, uid, set, TAG_NONE, roaming, rxBytes, rxPackets, txBytes,
-                txPackets, operations);
-    }
-
-    private void expectSystemReady() throws Exception {
-        mNetManager.setGlobalAlert(anyLong());
-        expectLastCall().atLeastOnce();
-
-        expectNetworkStatsSummary(buildEmptyStats());
-        expectBandwidthControlCheck();
-    }
-
-    private void expectNetworkState(NetworkState... state) throws Exception {
-        expect(mConnManager.getAllNetworkState()).andReturn(state).atLeastOnce();
-
-        final LinkProperties linkProp = state.length > 0 ? state[0].linkProperties : null;
-        expect(mConnManager.getActiveLinkProperties()).andReturn(linkProp).atLeastOnce();
-    }
-
-    private void expectNetworkStatsSummary(NetworkStats summary) throws Exception {
-        expect(mConnManager.getAllVpnInfo()).andReturn(new VpnInfo[0]).atLeastOnce();
-
-        expectNetworkStatsSummaryDev(summary);
-        expectNetworkStatsSummaryXt(summary);
-    }
-
-    private void expectNetworkStatsSummaryDev(NetworkStats summary) throws Exception {
-        expect(mNetManager.getNetworkStatsSummaryDev()).andReturn(summary).atLeastOnce();
-    }
-
-    private void expectNetworkStatsSummaryXt(NetworkStats summary) throws Exception {
-        expect(mNetManager.getNetworkStatsSummaryXt()).andReturn(summary).atLeastOnce();
-    }
-
-    private void expectNetworkStatsUidDetail(NetworkStats detail) throws Exception {
-        expectNetworkStatsUidDetail(detail, new String[0], new NetworkStats(0L, 0));
-    }
-
-    private void expectNetworkStatsUidDetail(
-            NetworkStats detail, String[] tetherIfacePairs, NetworkStats tetherStats)
-            throws Exception {
-        expect(mNetManager.getNetworkStatsUidDetail(eq(UID_ALL))).andReturn(detail).atLeastOnce();
-
-        // also include tethering details, since they are folded into UID
-        expect(mNetManager.getNetworkStatsTethering())
-                .andReturn(tetherStats).atLeastOnce();
-    }
-
-    private void expectDefaultSettings() throws Exception {
-        expectSettings(0L, HOUR_IN_MILLIS, WEEK_IN_MILLIS);
-    }
-
-    private void expectSettings(long persistBytes, long bucketDuration, long deleteAge)
-            throws Exception {
-        expect(mSettings.getPollInterval()).andReturn(HOUR_IN_MILLIS).anyTimes();
-        expect(mSettings.getTimeCacheMaxAge()).andReturn(DAY_IN_MILLIS).anyTimes();
-        expect(mSettings.getSampleEnabled()).andReturn(true).anyTimes();
-
-        final Config config = new Config(bucketDuration, deleteAge, deleteAge);
-        expect(mSettings.getDevConfig()).andReturn(config).anyTimes();
-        expect(mSettings.getXtConfig()).andReturn(config).anyTimes();
-        expect(mSettings.getUidConfig()).andReturn(config).anyTimes();
-        expect(mSettings.getUidTagConfig()).andReturn(config).anyTimes();
-
-        expect(mSettings.getGlobalAlertBytes(anyLong())).andReturn(MB_IN_BYTES).anyTimes();
-        expect(mSettings.getDevPersistBytes(anyLong())).andReturn(MB_IN_BYTES).anyTimes();
-        expect(mSettings.getXtPersistBytes(anyLong())).andReturn(MB_IN_BYTES).anyTimes();
-        expect(mSettings.getUidPersistBytes(anyLong())).andReturn(MB_IN_BYTES).anyTimes();
-        expect(mSettings.getUidTagPersistBytes(anyLong())).andReturn(MB_IN_BYTES).anyTimes();
-    }
-
-    private void expectCurrentTime() throws Exception {
-        expect(mTime.forceRefresh()).andReturn(false).anyTimes();
-        expect(mTime.hasCache()).andReturn(true).anyTimes();
-        expect(mTime.currentTimeMillis()).andReturn(currentTimeMillis()).anyTimes();
-        expect(mTime.getCacheAge()).andReturn(0L).anyTimes();
-        expect(mTime.getCacheCertainty()).andReturn(0L).anyTimes();
-    }
-
-    private void expectNetworkStatsPoll() throws Exception {
-        mNetManager.setGlobalAlert(anyLong());
-        expectLastCall().anyTimes();
-    }
-
-    private void expectBandwidthControlCheck() throws Exception {
-        expect(mNetManager.isBandwidthControlEnabled()).andReturn(true).atLeastOnce();
-    }
-
-    private void assertStatsFilesExist(boolean exist) {
-        final File basePath = new File(mStatsDir, "netstats");
-        if (exist) {
-            assertTrue(basePath.list().length > 0);
-        } else {
-            assertTrue(basePath.list().length == 0);
-        }
-    }
-
-    private static void assertValues(NetworkStats stats, String iface, int uid, int set,
-            int tag, int roaming, long rxBytes, long rxPackets, long txBytes, long txPackets,
-            int operations) {
-        final NetworkStats.Entry entry = new NetworkStats.Entry();
-        List<Integer> sets = new ArrayList<>();
-        if (set == SET_DEFAULT || set == SET_ALL) {
-            sets.add(SET_DEFAULT);
-        }
-        if (set == SET_FOREGROUND || set == SET_ALL) {
-            sets.add(SET_FOREGROUND);
-        }
-
-        List<Integer> roamings = new ArrayList<>();
-        if (roaming == ROAMING_NO || roaming == ROAMING_ALL) {
-            roamings.add(ROAMING_NO);
-        }
-        if (roaming == ROAMING_YES || roaming == ROAMING_ALL) {
-            roamings.add(ROAMING_YES);
-        }
-
-        for (int s : sets) {
-            for (int r : roamings) {
-                final int i = stats.findIndex(iface, uid, s, tag, r);
-                if (i != -1) {
-                    entry.add(stats.getValues(i, null));
-                }
-            }
-        }
-
-        assertEquals("unexpected rxBytes", rxBytes, entry.rxBytes);
-        assertEquals("unexpected rxPackets", rxPackets, entry.rxPackets);
-        assertEquals("unexpected txBytes", txBytes, entry.txBytes);
-        assertEquals("unexpected txPackets", txPackets, entry.txPackets);
-        assertEquals("unexpected operations", operations, entry.operations);
-    }
-
-    private static void assertValues(NetworkStatsHistory stats, long start, long end, long rxBytes,
-            long rxPackets, long txBytes, long txPackets, int operations) {
-        final NetworkStatsHistory.Entry entry = stats.getValues(start, end, null);
-        assertEquals("unexpected rxBytes", rxBytes, entry.rxBytes);
-        assertEquals("unexpected rxPackets", rxPackets, entry.rxPackets);
-        assertEquals("unexpected txBytes", txBytes, entry.txBytes);
-        assertEquals("unexpected txPackets", txPackets, entry.txPackets);
-        assertEquals("unexpected operations", operations, entry.operations);
-    }
-
-    private static NetworkState buildWifiState() {
-        final NetworkInfo info = new NetworkInfo(TYPE_WIFI, 0, null, null);
-        info.setDetailedState(DetailedState.CONNECTED, null, null);
-        final LinkProperties prop = new LinkProperties();
-        prop.setInterfaceName(TEST_IFACE);
-        return new NetworkState(info, prop, null, null, null, TEST_SSID);
-    }
-
-    private static NetworkState buildMobile3gState(String subscriberId) {
-        return buildMobile3gState(subscriberId, false /* isRoaming */);
-    }
-
-    private static NetworkState buildMobile3gState(String subscriberId, boolean isRoaming) {
-        final NetworkInfo info = new NetworkInfo(
-                TYPE_MOBILE, TelephonyManager.NETWORK_TYPE_UMTS, null, null);
-        info.setDetailedState(DetailedState.CONNECTED, null, null);
-        info.setRoaming(isRoaming);
-        final LinkProperties prop = new LinkProperties();
-        prop.setInterfaceName(TEST_IFACE);
-        return new NetworkState(info, prop, null, null, subscriberId, null);
-    }
-
-    private static NetworkState buildMobile4gState(String iface) {
-        final NetworkInfo info = new NetworkInfo(TYPE_WIMAX, 0, null, null);
-        info.setDetailedState(DetailedState.CONNECTED, null, null);
-        final LinkProperties prop = new LinkProperties();
-        prop.setInterfaceName(iface);
-        return new NetworkState(info, prop, null, null, null, null);
-    }
-
-    private NetworkStats buildEmptyStats() {
-        return new NetworkStats(getElapsedRealtime(), 0);
-    }
-
-    private long getElapsedRealtime() {
-        return mElapsedRealtime;
-    }
-
-    private long startTimeMillis() {
-        return TEST_START;
-    }
-
-    private long currentTimeMillis() {
-        return startTimeMillis() + mElapsedRealtime;
-    }
-
-    private void incrementCurrentTime(long duration) {
-        mElapsedRealtime += duration;
-    }
-
-    private void replay() {
-        EasyMock.replay(mNetManager, mTime, mSettings, mConnManager);
-    }
-
-    private void verifyAndReset() {
-        EasyMock.verify(mNetManager, mTime, mSettings, mConnManager);
-        EasyMock.reset(mNetManager, mTime, mSettings, mConnManager);
-    }
-
-    private void forcePollAndWaitForIdle() {
-        mServiceContext.sendBroadcast(new Intent(ACTION_NETWORK_STATS_POLL));
-        // Send dummy message to make sure that any previous message has been handled
-        mHandler.sendMessage(mHandler.obtainMessage(-1));
-        mHandlerThread.waitForIdle(WAIT_TIMEOUT);
-    }
-
-    static class LatchedHandler extends Handler {
-        private final ConditionVariable mCv;
-        int mLastMessageType = INVALID_TYPE;
-
-        LatchedHandler(Looper looper, ConditionVariable cv) {
-            super(looper);
-            mCv = cv;
-        }
-
-        @Override
-        public void handleMessage(Message msg) {
-            mLastMessageType = msg.what;
-            mCv.open();
-            super.handleMessage(msg);
-        }
-    }
-
-    /**
-     * A subclass of HandlerThread that allows callers to wait for it to become idle. waitForIdle
-     * will return immediately if the handler is already idle.
-     */
-    static class IdleableHandlerThread extends HandlerThread {
-        private IdleHandler mIdleHandler;
-
-        public IdleableHandlerThread(String name) {
-            super(name);
-        }
-
-        public void waitForIdle(long timeoutMs) {
-            final ConditionVariable cv = new ConditionVariable();
-            final MessageQueue queue = getLooper().getQueue();
-
-            synchronized (queue) {
-                if (queue.isIdle()) {
-                    return;
-                }
-
-                assertNull("BUG: only one idle handler allowed", mIdleHandler);
-                mIdleHandler = new IdleHandler() {
-                    public boolean queueIdle() {
-                        cv.open();
-                        mIdleHandler = null;
-                        return false;  // Remove the handler.
-                    }
-                };
-                queue.addIdleHandler(mIdleHandler);
-            }
-
-            if (!cv.block(timeoutMs)) {
-                fail("HandlerThread " + getName() + " did not become idle after " + timeoutMs
-                        + " ms");
-                queue.removeIdleHandler(mIdleHandler);
-            }
-        }
-    }
-
-}
diff --git a/services/tests/servicestests/src/com/android/server/notification/BuzzBeepBlinkTest.java b/services/tests/servicestests/src/com/android/server/notification/BuzzBeepBlinkTest.java
deleted file mode 100644
index d51f2d8152a..00000000000
--- a/services/tests/servicestests/src/com/android/server/notification/BuzzBeepBlinkTest.java
+++ /dev/null
@@ -1,542 +0,0 @@
-/*
- * Copyright (C) 2016 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.android.server.notification;
-
-
-import android.app.ActivityManager;
-import android.app.Notification;
-import android.app.Notification.Builder;
-import android.media.AudioAttributes;
-import android.media.AudioManager;
-import android.net.Uri;
-import android.os.Handler;
-import android.os.RemoteException;
-import android.os.UserHandle;
-import android.os.Vibrator;
-import android.service.notification.NotificationListenerService.Ranking;
-import android.service.notification.StatusBarNotification;
-import android.test.AndroidTestCase;
-import android.test.suitebuilder.annotation.SmallTest;
-
-import org.mockito.Mock;
-import org.mockito.Mockito;
-import org.mockito.MockitoAnnotations;
-
-import static org.mockito.Matchers.anyBoolean;
-import static org.mockito.Matchers.anyInt;
-import static org.mockito.Matchers.anyObject;
-import static org.mockito.Matchers.anyString;
-import static org.mockito.Matchers.eq;
-import static org.mockito.Mockito.never;
-import static org.mockito.Mockito.times;
-import static org.mockito.Mockito.verify;
-import static org.mockito.Mockito.when;
-
-public class BuzzBeepBlinkTest extends AndroidTestCase {
-
-    @Mock AudioManager mAudioManager;
-    @Mock Vibrator mVibrator;
-    @Mock android.media.IRingtonePlayer mRingtonePlayer;
-    @Mock Handler mHandler;
-
-    private NotificationManagerService mService;
-    private String mPkg = "com.android.server.notification";
-    private int mId = 1001;
-    private int mOtherId = 1002;
-    private String mTag = null;
-    private int mUid = 1000;
-    private int mPid = 2000;
-    private int mScore = 10;
-    private android.os.UserHandle mUser = UserHandle.of(ActivityManager.getCurrentUser());
-
-    @Override
-    public void setUp() {
-        MockitoAnnotations.initMocks(this);
-
-        when(mAudioManager.isAudioFocusExclusive()).thenReturn(false);
-        when(mAudioManager.getRingtonePlayer()).thenReturn(mRingtonePlayer);
-        when(mAudioManager.getStreamVolume(anyInt())).thenReturn(10);
-        when(mAudioManager.getRingerModeInternal()).thenReturn(AudioManager.RINGER_MODE_NORMAL);
-
-        mService = new NotificationManagerService(getContext());
-        mService.setAudioManager(mAudioManager);
-        mService.setVibrator(mVibrator);
-        mService.setSystemReady(true);
-        mService.setHandler(mHandler);
-        mService.setSystemNotificationSound("beep!");
-    }
-
-    //
-    // Convenience functions for creating notification records
-    //
-
-    private NotificationRecord getNoisyOtherNotification() {
-        return getNotificationRecord(mOtherId, false /* insistent */, false /* once */,
-                true /* noisy */, true /* buzzy*/);
-    }
-
-    private NotificationRecord getBeepyNotification() {
-        return getNotificationRecord(mId, false /* insistent */, false /* once */,
-                true /* noisy */, false /* buzzy*/);
-    }
-
-    private NotificationRecord getBeepyOnceNotification() {
-        return getNotificationRecord(mId, false /* insistent */, true /* once */,
-                true /* noisy */, false /* buzzy*/);
-    }
-
-    private NotificationRecord getQuietNotification() {
-        return getNotificationRecord(mId, false /* insistent */, false /* once */,
-                false /* noisy */, false /* buzzy*/);
-    }
-
-    private NotificationRecord getQuietOtherNotification() {
-        return getNotificationRecord(mOtherId, false /* insistent */, false /* once */,
-                false /* noisy */, false /* buzzy*/);
-    }
-
-    private NotificationRecord getQuietOnceNotification() {
-        return getNotificationRecord(mId, false /* insistent */, true /* once */,
-                false /* noisy */, false /* buzzy*/);
-    }
-
-    private NotificationRecord getInsistentBeepyNotification() {
-        return getNotificationRecord(mId, true /* insistent */, false /* once */,
-                true /* noisy */, false /* buzzy*/);
-    }
-
-    private NotificationRecord getBuzzyNotification() {
-        return getNotificationRecord(mId, false /* insistent */, false /* once */,
-                false /* noisy */, true /* buzzy*/);
-    }
-
-    private NotificationRecord getBuzzyOnceNotification() {
-        return getNotificationRecord(mId, false /* insistent */, true /* once */,
-                false /* noisy */, true /* buzzy*/);
-    }
-
-    private NotificationRecord getInsistentBuzzyNotification() {
-        return getNotificationRecord(mId, true /* insistent */, false /* once */,
-                false /* noisy */, true /* buzzy*/);
-    }
-
-    private NotificationRecord getNotificationRecord(int id, boolean insistent, boolean once,
-            boolean noisy, boolean buzzy) {
-        final Builder builder = new Builder(getContext())
-                .setContentTitle("foo")
-                .setSmallIcon(android.R.drawable.sym_def_app_icon)
-                .setPriority(Notification.PRIORITY_HIGH)
-                .setOnlyAlertOnce(once);
-
-        int defaults = 0;
-        if (noisy) {
-            defaults |= Notification.DEFAULT_SOUND;
-        }
-        if (buzzy) {
-            defaults |= Notification.DEFAULT_VIBRATE;
-        }
-        builder.setDefaults(defaults);
-
-        Notification n = builder.build();
-        if (insistent) {
-            n.flags |= Notification.FLAG_INSISTENT;
-        }
-        StatusBarNotification sbn = new StatusBarNotification(mPkg, mPkg, id, mTag, mUid, mPid,
-                mScore, n, mUser, System.currentTimeMillis());
-        return new NotificationRecord(getContext(), sbn);
-    }
-
-    //
-    // Convenience functions for interacting with mocks
-    //
-
-    private void verifyNeverBeep() throws RemoteException {
-        verify(mRingtonePlayer, never()).playAsync((Uri) anyObject(), (UserHandle) anyObject(),
-                anyBoolean(), (AudioAttributes) anyObject());
-    }
-
-    private void verifyBeep() throws RemoteException {
-        verify(mRingtonePlayer, times(1)).playAsync((Uri) anyObject(), (UserHandle) anyObject(),
-                eq(true), (AudioAttributes) anyObject());
-    }
-
-    private void verifyBeepLooped() throws RemoteException {
-        verify(mRingtonePlayer, times(1)).playAsync((Uri) anyObject(), (UserHandle) anyObject(),
-                eq(false), (AudioAttributes) anyObject());
-    }
-
-    private void verifyNeverStopAudio() throws RemoteException {
-        verify(mRingtonePlayer, never()).stopAsync();
-    }
-
-    private void verifyStopAudio() throws RemoteException {
-        verify(mRingtonePlayer, times(1)).stopAsync();
-    }
-
-    private void verifyNeverVibrate() {
-        verify(mVibrator, never()).vibrate(anyInt(), anyString(), (long[]) anyObject(),
-                anyInt(), (AudioAttributes) anyObject());
-    }
-
-    private void verifyVibrate() {
-        verify(mVibrator, times(1)).vibrate(anyInt(), anyString(), (long[]) anyObject(),
-                eq(-1), (AudioAttributes) anyObject());
-    }
-
-    private void verifyVibrateLooped() {
-        verify(mVibrator, times(1)).vibrate(anyInt(), anyString(), (long[]) anyObject(),
-                eq(0), (AudioAttributes) anyObject());
-    }
-
-    private void verifyStopVibrate() {
-        verify(mVibrator, times(1)).cancel();
-    }
-
-    private void verifyNeverStopVibrate() throws RemoteException {
-        verify(mVibrator, never()).cancel();
-    }
-
-    @SmallTest
-    public void testBeep() throws Exception {
-        NotificationRecord r = getBeepyNotification();
-
-        mService.buzzBeepBlinkLocked(r);
-
-        verifyBeepLooped();
-        verifyNeverVibrate();
-    }
-
-    //
-    // Tests
-    //
-
-    @SmallTest
-    public void testBeepInsistently() throws Exception {
-        NotificationRecord r = getInsistentBeepyNotification();
-
-        mService.buzzBeepBlinkLocked(r);
-
-        verifyBeep();
-    }
-
-    @SmallTest
-    public void testNoInterruptionForMin() throws Exception {
-        NotificationRecord r = getBeepyNotification();
-        r.setImportance(Ranking.IMPORTANCE_MIN, "foo");
-
-        mService.buzzBeepBlinkLocked(r);
-
-        verifyNeverBeep();
-        verifyNeverVibrate();
-    }
-
-    @SmallTest
-    public void testNoInterruptionForIntercepted() throws Exception {
-        NotificationRecord r = getBeepyNotification();
-        r.setIntercepted(true);
-
-        mService.buzzBeepBlinkLocked(r);
-
-        verifyNeverBeep();
-        verifyNeverVibrate();
-    }
-
-    @SmallTest
-    public void testBeepTwice() throws Exception {
-        NotificationRecord r = getBeepyNotification();
-
-        // set up internal state
-        mService.buzzBeepBlinkLocked(r);
-        Mockito.reset(mRingtonePlayer);
-
-        // update should beep
-        r.isUpdate = true;
-        mService.buzzBeepBlinkLocked(r);
-        verifyBeepLooped();
-    }
-
-    @SmallTest
-    public void testHonorAlertOnlyOnceForBeep() throws Exception {
-        NotificationRecord r = getBeepyNotification();
-        NotificationRecord s = getBeepyOnceNotification();
-        s.isUpdate = true;
-
-        // set up internal state
-        mService.buzzBeepBlinkLocked(r);
-        Mockito.reset(mRingtonePlayer);
-
-        // update should not beep
-        mService.buzzBeepBlinkLocked(s);
-        verifyNeverBeep();
-    }
-
-    @SmallTest
-    public void testNoisyUpdateDoesNotCancelAudio() throws Exception {
-        NotificationRecord r = getBeepyNotification();
-
-        mService.buzzBeepBlinkLocked(r);
-        r.isUpdate = true;
-        mService.buzzBeepBlinkLocked(r);
-
-        verifyNeverStopAudio();
-    }
-
-    @SmallTest
-    public void testNoisyOnceUpdateDoesNotCancelAudio() throws Exception {
-        NotificationRecord r = getBeepyNotification();
-        NotificationRecord s = getBeepyOnceNotification();
-        s.isUpdate = true;
-
-        mService.buzzBeepBlinkLocked(r);
-        mService.buzzBeepBlinkLocked(s);
-
-        verifyNeverStopAudio();
-    }
-
-    @SmallTest
-    public void testQuietUpdateDoesNotCancelAudioFromOther() throws Exception {
-        NotificationRecord r = getBeepyNotification();
-        NotificationRecord s = getQuietNotification();
-        s.isUpdate = true;
-        NotificationRecord other = getNoisyOtherNotification();
-
-        // set up internal state
-        mService.buzzBeepBlinkLocked(r);
-        mService.buzzBeepBlinkLocked(other); // this takes the audio stream
-        Mockito.reset(mRingtonePlayer);
-
-        // should not stop noise, since we no longer own it
-        mService.buzzBeepBlinkLocked(s); // this no longer owns the stream
-        verifyNeverStopAudio();
-    }
-
-    @SmallTest
-    public void testQuietInterloperDoesNotCancelAudio() throws Exception {
-        NotificationRecord r = getBeepyNotification();
-        NotificationRecord other = getQuietOtherNotification();
-
-        // set up internal state
-        mService.buzzBeepBlinkLocked(r);
-        Mockito.reset(mRingtonePlayer);
-
-        // should not stop noise, since it does not own it
-        mService.buzzBeepBlinkLocked(other);
-        verifyNeverStopAudio();
-    }
-
-    @SmallTest
-    public void testQuietUpdateCancelsAudio() throws Exception {
-        NotificationRecord r = getBeepyNotification();
-        NotificationRecord s = getQuietNotification();
-        s.isUpdate = true;
-
-        // set up internal state
-        mService.buzzBeepBlinkLocked(r);
-        Mockito.reset(mRingtonePlayer);
-
-        // quiet update should stop making noise
-        mService.buzzBeepBlinkLocked(s);
-        verifyStopAudio();
-    }
-
-    @SmallTest
-    public void testQuietOnceUpdateCancelsAudio() throws Exception {
-        NotificationRecord r = getBeepyNotification();
-        NotificationRecord s = getQuietOnceNotification();
-        s.isUpdate = true;
-
-        // set up internal state
-        mService.buzzBeepBlinkLocked(r);
-        Mockito.reset(mRingtonePlayer);
-
-        // stop making noise - this is a weird corner case, but quiet should override once
-        mService.buzzBeepBlinkLocked(s);
-        verifyStopAudio();
-    }
-
-    @SmallTest
-    public void testDemoteSoundToVibrate() throws Exception {
-        NotificationRecord r = getBeepyNotification();
-
-        // the phone is quiet
-        when(mAudioManager.getStreamVolume(anyInt())).thenReturn(0);
-        when(mAudioManager.getRingerModeInternal()).thenReturn(AudioManager.RINGER_MODE_VIBRATE);
-
-        mService.buzzBeepBlinkLocked(r);
-
-        verifyNeverBeep();
-        verifyVibrate();
-    }
-
-    @SmallTest
-    public void testDemotInsistenteSoundToVibrate() throws Exception {
-        NotificationRecord r = getInsistentBeepyNotification();
-
-        // the phone is quiet
-        when(mAudioManager.getStreamVolume(anyInt())).thenReturn(0);
-        when(mAudioManager.getRingerModeInternal()).thenReturn(AudioManager.RINGER_MODE_VIBRATE);
-
-        mService.buzzBeepBlinkLocked(r);
-
-        verifyVibrateLooped();
-    }
-
-    @SmallTest
-    public void testVibrate() throws Exception {
-        NotificationRecord r = getBuzzyNotification();
-
-        mService.buzzBeepBlinkLocked(r);
-
-        verifyNeverBeep();
-        verifyVibrate();
-    }
-
-    @SmallTest
-    public void testInsistenteVibrate() throws Exception {
-        NotificationRecord r = getInsistentBuzzyNotification();
-
-        mService.buzzBeepBlinkLocked(r);
-        verifyVibrateLooped();
-    }
-
-    @SmallTest
-    public void testVibratTwice() throws Exception {
-        NotificationRecord r = getBuzzyNotification();
-
-        // set up internal state
-        mService.buzzBeepBlinkLocked(r);
-        Mockito.reset(mVibrator);
-
-        // update should vibrate
-        r.isUpdate = true;
-        mService.buzzBeepBlinkLocked(r);
-        verifyVibrate();
-    }
-
-    @SmallTest
-    public void testHonorAlertOnlyOnceForBuzz() throws Exception {
-        NotificationRecord r = getBuzzyNotification();
-        NotificationRecord s = getBuzzyOnceNotification();
-        s.isUpdate = true;
-
-        // set up internal state
-        mService.buzzBeepBlinkLocked(r);
-        Mockito.reset(mVibrator);
-
-        // update should not beep
-        mService.buzzBeepBlinkLocked(s);
-        verifyNeverVibrate();
-    }
-
-    @SmallTest
-    public void testNoisyUpdateDoesNotCancelVibrate() throws Exception {
-        NotificationRecord r = getBuzzyNotification();
-
-        mService.buzzBeepBlinkLocked(r);
-        r.isUpdate = true;
-        mService.buzzBeepBlinkLocked(r);
-
-        verifyNeverStopVibrate();
-    }
-
-    @SmallTest
-    public void testNoisyOnceUpdateDoesNotCancelVibrate() throws Exception {
-        NotificationRecord r = getBuzzyNotification();
-        NotificationRecord s = getBuzzyOnceNotification();
-        s.isUpdate = true;
-
-        mService.buzzBeepBlinkLocked(r);
-        mService.buzzBeepBlinkLocked(s);
-
-        verifyNeverStopVibrate();
-    }
-
-    @SmallTest
-    public void testQuietUpdateDoesNotCancelVibrateFromOther() throws Exception {
-        NotificationRecord r = getBuzzyNotification();
-        NotificationRecord s = getQuietNotification();
-        s.isUpdate = true;
-        NotificationRecord other = getNoisyOtherNotification();
-
-        // set up internal state
-        mService.buzzBeepBlinkLocked(r);
-        mService.buzzBeepBlinkLocked(other); // this takes the vibrate stream
-        Mockito.reset(mVibrator);
-
-        // should not stop vibrate, since we no longer own it
-        mService.buzzBeepBlinkLocked(s); // this no longer owns the stream
-        verifyNeverStopVibrate();
-    }
-
-    @SmallTest
-    public void testQuietInterloperDoesNotCancelVibrate() throws Exception {
-        NotificationRecord r = getBuzzyNotification();
-        NotificationRecord other = getQuietOtherNotification();
-
-        // set up internal state
-        mService.buzzBeepBlinkLocked(r);
-        Mockito.reset(mVibrator);
-
-        // should not stop noise, since it does not own it
-        mService.buzzBeepBlinkLocked(other);
-        verifyNeverStopVibrate();
-    }
-
-    @SmallTest
-    public void testQuietUpdateCancelsVibrate() throws Exception {
-        NotificationRecord r = getBuzzyNotification();
-        NotificationRecord s = getQuietNotification();
-        s.isUpdate = true;
-
-        // set up internal state
-        mService.buzzBeepBlinkLocked(r);
-
-        // quiet update should stop making noise
-        mService.buzzBeepBlinkLocked(s);
-        verifyStopVibrate();
-    }
-
-    @SmallTest
-    public void testQuietOnceUpdateCancelsvibrate() throws Exception {
-        NotificationRecord r = getBuzzyNotification();
-        NotificationRecord s = getQuietOnceNotification();
-        s.isUpdate = true;
-
-        // set up internal state
-        mService.buzzBeepBlinkLocked(r);
-        Mockito.reset(mVibrator);
-
-        // stop making noise - this is a weird corner case, but quiet should override once
-        mService.buzzBeepBlinkLocked(s);
-        verifyStopVibrate();
-    }
-
-    @SmallTest
-    public void testQuietUpdateCancelsDemotedVibrate() throws Exception {
-        NotificationRecord r = getBeepyNotification();
-        NotificationRecord s = getQuietNotification();
-
-        // the phone is quiet
-        when(mAudioManager.getStreamVolume(anyInt())).thenReturn(0);
-        when(mAudioManager.getRingerModeInternal()).thenReturn(AudioManager.RINGER_MODE_VIBRATE);
-
-        mService.buzzBeepBlinkLocked(r);
-
-        // quiet update should stop making noise
-        mService.buzzBeepBlinkLocked(s);
-        verifyStopVibrate();
-    }
-}
diff --git a/services/tests/servicestests/src/com/android/server/notification/RankingHelperTest.java b/services/tests/servicestests/src/com/android/server/notification/RankingHelperTest.java
deleted file mode 100644
index 32501ad8878..00000000000
--- a/services/tests/servicestests/src/com/android/server/notification/RankingHelperTest.java
+++ /dev/null
@@ -1,143 +0,0 @@
-/*
- * Copyright (C) 2014 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.android.server.notification;
-
-import org.mockito.Mock;
-import org.mockito.MockitoAnnotations;
-
-import android.app.Notification;
-import android.os.UserHandle;
-import android.service.notification.StatusBarNotification;
-import android.test.AndroidTestCase;
-import android.test.suitebuilder.annotation.SmallTest;
-
-import java.util.ArrayList;
-
-public class RankingHelperTest extends AndroidTestCase {
-    @Mock NotificationUsageStats mUsageStats;
-    @Mock RankingHandler handler;
-
-    private Notification mNotiGroupGSortA;
-    private Notification mNotiGroupGSortB;
-    private Notification mNotiNoGroup;
-    private Notification mNotiNoGroup2;
-    private Notification mNotiNoGroupSortA;
-    private NotificationRecord mRecordGroupGSortA;
-    private NotificationRecord mRecordGroupGSortB;
-    private NotificationRecord mRecordNoGroup;
-    private NotificationRecord mRecordNoGroup2;
-    private NotificationRecord mRecordNoGroupSortA;
-    private RankingHelper mHelper;
-
-    @Override
-    public void setUp() {
-        MockitoAnnotations.initMocks(this);
-        UserHandle user = UserHandle.ALL;
-
-        mHelper = new RankingHelper(getContext(), handler, mUsageStats,
-                new String[] {ImportanceExtractor.class.getName()});
-
-        mNotiGroupGSortA = new Notification.Builder(getContext())
-                .setContentTitle("A")
-                .setGroup("G")
-                .setSortKey("A")
-                .setWhen(1205)
-                .build();
-        mRecordGroupGSortA = new NotificationRecord(getContext(), new StatusBarNotification(
-                "package", "package", 1, null, 0, 0, 0, mNotiGroupGSortA, user));
-
-        mNotiGroupGSortB = new Notification.Builder(getContext())
-                .setContentTitle("B")
-                .setGroup("G")
-                .setSortKey("B")
-                .setWhen(1200)
-                .build();
-        mRecordGroupGSortB = new NotificationRecord(getContext(), new StatusBarNotification(
-                "package", "package", 1, null, 0, 0, 0, mNotiGroupGSortB, user));
-
-        mNotiNoGroup = new Notification.Builder(getContext())
-                .setContentTitle("C")
-                .setWhen(1201)
-                .build();
-        mRecordNoGroup = new NotificationRecord(getContext(), new StatusBarNotification(
-                "package", "package", 1, null, 0, 0, 0, mNotiNoGroup, user));
-
-        mNotiNoGroup2 = new Notification.Builder(getContext())
-                .setContentTitle("D")
-                .setWhen(1202)
-                .build();
-        mRecordNoGroup2 = new NotificationRecord(getContext(), new StatusBarNotification(
-                "package", "package", 1, null, 0, 0, 0, mNotiNoGroup2, user));
-
-        mNotiNoGroupSortA = new Notification.Builder(getContext())
-                .setContentTitle("E")
-                .setWhen(1201)
-                .setSortKey("A")
-                .build();
-        mRecordNoGroupSortA = new NotificationRecord(getContext(), new StatusBarNotification(
-                "package", "package", 1, null, 0, 0, 0, mNotiNoGroupSortA, user));
-    }
-
-    @SmallTest
-    public void testFindAfterRankingWithASplitGroup() throws Exception {
-        ArrayList<NotificationRecord> notificationList = new ArrayList<NotificationRecord>(3);
-        notificationList.add(mRecordGroupGSortA);
-        notificationList.add(mRecordGroupGSortB);
-        notificationList.add(mRecordNoGroup);
-        notificationList.add(mRecordNoGroupSortA);
-        mHelper.sort(notificationList);
-        assertTrue(mHelper.indexOf(notificationList, mRecordGroupGSortA) >= 0);
-        assertTrue(mHelper.indexOf(notificationList, mRecordGroupGSortB) >= 0);
-        assertTrue(mHelper.indexOf(notificationList, mRecordNoGroup) >= 0);
-        assertTrue(mHelper.indexOf(notificationList, mRecordNoGroupSortA) >= 0);
-    }
-
-    @SmallTest
-    public void testSortShouldNotThrowWithPlainNotifications() throws Exception {
-        ArrayList<NotificationRecord> notificationList = new ArrayList<NotificationRecord>(2);
-        notificationList.add(mRecordNoGroup);
-        notificationList.add(mRecordNoGroup2);
-        mHelper.sort(notificationList);
-    }
-
-    @SmallTest
-    public void testSortShouldNotThrowOneSorted() throws Exception {
-        ArrayList<NotificationRecord> notificationList = new ArrayList<NotificationRecord>(2);
-        notificationList.add(mRecordNoGroup);
-        notificationList.add(mRecordNoGroupSortA);
-        mHelper.sort(notificationList);
-    }
-
-    @SmallTest
-    public void testSortShouldNotThrowOneNotification() throws Exception {
-        ArrayList<NotificationRecord> notificationList = new ArrayList<NotificationRecord>(1);
-        notificationList.add(mRecordNoGroup);
-        mHelper.sort(notificationList);
-    }
-
-    @SmallTest
-    public void testSortShouldNotThrowOneSortKey() throws Exception {
-        ArrayList<NotificationRecord> notificationList = new ArrayList<NotificationRecord>(1);
-        notificationList.add(mRecordGroupGSortB);
-        mHelper.sort(notificationList);
-    }
-
-    @SmallTest
-    public void testSortShouldNotThrowOnEmptyList() throws Exception {
-        ArrayList<NotificationRecord> notificationList = new ArrayList<NotificationRecord>();
-        mHelper.sort(notificationList);
-    }
-}
diff --git a/services/tests/servicestests/src/com/android/server/notification/RateEstimatorTest.java b/services/tests/servicestests/src/com/android/server/notification/RateEstimatorTest.java
deleted file mode 100644
index 3278cf1c0b7..00000000000
--- a/services/tests/servicestests/src/com/android/server/notification/RateEstimatorTest.java
+++ /dev/null
@@ -1,152 +0,0 @@
-/*
- * Copyright (C) 2016 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.android.server.notification;
-
-
-import android.test.AndroidTestCase;
-import android.test.suitebuilder.annotation.SmallTest;
-
-public class RateEstimatorTest extends AndroidTestCase {
-    private long mTestStartTime;
-    private RateEstimator mEstimator;
-
-    @Override
-    public void setUp() {
-        mTestStartTime = 1225731600000L;
-        mEstimator = new RateEstimator();
-    }
-
-    @SmallTest
-    public void testRunningTimeBackwardDoesntExplodeUpdate() throws Exception {
-        assertUpdateTime(mTestStartTime);
-        assertUpdateTime(mTestStartTime - 1000L);
-    }
-
-    @SmallTest
-    public void testRunningTimeBackwardDoesntExplodeGet() throws Exception {
-        assertUpdateTime(mTestStartTime);
-        final float rate = mEstimator.getRate(mTestStartTime - 1000L);
-        assertFalse(Float.isInfinite(rate));
-        assertFalse(Float.isNaN(rate));
-    }
-
-    @SmallTest
-    public void testInstantaneousEventsDontExplodeUpdate() throws Exception {
-        assertUpdateTime(mTestStartTime);
-        assertUpdateTime(mTestStartTime);
-    }
-
-    @SmallTest
-    public void testInstantaneousEventsDontExplodeGet() throws Exception {
-        assertUpdateTime(mTestStartTime);
-        assertUpdateTime(mTestStartTime);
-        final float rate = mEstimator.getRate(mTestStartTime);
-        assertFalse(Float.isInfinite(rate));
-        assertFalse(Float.isNaN(rate));
-    }
-
-    @SmallTest
-    public void testInstantaneousBurstIsEstimatedUnderTwoPercent() throws Exception {
-        assertUpdateTime(mTestStartTime);
-        long eventStart = mTestStartTime + 1000; // start event a long time after initialization
-        long nextEventTime = postEvents(eventStart, 0, 5); // five events at \inf
-        final float rate = mEstimator.getRate(nextEventTime);
-        assertLessThan("Rate", rate, 20f);
-    }
-
-    @SmallTest
-    public void testCompactBurstIsEstimatedUnderTwoPercent() throws Exception {
-        assertUpdateTime(mTestStartTime);
-        long eventStart = mTestStartTime + 1000; // start event a long time after initialization
-        long nextEventTime = postEvents(eventStart, 1, 5); // five events at 1000Hz
-        final float rate = mEstimator.getRate(nextEventTime);
-        assertLessThan("Rate", rate, 20f);
-    }
-
-    @SmallTest
-    public void testSustained1000HzBurstIsEstimatedOverNinetyPercent() throws Exception {
-        assertUpdateTime(mTestStartTime);
-        long eventStart = mTestStartTime + 1000; // start event a long time after initialization
-        long nextEventTime = postEvents(eventStart, 1, 100); // one hundred events at 1000Hz
-        final float rate = mEstimator.getRate(nextEventTime);
-        assertGreaterThan("Rate", rate, 900f);
-    }
-
-    @SmallTest
-    public void testSustained100HzBurstIsEstimatedOverNinetyPercent() throws Exception {
-        assertUpdateTime(mTestStartTime);
-        long eventStart = mTestStartTime + 1000; // start event a long time after initialization
-        long nextEventTime = postEvents(eventStart, 10, 100); // one hundred events at 100Hz
-        final float rate = mEstimator.getRate(nextEventTime);
-
-        assertGreaterThan("Rate", rate, 90f);
-    }
-
-    @SmallTest
-    public void testRecoverQuicklyAfterSustainedBurst() throws Exception {
-        assertUpdateTime(mTestStartTime);
-        long eventStart = mTestStartTime + 1000; // start event a long time after initialization
-        long nextEventTime = postEvents(eventStart, 10, 1000); // one hundred events at 100Hz
-        final float rate = mEstimator.getRate(nextEventTime + 5000L); // two seconds later
-        assertLessThan("Rate", rate, 2f);
-    }
-
-    @SmallTest
-    public void testEstimateShouldNotOvershoot() throws Exception {
-        assertUpdateTime(mTestStartTime);
-        long eventStart = mTestStartTime + 1000; // start event a long time after initialization
-        long nextEventTime = postEvents(eventStart, 1, 1000); // one thousand events at 1000Hz
-        final float rate = mEstimator.getRate(nextEventTime);
-        assertLessThan("Rate", rate, 1000f);
-    }
-
-    @SmallTest
-    public void testGetRateWithoutUpdate() throws Exception {
-        final float rate = mEstimator.getRate(mTestStartTime);
-        assertLessThan("Rate", rate, 0.1f);
-    }
-
-    @SmallTest
-    public void testGetRateWithOneUpdate() throws Exception {
-        assertUpdateTime(mTestStartTime);
-        final float rate = mEstimator.getRate(mTestStartTime+1);
-        assertLessThan("Rate", rate, 1f);
-    }
-
-    private void assertLessThan(String label, float a, float b)  {
-        assertTrue(String.format("%s was %f, but should be less than %f", label, a, b), a <= b);
-    }
-
-    private void assertGreaterThan(String label, float a, float b)  {
-        assertTrue(String.format("%s was %f, but should be more than %f", label, a, b), a >= b);
-    }
-
-    /** @returns the next event time. */
-    private long postEvents(long start, long dt, int num) {
-        long time = start;
-        for (int i = 0; i < num; i++) {
-            mEstimator.update(time);
-            time += dt;
-        }
-        return time;
-    }
-
-    private void assertUpdateTime(long time) {
-        final float rate = mEstimator.update(time);
-        assertFalse(Float.isInfinite(rate));
-        assertFalse(Float.isNaN(rate));
-    }
-}
diff --git a/services/tests/servicestests/src/com/android/server/notification/ValidateNotificationPeopleTest.java b/services/tests/servicestests/src/com/android/server/notification/ValidateNotificationPeopleTest.java
deleted file mode 100644
index a6fdee9ce42..00000000000
--- a/services/tests/servicestests/src/com/android/server/notification/ValidateNotificationPeopleTest.java
+++ /dev/null
@@ -1,152 +0,0 @@
-/*
- * Copyright (C) 2014 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.android.server.notification;
-
-import android.app.Notification;
-import android.os.Bundle;
-import android.test.AndroidTestCase;
-import android.test.suitebuilder.annotation.SmallTest;
-import android.text.SpannableString;
-
-import java.util.ArrayList;
-import java.util.Arrays;
-
-public class ValidateNotificationPeopleTest extends AndroidTestCase {
-
-    @SmallTest
-    public void testNoExtra() throws Exception {
-        Bundle bundle = new Bundle();
-        String[] result = ValidateNotificationPeople.getExtraPeople(bundle);
-        assertNull("lack of extra should return null", result);
-    }
-
-    @SmallTest
-    public void testSingleString() throws Exception {
-        String[] expected = { "foobar" };
-        Bundle bundle = new Bundle();
-        bundle.putString(Notification.EXTRA_PEOPLE, expected[0]);
-        String[] result = ValidateNotificationPeople.getExtraPeople(bundle);
-        assertStringArrayEquals("string should be in result[0]", expected, result);
-    }
-
-    @SmallTest
-    public void testSingleCharArray() throws Exception {
-        String[] expected = { "foobar" };
-        Bundle bundle = new Bundle();
-        bundle.putCharArray(Notification.EXTRA_PEOPLE, expected[0].toCharArray());
-        String[] result = ValidateNotificationPeople.getExtraPeople(bundle);
-        assertStringArrayEquals("char[] should be in result[0]", expected, result);
-    }
-
-    @SmallTest
-    public void testSingleCharSequence() throws Exception {
-        String[] expected = { "foobar" };
-        Bundle bundle = new Bundle();
-        bundle.putCharSequence(Notification.EXTRA_PEOPLE, new SpannableString(expected[0]));
-        String[] result = ValidateNotificationPeople.getExtraPeople(bundle);
-        assertStringArrayEquals("charSequence should be in result[0]", expected, result);
-    }
-
-    @SmallTest
-    public void testStringArraySingle() throws Exception {
-        Bundle bundle = new Bundle();
-        String[] expected = { "foobar" };
-        bundle.putStringArray(Notification.EXTRA_PEOPLE, expected);
-        String[] result = ValidateNotificationPeople.getExtraPeople(bundle);
-        assertStringArrayEquals("wrapped string should be in result[0]", expected, result);
-    }
-
-    @SmallTest
-    public void testStringArrayMultiple() throws Exception {
-        Bundle bundle = new Bundle();
-        String[] expected = { "foo", "bar", "baz" };
-        bundle.putStringArray(Notification.EXTRA_PEOPLE, expected);
-        String[] result = ValidateNotificationPeople.getExtraPeople(bundle);
-        assertStringArrayEquals("testStringArrayMultiple", expected, result);
-    }
-
-    @SmallTest
-    public void testStringArrayNulls() throws Exception {
-        Bundle bundle = new Bundle();
-        String[] expected = { "foo", null, "baz" };
-        bundle.putStringArray(Notification.EXTRA_PEOPLE, expected);
-        String[] result = ValidateNotificationPeople.getExtraPeople(bundle);
-        assertStringArrayEquals("testStringArrayNulls", expected, result);
-    }
-
-    @SmallTest
-    public void testCharSequenceArrayMultiple() throws Exception {
-        Bundle bundle = new Bundle();
-        String[] expected = { "foo", "bar", "baz" };
-        CharSequence[] charSeqArray = new CharSequence[expected.length];
-        for (int i = 0; i < expected.length; i++) {
-            charSeqArray[i] = new SpannableString(expected[i]);
-        }
-        bundle.putCharSequenceArray(Notification.EXTRA_PEOPLE, charSeqArray);
-        String[] result = ValidateNotificationPeople.getExtraPeople(bundle);
-        assertStringArrayEquals("testCharSequenceArrayMultiple", expected, result);
-    }
-
-    @SmallTest
-    public void testMixedCharSequenceArrayList() throws Exception {
-        Bundle bundle = new Bundle();
-        String[] expected = { "foo", "bar", "baz" };
-        CharSequence[] charSeqArray = new CharSequence[expected.length];
-        for (int i = 0; i < expected.length; i++) {
-            if (i % 2 == 0) {
-                charSeqArray[i] = expected[i];
-            } else {
-                charSeqArray[i] = new SpannableString(expected[i]);
-            }
-        }
-        bundle.putCharSequenceArray(Notification.EXTRA_PEOPLE, charSeqArray);
-        String[] result = ValidateNotificationPeople.getExtraPeople(bundle);
-        assertStringArrayEquals("testMixedCharSequenceArrayList", expected, result);
-    }
-
-    @SmallTest
-    public void testStringArrayList() throws Exception {
-        Bundle bundle = new Bundle();
-        String[] expected = { "foo", null, "baz" };
-        final ArrayList<String> stringArrayList = new ArrayList<String>(expected.length);
-        for (int i = 0; i < expected.length; i++) {
-            stringArrayList.add(expected[i]);
-        }
-        bundle.putStringArrayList(Notification.EXTRA_PEOPLE, stringArrayList);
-        String[] result = ValidateNotificationPeople.getExtraPeople(bundle);
-        assertStringArrayEquals("testStringArrayList", expected, result);
-    }
-
-    @SmallTest
-    public void testCharSequenceArrayList() throws Exception {
-        Bundle bundle = new Bundle();
-        String[] expected = { "foo", "bar", "baz" };
-        final ArrayList<CharSequence> stringArrayList =
-                new ArrayList<CharSequence>(expected.length);
-        for (int i = 0; i < expected.length; i++) {
-            stringArrayList.add(new SpannableString(expected[i]));
-        }
-        bundle.putCharSequenceArrayList(Notification.EXTRA_PEOPLE, stringArrayList);
-        String[] result = ValidateNotificationPeople.getExtraPeople(bundle);
-        assertStringArrayEquals("testCharSequenceArrayList", expected, result);
-    }
-
-    private void assertStringArrayEquals(String message, String[] expected, String[] result) {
-        String expectedString = Arrays.toString(expected);
-        String resultString = Arrays.toString(result);
-        assertEquals(message + ": arrays differ", expectedString, resultString);
-    }
-}
diff --git a/services/tests/servicestests/src/com/android/server/pm/BaseShortcutManagerTest.java b/services/tests/servicestests/src/com/android/server/pm/BaseShortcutManagerTest.java
deleted file mode 100644
index 792f3001c04..00000000000
--- a/services/tests/servicestests/src/com/android/server/pm/BaseShortcutManagerTest.java
+++ /dev/null
@@ -1,1952 +0,0 @@
-/*
- * Copyright (C) 2016 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.android.server.pm;
-
-import static com.android.server.pm.shortcutmanagertest.ShortcutManagerTestUtils.cloneShortcutList;
-import static com.android.server.pm.shortcutmanagertest.ShortcutManagerTestUtils.hashSet;
-import static com.android.server.pm.shortcutmanagertest.ShortcutManagerTestUtils.list;
-import static com.android.server.pm.shortcutmanagertest.ShortcutManagerTestUtils.makeBundle;
-import static com.android.server.pm.shortcutmanagertest.ShortcutManagerTestUtils.set;
-
-import static org.mockito.Matchers.any;
-import static org.mockito.Matchers.anyInt;
-import static org.mockito.Matchers.anyString;
-import static org.mockito.Matchers.eq;
-import static org.mockito.Mockito.doAnswer;
-import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.reset;
-import static org.mockito.Mockito.spy;
-import static org.mockito.Mockito.times;
-import static org.mockito.Mockito.verify;
-import static org.mockito.Mockito.when;
-
-import android.annotation.NonNull;
-import android.annotation.UserIdInt;
-import android.app.Activity;
-import android.app.ActivityManager;
-import android.app.ActivityManagerInternal;
-import android.app.IUidObserver;
-import android.app.usage.UsageStatsManagerInternal;
-import android.content.ActivityNotFoundException;
-import android.content.BroadcastReceiver;
-import android.content.ComponentName;
-import android.content.Context;
-import android.content.Intent;
-import android.content.IntentFilter;
-import android.content.pm.ActivityInfo;
-import android.content.pm.ApplicationInfo;
-import android.content.pm.ILauncherApps;
-import android.content.pm.LauncherApps;
-import android.content.pm.LauncherApps.ShortcutQuery;
-import android.content.pm.PackageInfo;
-import android.content.pm.PackageManager;
-import android.content.pm.PackageManagerInternal;
-import android.content.pm.ResolveInfo;
-import android.content.pm.ShortcutInfo;
-import android.content.pm.ShortcutManager;
-import android.content.pm.ShortcutServiceInternal;
-import android.content.pm.Signature;
-import android.content.pm.UserInfo;
-import android.content.res.Resources;
-import android.content.res.XmlResourceParser;
-import android.graphics.drawable.Icon;
-import android.net.Uri;
-import android.os.Bundle;
-import android.os.FileUtils;
-import android.os.Handler;
-import android.os.Looper;
-import android.os.PersistableBundle;
-import android.os.Process;
-import android.os.UserHandle;
-import android.os.UserManager;
-import android.test.InstrumentationTestCase;
-import android.test.mock.MockContext;
-import android.util.Log;
-import android.util.Pair;
-
-import com.android.internal.util.Preconditions;
-import com.android.server.LocalServices;
-import com.android.server.SystemService;
-import com.android.server.pm.LauncherAppsService.LauncherAppsImpl;
-import com.android.server.pm.ShortcutUser.PackageWithUser;
-
-import org.junit.Assert;
-import org.mockito.ArgumentCaptor;
-import org.mockito.invocation.InvocationOnMock;
-import org.mockito.stubbing.Answer;
-
-import java.io.BufferedReader;
-import java.io.ByteArrayOutputStream;
-import java.io.File;
-import java.io.FileReader;
-import java.io.IOException;
-import java.io.InputStreamReader;
-import java.io.PrintWriter;
-import java.util.ArrayList;
-import java.util.HashMap;
-import java.util.HashSet;
-import java.util.LinkedHashMap;
-import java.util.List;
-import java.util.Locale;
-import java.util.Map;
-import java.util.Set;
-import java.util.function.BiFunction;
-import java.util.function.BiPredicate;
-import java.util.function.Consumer;
-import java.util.function.Function;
-
-public abstract class BaseShortcutManagerTest extends InstrumentationTestCase {
-    protected static final String TAG = "ShortcutManagerTest";
-
-    protected static final boolean DUMP_IN_TEARDOWN = false; // DO NOT SUBMIT WITH true
-
-    /**
-     * Whether to enable dump or not.  Should be only true when debugging to avoid bugs where
-     * dump affecting the behavior.
-     */
-    protected static final boolean ENABLE_DUMP = false // DO NOT SUBMIT WITH true
-            || DUMP_IN_TEARDOWN || ShortcutService.DEBUG;
-
-    protected static final String[] EMPTY_STRINGS = new String[0]; // Just for readability.
-
-    protected static final String MAIN_ACTIVITY_CLASS = "MainActivity";
-
-    // public for mockito
-    public class BaseContext extends MockContext {
-        @Override
-        public Object getSystemService(String name) {
-            switch (name) {
-                case Context.USER_SERVICE:
-                    return mMockUserManager;
-            }
-            throw new UnsupportedOperationException();
-        }
-
-        @Override
-        public String getSystemServiceName(Class<?> serviceClass) {
-            return getTestContext().getSystemServiceName(serviceClass);
-        }
-
-        @Override
-        public PackageManager getPackageManager() {
-            return mMockPackageManager;
-        }
-
-        @Override
-        public Resources getResources() {
-            return getTestContext().getResources();
-        }
-
-        @Override
-        public Intent registerReceiverAsUser(BroadcastReceiver receiver, UserHandle user,
-                IntentFilter filter, String broadcastPermission, Handler scheduler) {
-            // ignore.
-            return null;
-        }
-
-        @Override
-        public void unregisterReceiver(BroadcastReceiver receiver) {
-            // ignore.
-        }
-    }
-
-    /** Context used in the client side */
-    public class ClientContext extends BaseContext {
-        @Override
-        public String getPackageName() {
-            return mInjectedClientPackage;
-        }
-
-        @Override
-        public int getUserId() {
-            return getCallingUserId();
-        }
-    }
-
-    /** Context used in the service side */
-    public class ServiceContext extends BaseContext {
-        long injectClearCallingIdentity() {
-            final int prevCallingUid = mInjectedCallingUid;
-            mInjectedCallingUid = Process.SYSTEM_UID;
-            return prevCallingUid;
-        }
-
-        void injectRestoreCallingIdentity(long token) {
-            mInjectedCallingUid = (int) token;
-        }
-
-        @Override
-        public int getUserId() {
-            return UserHandle.USER_SYSTEM;
-        }
-
-        public PackageInfo injectGetActivitiesWithMetadata(
-                String packageName, @UserIdInt int userId) {
-            return BaseShortcutManagerTest.this.injectGetActivitiesWithMetadata(packageName, userId);
-        }
-
-        public XmlResourceParser injectXmlMetaData(ActivityInfo activityInfo, String key) {
-            return BaseShortcutManagerTest.this.injectXmlMetaData(activityInfo, key);
-        }
-    }
-
-    /** ShortcutService with injection override methods. */
-    protected final class ShortcutServiceTestable extends ShortcutService {
-        final ServiceContext mContext;
-        IUidObserver mUidObserver;
-
-        public ShortcutServiceTestable(ServiceContext context, Looper looper) {
-            super(context, looper, /* onyForPackageManagerApis */ false);
-            mContext = context;
-        }
-
-        @Override
-        public String injectGetLocaleTagsForUser(@UserIdInt int userId) {
-            return mInjectedLocale.toLanguageTag();
-        }
-
-        @Override
-        boolean injectShouldPerformVerification() {
-            return true; // Always verify during unit tests.
-        }
-
-        @Override
-        String injectShortcutManagerConstants() {
-            return ConfigConstants.KEY_RESET_INTERVAL_SEC + "=" + (INTERVAL / 1000) + ","
-                    + ConfigConstants.KEY_MAX_SHORTCUTS + "=" + MAX_SHORTCUTS + ","
-                    + ConfigConstants.KEY_MAX_UPDATES_PER_INTERVAL + "="
-                    + MAX_UPDATES_PER_INTERVAL + ","
-                    + ConfigConstants.KEY_MAX_ICON_DIMENSION_DP + "=" + MAX_ICON_DIMENSION + ","
-                    + ConfigConstants.KEY_MAX_ICON_DIMENSION_DP_LOWRAM + "="
-                    + MAX_ICON_DIMENSION_LOWRAM + ","
-                    + ConfigConstants.KEY_ICON_FORMAT + "=PNG,"
-                    + ConfigConstants.KEY_ICON_QUALITY + "=100";
-        }
-
-        @Override
-        long injectClearCallingIdentity() {
-            return mContext.injectClearCallingIdentity();
-        }
-
-        @Override
-        void injectRestoreCallingIdentity(long token) {
-            mContext.injectRestoreCallingIdentity(token);
-        }
-
-        @Override
-        int injectDipToPixel(int dip) {
-            return dip;
-        }
-
-        @Override
-        long injectCurrentTimeMillis() {
-            return mInjectedCurrentTimeMillis;
-        }
-
-        @Override
-        long injectElapsedRealtime() {
-            // TODO This should be kept separately from mInjectedCurrentTimeMillis, since
-            // this should increase even if we rewind mInjectedCurrentTimeMillis in some tests.
-            return mInjectedCurrentTimeMillis - START_TIME;
-        }
-
-        @Override
-        int injectBinderCallingUid() {
-            return mInjectedCallingUid;
-        }
-
-        @Override
-        int injectGetPackageUid(String packageName, int userId) {
-            return getInjectedPackageInfo(packageName, userId, false).applicationInfo.uid;
-        }
-
-        @Override
-        File injectSystemDataPath() {
-            return new File(mInjectedFilePathRoot, "system");
-        }
-
-        @Override
-        File injectUserDataPath(@UserIdInt int userId) {
-            return new File(mInjectedFilePathRoot, "user-" + userId);
-        }
-
-        @Override
-        void injectValidateIconResPackage(ShortcutInfo shortcut, Icon icon) {
-            // Can't check
-        }
-
-        @Override
-        boolean injectIsLowRamDevice() {
-            return mInjectedIsLowRamDevice;
-        }
-
-        @Override
-        void injectRegisterUidObserver(IUidObserver observer, int which) {
-            mUidObserver = observer;
-        }
-
-        @Override
-        boolean hasShortcutHostPermission(@NonNull String callingPackage, int userId) {
-            return mDefaultLauncherChecker.test(callingPackage, userId);
-        }
-
-        @Override
-        PackageInfo injectPackageInfoWithUninstalled(String packageName, @UserIdInt int userId,
-                boolean getSignatures) {
-            return getInjectedPackageInfo(packageName, userId, getSignatures);
-        }
-
-        @Override
-        ApplicationInfo injectApplicationInfoWithUninstalled(
-                String packageName, @UserIdInt int userId) {
-            PackageInfo pi = injectPackageInfoWithUninstalled(
-                    packageName, userId, /* getSignatures= */ false);
-            return pi != null ? pi.applicationInfo : null;
-        }
-
-        @Override
-        List<PackageInfo> injectGetPackagesWithUninstalled(@UserIdInt int userId) {
-            return BaseShortcutManagerTest.this.getInstalledPackagesWithUninstalled(userId);
-        }
-
-        @Override
-        ActivityInfo injectGetActivityInfoWithMetadataWithUninstalled(ComponentName activity,
-                @UserIdInt int userId) {
-            final PackageInfo pi = mContext.injectGetActivitiesWithMetadata(
-                    activity.getPackageName(), userId);
-            if (pi == null || pi.activities == null) {
-                return null;
-            }
-            for (ActivityInfo ai : pi.activities) {
-                if (!mEnabledActivityChecker.test(ai.getComponentName(), userId)) {
-                    continue;
-                }
-                if (activity.equals(ai.getComponentName())) {
-                    return ai;
-                }
-            }
-            return null;
-        }
-
-        @Override
-        boolean injectIsMainActivity(@NonNull ComponentName activity, int userId) {
-            if (!mEnabledActivityChecker.test(activity, userId)) {
-                return false;
-            }
-            return mMainActivityChecker.test(activity, userId);
-        }
-
-        @Override
-        List<ResolveInfo> injectGetMainActivities(@NonNull String packageName, int userId) {
-            final PackageInfo pi = mContext.injectGetActivitiesWithMetadata(
-                    packageName, userId);
-            if (pi == null || pi.activities == null) {
-                return null;
-            }
-            final ArrayList<ResolveInfo> ret = new ArrayList<>(pi.activities.length);
-            for (int i = 0; i < pi.activities.length; i++) {
-                if (!mEnabledActivityChecker.test(pi.activities[i].getComponentName(), userId)) {
-                    continue;
-                }
-                final ResolveInfo ri = new ResolveInfo();
-                ri.activityInfo = pi.activities[i];
-                ret.add(ri);
-            }
-
-            return ret;
-        }
-
-        @Override
-        ComponentName injectGetDefaultMainActivity(@NonNull String packageName, int userId) {
-            return mMainActivityFetcher.apply(packageName, userId);
-        }
-
-        @Override
-        boolean injectIsActivityEnabledAndExported(ComponentName activity, @UserIdInt int userId) {
-            return mEnabledActivityChecker.test(activity, userId);
-        }
-
-        @Override
-        XmlResourceParser injectXmlMetaData(ActivityInfo activityInfo, String key) {
-            return mContext.injectXmlMetaData(activityInfo, key);
-        }
-
-        @Override
-        void injectPostToHandler(Runnable r) {
-            runOnHandler(r);
-        }
-
-        @Override
-        void injectRunOnNewThread(Runnable r) {
-            runOnHandler(r);
-        }
-
-        @Override
-        void injectEnforceCallingPermission(String permission, String message) {
-            if (!mCallerPermissions.contains(permission)) {
-                throw new SecurityException("Missing permission: " + permission);
-            }
-        }
-
-        @Override
-        boolean injectIsSafeModeEnabled() {
-            return mSafeMode;
-        }
-
-        @Override
-        String injectBuildFingerprint() {
-            return mInjectedBuildFingerprint;
-        }
-
-        @Override
-        void wtf(String message, Throwable th) {
-            // During tests, WTF is fatal.
-            fail(message + "  exception: " + th + "\n" + Log.getStackTraceString(th));
-        }
-    }
-
-    /** ShortcutManager with injection override methods. */
-    protected class ShortcutManagerTestable extends ShortcutManager {
-        public ShortcutManagerTestable(Context context, ShortcutServiceTestable service) {
-            super(context, service);
-        }
-
-        @Override
-        protected int injectMyUserId() {
-            return UserHandle.getUserId(mInjectedCallingUid);
-        }
-
-        @Override
-        public boolean setDynamicShortcuts(@NonNull List<ShortcutInfo> shortcutInfoList) {
-            // Note to simulate the binder RPC, we need to clone the incoming arguments.
-            // Otherwise bad things will happen because they're mutable.
-            return super.setDynamicShortcuts(cloneShortcutList(shortcutInfoList));
-        }
-
-        @Override
-        public boolean addDynamicShortcuts(@NonNull List<ShortcutInfo> shortcutInfoList) {
-            // Note to simulate the binder RPC, we need to clone the incoming arguments.
-            return super.addDynamicShortcuts(cloneShortcutList(shortcutInfoList));
-        }
-
-        @Override
-        public boolean updateShortcuts(List<ShortcutInfo> shortcutInfoList) {
-            // Note to simulate the binder RPC, we need to clone the incoming arguments.
-            return super.updateShortcuts(cloneShortcutList(shortcutInfoList));
-        }
-    }
-
-    protected class LauncherAppImplTestable extends LauncherAppsImpl {
-        final ServiceContext mContext;
-
-        public LauncherAppImplTestable(ServiceContext context) {
-            super(context);
-            mContext = context;
-        }
-
-        @Override
-        public void verifyCallingPackage(String callingPackage) {
-            // SKIP
-        }
-
-        @Override
-        void postToPackageMonitorHandler(Runnable r) {
-            runOnHandler(r);
-        }
-
-        @Override
-        int injectBinderCallingUid() {
-            return mInjectedCallingUid;
-        }
-
-        @Override
-        long injectClearCallingIdentity() {
-            final int prevCallingUid = mInjectedCallingUid;
-            mInjectedCallingUid = Process.SYSTEM_UID;
-            return prevCallingUid;
-        }
-
-        @Override
-        void injectRestoreCallingIdentity(long token) {
-            mInjectedCallingUid = (int) token;
-        }
-    }
-
-    protected class LauncherAppsTestable extends LauncherApps {
-        public LauncherAppsTestable(Context context, ILauncherApps service) {
-            super(context, service);
-        }
-    }
-
-    public static class ShortcutActivity extends Activity {
-    }
-
-    public static class ShortcutActivity2 extends Activity {
-    }
-
-    public static class ShortcutActivity3 extends Activity {
-    }
-
-    protected Looper mLooper;
-    protected Handler mHandler;
-
-    protected ServiceContext mServiceContext;
-    protected ClientContext mClientContext;
-
-    protected ShortcutServiceTestable mService;
-    protected ShortcutManagerTestable mManager;
-    protected ShortcutServiceInternal mInternal;
-
-    protected LauncherAppImplTestable mLauncherAppImpl;
-
-    // LauncherApps has per-instace state, so we need a differnt instance for each launcher.
-    protected final Map<Pair<Integer, String>, LauncherAppsTestable>
-            mLauncherAppsMap = new HashMap<>();
-    protected LauncherAppsTestable mLauncherApps; // Current one
-
-    protected File mInjectedFilePathRoot;
-
-    protected boolean mSafeMode;
-
-    protected long mInjectedCurrentTimeMillis;
-
-    protected boolean mInjectedIsLowRamDevice;
-
-    protected Locale mInjectedLocale = Locale.ENGLISH;
-
-    protected int mInjectedCallingUid;
-    protected String mInjectedClientPackage;
-
-    protected Map<String, PackageInfo> mInjectedPackages;
-
-    protected Set<PackageWithUser> mUninstalledPackages;
-    protected Set<String> mSystemPackages;
-
-    protected PackageManager mMockPackageManager;
-    protected PackageManagerInternal mMockPackageManagerInternal;
-    protected UserManager mMockUserManager;
-    protected UsageStatsManagerInternal mMockUsageStatsManagerInternal;
-    protected ActivityManagerInternal mMockActivityManagerInternal;
-
-    protected static final String CALLING_PACKAGE_1 = "com.android.test.1";
-    protected static final int CALLING_UID_1 = 10001;
-
-    protected static final String CALLING_PACKAGE_2 = "com.android.test.2";
-    protected static final int CALLING_UID_2 = 10002;
-
-    protected static final String CALLING_PACKAGE_3 = "com.android.test.3";
-    protected static final int CALLING_UID_3 = 10003;
-
-    protected static final String CALLING_PACKAGE_4 = "com.android.test.4";
-    protected static final int CALLING_UID_4 = 10004;
-
-    protected static final String LAUNCHER_1 = "com.android.launcher.1";
-    protected static final int LAUNCHER_UID_1 = 10011;
-
-    protected static final String LAUNCHER_2 = "com.android.launcher.2";
-    protected static final int LAUNCHER_UID_2 = 10012;
-
-    protected static final String LAUNCHER_3 = "com.android.launcher.3";
-    protected static final int LAUNCHER_UID_3 = 10013;
-
-    protected static final String LAUNCHER_4 = "com.android.launcher.4";
-    protected static final int LAUNCHER_UID_4 = 10014;
-
-    protected static final int USER_0 = UserHandle.USER_SYSTEM;
-    protected static final int USER_10 = 10;
-    protected static final int USER_11 = 11;
-    protected static final int USER_P0 = 20; // profile of user 0
-
-    protected static final UserHandle HANDLE_USER_0 = UserHandle.of(USER_0);
-    protected static final UserHandle HANDLE_USER_10 = UserHandle.of(USER_10);
-    protected static final UserHandle HANDLE_USER_11 = UserHandle.of(USER_11);
-    protected static final UserHandle HANDLE_USER_P0 = UserHandle.of(USER_P0);
-
-    protected static final UserInfo USER_INFO_0 = withProfileGroupId(
-            new UserInfo(USER_0, "user0",
-                    UserInfo.FLAG_ADMIN | UserInfo.FLAG_PRIMARY | UserInfo.FLAG_INITIALIZED), 10);
-
-    protected static final UserInfo USER_INFO_10 =
-            new UserInfo(USER_10, "user10", UserInfo.FLAG_INITIALIZED);
-
-    protected static final UserInfo USER_INFO_11 =
-            new UserInfo(USER_11, "user11", UserInfo.FLAG_INITIALIZED);
-
-    protected static final UserInfo USER_INFO_P0 = withProfileGroupId(
-            new UserInfo(USER_P0, "userP0",
-                    UserInfo.FLAG_MANAGED_PROFILE), 10);
-
-    protected BiPredicate<String, Integer> mDefaultLauncherChecker =
-            (callingPackage, userId) ->
-            LAUNCHER_1.equals(callingPackage) || LAUNCHER_2.equals(callingPackage)
-            || LAUNCHER_3.equals(callingPackage) || LAUNCHER_4.equals(callingPackage);
-
-    protected BiPredicate<ComponentName, Integer> mMainActivityChecker =
-            (activity, userId) -> true;
-
-    protected BiFunction<String, Integer, ComponentName> mMainActivityFetcher =
-            (packageName, userId) -> new ComponentName(packageName, MAIN_ACTIVITY_CLASS);
-
-    protected BiPredicate<ComponentName, Integer> mEnabledActivityChecker
-            = (activity, userId) -> true; // all activities are enabled.
-
-    protected static final long START_TIME = 1440000000101L;
-
-    protected static final long INTERVAL = 10000;
-
-    protected static final int MAX_SHORTCUTS = 10;
-
-    protected static final int MAX_UPDATES_PER_INTERVAL = 3;
-
-    protected static final int MAX_ICON_DIMENSION = 128;
-
-    protected static final int MAX_ICON_DIMENSION_LOWRAM = 32;
-
-    protected static final ShortcutQuery QUERY_ALL = new ShortcutQuery();
-
-    protected final ArrayList<String> mCallerPermissions = new ArrayList<>();
-
-    protected final HashMap<String, LinkedHashMap<ComponentName, Integer>> mActivityMetadataResId
-            = new HashMap<>();
-
-    protected final Map<Integer, UserInfo> mUserInfos = new HashMap<>();
-    protected final Map<Integer, Boolean> mRunningUsers = new HashMap<>();
-    protected final Map<Integer, Boolean> mUnlockedUsers = new HashMap<>();
-
-    protected static final String PACKAGE_SYSTEM_LAUNCHER = "com.android.systemlauncher";
-    protected static final String PACKAGE_SYSTEM_LAUNCHER_NAME = "systemlauncher_name";
-    protected static final int PACKAGE_SYSTEM_LAUNCHER_PRIORITY = 0;
-
-    protected static final String PACKAGE_FALLBACK_LAUNCHER = "com.android.settings";
-    protected static final String PACKAGE_FALLBACK_LAUNCHER_NAME = "fallback";
-    protected static final int PACKAGE_FALLBACK_LAUNCHER_PRIORITY = -999;
-
-    protected String mInjectedBuildFingerprint = "build1";
-
-    static {
-        QUERY_ALL.setQueryFlags(
-                ShortcutQuery.FLAG_GET_ALL_KINDS);
-    }
-
-    @Override
-    protected void setUp() throws Exception {
-        super.setUp();
-
-        mLooper = Looper.getMainLooper();
-        mHandler = new Handler(mLooper);
-
-        mServiceContext = spy(new ServiceContext());
-        mClientContext = new ClientContext();
-
-        mMockPackageManager = mock(PackageManager.class);
-        mMockPackageManagerInternal = mock(PackageManagerInternal.class);
-        mMockUserManager = mock(UserManager.class);
-        mMockUsageStatsManagerInternal = mock(UsageStatsManagerInternal.class);
-        mMockActivityManagerInternal = mock(ActivityManagerInternal.class);
-
-        LocalServices.removeServiceForTest(PackageManagerInternal.class);
-        LocalServices.addService(PackageManagerInternal.class, mMockPackageManagerInternal);
-        LocalServices.removeServiceForTest(UsageStatsManagerInternal.class);
-        LocalServices.addService(UsageStatsManagerInternal.class, mMockUsageStatsManagerInternal);
-        LocalServices.removeServiceForTest(ActivityManagerInternal.class);
-        LocalServices.addService(ActivityManagerInternal.class, mMockActivityManagerInternal);
-
-        // Prepare injection values.
-
-        mInjectedCurrentTimeMillis = START_TIME;
-
-        mInjectedPackages = new HashMap<>();
-        addPackage(CALLING_PACKAGE_1, CALLING_UID_1, 1);
-        addPackage(CALLING_PACKAGE_2, CALLING_UID_2, 2);
-        addPackage(CALLING_PACKAGE_3, CALLING_UID_3, 3);
-        addPackage(CALLING_PACKAGE_4, CALLING_UID_4, 10);
-        addPackage(LAUNCHER_1, LAUNCHER_UID_1, 4);
-        addPackage(LAUNCHER_2, LAUNCHER_UID_2, 5);
-        addPackage(LAUNCHER_3, LAUNCHER_UID_3, 6);
-        addPackage(LAUNCHER_4, LAUNCHER_UID_4, 10);
-
-        // CALLING_PACKAGE_3 / LAUNCHER_3 are not backup target.
-        updatePackageInfo(CALLING_PACKAGE_3,
-                pi -> pi.applicationInfo.flags &= ~ApplicationInfo.FLAG_ALLOW_BACKUP);
-        updatePackageInfo(LAUNCHER_3,
-                pi -> pi.applicationInfo.flags &= ~ApplicationInfo.FLAG_ALLOW_BACKUP);
-
-        mUninstalledPackages = new HashSet<>();
-        mSystemPackages = new HashSet<>();
-
-        mInjectedFilePathRoot = new File(getTestContext().getCacheDir(), "test-files");
-
-        deleteAllSavedFiles();
-
-        // Set up users.
-        when(mMockUserManager.getUserInfo(anyInt())).thenAnswer(new AnswerWithSystemCheck<>(
-                inv -> mUserInfos.get((Integer) inv.getArguments()[0])));
-
-        mUserInfos.put(USER_0, USER_INFO_0);
-        mUserInfos.put(USER_10, USER_INFO_10);
-        mUserInfos.put(USER_11, USER_INFO_11);
-        mUserInfos.put(USER_P0, USER_INFO_P0);
-
-        // Set up isUserRunning and isUserUnlocked.
-        when(mMockUserManager.isUserRunning(anyInt())).thenAnswer(new AnswerWithSystemCheck<>(
-                        inv -> b(mRunningUsers.get((Integer) inv.getArguments()[0]))));
-
-        when(mMockUserManager.isUserUnlocked(anyInt()))
-                .thenAnswer(new AnswerWithSystemCheck<>(inv -> {
-                    final int userId = (Integer) inv.getArguments()[0];
-                    return b(mRunningUsers.get(userId)) && b(mUnlockedUsers.get(userId));
-                }));
-        // isUserUnlockingOrUnlocked() return the same value as isUserUnlocked().
-        when(mMockUserManager.isUserUnlockingOrUnlocked(anyInt()))
-                .thenAnswer(new AnswerWithSystemCheck<>(inv -> {
-                    final int userId = (Integer) inv.getArguments()[0];
-                    return b(mRunningUsers.get(userId)) && b(mUnlockedUsers.get(userId));
-                }));
-
-        when(mMockActivityManagerInternal.getUidProcessState(anyInt())).thenReturn(
-                ActivityManager.PROCESS_STATE_CACHED_EMPTY);
-
-        // User 0 and P0 are always running
-        mRunningUsers.put(USER_0, true);
-        mRunningUsers.put(USER_10, false);
-        mRunningUsers.put(USER_11, false);
-        mRunningUsers.put(USER_P0, true);
-
-        // Unlock all users by default.
-        mUnlockedUsers.put(USER_0, true);
-        mUnlockedUsers.put(USER_10, true);
-        mUnlockedUsers.put(USER_11, true);
-        mUnlockedUsers.put(USER_P0, true);
-
-        // Set up resources
-        setUpAppResources();
-
-        // Start the service.
-        initService();
-        setCaller(CALLING_PACKAGE_1);
-    }
-
-    private static boolean b(Boolean value) {
-        return (value != null && value);
-    }
-
-    /**
-     * Returns a boolean but also checks if the current UID is SYSTEM_UID.
-     */
-    protected class AnswerWithSystemCheck<T> implements Answer<T> {
-        private final Function<InvocationOnMock, T> mChecker;
-
-        public AnswerWithSystemCheck(Function<InvocationOnMock, T> checker) {
-            mChecker = checker;
-        }
-
-        @Override
-        public T answer(InvocationOnMock invocation) throws Throwable {
-            assertEquals("Must be called on SYSTEM UID.",
-                    Process.SYSTEM_UID, mInjectedCallingUid);
-            return mChecker.apply(invocation);
-        }
-    }
-
-    protected void setUpAppResources() throws Exception {
-        setUpAppResources(/* offset = */ 0);
-    }
-
-    protected void setUpAppResources(int ressIdOffset) throws Exception {
-        // ressIdOffset is used to adjust resource IDs to emulate the case where an updated app
-        // has resource IDs changed.
-
-        doAnswer(pmInvocation -> {
-            assertEquals(Process.SYSTEM_UID, mInjectedCallingUid);
-
-            final String packageName = (String) pmInvocation.getArguments()[0];
-            final int userId = (Integer) pmInvocation.getArguments()[1];
-
-            final Resources res = mock(Resources.class);
-
-            doAnswer(resInvocation -> {
-                final int argResId = (Integer) resInvocation.getArguments()[0];
-
-                return "string-" + packageName + "-user:" + userId + "-res:" + argResId
-                        + "/" + mInjectedLocale;
-            }).when(res).getString(anyInt());
-
-            doAnswer(resInvocation -> {
-                final int resId = (Integer) resInvocation.getArguments()[0];
-
-                // Always use the "string" resource type.  The type doesn't matter during the test.
-                return packageName + ":string/r" + resId;
-            }).when(res).getResourceName(anyInt());
-
-            doAnswer(resInvocation -> {
-                final String argResName = (String) resInvocation.getArguments()[0];
-                final String argType = (String) resInvocation.getArguments()[1];
-                final String argPackageName = (String) resInvocation.getArguments()[2];
-
-                // See the above code.  getResourceName() will just use "r" + res ID as the entry
-                // name.
-                String entryName = argResName;
-                if (entryName.contains("/")) {
-                    entryName = ShortcutInfo.getResourceEntryName(entryName);
-                }
-                return Integer.parseInt(entryName.substring(1)) + ressIdOffset;
-            }).when(res).getIdentifier(anyString(), anyString(), anyString());
-            return res;
-        }).when(mMockPackageManager).getResourcesForApplicationAsUser(anyString(), anyInt());
-    }
-
-    protected static UserInfo withProfileGroupId(UserInfo in, int groupId) {
-        in.profileGroupId = groupId;
-        return in;
-    }
-
-    @Override
-    protected void tearDown() throws Exception {
-        if (DUMP_IN_TEARDOWN) dumpsysOnLogcat("Teardown");
-
-        shutdownServices();
-
-        super.tearDown();
-    }
-
-    protected Context getTestContext() {
-        return getInstrumentation().getContext();
-    }
-
-    protected ShortcutManager getManager() {
-        return mManager;
-    }
-
-    protected void deleteAllSavedFiles() {
-        // Empty the data directory.
-        if (mInjectedFilePathRoot.exists()) {
-            Assert.assertTrue("failed to delete dir",
-                    FileUtils.deleteContents(mInjectedFilePathRoot));
-        }
-        mInjectedFilePathRoot.mkdirs();
-    }
-
-    /** (Re-) init the manager and the service. */
-    protected void initService() {
-        shutdownServices();
-
-        LocalServices.removeServiceForTest(ShortcutServiceInternal.class);
-
-        // Instantiate targets.
-        mService = new ShortcutServiceTestable(mServiceContext, mLooper);
-        mManager = new ShortcutManagerTestable(mClientContext, mService);
-
-        mInternal = LocalServices.getService(ShortcutServiceInternal.class);
-
-        mLauncherAppImpl = new LauncherAppImplTestable(mServiceContext);
-        mLauncherApps = null;
-        mLauncherAppsMap.clear();
-
-        // Send boot sequence events.
-        mService.onBootPhase(SystemService.PHASE_LOCK_SETTINGS_READY);
-
-        mService.onBootPhase(SystemService.PHASE_BOOT_COMPLETED);
-    }
-
-    protected void shutdownServices() {
-        if (mService != null) {
-            // Flush all the unsaved data from the previous instance.
-            mService.saveDirtyInfo();
-
-            // Make sure everything is consistent.
-            mService.verifyStates();
-        }
-        LocalServices.removeServiceForTest(ShortcutServiceInternal.class);
-
-        mService = null;
-        mManager = null;
-        mInternal = null;
-        mLauncherAppImpl = null;
-        mLauncherApps = null;
-        mLauncherAppsMap.clear();
-    }
-
-    protected void runOnHandler(Runnable r) {
-        final long token = mServiceContext.injectClearCallingIdentity();
-        try {
-            r.run();
-        } finally {
-            mServiceContext.injectRestoreCallingIdentity(token);
-        }
-    }
-
-    protected void addPackage(String packageName, int uid, int version) {
-        addPackage(packageName, uid, version, packageName);
-    }
-
-    protected Signature[] genSignatures(String... signatures) {
-        final Signature[] sigs = new Signature[signatures.length];
-        for (int i = 0; i < signatures.length; i++){
-            sigs[i] = new Signature(signatures[i].getBytes());
-        }
-        return sigs;
-    }
-
-    protected PackageInfo genPackage(String packageName, int uid, int version, String... signatures) {
-        final PackageInfo pi = new PackageInfo();
-        pi.packageName = packageName;
-        pi.applicationInfo = new ApplicationInfo();
-        pi.applicationInfo.uid = uid;
-        pi.applicationInfo.flags = ApplicationInfo.FLAG_INSTALLED
-                | ApplicationInfo.FLAG_ALLOW_BACKUP;
-        pi.versionCode = version;
-        pi.applicationInfo.versionCode = version;
-        pi.signatures = genSignatures(signatures);
-
-        return pi;
-    }
-
-    protected void addPackage(String packageName, int uid, int version, String... signatures) {
-        mInjectedPackages.put(packageName, genPackage(packageName, uid, version, signatures));
-    }
-
-    protected void updatePackageInfo(String packageName, Consumer<PackageInfo> c) {
-        c.accept(mInjectedPackages.get(packageName));
-    }
-
-    protected void updatePackageVersion(String packageName, int increment) {
-        updatePackageInfo(packageName, pi -> {
-            pi.versionCode += increment;
-            pi.applicationInfo.versionCode += increment;
-        });
-    }
-
-    protected void updatePackageLastUpdateTime(String packageName, long increment) {
-        updatePackageInfo(packageName, pi -> {
-            pi.lastUpdateTime += increment;
-        });
-    }
-
-    protected void setPackageLastUpdateTime(String packageName, long value) {
-        updatePackageInfo(packageName, pi -> {
-            pi.lastUpdateTime = value;
-        });
-    }
-
-    protected void uninstallPackage(int userId, String packageName) {
-        if (ENABLE_DUMP) {
-            Log.v(TAG, "Unnstall package " + packageName + " / " + userId);
-        }
-        mUninstalledPackages.add(PackageWithUser.of(userId, packageName));
-    }
-
-    protected void installPackage(int userId, String packageName) {
-        if (ENABLE_DUMP) {
-            Log.v(TAG, "Install package " + packageName + " / " + userId);
-        }
-        mUninstalledPackages.remove(PackageWithUser.of(userId, packageName));
-    }
-
-    PackageInfo getInjectedPackageInfo(String packageName, @UserIdInt int userId,
-            boolean getSignatures) {
-        final PackageInfo pi = mInjectedPackages.get(packageName);
-        if (pi == null) return null;
-
-        final PackageInfo ret = new PackageInfo();
-        ret.packageName = pi.packageName;
-        ret.versionCode = pi.versionCode;
-        ret.lastUpdateTime = pi.lastUpdateTime;
-
-        ret.applicationInfo = new ApplicationInfo(pi.applicationInfo);
-        ret.applicationInfo.uid = UserHandle.getUid(userId, pi.applicationInfo.uid);
-        ret.applicationInfo.packageName = pi.packageName;
-
-        if (mUninstalledPackages.contains(PackageWithUser.of(userId, packageName))) {
-            ret.applicationInfo.flags &= ~ApplicationInfo.FLAG_INSTALLED;
-        }
-        if (mSystemPackages.contains(packageName)) {
-            ret.applicationInfo.flags |= ApplicationInfo.FLAG_SYSTEM;
-        }
-
-        if (getSignatures) {
-            ret.signatures = pi.signatures;
-        }
-
-        return ret;
-    }
-
-    protected void addApplicationInfo(PackageInfo pi, List<ApplicationInfo> list) {
-        if (pi != null && pi.applicationInfo != null) {
-            list.add(pi.applicationInfo);
-        }
-    }
-
-    protected List<ApplicationInfo> getInstalledApplications(int userId) {
-        final ArrayList<ApplicationInfo> ret = new ArrayList<>();
-
-        addApplicationInfo(getInjectedPackageInfo(CALLING_PACKAGE_1, userId, false), ret);
-        addApplicationInfo(getInjectedPackageInfo(CALLING_PACKAGE_2, userId, false), ret);
-        addApplicationInfo(getInjectedPackageInfo(CALLING_PACKAGE_3, userId, false), ret);
-        addApplicationInfo(getInjectedPackageInfo(CALLING_PACKAGE_4, userId, false), ret);
-        addApplicationInfo(getInjectedPackageInfo(LAUNCHER_1, userId, false), ret);
-        addApplicationInfo(getInjectedPackageInfo(LAUNCHER_2, userId, false), ret);
-        addApplicationInfo(getInjectedPackageInfo(LAUNCHER_3, userId, false), ret);
-        addApplicationInfo(getInjectedPackageInfo(LAUNCHER_4, userId, false), ret);
-
-        return ret;
-    }
-
-    private void addPackageInfo(PackageInfo pi, List<PackageInfo> list) {
-        if (pi != null) {
-            list.add(pi);
-        }
-    }
-
-    private List<PackageInfo> getInstalledPackagesWithUninstalled(int userId) {
-        final ArrayList<PackageInfo> ret = new ArrayList<>();
-
-        addPackageInfo(getInjectedPackageInfo(CALLING_PACKAGE_1, userId, false), ret);
-        addPackageInfo(getInjectedPackageInfo(CALLING_PACKAGE_2, userId, false), ret);
-        addPackageInfo(getInjectedPackageInfo(CALLING_PACKAGE_3, userId, false), ret);
-        addPackageInfo(getInjectedPackageInfo(CALLING_PACKAGE_4, userId, false), ret);
-        addPackageInfo(getInjectedPackageInfo(LAUNCHER_1, userId, false), ret);
-        addPackageInfo(getInjectedPackageInfo(LAUNCHER_2, userId, false), ret);
-        addPackageInfo(getInjectedPackageInfo(LAUNCHER_3, userId, false), ret);
-        addPackageInfo(getInjectedPackageInfo(LAUNCHER_4, userId, false), ret);
-
-        return ret;
-    }
-
-    protected void addManifestShortcutResource(ComponentName activity, int resId) {
-        final String packageName = activity.getPackageName();
-        LinkedHashMap<ComponentName, Integer> map = mActivityMetadataResId.get(packageName);
-        if (map == null) {
-            map = new LinkedHashMap<>();
-            mActivityMetadataResId.put(packageName, map);
-        }
-        map.put(activity, resId);
-    }
-
-    protected PackageInfo injectGetActivitiesWithMetadata(String packageName, @UserIdInt int userId) {
-        final PackageInfo ret = getInjectedPackageInfo(packageName, userId,
-                /* getSignatures=*/ false);
-
-        final HashMap<ComponentName, Integer> activities = mActivityMetadataResId.get(packageName);
-        if (activities != null) {
-            final ArrayList<ActivityInfo> list = new ArrayList<>();
-
-            for (ComponentName cn : activities.keySet()) {
-                ActivityInfo ai = new ActivityInfo();
-                ai.packageName = cn.getPackageName();
-                ai.name = cn.getClassName();
-                ai.metaData = new Bundle();
-                ai.metaData.putInt(ShortcutParser.METADATA_KEY, activities.get(cn));
-                ai.applicationInfo = ret.applicationInfo;
-                list.add(ai);
-            }
-            ret.activities = list.toArray(new ActivityInfo[list.size()]);
-        }
-        return ret;
-    }
-
-    protected XmlResourceParser injectXmlMetaData(ActivityInfo activityInfo, String key) {
-        if (!ShortcutParser.METADATA_KEY.equals(key) || activityInfo.metaData == null) {
-            return null;
-        }
-        final int resId = activityInfo.metaData.getInt(key);
-        return getTestContext().getResources().getXml(resId);
-    }
-
-    /** Replace the current calling package */
-    protected void setCaller(String packageName, int userId) {
-        mInjectedClientPackage = packageName;
-        mInjectedCallingUid =
-                Preconditions.checkNotNull(getInjectedPackageInfo(packageName, userId, false),
-                        "Unknown package").applicationInfo.uid;
-
-        // Set up LauncherApps for this caller.
-        final Pair<Integer, String> key = Pair.create(userId, packageName);
-        if (!mLauncherAppsMap.containsKey(key)) {
-            mLauncherAppsMap.put(key, new LauncherAppsTestable(mClientContext, mLauncherAppImpl));
-        }
-        mLauncherApps = mLauncherAppsMap.get(key);
-    }
-
-    protected void setCaller(String packageName) {
-        setCaller(packageName, UserHandle.USER_SYSTEM);
-    }
-
-    protected String getCallingPackage() {
-        return mInjectedClientPackage;
-    }
-
-    protected void setDefaultLauncherChecker(BiPredicate<String, Integer> p) {
-        mDefaultLauncherChecker = p;
-    }
-
-    protected void runWithCaller(String packageName, int userId, Runnable r) {
-        final String previousPackage = mInjectedClientPackage;
-        final int previousUserId = UserHandle.getUserId(mInjectedCallingUid);
-
-        setCaller(packageName, userId);
-
-        r.run();
-
-        setCaller(previousPackage, previousUserId);
-    }
-
-    protected void runWithSystemUid(Runnable r) {
-        final int origUid = mInjectedCallingUid;
-        mInjectedCallingUid = Process.SYSTEM_UID;
-        r.run();
-        mInjectedCallingUid = origUid;
-    }
-
-    protected void lookupAndFillInResourceNames(ShortcutInfo si) {
-        runWithSystemUid(() -> si.lookupAndFillInResourceNames(
-                mService.injectGetResourcesForApplicationAsUser(si.getPackage(), si.getUserId())));
-    }
-
-    protected int getCallingUserId() {
-        return UserHandle.getUserId(mInjectedCallingUid);
-    }
-
-    protected UserHandle getCallingUser() {
-        return UserHandle.of(getCallingUserId());
-    }
-
-    /** For debugging */
-    protected void dumpsysOnLogcat() {
-        dumpsysOnLogcat("");
-    }
-
-    protected void dumpsysOnLogcat(String message) {
-        dumpsysOnLogcat(message, false);
-    }
-
-    protected void dumpsysOnLogcat(String message, boolean force) {
-        if (force || !ENABLE_DUMP) return;
-
-        Log.v(TAG, "Dumping ShortcutService: " + message);
-        for (String line : dumpsys(null).split("\n")) {
-            Log.v(TAG, line);
-        }
-    }
-
-    protected String dumpCheckin() {
-        return dumpsys(new String[]{"--checkin"});
-    }
-
-    private String dumpsys(String[] args) {
-        final ArrayList<String> origPermissions = new ArrayList<>(mCallerPermissions);
-        mCallerPermissions.add(android.Manifest.permission.DUMP);
-        try {
-            final ByteArrayOutputStream out = new ByteArrayOutputStream();
-            final PrintWriter pw = new PrintWriter(out);
-            mService.dump(/* fd */ null, pw, args);
-            pw.close();
-
-            return out.toString();
-        } finally {
-            mCallerPermissions.clear();
-            mCallerPermissions.addAll(origPermissions);
-        }
-    }
-
-    /**
-     * For debugging, dump arbitrary file on logcat.
-     */
-    protected void dumpFileOnLogcat(String path) {
-        dumpFileOnLogcat(path, "");
-    }
-
-    protected void dumpFileOnLogcat(String path, String message) {
-        if (!ENABLE_DUMP) return;
-
-        Log.v(TAG, "Dumping file: " + path + " " + message);
-        final StringBuilder sb = new StringBuilder();
-        try (BufferedReader br = new BufferedReader(new FileReader(path))) {
-            String line;
-            while ((line = br.readLine()) != null) {
-                Log.v(TAG, line);
-            }
-        } catch (Exception e) {
-            Log.e(TAG, "Couldn't read file", e);
-            fail("Exception " + e);
-        }
-    }
-
-    /**
-     * For debugging, dump the main state file on logcat.
-     */
-    protected void dumpBaseStateFile() {
-        mService.saveDirtyInfo();
-        dumpFileOnLogcat(mInjectedFilePathRoot.getAbsolutePath()
-                + "/system/" + ShortcutService.FILENAME_BASE_STATE);
-    }
-
-    /**
-     * For debugging, dump per-user state file on logcat.
-     */
-    protected void dumpUserFile(int userId) {
-        dumpUserFile(userId, "");
-    }
-
-    protected void dumpUserFile(int userId, String message) {
-        mService.saveDirtyInfo();
-        dumpFileOnLogcat(mInjectedFilePathRoot.getAbsolutePath()
-                + "/user-" + userId
-                + "/" + ShortcutService.FILENAME_USER_PACKAGES, message);
-    }
-
-    /**
-     * Make a shortcut with an ID.
-     */
-    protected ShortcutInfo makeShortcut(String id) {
-        return makeShortcut(
-                id, "Title-" + id, /* activity =*/ null, /* icon =*/ null,
-                makeIntent(Intent.ACTION_VIEW, ShortcutActivity.class), /* rank =*/ 0);
-    }
-
-    protected ShortcutInfo makeShortcutWithTitle(String id, String title) {
-        return makeShortcut(
-                id, title, /* activity =*/ null, /* icon =*/ null,
-                makeIntent(Intent.ACTION_VIEW, ShortcutActivity.class), /* rank =*/ 0);
-    }
-
-    /**
-     * Make a shortcut with an ID and timestamp.
-     */
-    protected ShortcutInfo makeShortcutWithTimestamp(String id, long timestamp) {
-        final ShortcutInfo s = makeShortcut(
-                id, "Title-" + id, /* activity =*/ null, /* icon =*/ null,
-                makeIntent(Intent.ACTION_VIEW, ShortcutActivity.class), /* rank =*/ 0);
-        s.setTimestamp(timestamp);
-        return s;
-    }
-
-    /**
-     * Make a shortcut with an ID, a timestamp and an activity component
-     */
-    protected ShortcutInfo makeShortcutWithTimestampWithActivity(String id, long timestamp,
-            ComponentName activity) {
-        final ShortcutInfo s = makeShortcut(
-                id, "Title-" + id, activity, /* icon =*/ null,
-                makeIntent(Intent.ACTION_VIEW, ShortcutActivity.class), /* rank =*/ 0);
-        s.setTimestamp(timestamp);
-        return s;
-    }
-
-    /**
-     * Make a shortcut with an ID and icon.
-     */
-    protected ShortcutInfo makeShortcutWithIcon(String id, Icon icon) {
-        return makeShortcut(
-                id, "Title-" + id, /* activity =*/ null, icon,
-                makeIntent(Intent.ACTION_VIEW, ShortcutActivity.class), /* rank =*/ 0);
-    }
-
-    protected ShortcutInfo makePackageShortcut(String packageName, String id) {
-        String origCaller = getCallingPackage();
-
-        setCaller(packageName);
-        ShortcutInfo s = makeShortcut(
-                id, "Title-" + id, /* activity =*/ null, /* icon =*/ null,
-                makeIntent(Intent.ACTION_VIEW, ShortcutActivity.class), /* rank =*/ 0);
-        setCaller(origCaller); // restore the caller
-
-        return s;
-    }
-
-    /**
-     * Make multiple shortcuts with IDs.
-     */
-    protected List<ShortcutInfo> makeShortcuts(String... ids) {
-        final ArrayList<ShortcutInfo> ret = new ArrayList();
-        for (String id : ids) {
-            ret.add(makeShortcut(id));
-        }
-        return ret;
-    }
-
-    protected ShortcutInfo.Builder makeShortcutBuilder() {
-        return new ShortcutInfo.Builder(mClientContext);
-    }
-
-    protected ShortcutInfo makeShortcutWithActivity(String id, ComponentName activity) {
-        return makeShortcut(
-                id, "Title-" + id, activity, /* icon =*/ null,
-                makeIntent(Intent.ACTION_VIEW, ShortcutActivity.class), /* rank =*/ 0);
-    }
-
-    protected ShortcutInfo makeShortcutWithIntent(String id, Intent intent) {
-        return makeShortcut(
-                id, "Title-" + id, /* activity =*/ null, /* icon =*/ null,
-                intent, /* rank =*/ 0);
-    }
-
-    protected ShortcutInfo makeShortcutWithActivityAndTitle(String id, ComponentName activity,
-            String title) {
-        return makeShortcut(
-                id, title, activity, /* icon =*/ null,
-                makeIntent(Intent.ACTION_VIEW, ShortcutActivity.class), /* rank =*/ 0);
-    }
-
-    protected ShortcutInfo makeShortcutWithActivityAndRank(String id, ComponentName activity,
-            int rank) {
-        return makeShortcut(
-                id, "Title-" + id, activity, /* icon =*/ null,
-                makeIntent(Intent.ACTION_VIEW, ShortcutActivity.class), rank);
-    }
-
-    /**
-     * Make a shortcut with details.
-     */
-    protected ShortcutInfo makeShortcut(String id, String title, ComponentName activity,
-            Icon icon, Intent intent, int rank) {
-        final ShortcutInfo.Builder  b = new ShortcutInfo.Builder(mClientContext, id)
-                .setActivity(new ComponentName(mClientContext.getPackageName(), "dummy"))
-                .setShortLabel(title)
-                .setRank(rank)
-                .setIntent(intent);
-        if (icon != null) {
-            b.setIcon(icon);
-        }
-        if (activity != null) {
-            b.setActivity(activity);
-        }
-        final ShortcutInfo s = b.build();
-
-        s.setTimestamp(mInjectedCurrentTimeMillis); // HACK
-
-        return s;
-    }
-
-    protected ShortcutInfo makeShortcutWithIntents(String id, Intent... intents) {
-        return makeShortcut(
-                id, "Title-" + id, /* activity =*/ null, /* icon =*/ null,
-                intents, /* rank =*/ 0);
-    }
-
-    /**
-     * Make a shortcut with details.
-     */
-    protected ShortcutInfo makeShortcut(String id, String title, ComponentName activity,
-            Icon icon, Intent[] intents, int rank) {
-        final ShortcutInfo.Builder  b = new ShortcutInfo.Builder(mClientContext, id)
-                .setActivity(new ComponentName(mClientContext.getPackageName(), "dummy"))
-                .setShortLabel(title)
-                .setRank(rank)
-                .setIntents(intents);
-        if (icon != null) {
-            b.setIcon(icon);
-        }
-        if (activity != null) {
-            b.setActivity(activity);
-        }
-        final ShortcutInfo s = b.build();
-
-        s.setTimestamp(mInjectedCurrentTimeMillis); // HACK
-
-        return s;
-    }
-
-    /**
-     * Make a shortcut with details.
-     */
-    protected ShortcutInfo makeShortcutWithExtras(String id, Intent intent,
-            PersistableBundle extras) {
-        final ShortcutInfo.Builder  b = new ShortcutInfo.Builder(mClientContext, id)
-                .setActivity(new ComponentName(mClientContext.getPackageName(), "dummy"))
-                .setShortLabel("title-" + id)
-                .setExtras(extras)
-                .setIntent(intent);
-        final ShortcutInfo s = b.build();
-
-        s.setTimestamp(mInjectedCurrentTimeMillis); // HACK
-
-        return s;
-    }
-
-    /**
-     * Make an intent.
-     */
-    protected Intent makeIntent(String action, Class<?> clazz, Object... bundleKeysAndValues) {
-        final Intent intent = new Intent(action);
-        intent.setComponent(makeComponent(clazz));
-        intent.replaceExtras(makeBundle(bundleKeysAndValues));
-        return intent;
-    }
-
-    /**
-     * Make an component name, with the client context.
-     */
-    @NonNull
-    protected ComponentName makeComponent(Class<?> clazz) {
-        return new ComponentName(mClientContext, clazz);
-    }
-
-    @NonNull
-    protected ShortcutInfo findById(List<ShortcutInfo> list, String id) {
-        for (ShortcutInfo s : list) {
-            if (s.getId().equals(id)) {
-                return s;
-            }
-        }
-        fail("Shortcut with id " + id + " not found");
-        return null;
-    }
-
-    protected void assertSystem() {
-        assertEquals("Caller must be system", Process.SYSTEM_UID, mInjectedCallingUid);
-    }
-
-    protected void assertResetTimes(long expectedLastResetTime, long expectedNextResetTime) {
-        assertEquals(expectedLastResetTime, mService.getLastResetTimeLocked());
-        assertEquals(expectedNextResetTime, mService.getNextResetTimeLocked());
-    }
-
-    public static List<ShortcutInfo> assertAllNotHaveIcon(
-            List<ShortcutInfo> actualShortcuts) {
-        for (ShortcutInfo s : actualShortcuts) {
-            assertNull("ID " + s.getId(), s.getIcon());
-        }
-        return actualShortcuts;
-    }
-
-    @NonNull
-    protected List<ShortcutInfo> assertAllHaveFlags(@NonNull List<ShortcutInfo> actualShortcuts,
-            int shortcutFlags) {
-        for (ShortcutInfo s : actualShortcuts) {
-            assertTrue("ID " + s.getId() + " doesn't have flags " + shortcutFlags,
-                    s.hasFlags(shortcutFlags));
-        }
-        return actualShortcuts;
-    }
-
-    protected ShortcutInfo getPackageShortcut(String packageName, String shortcutId, int userId) {
-        return mService.getPackageShortcutForTest(packageName, shortcutId, userId);
-    }
-
-    protected void assertShortcutExists(String packageName, String shortcutId, int userId) {
-        assertTrue(getPackageShortcut(packageName, shortcutId, userId) != null);
-    }
-
-    protected void assertShortcutNotExists(String packageName, String shortcutId, int userId) {
-        assertTrue(getPackageShortcut(packageName, shortcutId, userId) == null);
-    }
-
-    protected Intent[] launchShortcutAndGetIntentsInner(Runnable shortcutStarter,
-            @NonNull String packageName, @NonNull String shortcutId, int userId) {
-        reset(mMockActivityManagerInternal);
-        shortcutStarter.run();
-
-        final ArgumentCaptor<Intent[]> intentsCaptor = ArgumentCaptor.forClass(Intent[].class);
-        verify(mMockActivityManagerInternal).startActivitiesAsPackage(
-                eq(packageName),
-                eq(userId),
-                intentsCaptor.capture(),
-                any(Bundle.class));
-        return intentsCaptor.getValue();
-    }
-
-    protected Intent[] launchShortcutAndGetIntents(
-            @NonNull String packageName, @NonNull String shortcutId, int userId) {
-        return launchShortcutAndGetIntentsInner(
-                () -> {
-                    mLauncherApps.startShortcut(packageName, shortcutId, null, null,
-                            UserHandle.of(userId));
-                }, packageName, shortcutId, userId
-        );
-    }
-
-    protected Intent launchShortcutAndGetIntent(
-            @NonNull String packageName, @NonNull String shortcutId, int userId) {
-        final Intent[] intents = launchShortcutAndGetIntents(packageName, shortcutId, userId);
-        assertEquals(1, intents.length);
-        return intents[0];
-    }
-
-    protected Intent[] launchShortcutAndGetIntents_withShortcutInfo(
-            @NonNull String packageName, @NonNull String shortcutId, int userId) {
-        return launchShortcutAndGetIntentsInner(
-                () -> {
-                    mLauncherApps.startShortcut(
-                            getShortcutInfoAsLauncher(packageName, shortcutId, userId), null, null);
-                }, packageName, shortcutId, userId
-        );
-    }
-
-    protected Intent launchShortcutAndGetIntent_withShortcutInfo(
-            @NonNull String packageName, @NonNull String shortcutId, int userId) {
-        final Intent[] intents = launchShortcutAndGetIntents_withShortcutInfo(
-                packageName, shortcutId, userId);
-        assertEquals(1, intents.length);
-        return intents[0];
-    }
-
-    protected void assertShortcutLaunchable(@NonNull String packageName, @NonNull String shortcutId,
-            int userId) {
-        assertNotNull(launchShortcutAndGetIntent(packageName, shortcutId, userId));
-        assertNotNull(launchShortcutAndGetIntent_withShortcutInfo(packageName, shortcutId, userId));
-    }
-
-    protected void assertShortcutNotLaunched(@NonNull String packageName,
-            @NonNull String shortcutId, int userId) {
-        reset(mMockActivityManagerInternal);
-        try {
-            mLauncherApps.startShortcut(packageName, shortcutId, null, null,
-                    UserHandle.of(userId));
-            fail("ActivityNotFoundException was not thrown");
-        } catch (ActivityNotFoundException expected) {
-        }
-        // This shouldn't have been called.
-        verify(mMockActivityManagerInternal, times(0)).startActivitiesAsPackage(
-                anyString(),
-                anyInt(),
-                any(Intent[].class),
-                any(Bundle.class));
-    }
-
-    protected void assertStartShortcutThrowsException(@NonNull String packageName,
-            @NonNull String shortcutId, int userId, Class<?> expectedException) {
-        Exception thrown = null;
-        try {
-            mLauncherApps.startShortcut(packageName, shortcutId, null, null,
-                    UserHandle.of(userId));
-        } catch (Exception e) {
-            thrown = e;
-        }
-        assertNotNull("Exception was not thrown", thrown);
-        assertEquals("Exception type different", expectedException, thrown.getClass());
-    }
-
-    protected void assertBitmapDirectories(int userId, String... expectedDirectories) {
-        final Set<String> expected = hashSet(set(expectedDirectories));
-
-        final Set<String> actual = new HashSet<>();
-
-        final File[] files = mService.getUserBitmapFilePath(userId).listFiles();
-        if (files != null) {
-            for (File child : files) {
-                if (child.isDirectory()) {
-                    actual.add(child.getName());
-                }
-            }
-        }
-
-        assertEquals(expected, actual);
-    }
-
-    protected void assertBitmapFiles(int userId, String packageName, String... expectedFiles) {
-        final Set<String> expected = hashSet(set(expectedFiles));
-
-        final Set<String> actual = new HashSet<>();
-
-        final File[] files = new File(mService.getUserBitmapFilePath(userId), packageName)
-                .listFiles();
-        if (files != null) {
-            for (File child : files) {
-                if (child.isFile()) {
-                    actual.add(child.getName());
-                }
-            }
-        }
-
-        assertEquals(expected, actual);
-    }
-
-    protected String getBitmapFilename(int userId, String packageName, String shortcutId) {
-        final ShortcutInfo si = mService.getPackageShortcutForTest(packageName, shortcutId, userId);
-        if (si == null) {
-            return null;
-        }
-        return new File(si.getBitmapPath()).getName();
-    }
-
-    /**
-     * @return all shortcuts stored internally for the caller.  This reflects the *internal* view
-     * of shortcuts, which may be different from what {@link #getCallerVisibleShortcuts} would
-     * return, because getCallerVisibleShortcuts() will get shortcuts from the proper "front door"
-     * which performs some extra checks, like {@link ShortcutPackage#onRestored}.
-     */
-    protected List<ShortcutInfo> getCallerShortcuts() {
-        final ShortcutPackage p = mService.getPackageShortcutForTest(
-                getCallingPackage(), getCallingUserId());
-        return p == null ? null : p.getAllShortcutsForTest();
-    }
-
-    /**
-     * @return all shortcuts owned by caller that are actually visible via ShortcutManager.
-     * See also {@link #getCallerShortcuts}.
-     */
-    protected List<ShortcutInfo> getCallerVisibleShortcuts() {
-        final ArrayList<ShortcutInfo> ret = new ArrayList<>();
-        ret.addAll(mManager.getDynamicShortcuts());
-        ret.addAll(mManager.getPinnedShortcuts());
-        ret.addAll(mManager.getManifestShortcuts());
-        return ret;
-    }
-
-    protected ShortcutInfo getCallerShortcut(String shortcutId) {
-        return getPackageShortcut(getCallingPackage(), shortcutId, getCallingUserId());
-    }
-
-    protected List<ShortcutInfo> getLauncherShortcuts(String launcher, int userId, int queryFlags) {
-        final List<ShortcutInfo>[] ret = new List[1];
-        runWithCaller(launcher, userId, () -> {
-            final ShortcutQuery q = new ShortcutQuery();
-            q.setQueryFlags(queryFlags);
-            ret[0] = mLauncherApps.getShortcuts(q, UserHandle.of(userId));
-        });
-        return ret[0];
-    }
-
-    protected List<ShortcutInfo> getLauncherPinnedShortcuts(String launcher, int userId) {
-        return getLauncherShortcuts(launcher, userId, ShortcutQuery.FLAG_GET_PINNED);
-    }
-
-    protected ShortcutInfo getShortcutInfoAsLauncher(String packageName, String shortcutId,
-            int userId) {
-        final List<ShortcutInfo> infoList =
-                mLauncherApps.getShortcutInfo(packageName, list(shortcutId),
-                        UserHandle.of(userId));
-        assertEquals("No shortcutInfo found (or too many of them)", 1, infoList.size());
-        return infoList.get(0);
-    }
-
-    protected Intent genPackageAddIntent(String packageName, int userId) {
-        installPackage(userId, packageName);
-
-        Intent i = new Intent(Intent.ACTION_PACKAGE_ADDED);
-        i.setData(Uri.parse("package:" + packageName));
-        i.putExtra(Intent.EXTRA_USER_HANDLE, userId);
-        return i;
-    }
-
-    protected Intent genPackageDeleteIntent(String pakcageName, int userId) {
-        uninstallPackage(userId, pakcageName);
-
-        Intent i = new Intent(Intent.ACTION_PACKAGE_REMOVED);
-        i.setData(Uri.parse("package:" + pakcageName));
-        i.putExtra(Intent.EXTRA_USER_HANDLE, userId);
-        return i;
-    }
-
-    protected Intent genPackageUpdateIntent(String pakcageName, int userId) {
-        installPackage(userId, pakcageName);
-
-        Intent i = new Intent(Intent.ACTION_PACKAGE_ADDED);
-        i.setData(Uri.parse("package:" + pakcageName));
-        i.putExtra(Intent.EXTRA_USER_HANDLE, userId);
-        i.putExtra(Intent.EXTRA_REPLACING, true);
-        return i;
-    }
-
-    protected Intent genPackageChangedIntent(String pakcageName, int userId) {
-        Intent i = new Intent(Intent.ACTION_PACKAGE_CHANGED);
-        i.setData(Uri.parse("package:" + pakcageName));
-        i.putExtra(Intent.EXTRA_USER_HANDLE, userId);
-        return i;
-    }
-
-    protected Intent genPackageDataClear(String packageName, int userId) {
-        Intent i = new Intent(Intent.ACTION_PACKAGE_DATA_CLEARED);
-        i.setData(Uri.parse("package:" + packageName));
-        i.putExtra(Intent.EXTRA_USER_HANDLE, userId);
-        return i;
-    }
-
-    protected void assertExistsAndShadow(ShortcutPackageItem spi) {
-        assertNotNull(spi);
-        assertTrue(spi.getPackageInfo().isShadow());
-    }
-
-    protected File makeFile(File baseDirectory, String... paths) {
-        File ret = baseDirectory;
-
-        for (String path : paths) {
-            ret = new File(ret, path);
-        }
-
-        return ret;
-    }
-
-    protected boolean bitmapDirectoryExists(String packageName, int userId) {
-        final File path = new File(mService.getUserBitmapFilePath(userId), packageName);
-        return path.isDirectory();
-    }
-    protected static ShortcutQuery buildQuery(long changedSince,
-            String packageName, ComponentName componentName,
-            /* @ShortcutQuery.QueryFlags */ int flags) {
-        return buildQuery(changedSince, packageName, null, componentName, flags);
-    }
-
-    protected static ShortcutQuery buildQuery(long changedSince,
-            String packageName, List<String> shortcutIds, ComponentName componentName,
-            /* @ShortcutQuery.QueryFlags */ int flags) {
-        final ShortcutQuery q = new ShortcutQuery();
-        q.setChangedSince(changedSince);
-        q.setPackage(packageName);
-        q.setShortcutIds(shortcutIds);
-        q.setActivity(componentName);
-        q.setQueryFlags(flags);
-        return q;
-    }
-
-    protected static ShortcutQuery buildAllQuery(String packageName) {
-        final ShortcutQuery q = new ShortcutQuery();
-        q.setPackage(packageName);
-        q.setQueryFlags(ShortcutQuery.FLAG_GET_ALL_KINDS);
-        return q;
-    }
-
-    protected static ShortcutQuery buildPinnedQuery(String packageName) {
-        final ShortcutQuery q = new ShortcutQuery();
-        q.setPackage(packageName);
-        q.setQueryFlags(ShortcutQuery.FLAG_GET_PINNED);
-        return q;
-    }
-
-    protected static ShortcutQuery buildQueryWithFlags(int queryFlags) {
-        final ShortcutQuery q = new ShortcutQuery();
-        q.setQueryFlags(queryFlags);
-        return q;
-    }
-
-    protected void backupAndRestore() {
-        int prevUid = mInjectedCallingUid;
-
-        mInjectedCallingUid = Process.SYSTEM_UID; // Only system can call it.
-
-        dumpsysOnLogcat("Before backup");
-
-        final byte[] payload =  mService.getBackupPayload(USER_0);
-        if (ENABLE_DUMP) {
-            final String xml = new String(payload);
-            Log.v(TAG, "Backup payload:");
-            for (String line : xml.split("\n")) {
-                Log.v(TAG, line);
-            }
-        }
-
-        // Before doing anything else, uninstall all packages.
-        for (int userId : list(USER_0, USER_P0)) {
-            for (String pkg : list(CALLING_PACKAGE_1, CALLING_PACKAGE_2, CALLING_PACKAGE_3,
-                    LAUNCHER_1, LAUNCHER_2, LAUNCHER_3)) {
-                uninstallPackage(userId, pkg);
-            }
-        }
-
-        shutdownServices();
-
-        deleteAllSavedFiles();
-
-        initService();
-        mService.applyRestore(payload, USER_0);
-
-        // handleUnlockUser will perform the gone package check, but it shouldn't remove
-        // shadow information.
-        mService.handleUnlockUser(USER_0);
-
-        dumpsysOnLogcat("After restore");
-
-        mInjectedCallingUid = prevUid;
-    }
-
-    protected void prepareCrossProfileDataSet() {
-        mRunningUsers.put(USER_10, true); // this test needs user 10.
-
-        runWithCaller(CALLING_PACKAGE_1, USER_0, () -> {
-            assertTrue(mManager.setDynamicShortcuts(list(
-                    makeShortcut("s1"), makeShortcut("s2"), makeShortcut("s3"),
-                    makeShortcut("s4"), makeShortcut("s5"), makeShortcut("s6"))));
-        });
-        runWithCaller(CALLING_PACKAGE_2, USER_0, () -> {
-            assertTrue(mManager.setDynamicShortcuts(list(
-                    makeShortcut("s1"), makeShortcut("s2"), makeShortcut("s3"),
-                    makeShortcut("s4"), makeShortcut("s5"), makeShortcut("s6"))));
-        });
-        runWithCaller(CALLING_PACKAGE_3, USER_0, () -> {
-            assertTrue(mManager.setDynamicShortcuts(list(
-                    makeShortcut("s1"), makeShortcut("s2"), makeShortcut("s3"),
-                    makeShortcut("s4"), makeShortcut("s5"), makeShortcut("s6"))));
-        });
-        runWithCaller(CALLING_PACKAGE_4, USER_0, () -> {
-            assertTrue(mManager.setDynamicShortcuts(list()));
-        });
-        runWithCaller(CALLING_PACKAGE_1, USER_P0, () -> {
-            assertTrue(mManager.setDynamicShortcuts(list(
-                    makeShortcut("s1"), makeShortcut("s2"), makeShortcut("s3"),
-                    makeShortcut("s4"), makeShortcut("s5"), makeShortcut("s6"))));
-        });
-        runWithCaller(CALLING_PACKAGE_1, USER_10, () -> {
-            assertTrue(mManager.setDynamicShortcuts(list(
-                    makeShortcut("x1"), makeShortcut("x2"), makeShortcut("x3"),
-                    makeShortcut("x4"), makeShortcut("x5"), makeShortcut("x6"))));
-        });
-
-        runWithCaller(LAUNCHER_1, USER_0, () -> {
-            mLauncherApps.pinShortcuts(CALLING_PACKAGE_1, list("s1"), HANDLE_USER_0);
-            mLauncherApps.pinShortcuts(CALLING_PACKAGE_2, list("s1", "s2"), HANDLE_USER_0);
-            mLauncherApps.pinShortcuts(CALLING_PACKAGE_3, list("s1", "s2", "s3"), HANDLE_USER_0);
-
-            mLauncherApps.pinShortcuts(CALLING_PACKAGE_1, list("s1", "s4"), HANDLE_USER_P0);
-        });
-        runWithCaller(LAUNCHER_2, USER_0, () -> {
-            mLauncherApps.pinShortcuts(CALLING_PACKAGE_1, list("s2"), HANDLE_USER_0);
-            mLauncherApps.pinShortcuts(CALLING_PACKAGE_2, list("s2", "s3"), HANDLE_USER_0);
-            mLauncherApps.pinShortcuts(CALLING_PACKAGE_3, list("s2", "s3", "s4"), HANDLE_USER_0);
-
-            mLauncherApps.pinShortcuts(CALLING_PACKAGE_1, list("s2", "s5"), HANDLE_USER_P0);
-        });
-
-        // Note LAUNCHER_3 has allowBackup=false.
-        runWithCaller(LAUNCHER_3, USER_0, () -> {
-            mLauncherApps.pinShortcuts(CALLING_PACKAGE_1, list("s3"), HANDLE_USER_0);
-            mLauncherApps.pinShortcuts(CALLING_PACKAGE_2, list("s3", "s4"), HANDLE_USER_0);
-            mLauncherApps.pinShortcuts(CALLING_PACKAGE_3, list("s3", "s4", "s5"), HANDLE_USER_0);
-
-            mLauncherApps.pinShortcuts(CALLING_PACKAGE_1, list("s3", "s6"), HANDLE_USER_P0);
-        });
-        runWithCaller(LAUNCHER_4, USER_0, () -> {
-            mLauncherApps.pinShortcuts(CALLING_PACKAGE_1, list(), HANDLE_USER_0);
-            mLauncherApps.pinShortcuts(CALLING_PACKAGE_2, list(), HANDLE_USER_0);
-            mLauncherApps.pinShortcuts(CALLING_PACKAGE_3, list(), HANDLE_USER_0);
-            mLauncherApps.pinShortcuts(CALLING_PACKAGE_4, list(), HANDLE_USER_0);
-        });
-
-        // Launcher on a managed profile is referring ot user 0!
-        runWithCaller(LAUNCHER_1, USER_P0, () -> {
-            mLauncherApps.pinShortcuts(CALLING_PACKAGE_1, list("s3", "s4"), HANDLE_USER_0);
-            mLauncherApps.pinShortcuts(CALLING_PACKAGE_2, list("s3", "s4", "s5"), HANDLE_USER_0);
-            mLauncherApps.pinShortcuts(CALLING_PACKAGE_3, list("s3", "s4", "s5", "s6"),
-                    HANDLE_USER_0);
-
-            mLauncherApps.pinShortcuts(CALLING_PACKAGE_1, list("s4", "s1"), HANDLE_USER_P0);
-        });
-        runWithCaller(LAUNCHER_1, USER_10, () -> {
-            mLauncherApps.pinShortcuts(CALLING_PACKAGE_1, list("x4", "x5"), HANDLE_USER_10);
-            mLauncherApps.pinShortcuts(CALLING_PACKAGE_2, list("x4", "x5", "x6"), HANDLE_USER_10);
-            mLauncherApps.pinShortcuts(CALLING_PACKAGE_3, list("x4", "x5", "x6", "x1"),
-                    HANDLE_USER_10);
-        });
-
-        // Then remove some dynamic shortcuts.
-        runWithCaller(CALLING_PACKAGE_1, USER_0, () -> {
-            assertTrue(mManager.setDynamicShortcuts(list(
-                    makeShortcut("s1"), makeShortcut("s2"), makeShortcut("s3"))));
-        });
-        runWithCaller(CALLING_PACKAGE_2, USER_0, () -> {
-            assertTrue(mManager.setDynamicShortcuts(list(
-                    makeShortcut("s1"), makeShortcut("s2"), makeShortcut("s3"))));
-        });
-        runWithCaller(CALLING_PACKAGE_3, USER_0, () -> {
-            assertTrue(mManager.setDynamicShortcuts(list(
-                    makeShortcut("s1"), makeShortcut("s2"), makeShortcut("s3"))));
-        });
-        runWithCaller(CALLING_PACKAGE_4, USER_0, () -> {
-            assertTrue(mManager.setDynamicShortcuts(list()));
-        });
-        runWithCaller(CALLING_PACKAGE_1, USER_P0, () -> {
-            assertTrue(mManager.setDynamicShortcuts(list(
-                    makeShortcut("s1"), makeShortcut("s2"), makeShortcut("s3"))));
-        });
-        runWithCaller(CALLING_PACKAGE_1, USER_10, () -> {
-            assertTrue(mManager.setDynamicShortcuts(list(
-                    makeShortcut("x1"), makeShortcut("x2"), makeShortcut("x3"))));
-        });
-    }
-
-    public static List<ShortcutInfo> assertAllHaveIconResId(
-            List<ShortcutInfo> actualShortcuts) {
-        for (ShortcutInfo s : actualShortcuts) {
-            assertTrue("ID " + s.getId() + " not have icon res ID", s.hasIconResource());
-            assertFalse("ID " + s.getId() + " shouldn't have icon FD", s.hasIconFile());
-        }
-        return actualShortcuts;
-    }
-
-    public static List<ShortcutInfo> assertAllHaveIconFile(
-            List<ShortcutInfo> actualShortcuts) {
-        for (ShortcutInfo s : actualShortcuts) {
-            assertFalse("ID " + s.getId() + " shouldn't have icon res ID", s.hasIconResource());
-            assertTrue("ID " + s.getId() + " not have icon FD", s.hasIconFile());
-        }
-        return actualShortcuts;
-    }
-
-    public static List<ShortcutInfo> assertAllHaveIcon(
-            List<ShortcutInfo> actualShortcuts) {
-        for (ShortcutInfo s : actualShortcuts) {
-            assertTrue("ID " + s.getId() + " has no icon ", s.hasIconFile() || s.hasIconResource());
-        }
-        return actualShortcuts;
-    }
-
-    public static List<ShortcutInfo> assertAllStringsResolved(
-            List<ShortcutInfo> actualShortcuts) {
-        for (ShortcutInfo s : actualShortcuts) {
-            assertTrue("ID " + s.getId(), s.hasStringResourcesResolved());
-        }
-        return actualShortcuts;
-    }
-
-    public String readTestAsset(String assetPath) throws IOException {
-        final StringBuilder sb = new StringBuilder();
-        try (BufferedReader br = new BufferedReader(
-                new InputStreamReader(
-                        getTestContext().getResources().getAssets().open(assetPath)))) {
-            String line;
-            while ((line = br.readLine()) != null) {
-                sb.append(line);
-                sb.append(System.lineSeparator());
-            }
-        }
-        return sb.toString();
-    }
-
-    protected void prepareGetHomeActivitiesAsUser(ComponentName preferred,
-            List<ResolveInfo> candidates, int userId) {
-        doAnswer(inv -> {
-            ((List) inv.getArguments()[0]).addAll(candidates);
-            return preferred;
-        }).when(mMockPackageManagerInternal).getHomeActivitiesAsUser(any(List.class), eq(userId));
-    }
-
-    protected static ComponentName cn(String packageName, String name) {
-        return new ComponentName(packageName, name);
-    }
-
-    protected static ResolveInfo ri(String packageName, String name, boolean isSystem, int priority) {
-        final ResolveInfo ri = new ResolveInfo();
-        ri.activityInfo = new ActivityInfo();
-        ri.activityInfo.applicationInfo = new ApplicationInfo();
-
-        ri.activityInfo.packageName = packageName;
-        ri.activityInfo.name = name;
-        if (isSystem) {
-            ri.activityInfo.applicationInfo.flags |= ApplicationInfo.FLAG_SYSTEM;
-        }
-        ri.priority = priority;
-        return ri;
-    }
-
-    protected static ResolveInfo getSystemLauncher() {
-        return ri(PACKAGE_SYSTEM_LAUNCHER, PACKAGE_SYSTEM_LAUNCHER_NAME, true,
-                PACKAGE_SYSTEM_LAUNCHER_PRIORITY);
-    }
-
-    protected static ResolveInfo getFallbackLauncher() {
-        return ri(PACKAGE_FALLBACK_LAUNCHER, PACKAGE_FALLBACK_LAUNCHER_NAME, true,
-                PACKAGE_FALLBACK_LAUNCHER_PRIORITY);
-    }
-}
diff --git a/services/tests/servicestests/src/com/android/server/pm/KeySetManagerServiceTest.java b/services/tests/servicestests/src/com/android/server/pm/KeySetManagerServiceTest.java
deleted file mode 100644
index ba83be19bed..00000000000
--- a/services/tests/servicestests/src/com/android/server/pm/KeySetManagerServiceTest.java
+++ /dev/null
@@ -1,804 +0,0 @@
-/*
- * Copyright (C) 2015 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.android.server.pm;
-
-
-import android.content.pm.PackageParser;
-import android.content.pm.Signature;
-import android.util.ArrayMap;
-import android.util.ArraySet;
-import android.util.LongSparseArray;
-import com.android.internal.util.ArrayUtils;
-
-import java.io.File;
-import java.io.IOException;
-import java.security.cert.CertificateException;
-import java.security.PublicKey;
-
-import android.test.AndroidTestCase;
-
-public class KeySetManagerServiceTest extends AndroidTestCase {
-
-    private ArrayMap<String, PackageSetting> mPackagesMap;
-    private KeySetManagerService mKsms;
-
-    public PackageSetting generateFakePackageSetting(String name) {
-        return new PackageSetting(name, name, new File(mContext.getCacheDir(), "fakeCodePath"),
-                new File(mContext.getCacheDir(), "fakeResPath"), "", "", "",
-                "", 1, 0, 0, null, null);
-    }
-
-    @Override
-    public void setUp() throws Exception {
-        super.setUp();
-        mPackagesMap = new ArrayMap<String, PackageSetting>();
-        mKsms = new KeySetManagerService(mPackagesMap);
-    }
-
-    public void testPackageKeySetDataConstructorUnassignend() {
-        PackageKeySetData pksd = new PackageKeySetData();
-        assertEquals(PackageKeySetData.KEYSET_UNASSIGNED, pksd.getProperSigningKeySet());
-        assertNull(pksd.getUpgradeKeySets());
-        ArrayMap<String, Long> aliases = pksd.getAliases();
-        assertNotNull(aliases);
-        assertEquals(0, aliases.size());
-    }
-
-    /* test equivalence of PackageManager cert encoding and PackageParser manifest keys */
-    public void testPublicKeyCertReprEquiv() throws CertificateException {
-        PublicKey keyA = PackageParser.parsePublicKey(KeySetStrings.ctsKeySetPublicKeyA);
-        PublicKey keyB = PackageParser.parsePublicKey(KeySetStrings.ctsKeySetPublicKeyB);
-        PublicKey keyC = PackageParser.parsePublicKey(KeySetStrings.ctsKeySetPublicKeyC);
-
-        Signature sigA = new Signature(KeySetStrings.ctsKeySetCertA);
-        Signature sigB = new Signature(KeySetStrings.ctsKeySetCertB);
-        Signature sigC = new Signature(KeySetStrings.ctsKeySetCertC);
-
-        assertNotNull(keyA);
-        assertNotNull(keyB);
-        assertNotNull(keyC);
-
-        assertEquals(keyA, sigA.getPublicKey());
-        assertEquals(keyB, sigB.getPublicKey());
-        assertEquals(keyC, sigC.getPublicKey());
-
-        byte[] bArrayPk = keyA.getEncoded();
-        byte[] bArrayCert = sigA.getPublicKey().getEncoded();
-        assertEquals(bArrayPk.length, bArrayCert.length);
-        assertEquals(true, ArrayUtils.equals(bArrayPk, bArrayCert, bArrayPk.length));
-
-        bArrayPk = keyB.getEncoded();
-        bArrayCert = sigB.getPublicKey().getEncoded();
-        assertEquals(bArrayPk.length, bArrayCert.length);
-        assertEquals(true, ArrayUtils.equals(bArrayPk, bArrayCert, bArrayPk.length));
-
-        bArrayPk = keyC.getEncoded();
-        bArrayCert = sigC.getPublicKey().getEncoded();
-        assertEquals(bArrayPk.length, bArrayCert.length);
-        assertEquals(true, ArrayUtils.equals(bArrayPk, bArrayCert, bArrayPk.length));
-    }
-
-    public void testEncodePublicKey() throws IOException {
-        ArrayMap<String, PackageSetting> packagesMap = new ArrayMap<String, PackageSetting>();
-        KeySetManagerService ksms = new KeySetManagerService(packagesMap);
-
-        PublicKey keyA = PackageParser.parsePublicKey(KeySetStrings.ctsKeySetPublicKeyA);
-        PublicKey keyB = PackageParser.parsePublicKey(KeySetStrings.ctsKeySetPublicKeyB);
-        PublicKey keyC = PackageParser.parsePublicKey(KeySetStrings.ctsKeySetPublicKeyC);
-
-        assertEquals(ksms.encodePublicKey(keyA), KeySetStrings.ctsKeySetPublicKeyA);
-        assertEquals(ksms.encodePublicKey(keyB), KeySetStrings.ctsKeySetPublicKeyB);
-        assertEquals(ksms.encodePublicKey(keyC), KeySetStrings.ctsKeySetPublicKeyC);
-    }
-
-    /*
-     * Add the keyset information for a package to a system w/no previous keysets
-     */
-    public void testAddSigningKSToPackageEmpty() throws ReflectiveOperationException {
-
-        /* create PackageSetting and add to Settings mPackages */
-        PackageSetting ps = generateFakePackageSetting("packageA");
-        mPackagesMap.put(ps.name, ps);
-
-        /* collect signing key and add */
-        ArraySet<PublicKey> signingKeys = new ArraySet<PublicKey>();
-        PublicKey keyA = PackageParser.parsePublicKey(KeySetStrings.ctsKeySetPublicKeyA);
-        signingKeys.add(keyA);
-        mKsms.addSigningKeySetToPackageLPw(ps, signingKeys);
-
-        assertEquals(1, KeySetUtils.getKeySetRefCount(mKsms, 1));
-        assertEquals(1, KeySetUtils.getPubKeyRefCount(mKsms, 1));
-        assertEquals(keyA, KeySetUtils.getPubKey(mKsms, 1));
-        LongSparseArray<ArraySet<Long>> ksMapping = KeySetUtils.getKeySetMapping(mKsms);
-        assertEquals(1, ksMapping.size());
-        ArraySet<Long> mapping = ksMapping.get(1);
-        assertEquals(1, mapping.size());
-        assertTrue(mapping.contains(new Long(1)));
-        assertEquals(1, ps.keySetData.getProperSigningKeySet());
-    }
-
-    /*
-     * upgrade an app (same packagename) with same keyset and verify that
-     * nothing changed.
-     */
-    public void testAddSigningKSToPackageUpgradeSame() throws ReflectiveOperationException {
-
-        /* create PackageSetting and add to Settings mPackages */
-        PackageSetting ps = generateFakePackageSetting("packageA");
-        mPackagesMap.put(ps.name, ps);
-
-        /* collect signing key and add */
-        ArraySet<PublicKey> signingKeys = new ArraySet<PublicKey>();
-        PublicKey keyA = PackageParser.parsePublicKey(KeySetStrings.ctsKeySetPublicKeyA);
-        signingKeys.add(keyA);
-        mKsms.addSigningKeySetToPackageLPw(ps, signingKeys);
-
-        /* add again, to represent upgrade of package */
-        mKsms.addSigningKeySetToPackageLPw(ps, signingKeys);
-
-        assertEquals(1, KeySetUtils.getKeySetRefCount(mKsms, 1));
-        assertEquals(1, KeySetUtils.getPubKeyRefCount(mKsms, 1));
-        assertEquals(keyA, KeySetUtils.getPubKey(mKsms, 1));
-        LongSparseArray<ArraySet<Long>> ksMapping = KeySetUtils.getKeySetMapping(mKsms);
-        assertEquals(1, ksMapping.size());
-        ArraySet<Long> mapping = ksMapping.get(1);
-        assertEquals(1, mapping.size());
-        assertTrue(mapping.contains(new Long(1)));
-        assertEquals(1, ps.keySetData.getProperSigningKeySet());
-    }
-
-    /*
-     * upgrade an app (same packagename) with different unique keyset and verify
-     * that the old was removed.
-     */
-    public void testAddSigningKSToPackageUpgradeDiff() throws ReflectiveOperationException {
-
-        /* create PackageSetting and add to Settings mPackages */
-        PackageSetting ps = generateFakePackageSetting("packageA");
-        mPackagesMap.put(ps.name, ps);
-
-        /* collect signing key and add */
-        ArraySet<PublicKey> signingKeys = new ArraySet<PublicKey>();
-        PublicKey keyA = PackageParser.parsePublicKey(KeySetStrings.ctsKeySetPublicKeyA);
-        signingKeys.add(keyA);
-        mKsms.addSigningKeySetToPackageLPw(ps, signingKeys);
-
-        /* now upgrade with new key */
-        PublicKey keyB = PackageParser.parsePublicKey(KeySetStrings.ctsKeySetPublicKeyB);
-        signingKeys.removeAt(0);
-        signingKeys.add(keyB);
-        mKsms.addSigningKeySetToPackageLPw(ps, signingKeys);
-
-        assertEquals(0, KeySetUtils.getKeySetRefCount(mKsms, 1));
-        assertEquals(1, KeySetUtils.getKeySetRefCount(mKsms, 2));
-        assertEquals(0, KeySetUtils.getPubKeyRefCount(mKsms, 1));
-        assertEquals(1, KeySetUtils.getPubKeyRefCount(mKsms, 2));
-        assertEquals(keyB, KeySetUtils.getPubKey(mKsms, 2));
-        LongSparseArray<ArraySet<Long>> ksMapping = KeySetUtils.getKeySetMapping(mKsms);
-        assertEquals(1, ksMapping.size());
-        ArraySet<Long> mapping = ksMapping.get(2);
-        assertEquals(1, mapping.size());
-        assertTrue(mapping.contains(new Long(2)));
-        assertEquals(2, ps.keySetData.getProperSigningKeySet());
-    }
-
-    /*
-     * upgrade an app (same packagename) with different keyset and verify
-     * that the old had its ref count reduced due to reference by other ps.
-     */
-    public void testAddSigningKSToPackageUpgradeDiff2() throws ReflectiveOperationException {
-
-        /* create PackageSetting and add to Settings mPackages */
-        PackageSetting ps1 = generateFakePackageSetting("packageA");
-        mPackagesMap.put(ps1.name, ps1);
-        PackageSetting ps2 = generateFakePackageSetting("packageB");
-        mPackagesMap.put(ps2.name, ps2);
-
-        /* collect signing key and add */
-        ArraySet<PublicKey> signingKeys = new ArraySet<PublicKey>();
-        PublicKey keyA = PackageParser.parsePublicKey(KeySetStrings.ctsKeySetPublicKeyA);
-        signingKeys.add(keyA);
-        mKsms.addSigningKeySetToPackageLPw(ps1, signingKeys);
-        mKsms.addSigningKeySetToPackageLPw(ps2, signingKeys);
-
-        /* now upgrade with new key */
-        PublicKey keyB = PackageParser.parsePublicKey(KeySetStrings.ctsKeySetPublicKeyB);
-        signingKeys.removeAt(0);
-        signingKeys.add(keyB);
-        mKsms.addSigningKeySetToPackageLPw(ps1, signingKeys);
-
-        assertEquals(1, KeySetUtils.getKeySetRefCount(mKsms, 1));
-        assertEquals(1, KeySetUtils.getKeySetRefCount(mKsms, 2));
-        assertEquals(1, KeySetUtils.getPubKeyRefCount(mKsms, 1));
-        assertEquals(1, KeySetUtils.getPubKeyRefCount(mKsms, 2));
-        assertEquals(keyA, KeySetUtils.getPubKey(mKsms, 1));
-        assertEquals(keyB, KeySetUtils.getPubKey(mKsms, 2));
-        LongSparseArray<ArraySet<Long>> ksMapping = KeySetUtils.getKeySetMapping(mKsms);
-        assertEquals(2, ksMapping.size());
-        ArraySet<Long> mapping = ksMapping.get(1);
-        assertEquals(1, mapping.size());
-        assertTrue(mapping.contains(new Long(1)));
-        mapping = ksMapping.get(2);
-        assertEquals(1, mapping.size());
-        assertTrue(mapping.contains(new Long(2)));
-        assertEquals(2, ps1.keySetData.getProperSigningKeySet());
-        assertEquals(1, ps2.keySetData.getProperSigningKeySet());
-    }
-
-    /*
-     * Add orthoganal keyset info to system and ensure previous keysets are
-     * unmodified.
-     */
-    public void testAddSigningKSToPackageNewOrtho() throws ReflectiveOperationException {
-
-        /* create PackageSettings and add to Settings mPackages */
-        PackageSetting ps1 = generateFakePackageSetting("packageA");
-        mPackagesMap.put(ps1.name, ps1);
-        PackageSetting ps2 = generateFakePackageSetting("packageB");
-        mPackagesMap.put(ps2.name, ps2);
-
-        /* collect signing key and add */
-        ArraySet<PublicKey> signingKeys1 = new ArraySet<PublicKey>();
-        PublicKey keyA = PackageParser.parsePublicKey(KeySetStrings.ctsKeySetPublicKeyA);
-        signingKeys1.add(keyA);
-        mKsms.addSigningKeySetToPackageLPw(ps1, signingKeys1);
-
-        /* collect second signing key and add */
-        ArraySet<PublicKey> signingKeys2 = new ArraySet<PublicKey>();
-        PublicKey keyB = PackageParser.parsePublicKey(KeySetStrings.ctsKeySetPublicKeyB);
-        signingKeys2.add(keyB);
-        mKsms.addSigningKeySetToPackageLPw(ps2, signingKeys2);
-
-        /* verify first is unchanged */
-        assertEquals(1, KeySetUtils.getKeySetRefCount(mKsms, 1));
-        assertEquals(1, KeySetUtils.getPubKeyRefCount(mKsms, 1));
-        assertEquals(keyA, KeySetUtils.getPubKey(mKsms, 1));
-        LongSparseArray<ArraySet<Long>> ksMapping = KeySetUtils.getKeySetMapping(mKsms);
-        assertEquals(2, ksMapping.size());
-        ArraySet<Long> mapping = ksMapping.get(1);
-        assertEquals(1, mapping.size());
-        assertTrue(mapping.contains(new Long(1)));
-        assertEquals(1, ps1.keySetData.getProperSigningKeySet());
-
-        /* verify second */
-        assertEquals(1, KeySetUtils.getKeySetRefCount(mKsms, 2));
-        assertEquals(1, KeySetUtils.getPubKeyRefCount(mKsms, 2));
-        assertEquals(keyB, KeySetUtils.getPubKey(mKsms, 2));
-        mapping = ksMapping.get(2);
-        assertEquals(1, mapping.size());
-        assertTrue(mapping.contains(new  Long(2)));
-        assertEquals(2, ps2.keySetData.getProperSigningKeySet());
-    }
-
-    /*
-     * Add identical keyset info to system via new package and ensure previous
-     * keysets has reference count incremented
-     */
-    public void testAddSigningKSToPackageNewSame() throws ReflectiveOperationException {
-
-        /* create PackageSettings and add to Settings mPackages */
-        PackageSetting ps1 = generateFakePackageSetting("packageA");
-        mPackagesMap.put(ps1.name, ps1);
-        PackageSetting ps2 = generateFakePackageSetting("packageB");
-        mPackagesMap.put(ps2.name, ps2);
-
-        /* collect signing key and add */
-        ArraySet<PublicKey> signingKeys = new ArraySet<PublicKey>();
-        PublicKey keyA = PackageParser.parsePublicKey(KeySetStrings.ctsKeySetPublicKeyA);
-        signingKeys.add(keyA);
-        mKsms.addSigningKeySetToPackageLPw(ps1, signingKeys);
-
-        /* add again for second package */
-        mKsms.addSigningKeySetToPackageLPw(ps2, signingKeys);
-
-        assertEquals(2, KeySetUtils.getKeySetRefCount(mKsms, 1));
-        assertEquals(1, KeySetUtils.getPubKeyRefCount(mKsms, 1));
-        assertEquals(keyA, KeySetUtils.getPubKey(mKsms, 1));
-        LongSparseArray<ArraySet<Long>> ksMapping = KeySetUtils.getKeySetMapping(mKsms);
-        assertEquals(1, ksMapping.size());
-        ArraySet<Long> mapping = ksMapping.get(1);
-        assertEquals(1, mapping.size());
-        assertTrue(mapping.contains(new Long(1)));
-        assertEquals(1, ps1.keySetData.getProperSigningKeySet());
-        assertEquals(1, ps2.keySetData.getProperSigningKeySet());
-    }
-
-    /*
-     * add a package which is signed by a keyset which contains a previously seen
-     * public key and make sure its refernces are incremented.
-     */
-    public void testAddSigningKSToPackageSuper() throws ReflectiveOperationException {
-
-        /* create PackageSettings and add to Settings mPackages */
-        PackageSetting ps1 = generateFakePackageSetting("packageA");
-        mPackagesMap.put(ps1.name, ps1);
-        PackageSetting ps2 = generateFakePackageSetting("packageB");
-        mPackagesMap.put(ps2.name, ps2);
-
-        /* collect signing key and add */
-        ArraySet<PublicKey> signingKeys = new ArraySet<PublicKey>();
-        PublicKey keyA = PackageParser.parsePublicKey(KeySetStrings.ctsKeySetPublicKeyA);
-        signingKeys.add(keyA);
-        mKsms.addSigningKeySetToPackageLPw(ps1, signingKeys);
-
-        /* give ps2 a superset (add keyB) */
-        PublicKey keyB = PackageParser.parsePublicKey(KeySetStrings.ctsKeySetPublicKeyB);
-        signingKeys.add(keyB);
-        mKsms.addSigningKeySetToPackageLPw(ps2, signingKeys);
-
-        assertEquals(1, KeySetUtils.getKeySetRefCount(mKsms, 1));
-        assertEquals(1, KeySetUtils.getKeySetRefCount(mKsms, 2));
-        assertEquals(2, KeySetUtils.getPubKeyRefCount(mKsms, 1));
-        assertEquals(1, KeySetUtils.getPubKeyRefCount(mKsms, 2));
-        assertEquals(keyA, KeySetUtils.getPubKey(mKsms, 1));
-        assertEquals(keyB, KeySetUtils.getPubKey(mKsms, 2));
-        LongSparseArray<ArraySet<Long>> ksMapping = KeySetUtils.getKeySetMapping(mKsms);
-        assertEquals(2, ksMapping.size());
-        ArraySet<Long> mapping = ksMapping.get(1);
-        assertEquals(1, mapping.size());
-        assertTrue(mapping.contains(new Long(1)));
-        mapping = ksMapping.get(2);
-        assertEquals(2, mapping.size());
-        assertTrue(mapping.contains(new Long(1)));
-        assertTrue(mapping.contains(new Long(2)));
-        assertEquals(1, ps1.keySetData.getProperSigningKeySet());
-        assertEquals(2, ps2.keySetData.getProperSigningKeySet());
-    }
-
-    /*
-     * Upgrade an app (same pkgName) with different keyset which contains a public
-     * key from the previous keyset.  Verify old keyset removed and pub key ref
-     * count is accurate.
-     */
-    public void testAddSigningKSToPackageUpgradeDiffSuper() throws ReflectiveOperationException {
-
-        /* create PackageSetting and add to Settings mPackages */
-        PackageSetting ps = generateFakePackageSetting("packageA");
-        mPackagesMap.put(ps.name, ps);
-
-        /* collect signing key and add */
-        ArraySet<PublicKey> signingKeys = new ArraySet<PublicKey>();
-        PublicKey keyA = PackageParser.parsePublicKey(KeySetStrings.ctsKeySetPublicKeyA);
-        signingKeys.add(keyA);
-        mKsms.addSigningKeySetToPackageLPw(ps, signingKeys);
-
-        /* now with additional key */
-        PublicKey keyB = PackageParser.parsePublicKey(KeySetStrings.ctsKeySetPublicKeyB);
-        signingKeys.add(keyB);
-        mKsms.addSigningKeySetToPackageLPw(ps, signingKeys);
-
-        assertEquals(0, KeySetUtils.getKeySetRefCount(mKsms, 1));
-        assertEquals(1, KeySetUtils.getKeySetRefCount(mKsms, 2));
-        assertEquals(0, KeySetUtils.getPubKeyRefCount(mKsms, 1));
-        assertEquals(1, KeySetUtils.getPubKeyRefCount(mKsms, 2));
-        assertEquals(1, KeySetUtils.getPubKeyRefCount(mKsms, 3));
-
-        /* the pub key is removed w/prev keyset and may be either 2 or 3 */
-        assertTrue(keyA.equals(KeySetUtils.getPubKey(mKsms, 2)) || keyA.equals(KeySetUtils.getPubKey(mKsms, 3)));
-        assertTrue(keyB.equals(KeySetUtils.getPubKey(mKsms, 2)) || keyB.equals(KeySetUtils.getPubKey(mKsms, 3)));
-        assertFalse(KeySetUtils.getPubKey(mKsms, 2).equals(KeySetUtils.getPubKey(mKsms, 3)));
-        LongSparseArray<ArraySet<Long>> ksMapping = KeySetUtils.getKeySetMapping(mKsms);
-        assertEquals(1, ksMapping.size());
-        ArraySet<Long> mapping = ksMapping.get(2);
-        assertEquals(2, mapping.size());
-        assertTrue(mapping.contains(new Long(2)));
-        assertTrue(mapping.contains(new Long(3)));
-        assertEquals(2, ps.keySetData.getProperSigningKeySet());
-    }
-
-    /* add a defined keyset make sure it shows up */
-    public void testAddDefinedKSToPackageEmpty() throws ReflectiveOperationException {
-
-        /* create PackageSetting and add to Settings mPackages */
-        PackageSetting ps = generateFakePackageSetting("packageA");
-        mPackagesMap.put(ps.name, ps);
-
-        /* collect key and add */
-        ArrayMap<String, ArraySet<PublicKey>> definedKS = new ArrayMap<String, ArraySet<PublicKey>>();
-        ArraySet<PublicKey> keys = new ArraySet<PublicKey>();
-        PublicKey keyA = PackageParser.parsePublicKey(KeySetStrings.ctsKeySetPublicKeyA);
-        keys.add(keyA);
-        definedKS.put("aliasA", keys);
-        mKsms.addDefinedKeySetsToPackageLPw(ps, definedKS);
-
-        assertEquals(1, KeySetUtils.getKeySetRefCount(mKsms, 1));
-        assertEquals(1, KeySetUtils.getPubKeyRefCount(mKsms, 1));
-        assertEquals(keyA, KeySetUtils.getPubKey(mKsms, 1));
-        LongSparseArray<ArraySet<Long>> ksMapping = KeySetUtils.getKeySetMapping(mKsms);
-        assertEquals(1, ksMapping.size());
-        ArraySet<Long> mapping = ksMapping.get(1);
-        assertEquals(1, mapping.size());
-        assertTrue(mapping.contains(new Long(1)));
-        assertNotNull(ps.keySetData.getAliases().get("aliasA"));
-        assertEquals(new Long(1), ps.keySetData.getAliases().get("aliasA"));
-    }
-
-    /* add 2 defined keysets which refer to same keyset and make sure ref-ct is 2 */
-    public void testAddDefinedKSToPackageDoubleAlias() throws ReflectiveOperationException {
-
-        /* create PackageSetting and add to Settings mPackages */
-        PackageSetting ps = generateFakePackageSetting("packageA");
-        mPackagesMap.put(ps.name, ps);
-
-        /* collect key and add */
-        ArrayMap<String, ArraySet<PublicKey>> definedKS = new ArrayMap<String, ArraySet<PublicKey>>();
-        ArraySet<PublicKey> keys = new ArraySet<PublicKey>();
-        PublicKey keyA = PackageParser.parsePublicKey(KeySetStrings.ctsKeySetPublicKeyA);
-        keys.add(keyA);
-        definedKS.put("aliasA", keys);
-        definedKS.put("aliasA2", keys);
-        mKsms.addDefinedKeySetsToPackageLPw(ps, definedKS);
-
-        assertEquals(2, KeySetUtils.getKeySetRefCount(mKsms, 1));
-        assertEquals(1, KeySetUtils.getPubKeyRefCount(mKsms, 1));
-        assertEquals(keyA, KeySetUtils.getPubKey(mKsms, 1));
-        LongSparseArray<ArraySet<Long>> ksMapping = KeySetUtils.getKeySetMapping(mKsms);
-        assertEquals(1, ksMapping.size());
-        ArraySet<Long> mapping = ksMapping.get(1);
-        assertEquals(1, mapping.size());
-        assertTrue(mapping.contains(new Long(1)));
-        assertNotNull(ps.keySetData.getAliases().get("aliasA"));
-        assertEquals(new Long(1), ps.keySetData.getAliases().get("aliasA"));
-        assertNotNull(ps.keySetData.getAliases().get("aliasA2"));
-        assertEquals(new Long(1), ps.keySetData.getAliases().get("aliasA2"));
-    }
-
-    /* upgrd defined keyset ortho (make sure previous is removed for pkg) */
-    public void testAddDefinedKSToPackageOrthoUpgr() throws ReflectiveOperationException {
-
-        /* create PackageSetting and add to Settings mPackages */
-        PackageSetting ps = generateFakePackageSetting("packageA");
-        mPackagesMap.put(ps.name, ps);
-
-        /* collect key and add */
-        ArrayMap<String, ArraySet<PublicKey>> definedKS = new ArrayMap<String, ArraySet<PublicKey>>();
-        ArraySet<PublicKey> keys = new ArraySet<PublicKey>();
-        PublicKey keyA = PackageParser.parsePublicKey(KeySetStrings.ctsKeySetPublicKeyA);
-        keys.add(keyA);
-        definedKS.put("aliasA", keys);
-        mKsms.addDefinedKeySetsToPackageLPw(ps, definedKS);
-
-        /* now upgrade to different defined key-set */
-        keys = new ArraySet<PublicKey>();
-        PublicKey keyB = PackageParser.parsePublicKey(KeySetStrings.ctsKeySetPublicKeyB);
-        keys.add(keyB);
-        definedKS.remove("aliasA");
-        definedKS.put("aliasB", keys);
-        mKsms.addDefinedKeySetsToPackageLPw(ps, definedKS);
-
-        assertEquals(0, KeySetUtils.getKeySetRefCount(mKsms, 1));
-        assertEquals(0, KeySetUtils.getPubKeyRefCount(mKsms, 1));
-        assertEquals(1, KeySetUtils.getKeySetRefCount(mKsms, 2));
-        assertEquals(1, KeySetUtils.getPubKeyRefCount(mKsms, 2));
-        assertEquals(keyB, KeySetUtils.getPubKey(mKsms, 2));
-        LongSparseArray<ArraySet<Long>> ksMapping = KeySetUtils.getKeySetMapping(mKsms);
-        assertEquals(1, ksMapping.size());
-        ArraySet<Long> mapping = ksMapping.get(2);
-        assertEquals(1, mapping.size());
-        assertTrue(mapping.contains(new Long(2)));
-        assertNull(ps.keySetData.getAliases().get("aliasA"));
-        assertNotNull(ps.keySetData.getAliases().get("aliasB"));
-        assertEquals(new Long(2), ps.keySetData.getAliases().get("aliasB"));
-    }
-
-    /* upgrd defined keyset ortho but reuse alias (make sure old is removed and
-     * alias points to new keyset)
-     */
-    public void testAddDefinedKSToPackageOrthoUpgrAliasSame() throws ReflectiveOperationException {
-
-        /* create PackageSetting and add to Settings mPackages */
-        PackageSetting ps = generateFakePackageSetting("packageA");
-        mPackagesMap.put(ps.name, ps);
-
-        /* collect key and add */
-        ArrayMap<String, ArraySet<PublicKey>> definedKS = new ArrayMap<String, ArraySet<PublicKey>>();
-        ArraySet<PublicKey> keys = new ArraySet<PublicKey>();
-        PublicKey keyA = PackageParser.parsePublicKey(KeySetStrings.ctsKeySetPublicKeyA);
-        keys.add(keyA);
-        definedKS.put("aliasA", keys);
-        mKsms.addDefinedKeySetsToPackageLPw(ps, definedKS);
-
-        /* now upgrade to different set w/same alias as before */
-        keys = new ArraySet<PublicKey>();
-        PublicKey keyB = PackageParser.parsePublicKey(KeySetStrings.ctsKeySetPublicKeyB);
-        keys.add(keyB);
-        definedKS.put("aliasA", keys);
-        mKsms.addDefinedKeySetsToPackageLPw(ps, definedKS);
-
-        assertEquals(0, KeySetUtils.getKeySetRefCount(mKsms, 1));
-        assertEquals(0, KeySetUtils.getPubKeyRefCount(mKsms, 1));
-        assertEquals(1, KeySetUtils.getKeySetRefCount(mKsms, 2));
-        assertEquals(1, KeySetUtils.getPubKeyRefCount(mKsms, 2));
-        assertEquals(keyB, KeySetUtils.getPubKey(mKsms, 2));
-        LongSparseArray<ArraySet<Long>> ksMapping = KeySetUtils.getKeySetMapping(mKsms);
-        assertEquals(1, ksMapping.size());
-        ArraySet<Long> mapping = ksMapping.get(2);
-        assertEquals(1, mapping.size());
-        assertTrue(mapping.contains(new Long(2)));
-        assertNotNull(ps.keySetData.getAliases().get("aliasA"));
-        assertEquals(new Long(2), ps.keySetData.getAliases().get("aliasA"));
-    }
-
-     /* Start with defined ks of (A, B) and upgrade to (B, C).  Make sure B is
-      * unchanged. */
-    public void testAddDefinedKSToPackageOverlapUpgr() throws ReflectiveOperationException {
-
-        /* create PackageSetting and add to Settings mPackages */
-        PackageSetting ps = generateFakePackageSetting("packageA");
-        mPackagesMap.put(ps.name, ps);
-
-        /* collect keys A and B and add */
-        ArrayMap<String, ArraySet<PublicKey>> definedKS = new ArrayMap<String, ArraySet<PublicKey>>();
-        ArraySet<PublicKey> keys1 = new ArraySet<PublicKey>();
-        ArraySet<PublicKey> keys2 = new ArraySet<PublicKey>();
-        PublicKey keyA = PackageParser.parsePublicKey(KeySetStrings.ctsKeySetPublicKeyA);
-        PublicKey keyB = PackageParser.parsePublicKey(KeySetStrings.ctsKeySetPublicKeyB);
-        keys1.add(keyA);
-        keys2.add(keyB);
-        definedKS.put("aliasA", keys1);
-        definedKS.put("aliasB", keys2);
-        mKsms.addDefinedKeySetsToPackageLPw(ps, definedKS);
-
-        /* now upgrade to different set (B, C) */
-        keys1 = new ArraySet<PublicKey>();
-        PublicKey keyC = PackageParser.parsePublicKey(KeySetStrings.ctsKeySetPublicKeyC);
-        keys1.add(keyC);
-        definedKS.remove("aliasA");
-        definedKS.put("aliasC", keys1);
-        mKsms.addDefinedKeySetsToPackageLPw(ps, definedKS);
-
-        assertEquals(1, KeySetUtils.getKeySetRefCount(mKsms, 3));
-        assertEquals(1, KeySetUtils.getPubKeyRefCount(mKsms, 3));
-        assertEquals(keyC, KeySetUtils.getPubKey(mKsms, 3));
-        LongSparseArray<ArraySet<Long>> ksMapping = KeySetUtils.getKeySetMapping(mKsms);
-        assertEquals(2, ksMapping.size());
-        ArraySet<Long> mapping = ksMapping.get(3);
-        assertEquals(1, mapping.size());
-        assertTrue(mapping.contains(new Long(3)));
-        assertEquals(new Long(3), ps.keySetData.getAliases().get("aliasC"));
-
-        /* either keyset w/keyA or w/keyB was added first, address both cases */
-        if (1 == KeySetUtils.getKeySetRefCount(mKsms, 1)) {
-
-            /* keyB was added first and should have keyset 1 and pub-key 1 */
-            assertEquals(1, KeySetUtils.getPubKeyRefCount(mKsms, 1));
-            assertEquals(0, KeySetUtils.getKeySetRefCount(mKsms, 2));
-            assertEquals(0, KeySetUtils.getPubKeyRefCount(mKsms, 2));
-            assertEquals(keyB, KeySetUtils.getPubKey(mKsms, 1));
-            mapping = ksMapping.get(1);
-            assertEquals(1, mapping.size());
-            assertTrue(mapping.contains(new Long(1)));
-            assertEquals(new Long(1), ps.keySetData.getAliases().get("aliasB"));
-        } else {
-
-            /* keyA was added first and keyB has id 2 */
-            assertEquals(1, KeySetUtils.getKeySetRefCount(mKsms, 2));
-            assertEquals(1, KeySetUtils.getPubKeyRefCount(mKsms, 2));
-            assertEquals(0, KeySetUtils.getKeySetRefCount(mKsms, 1));
-            assertEquals(0, KeySetUtils.getPubKeyRefCount(mKsms, 1));
-            assertEquals(keyB, KeySetUtils.getPubKey(mKsms, 2));
-            mapping = ksMapping.get(2);
-            assertEquals(1, mapping.size());
-            assertTrue(mapping.contains(new Long(2)));
-            assertEquals(new Long(2), ps.keySetData.getAliases().get("aliasB"));
-        }
-        assertNull(ps.keySetData.getAliases().get("aliasA"));
-    }
-
-    /* add defined keyset, remove it, add again and make sure diff id. */
-    public void testAddDefinedKSToPackageThree() throws ReflectiveOperationException {
-
-        /* create PackageSetting and add to Settings mPackages */
-        PackageSetting ps = generateFakePackageSetting("packageA");
-        mPackagesMap.put(ps.name, ps);
-
-        /* collect key and add */
-        ArrayMap<String, ArraySet<PublicKey>> definedKS = new ArrayMap<String, ArraySet<PublicKey>>();
-        ArraySet<PublicKey> keys1 = new ArraySet<PublicKey>();
-        PublicKey keyA = PackageParser.parsePublicKey(KeySetStrings.ctsKeySetPublicKeyA);
-        keys1.add(keyA);
-        definedKS.put("aliasA", keys1);
-        mKsms.addDefinedKeySetsToPackageLPw(ps, definedKS);
-
-        /* now upgrade to different set */
-        ArraySet<PublicKey> keys2 = new ArraySet<PublicKey>();
-        PublicKey keyB = PackageParser.parsePublicKey(KeySetStrings.ctsKeySetPublicKeyB);
-        keys2.add(keyB);
-        definedKS.remove("aliasA");
-        definedKS.put("aliasB", keys2);
-        mKsms.addDefinedKeySetsToPackageLPw(ps, definedKS);
-
-        /* upgrade back to original */
-        definedKS.remove("aliasB");
-        definedKS.put("aliasA", keys1);
-        mKsms.addDefinedKeySetsToPackageLPw(ps, definedKS);
-
-        assertEquals(0, KeySetUtils.getKeySetRefCount(mKsms, 1));
-        assertEquals(0, KeySetUtils.getKeySetRefCount(mKsms, 2));
-        assertEquals(1, KeySetUtils.getKeySetRefCount(mKsms, 3));
-        assertEquals(0, KeySetUtils.getPubKeyRefCount(mKsms, 1));
-        assertEquals(0, KeySetUtils.getPubKeyRefCount(mKsms, 2));
-        assertEquals(1, KeySetUtils.getPubKeyRefCount(mKsms, 3));
-        assertEquals(keyA, KeySetUtils.getPubKey(mKsms, 3));
-        LongSparseArray<ArraySet<Long>> ksMapping = KeySetUtils.getKeySetMapping(mKsms);
-        assertEquals(1, ksMapping.size());
-        ArraySet<Long> mapping = ksMapping.get(3);
-        assertEquals(1, mapping.size());
-        assertTrue(mapping.contains(new Long(3)));
-        assertEquals(new Long(3), ps.keySetData.getAliases().get("aliasA"));
-    }
-
-    /* add upgrade keyset for existing defined keyset and check that it is recorded */
-    public void testAddUpgradeKSToPackageEmpty() {
-
-        /* create PackageSetting and add to Settings mPackages */
-        PackageSetting ps = generateFakePackageSetting("packageA");
-        mPackagesMap.put(ps.name, ps);
-
-        /* collect key and add, and denote as an upgrade keyset */
-        ArrayMap<String, ArraySet<PublicKey>> definedKS = new ArrayMap<String, ArraySet<PublicKey>>();
-        ArraySet<PublicKey> keys = new ArraySet<PublicKey>();
-        PublicKey keyA = PackageParser.parsePublicKey(KeySetStrings.ctsKeySetPublicKeyA);
-        keys.add(keyA);
-        definedKS.put("aliasA", keys);
-        mKsms.addDefinedKeySetsToPackageLPw(ps, definedKS);
-        ArraySet<String> upgradeKS = new ArraySet<String>();
-        upgradeKS.add("aliasA");
-        mKsms.addUpgradeKeySetsToPackageLPw(ps, upgradeKS);
-
-        assertEquals(1, ps.keySetData.getUpgradeKeySets().length);
-        assertEquals(1, ps.keySetData.getUpgradeKeySets()[0]);
-    }
-
-    /* add upgrade keyset for non-existing defined and check that it compains */
-    public void testAddUpgradeKSToPackageWrong() {
-
-        /* create PackageSetting and add to Settings mPackages */
-        PackageSetting ps = generateFakePackageSetting("packageA");
-        mPackagesMap.put(ps.name, ps);
-
-        /* collect key and add and try to specify bogus upgrade keyset */
-        ArrayMap<String, ArraySet<PublicKey>> definedKS = new ArrayMap<String, ArraySet<PublicKey>>();
-        ArraySet<PublicKey> keys = new ArraySet<PublicKey>();
-        PublicKey keyA = PackageParser.parsePublicKey(KeySetStrings.ctsKeySetPublicKeyA);
-        keys.add(keyA);
-        definedKS.put("aliasA", keys);
-        mKsms.addDefinedKeySetsToPackageLPw(ps, definedKS);
-        ArraySet<String> upgradeKS = new ArraySet<String>();
-        upgradeKS.add("aliasB");
-        try {
-            mKsms.addUpgradeKeySetsToPackageLPw(ps, upgradeKS);
-        } catch (IllegalArgumentException e) {
-
-            /* should have been caught in packagemanager, so exception thrown */
-            return;
-        }
-        fail("Expected IllegalArgumentException when adding undefined upgrade keyset!!");
-    }
-
-    /* upgrade from defined keysets w/upgrade to different defined keysets and
-     * make sure the previously specified upgrade keyset has been removed. */
-    public void testAddUpgradeKSToPackageDisappear() {
-
-        /* create PackageSetting and add to Settings mPackages */
-        PackageSetting ps = generateFakePackageSetting("packageA");
-        mPackagesMap.put(ps.name, ps);
-
-        /* collect key and add */
-        ArrayMap<String, ArraySet<PublicKey>> definedKS = new ArrayMap<String, ArraySet<PublicKey>>();
-        ArraySet<PublicKey> keys = new ArraySet<PublicKey>();
-        PublicKey keyA = PackageParser.parsePublicKey(KeySetStrings.ctsKeySetPublicKeyA);
-        keys.add(keyA);
-        definedKS.put("aliasA", keys);
-        mKsms.addDefinedKeySetsToPackageLPw(ps, definedKS);
-        ArraySet<String> upgradeKS = new ArraySet<String>();
-        upgradeKS.add("aliasA");
-        mKsms.addUpgradeKeySetsToPackageLPw(ps, upgradeKS);
-
-        keys = new ArraySet<PublicKey>();
-        PublicKey keyB = PackageParser.parsePublicKey(KeySetStrings.ctsKeySetPublicKeyB);
-        keys.add(keyB);
-        definedKS.remove("aliasA");
-        definedKS.put("aliasB", keys);
-        mKsms.addDefinedKeySetsToPackageLPw(ps, definedKS);
-        assertNull(ps.keySetData.getUpgradeKeySets());
-    }
-
-    /* remove package and validate that keyset and public keys are removed */
-    public void testRemoveAppKSDataUnique() throws ReflectiveOperationException {
-
-        /* create PackageSetting and add to Settings mPackages */
-        PackageSetting ps = generateFakePackageSetting("packageA");
-        mPackagesMap.put(ps.name, ps);
-
-        /* collect signing key and add */
-        ArraySet<PublicKey> signingKeys = new ArraySet<PublicKey>();
-        PublicKey keyA = PackageParser.parsePublicKey(KeySetStrings.ctsKeySetPublicKeyA);
-        signingKeys.add(keyA);
-        mKsms.addSigningKeySetToPackageLPw(ps, signingKeys);
-
-        /* remove its references */
-        mKsms.removeAppKeySetDataLPw(ps.name);
-        assertEquals(0, KeySetUtils.getKeySetRefCount(mKsms, 1));
-        assertEquals(0, KeySetUtils.getPubKeyRefCount(mKsms, 1));
-        LongSparseArray<ArraySet<Long>> ksMapping = KeySetUtils.getKeySetMapping(mKsms);
-        assertEquals(0, ksMapping.size());
-        assertEquals(PackageKeySetData.KEYSET_UNASSIGNED, ps.keySetData.getProperSigningKeySet());
-    }
-
-    /* remove package and validate that keysets remain if defined elsewhere but
-     * have refcounts decreased. */
-    public void testRemoveAppKSDataDup() throws ReflectiveOperationException {
-
-        /* create PackageSettings and add to Settings mPackages */
-        PackageSetting ps1 = generateFakePackageSetting("packageA");
-        mPackagesMap.put(ps1.name, ps1);
-        PackageSetting ps2 = generateFakePackageSetting("packageB");
-        mPackagesMap.put(ps2.name, ps2);
-
-        /* collect signing key and add for both packages */
-        ArraySet<PublicKey> signingKeys = new ArraySet<PublicKey>();
-        PublicKey keyA = PackageParser.parsePublicKey(KeySetStrings.ctsKeySetPublicKeyA);
-        signingKeys.add(keyA);
-        mKsms.addSigningKeySetToPackageLPw(ps1, signingKeys);
-        mKsms.addSigningKeySetToPackageLPw(ps2, signingKeys);
-
-        /* remove references from first package */
-        mKsms.removeAppKeySetDataLPw(ps1.name);
-
-        assertEquals(1, KeySetUtils.getKeySetRefCount(mKsms, 1));
-        assertEquals(1, KeySetUtils.getPubKeyRefCount(mKsms, 1));
-        LongSparseArray<ArraySet<Long>> ksMapping = KeySetUtils.getKeySetMapping(mKsms);
-        assertEquals(1, ksMapping.size());
-        assertEquals(PackageKeySetData.KEYSET_UNASSIGNED, ps1.keySetData.getProperSigningKeySet());
-        assertEquals(1, ps2.keySetData.getProperSigningKeySet());
-    }
-
-    /* remove package which used defined and upgrade keysets and ensure  removed */
-    public void testRemoveAppKSDataDefined() throws ReflectiveOperationException {
-
-        /* create PackageSetting and add to Settings mPackages */
-        PackageSetting ps = generateFakePackageSetting("packageA");
-        mPackagesMap.put(ps.name, ps);
-
-        /* collect key and add */
-        ArrayMap<String, ArraySet<PublicKey>> definedKS = new ArrayMap<String, ArraySet<PublicKey>>();
-        ArraySet<PublicKey> keys = new ArraySet<PublicKey>();
-        PublicKey keyA = PackageParser.parsePublicKey(KeySetStrings.ctsKeySetPublicKeyA);
-        keys.add(keyA);
-
-        /* removal requires signing keyset to be specified (since all apps are
-         * assumed to have it).  We skipped this in the defined tests, but can't
-         * here. */
-        mKsms.addSigningKeySetToPackageLPw(ps, keys);
-
-        definedKS.put("aliasA", keys);
-        mKsms.addDefinedKeySetsToPackageLPw(ps, definedKS);
-        ArraySet<String> upgradeKS = new ArraySet<String>();
-        upgradeKS.add("aliasA");
-        mKsms.addUpgradeKeySetsToPackageLPw(ps, upgradeKS);
-        mKsms.removeAppKeySetDataLPw(ps.name);
-
-        assertEquals(0, KeySetUtils.getKeySetRefCount(mKsms, 1));
-        assertEquals(0, KeySetUtils.getPubKeyRefCount(mKsms, 1));
-        LongSparseArray<ArraySet<Long>> ksMapping = KeySetUtils.getKeySetMapping(mKsms);
-        assertEquals(0, ksMapping.size());
-        assertEquals(PackageKeySetData.KEYSET_UNASSIGNED, ps.keySetData.getProperSigningKeySet());
-        assertEquals(0, ps.keySetData.getAliases().size());
-        assertNull(ps.keySetData.getUpgradeKeySets());
-    }
-}
diff --git a/services/tests/servicestests/src/com/android/server/pm/KeySetStrings.java b/services/tests/servicestests/src/com/android/server/pm/KeySetStrings.java
deleted file mode 100644
index 89d01ae3cd9..00000000000
--- a/services/tests/servicestests/src/com/android/server/pm/KeySetStrings.java
+++ /dev/null
@@ -1,137 +0,0 @@
-/*
- * Copyright (C) 2015 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.android.server.pm;
-
-public class KeySetStrings {
-
-    /*
-     * public keys taken from:
-     * openssl x509 -in cts-keyset-test-${N}.x509.pem -inform PEM -pubkey
-     * in /platform/cts/hostsidetests/appsecurity/certs/keysets
-     */
-    public static final String ctsKeySetPublicKeyA =
-            "MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAwf5zJblvYSB7Ym7or/7Ggg"
-            + "AAu7mp7RrykPJsXhod8doFhVT5s7eF3A4MCE55vvANP7HvwMw2b+T6qx7Pq0VJtb"
-            + "bSDtlBHBtIc47Pjq0CsDg590BUcgKp7PdJ9J6UVgtzDnV6cGEpXmSag3sY+lqiW0"
-            + "4ytPhCVwzYTWGdYe9+TIl47cBrveRfLOlGrcuFQe+zCTmDFqzBKCRHK9b7l5PDWv"
-            + "XXyg65Uu/MBUA/TZWO0fEqOlxZG/nn6DUKQLhPdmJRXWJ3WqMNMhJGD+nKtkmdX7"
-            + "03xRqmg4h+6g0S7M9Y3IQ2NUGyw05AYzCguHB/Mv6uVIiW659wpbyb45TgKG3UhQ"
-            + "IDAQAB";
-
-    public static final String ctsKeySetPublicKeyB =
-            "MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAoeFZqMqTbZiozFTXMkXtSK"
-            + "JRzn2qODZgvVXAAwKTi50xYcbPcHTfKxtif8+q7OCp/50JYDH32bg6wkUunn5+dE"
-            + "aHkxZY8d7uw46tQtl5dNGi+6cc4MezVLCS6nkqNDusAgdvgLU6Fl6SGi02KTp1vk"
-            + "t6CwLO977YJP7kt9ouDRTG7ASJiq3OyRRoOqYHhD9gpsbUq4w+1bXGfuuZujA1dX"
-            + "yovXtvrHUGOdFIEBYOVYGfCcwh3lXPmjNJMlHtKQkurq8/LH7a1B5ocoXCGsyR8Y"
-            + "HdlWfrqRAfzgOB1KCnNNmWqskU9LOci3uQn9IDeMEFmAd8FqF8SwV+4Ludk/xWGQ"
-            + "IDAQAB";
-
-    public static final String ctsKeySetPublicKeyC =
-            "MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEArwIJ/p9zZ6pGe7h1lBJULE"
-            + "5lbYbC3mh5G43OsJ+B0CebN4KzEKyVg+wmkuGSvG2xXUp1BlbipSjnTJ5bUt2iBu"
-            + "wB81Lvumg9GOfCpTBGtfE4a4igtfo7e2U8IbRzEYbhaZlBEmC1BDUvdTFdMRGZPu"
-            + "hUcMkwit4RpHkL6rttuOfaeoJwsgEjbELyzgcm+1Z49Den/JmmXNGMw1/QMibBFG"
-            + "vGkhu2rHg/SYiKpupclU4FIeALcOSnPkrrY6LuSATHDnYvuvK3Vhu0EBKID+rAv5"
-            + "j6BNvnu25SAf3GgS7PLuyVlhiE5p3hTevXn5g/7tjJlXa0FsbMlnFf53WyP9pRWw"
-            + "IDAQAB";
-
-    /*
-     * certs taken from packagemanager packages.xml output corresponding to certs in
-     * /platform/cts/hostsidetests/appsecurity/certs/keysets
-     */
-    public static final String ctsKeySetCertA =
-            "3082030b308201f3a0030201020209009d76e8a600170813300d06092a864886f7"
-            + "0d0101050500301c311a301806035504030c116374732d6b65797365742d7465"
-            + "73742d61301e170d3134303931313030343434385a170d343230313237303034"
-            + "3434385a301c311a301806035504030c116374732d6b65797365742d74657374"
-            + "2d6130820122300d06092a864886f70d01010105000382010f003082010a0282"
-            + "010100c1fe7325b96f61207b626ee8affec6820000bbb9a9ed1af290f26c5e1a"
-            + "1df1da058554f9b3b785dc0e0c084e79bef00d3fb1efc0cc366fe4faab1ecfab"
-            + "4549b5b6d20ed9411c1b48738ecf8ead02b03839f740547202a9ecf749f49e94"
-            + "560b730e757a7061295e649a837b18fa5aa25b4e32b4f842570cd84d619d61ef"
-            + "7e4c8978edc06bbde45f2ce946adcb8541efb309398316acc12824472bd6fb97"
-            + "93c35af5d7ca0eb952efcc05403f4d958ed1f12a3a5c591bf9e7e8350a40b84f"
-            + "7662515d62775aa30d3212460fe9cab6499d5fbd37c51aa683887eea0d12eccf"
-            + "58dc84363541b2c34e406330a0b8707f32feae548896eb9f70a5bc9be394e028"
-            + "6dd4850203010001a350304e301d0603551d0e04160414debf602e08b7573bce"
-            + "4816ac32eab215fb052892301f0603551d23041830168014debf602e08b7573b"
-            + "ce4816ac32eab215fb052892300c0603551d13040530030101ff300d06092a86"
-            + "4886f70d0101050500038201010092f1b8d08252d808d3051dce80780bd27eef"
-            + "e3f6b6d935398afb448209461b6f8b352e830d4358661e1b3e9eb9ab3937bddd"
-            + "581a28f533da1ebeb6838ce4a84ca64c43507c5ef9528917857e4d1c4c5996cf"
-            + "6b3d30823db514a715eeee709d69e38b4f0ef5dce4b08ce40fd52b39ac651311"
-            + "b6d1814913d922ce84748b6999256851fb583a49e35cecf79a527108df8e062d"
-            + "f4831addbb12a661999d41849e2545150cab74c91447dd15e55cdf3f8082dcab"
-            + "667c5cee3350d0f15d3970edcf3e81882e80985b0c0bf9917adb55c634de3a92"
-            + "e8fb5d9413b1703bec116b9ee9346b658f394acfe0c60406718be80b7110df8b"
-            + "44c984f001e1d16aac3831afee18";
-
-    public static final String ctsKeySetCertB =
-            "3082030b308201f3a003020102020900e670a5b2ec1e8a12300d06092a864886f7"
-            + "0d0101050500301c311a301806035504030c116374732d6b65797365742d7465"
-            + "73742d62301e170d3134303931313030343434315a170d343230313237303034"
-            + "3434315a301c311a301806035504030c116374732d6b65797365742d74657374"
-            + "2d6230820122300d06092a864886f70d01010105000382010f003082010a0282"
-            + "010100a1e159a8ca936d98a8cc54d73245ed48a251ce7daa383660bd55c00302"
-            + "938b9d3161c6cf7074df2b1b627fcfaaece0a9ff9d096031f7d9b83ac2452e9e"
-            + "7e7e744687931658f1deeec38ead42d97974d1a2fba71ce0c7b354b092ea792a"
-            + "343bac02076f80b53a165e921a2d36293a75be4b7a0b02cef7bed824fee4b7da"
-            + "2e0d14c6ec04898aadcec914683aa607843f60a6c6d4ab8c3ed5b5c67eeb99ba"
-            + "3035757ca8bd7b6fac750639d14810160e55819f09cc21de55cf9a33493251ed"
-            + "29092eaeaf3f2c7edad41e687285c21acc91f181dd9567eba9101fce0381d4a0"
-            + "a734d996aac914f4b39c8b7b909fd20378c10598077c16a17c4b057ee0bb9d93"
-            + "fc56190203010001a350304e301d0603551d0e04160414ccd4d9d47dcc18889d"
-            + "cba32de37e6570c88f8109301f0603551d23041830168014ccd4d9d47dcc1888"
-            + "9dcba32de37e6570c88f8109300c0603551d13040530030101ff300d06092a86"
-            + "4886f70d0101050500038201010061951cf9c9a629b30b560d53d62a72796edc"
-            + "97b0b210b567859311b14574abb052ef08cabb0b18cef5517597eabee9498a07"
-            + "a04472b8e6eee8668c05d2ff28141a36351593551f0c9d27feb4367fd0d23c76"
-            + "e36035f9d06d2d24b4167120fabdcfddfbe872bd127a602de8563ad6027ee19a"
-            + "fc21065cf02d6aaf97bf78388c3c129e72d1b31f5727896aaad7fe6773fbc285"
-            + "34e89194a75e1ecf64bcc5fa228e71e3be9efc78cb39bbabf60e334b403fc3e4"
-            + "9eb59c3407883d10efb04470a7d7d12114e7c9ddc3b381ffc43e8e8a830efa59"
-            + "38e47eef0d4dd39a80186c3b4236f812f52775941fe1dd73d51f6f50ab0916e3"
-            + "149c31feabcf38860be45d113a54";
-
-    public static final String ctsKeySetCertC =
-            "3082030b308201f3a0030201020209008f2e824e4e17810d300d06092a864886f7"
-            + "0d0101050500301c311a301806035504030c116374732d6b65797365742d7465"
-            + "73742d63301e170d3134303931313030343432325a170d343230313237303034"
-            + "3432325a301c311a301806035504030c116374732d6b65797365742d74657374"
-            + "2d6330820122300d06092a864886f70d01010105000382010f003082010a0282"
-            + "010100af0209fe9f7367aa467bb8759412542c4e656d86c2de68791b8dceb09f"
-            + "81d0279b3782b310ac9583ec2692e192bc6db15d4a750656e2a528e74c9e5b52"
-            + "dda206ec01f352efba683d18e7c2a53046b5f1386b88a0b5fa3b7b653c21b473"
-            + "1186e16999411260b504352f75315d3111993ee85470c9308ade11a4790beabb"
-            + "6db8e7da7a8270b201236c42f2ce0726fb5678f437a7fc99a65cd18cc35fd032"
-            + "26c1146bc6921bb6ac783f49888aa6ea5c954e0521e00b70e4a73e4aeb63a2ee"
-            + "4804c70e762fbaf2b7561bb41012880feac0bf98fa04dbe7bb6e5201fdc6812e"
-            + "cf2eec95961884e69de14debd79f983feed8c99576b416c6cc96715fe775b23f"
-            + "da515b0203010001a350304e301d0603551d0e041604141b8137c73974a17633"
-            + "686f93798a7f7b8385bded301f0603551d230418301680141b8137c73974a176"
-            + "33686f93798a7f7b8385bded300c0603551d13040530030101ff300d06092a86"
-            + "4886f70d01010505000382010100276ce2ca7b78b12aa2e432c8287075af91e5"
-            + "2a15a8586e23cdd7524a4c5ae04156307e95275cdfd841f2d28c0583cb36779e"
-            + "25d849a8b608eb48a84a50202a7825c7847e865409b1dd01303b5b1bdfafecab"
-            + "bfe1c6ec5f30ce1cb16b93db72ef726f77a48ca4f5ac5e12c4ad08c6df6fbf7e"
-            + "1548ef7ca80cf1d98abb550c0e28b246e8c0f1a975ffb624f1a4aeec11f01ba6"
-            + "02631d56645f5ae042dbf67b444b160711ca2629c456c5cc12e2ff56fa1332b6"
-            + "92483d14d2e6fb8e026246058fb5826e3958ee8f780d0fc2b840d51c2bbf0d24"
-            + "e9e108ef1c2d9ec13797bb4e5793349628a2ddb2a79c9d9c5736e7aea93e4552"
-            + "18fd162e0a42a4fbb4aa9df82b8a";
-}
diff --git a/services/tests/servicestests/src/com/android/server/pm/KeySetUtils.java b/services/tests/servicestests/src/com/android/server/pm/KeySetUtils.java
deleted file mode 100644
index 9e1a366c8fc..00000000000
--- a/services/tests/servicestests/src/com/android/server/pm/KeySetUtils.java
+++ /dev/null
@@ -1,89 +0,0 @@
-/*
- * Copyright (C) 2015 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.android.server.pm;
-
-import android.util.ArraySet;
-import android.util.LongSparseArray;
-
-import java.lang.reflect.Field;
-import java.security.PublicKey;
-
-public class KeySetUtils {
-
-    public static PublicKey getPubKey(KeySetManagerService ksms, long pkId)
-            throws NoSuchFieldException, IllegalAccessException {
-        Field pkField = ksms.getClass().getDeclaredField("mPublicKeys");
-        pkField.setAccessible(true);
-        LongSparseArray<KeySetManagerService.PublicKeyHandle> mPublicKeys =
-            (LongSparseArray<KeySetManagerService.PublicKeyHandle>) pkField.get(ksms);
-        KeySetManagerService.PublicKeyHandle pkh = mPublicKeys.get(pkId);
-        if (pkh == null) {
-            return null;
-        } else {
-            return pkh.getKey();
-        }
-    }
-
-    public static int getPubKeyRefCount(KeySetManagerService ksms, long pkId)
-            throws NoSuchFieldException, IllegalAccessException {
-        Field pkField = ksms.getClass().getDeclaredField("mPublicKeys");
-        pkField.setAccessible(true);
-        LongSparseArray<KeySetManagerService.PublicKeyHandle> mPublicKeys =
-            (LongSparseArray<KeySetManagerService.PublicKeyHandle>) pkField.get(ksms);
-        KeySetManagerService.PublicKeyHandle pkh = mPublicKeys.get(pkId);
-        if (pkh == null) {
-            return 0;
-        } else {
-            return pkh.getRefCountLPr();
-        }
-    }
-
-    public static int getKeySetRefCount(KeySetManagerService ksms, long keysetId)
-            throws NoSuchFieldException, IllegalAccessException {
-        Field ksField = ksms.getClass().getDeclaredField("mKeySets");
-        ksField.setAccessible(true);
-        LongSparseArray<KeySetHandle> mKeySets =
-            (LongSparseArray<KeySetHandle>) ksField.get(ksms);
-        KeySetHandle ksh = mKeySets.get(keysetId);
-        if (ksh == null) {
-            return 0;
-        } else {
-            return ksh.getRefCountLPr();
-        }
-    }
-
-    public static LongSparseArray<ArraySet<Long>> getKeySetMapping(KeySetManagerService ksms)
-            throws NoSuchFieldException, IllegalAccessException {
-        Field ksField = ksms.getClass().getDeclaredField("mKeySetMapping");
-        ksField.setAccessible(true);
-        return (LongSparseArray<ArraySet<Long>>) ksField.get(ksms);
-    }
-
-    public static Long getLastIssuedKeyId(KeySetManagerService ksms)
-            throws NoSuchFieldException, IllegalAccessException {
-        Field ksField = ksms.getClass().getDeclaredField("lastIssuedKeyId");
-        ksField.setAccessible(true);
-        return (Long) ksField.get(ksms);
-    }
-
-    public static Long getLastIssuedKeySetId(KeySetManagerService ksms)
-            throws NoSuchFieldException, IllegalAccessException {
-        Field ksField = ksms.getClass().getDeclaredField("lastIssuedKeySetId");
-        ksField.setAccessible(true);
-        return (Long) ksField.get(ksms);
-    }
-}
diff --git a/services/tests/servicestests/src/com/android/server/pm/PackageManagerSettingsTests.java b/services/tests/servicestests/src/com/android/server/pm/PackageManagerSettingsTests.java
deleted file mode 100644
index bf6343f9c23..00000000000
--- a/services/tests/servicestests/src/com/android/server/pm/PackageManagerSettingsTests.java
+++ /dev/null
@@ -1,349 +0,0 @@
-/*
- * Copyright (C) 2012 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.android.server.pm;
-
-import static android.content.pm.PackageManager.COMPONENT_ENABLED_STATE_DEFAULT;
-import static android.content.pm.PackageManager.COMPONENT_ENABLED_STATE_DISABLED;
-import static android.content.pm.PackageManager.COMPONENT_ENABLED_STATE_DISABLED_USER;
-import static android.content.pm.PackageManager.COMPONENT_ENABLED_STATE_ENABLED;
-
-import android.annotation.NonNull;
-import android.content.Context;
-import android.content.pm.PackageParser;
-import android.content.pm.UserInfo;
-import android.os.UserHandle;
-import android.test.AndroidTestCase;
-import android.util.ArrayMap;
-import android.util.ArraySet;
-import android.util.Log;
-import android.util.LongSparseArray;
-
-import com.android.internal.os.AtomicFile;
-
-import java.lang.reflect.Constructor;
-import java.io.File;
-import java.io.FileOutputStream;
-import java.io.IOException;
-import java.security.PublicKey;
-import java.util.ArrayList;
-import java.util.List;
-
-public class PackageManagerSettingsTests extends AndroidTestCase {
-    private static final String PACKAGE_NAME_2 = "com.google.app2";
-    private static final String PACKAGE_NAME_3 = "com.android.app3";
-    private static final String PACKAGE_NAME_1 = "com.google.app1";
-    private static final boolean localLOGV = true;
-    public static final String TAG = "PackageManagerSettingsTests";
-    protected final String PREFIX = "android.content.pm";
-
-    private @NonNull List<UserInfo> createFakeUsers() {
-        ArrayList<UserInfo> users = new ArrayList<>();
-        users.add(new UserInfo(UserHandle.USER_SYSTEM, "test user", UserInfo.FLAG_INITIALIZED));
-        return users;
-    }
-
-    private void writeFile(File file, byte[] data) {
-        file.mkdirs();
-        try {
-            AtomicFile aFile = new AtomicFile(file);
-            FileOutputStream fos = aFile.startWrite();
-            fos.write(data);
-            aFile.finishWrite(fos);
-        } catch (IOException ioe) {
-            Log.e(TAG, "Cannot write file " + file.getPath());
-        }
-    }
-
-    private void writePackagesXml() {
-        writeFile(new File(getContext().getFilesDir(), "system/packages.xml"),
-                ("<?xml version='1.0' encoding='utf-8' standalone='yes' ?>"
-                + "<packages>"
-                + "<last-platform-version internal=\"15\" external=\"0\" fingerprint=\"foo\" />"
-                + "<permission-trees>"
-                + "<item name=\"com.google.android.permtree\" package=\"com.google.android.permpackage\" />"
-                + "</permission-trees>"
-                + "<permissions>"
-                + "<item name=\"android.permission.WRITE_CALL_LOG\" package=\"android\" protection=\"1\" />"
-                + "<item name=\"android.permission.ASEC_ACCESS\" package=\"android\" protection=\"2\" />"
-                + "<item name=\"android.permission.ACCESS_WIMAX_STATE\" package=\"android\" />"
-                + "<item name=\"android.permission.REBOOT\" package=\"android\" protection=\"18\" />"
-                + "</permissions>"
-                + "<package name=\"com.google.app1\" codePath=\"/system/app/app1.apk\" nativeLibraryPath=\"/data/data/com.google.app1/lib\" flags=\"1\" ft=\"1360e2caa70\" it=\"135f2f80d08\" ut=\"1360e2caa70\" version=\"1109\" sharedUserId=\"11000\">"
-                + "<sigs count=\"1\">"
-                + "<cert index=\"0\" key=\"" + KeySetStrings.ctsKeySetCertA + "\" />"
-                + "</sigs>"
-                + "<proper-signing-keyset identifier=\"1\" />"
-                + "</package>"
-                + "<package name=\"com.google.app2\" codePath=\"/system/app/app2.apk\" nativeLibraryPath=\"/data/data/com.google.app2/lib\" flags=\"1\" ft=\"1360e578718\" it=\"135f2f80d08\" ut=\"1360e578718\" version=\"15\" enabled=\"3\" userId=\"11001\">"
-                + "<sigs count=\"1\">"
-                + "<cert index=\"0\" />"
-                + "</sigs>"
-                + "<proper-signing-keyset identifier=\"1\" />"
-                + "<defined-keyset alias=\"AB\" identifier=\"4\" />"
-                + "</package>"
-                + "<package name=\"com.android.app3\" codePath=\"/system/app/app3.apk\" nativeLibraryPath=\"/data/data/com.android.app3/lib\" flags=\"1\" ft=\"1360e577b60\" it=\"135f2f80d08\" ut=\"1360e577b60\" version=\"15\" userId=\"11030\">"
-                + "<sigs count=\"1\">"
-                + "<cert index=\"1\" key=\"" + KeySetStrings.ctsKeySetCertB + "\" />"
-                + "</sigs>"
-                + "<proper-signing-keyset identifier=\"2\" />"
-                + "<upgrade-keyset identifier=\"3\" />"
-                + "<defined-keyset alias=\"C\" identifier=\"3\" />"
-                + "</package>"
-                + "<shared-user name=\"com.android.shared1\" userId=\"11000\">"
-                + "<sigs count=\"1\">"
-                + "<cert index=\"1\" />"
-                + "</sigs>"
-                + "<perms>"
-                + "<item name=\"android.permission.REBOOT\" />"
-                + "</perms>"
-                + "</shared-user>"
-                + "<keyset-settings version=\"1\">"
-                + "<keys>"
-                + "<public-key identifier=\"1\" value=\"" + KeySetStrings.ctsKeySetPublicKeyA + "\" />"
-                + "<public-key identifier=\"2\" value=\"" + KeySetStrings.ctsKeySetPublicKeyB + "\" />"
-                + "<public-key identifier=\"3\" value=\"" + KeySetStrings.ctsKeySetPublicKeyC + "\" />"
-                + "</keys>"
-                + "<keysets>"
-                + "<keyset identifier=\"1\">"
-                + "<key-id identifier=\"1\" />"
-                + "</keyset>"
-                + "<keyset identifier=\"2\">"
-                + "<key-id identifier=\"2\" />"
-                + "</keyset>"
-                + "<keyset identifier=\"3\">"
-                + "<key-id identifier=\"3\" />"
-                + "</keyset>"
-                + "<keyset identifier=\"4\">"
-                + "<key-id identifier=\"1\" />"
-                + "<key-id identifier=\"2\" />"
-                + "</keyset>"
-                + "</keysets>"
-                + "<lastIssuedKeyId value=\"3\" />"
-                + "<lastIssuedKeySetId value=\"4\" />"
-                + "</keyset-settings>"
-                + "</packages>").getBytes());
-    }
-
-    private void writeStoppedPackagesXml() {
-        writeFile(new File(getContext().getFilesDir(), "system/packages-stopped.xml"),
-                ( "<?xml version='1.0' encoding='utf-8' standalone='yes' ?>"
-                + "<stopped-packages>"
-                + "<pkg name=\"com.google.app1\" nl=\"1\" />"
-                + "<pkg name=\"com.android.app3\" nl=\"1\" />"
-                + "</stopped-packages>")
-                .getBytes());
-    }
-
-    private void writePackagesList() {
-        writeFile(new File(getContext().getFilesDir(), "system/packages.list"),
-                ( "com.google.app1 11000 0 /data/data/com.google.app1 seinfo1"
-                + "com.google.app2 11001 0 /data/data/com.google.app2 seinfo2"
-                + "com.android.app3 11030 0 /data/data/com.android.app3 seinfo3")
-                .getBytes());
-    }
-
-    private void deleteSystemFolder() {
-        File systemFolder = new File(getContext().getFilesDir(), "system");
-        deleteFolder(systemFolder);
-    }
-
-    private static void deleteFolder(File folder) {
-        File[] files = folder.listFiles();
-        if (files != null) {
-            for (File file : files) {
-                deleteFolder(file);
-            }
-        }
-        folder.delete();
-    }
-
-    private void writeOldFiles() {
-        deleteSystemFolder();
-        writePackagesXml();
-        writeStoppedPackagesXml();
-        writePackagesList();
-    }
-
-    private void createUserManagerServiceRef() throws ReflectiveOperationException {
-        Constructor<UserManagerService> umsc =
-                UserManagerService.class.getDeclaredConstructor(
-                        Context.class,
-                        PackageManagerService.class,
-                        Object.class,
-                        Object.class,
-                        File.class,
-                        File.class);
-        umsc.setAccessible(true);
-        UserManagerService ums = umsc.newInstance(getContext(), null,
-                new Object(), new Object(), getContext().getFilesDir(),
-                new File(getContext().getFilesDir(), "user"));
-    }
-
-    private void verifyKeySetMetaData(Settings settings)
-            throws ReflectiveOperationException, IllegalAccessException {
-        ArrayMap<String, PackageSetting> packages = settings.mPackages;
-        KeySetManagerService ksms = settings.mKeySetManagerService;
-
-        /* verify keyset and public key ref counts */
-        assertEquals(2, KeySetUtils.getKeySetRefCount(ksms, 1));
-        assertEquals(1, KeySetUtils.getKeySetRefCount(ksms, 2));
-        assertEquals(1, KeySetUtils.getKeySetRefCount(ksms, 3));
-        assertEquals(1, KeySetUtils.getKeySetRefCount(ksms, 4));
-        assertEquals(2, KeySetUtils.getPubKeyRefCount(ksms, 1));
-        assertEquals(2, KeySetUtils.getPubKeyRefCount(ksms, 2));
-        assertEquals(1, KeySetUtils.getPubKeyRefCount(ksms, 3));
-
-        /* verify public keys properly read */
-        PublicKey keyA = PackageParser.parsePublicKey(KeySetStrings.ctsKeySetPublicKeyA);
-        PublicKey keyB = PackageParser.parsePublicKey(KeySetStrings.ctsKeySetPublicKeyB);
-        PublicKey keyC = PackageParser.parsePublicKey(KeySetStrings.ctsKeySetPublicKeyC);
-        assertEquals(keyA, KeySetUtils.getPubKey(ksms, 1));
-        assertEquals(keyB, KeySetUtils.getPubKey(ksms, 2));
-        assertEquals(keyC, KeySetUtils.getPubKey(ksms, 3));
-
-        /* verify mapping is correct (ks -> pub keys) */
-        LongSparseArray<ArraySet<Long>> ksMapping = KeySetUtils.getKeySetMapping(ksms);
-        ArraySet<Long> mapping = ksMapping.get(1);
-        assertEquals(1, mapping.size());
-        assertTrue(mapping.contains(new Long(1)));
-        mapping = ksMapping.get(2);
-        assertEquals(1, mapping.size());
-        assertTrue(mapping.contains(new Long(2)));
-        mapping = ksMapping.get(3);
-        assertEquals(1, mapping.size());
-        assertTrue(mapping.contains(new Long(3)));
-        mapping = ksMapping.get(4);
-        assertEquals(2, mapping.size());
-        assertTrue(mapping.contains(new Long(1)));
-        assertTrue(mapping.contains(new Long(2)));
-
-        /* verify lastIssuedIds are consistent */
-        assertEquals(new Long(3), KeySetUtils.getLastIssuedKeyId(ksms));
-        assertEquals(new Long(4), KeySetUtils.getLastIssuedKeySetId(ksms));
-
-        /* verify packages have been given the appropriat information */
-        PackageSetting ps = packages.get("com.google.app1");
-        assertEquals(1, ps.keySetData.getProperSigningKeySet());
-        ps = packages.get("com.google.app2");
-        assertEquals(1, ps.keySetData.getProperSigningKeySet());
-        assertEquals(new Long(4), ps.keySetData.getAliases().get("AB"));
-        ps = packages.get("com.android.app3");
-        assertEquals(2, ps.keySetData.getProperSigningKeySet());
-        assertEquals(new Long(3), ps.keySetData.getAliases().get("C"));
-        assertEquals(1, ps.keySetData.getUpgradeKeySets().length);
-        assertEquals(3, ps.keySetData.getUpgradeKeySets()[0]);
-    }
-
-    /* make sure our initialized keysetmanagerservice metadata matches packages.xml */
-    public void testReadKeySetSettings()
-            throws ReflectiveOperationException, IllegalAccessException {
-
-        /* write out files and read */
-        writeOldFiles();
-        createUserManagerServiceRef();
-        Settings settings = new Settings(getContext().getFilesDir(), new Object());
-        assertEquals(true, settings.readLPw(createFakeUsers()));
-        verifyKeySetMetaData(settings);
-    }
-
-    /* read in data, write it out, and read it back in.  Verify same. */
-    public void testWriteKeySetSettings()
-            throws ReflectiveOperationException, IllegalAccessException {
-
-        /* write out files and read */
-        writeOldFiles();
-        createUserManagerServiceRef();
-        Settings settings = new Settings(getContext().getFilesDir(), new Object());
-        assertEquals(true, settings.readLPw(createFakeUsers()));
-
-        /* write out, read back in and verify the same */
-        settings.writeLPr();
-        assertEquals(true, settings.readLPw(createFakeUsers()));
-        verifyKeySetMetaData(settings);
-    }
-
-    public void testSettingsReadOld() {
-        // Write the package files and make sure they're parsed properly the first time
-        writeOldFiles();
-        Settings settings = new Settings(getContext().getFilesDir(), new Object());
-        assertEquals(true, settings.readLPw(createFakeUsers()));
-        assertNotNull(settings.peekPackageLPr(PACKAGE_NAME_3));
-        assertNotNull(settings.peekPackageLPr(PACKAGE_NAME_1));
-
-        PackageSetting ps = settings.peekPackageLPr(PACKAGE_NAME_1);
-        assertEquals(COMPONENT_ENABLED_STATE_DEFAULT, ps.getEnabled(0));
-        assertEquals(true, ps.getNotLaunched(0));
-
-        ps = settings.peekPackageLPr(PACKAGE_NAME_2);
-        assertEquals(false, ps.getStopped(0));
-        assertEquals(COMPONENT_ENABLED_STATE_DISABLED_USER, ps.getEnabled(0));
-        assertEquals(COMPONENT_ENABLED_STATE_DEFAULT, ps.getEnabled(1));
-    }
-
-    public void testNewPackageRestrictionsFile() throws ReflectiveOperationException {
-
-        // Write the package files and make sure they're parsed properly the first time
-        writeOldFiles();
-        createUserManagerServiceRef();
-        Settings settings = new Settings(getContext().getFilesDir(), new Object());
-        assertEquals(true, settings.readLPw(createFakeUsers()));
-        settings.writeLPr();
-
-        // Create Settings again to make it read from the new files
-        settings = new Settings(getContext().getFilesDir(), new Object());
-        assertEquals(true, settings.readLPw(createFakeUsers()));
-
-        PackageSetting ps = settings.peekPackageLPr(PACKAGE_NAME_2);
-        assertEquals(COMPONENT_ENABLED_STATE_DISABLED_USER, ps.getEnabled(0));
-        assertEquals(COMPONENT_ENABLED_STATE_DEFAULT, ps.getEnabled(1));
-    }
-
-    public void testEnableDisable() {
-        // Write the package files and make sure they're parsed properly the first time
-        writeOldFiles();
-        Settings settings = new Settings(getContext().getFilesDir(), new Object());
-        assertEquals(true, settings.readLPw(createFakeUsers()));
-
-        // Enable/Disable a package
-        PackageSetting ps = settings.peekPackageLPr(PACKAGE_NAME_1);
-        ps.setEnabled(COMPONENT_ENABLED_STATE_DISABLED, 0, null);
-        ps.setEnabled(COMPONENT_ENABLED_STATE_ENABLED, 1, null);
-        assertEquals(COMPONENT_ENABLED_STATE_DISABLED, ps.getEnabled(0));
-        assertEquals(COMPONENT_ENABLED_STATE_ENABLED, ps.getEnabled(1));
-
-        // Enable/Disable a component
-        ArraySet<String> components = new ArraySet<String>();
-        String component1 = PACKAGE_NAME_1 + "/.Component1";
-        components.add(component1);
-        ps.setDisabledComponents(components, 0);
-        ArraySet<String> componentsDisabled = ps.getDisabledComponents(0);
-        assertEquals(1, componentsDisabled.size());
-        assertEquals(component1, componentsDisabled.toArray()[0]);
-        boolean hasEnabled =
-                ps.getEnabledComponents(0) != null && ps.getEnabledComponents(1).size() > 0;
-        assertEquals(false, hasEnabled);
-
-        // User 1 should not have any disabled components
-        boolean hasDisabled =
-                ps.getDisabledComponents(1) != null && ps.getDisabledComponents(1).size() > 0;
-        assertEquals(false, hasDisabled);
-        ps.setEnabledComponents(components, 1);
-        assertEquals(1, ps.getEnabledComponents(1).size());
-        hasEnabled = ps.getEnabledComponents(0) != null && ps.getEnabledComponents(0).size() > 0;
-        assertEquals(false, hasEnabled);
-    }
-}
diff --git a/services/tests/servicestests/src/com/android/server/pm/PackageVerificationStateTest.java b/services/tests/servicestests/src/com/android/server/pm/PackageVerificationStateTest.java
deleted file mode 100644
index ebd363386fa..00000000000
--- a/services/tests/servicestests/src/com/android/server/pm/PackageVerificationStateTest.java
+++ /dev/null
@@ -1,205 +0,0 @@
-/*
- * Copyright (C) 2011 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.android.server.pm;
-
-import android.content.pm.PackageManager;
-import com.android.server.pm.PackageVerificationState;
-
-import android.test.AndroidTestCase;
-
-public class PackageVerificationStateTest extends AndroidTestCase {
-    private static final int REQUIRED_UID = 1948;
-
-    private static final int SUFFICIENT_UID_1 = 1005;
-
-    private static final int SUFFICIENT_UID_2 = 8938;
-
-    public void testPackageVerificationState_OnlyRequiredVerifier_AllowedInstall() {
-        PackageVerificationState state = new PackageVerificationState(REQUIRED_UID, null);
-
-        assertFalse("Verification should not be marked as complete yet",
-                state.isVerificationComplete());
-
-        state.setVerifierResponse(REQUIRED_UID, PackageManager.VERIFICATION_ALLOW);
-
-        assertTrue("Verification should be considered complete now",
-                state.isVerificationComplete());
-
-        assertTrue("Installation should be marked as allowed",
-                state.isInstallAllowed());
-    }
-
-    public void testPackageVerificationState_OnlyRequiredVerifier_DeniedInstall() {
-        PackageVerificationState state = new PackageVerificationState(REQUIRED_UID, null);
-
-        assertFalse("Verification should not be marked as complete yet",
-                state.isVerificationComplete());
-
-        state.setVerifierResponse(REQUIRED_UID, PackageManager.VERIFICATION_REJECT);
-
-        assertTrue("Verification should be considered complete now",
-                state.isVerificationComplete());
-
-        assertFalse("Installation should be marked as allowed",
-                state.isInstallAllowed());
-    }
-
-    public void testPackageVerificationState_RequiredAndOneSufficient_RequiredDeniedInstall() {
-        PackageVerificationState state = new PackageVerificationState(REQUIRED_UID, null);
-
-        assertFalse("Verification should not be marked as complete yet",
-                state.isVerificationComplete());
-
-        state.addSufficientVerifier(SUFFICIENT_UID_1);
-
-        assertFalse("Verification should not be marked as complete yet",
-                state.isVerificationComplete());
-
-        state.setVerifierResponse(SUFFICIENT_UID_1, PackageManager.VERIFICATION_ALLOW);
-
-        assertFalse("Verification should not be marked as complete yet",
-                state.isVerificationComplete());
-
-        state.setVerifierResponse(REQUIRED_UID, PackageManager.VERIFICATION_REJECT);
-
-        assertTrue("Verification should be considered complete now",
-                state.isVerificationComplete());
-
-        assertFalse("Installation should be marked as allowed",
-                state.isInstallAllowed());
-    }
-
-    public void testPackageVerificationState_RequiredAndOneSufficient_SufficientDeniedInstall() {
-        PackageVerificationState state = new PackageVerificationState(REQUIRED_UID, null);
-
-        assertFalse("Verification should not be marked as complete yet",
-                state.isVerificationComplete());
-
-        state.addSufficientVerifier(SUFFICIENT_UID_1);
-
-        assertFalse("Verification should not be marked as complete yet",
-                state.isVerificationComplete());
-
-        state.setVerifierResponse(SUFFICIENT_UID_1, PackageManager.VERIFICATION_REJECT);
-
-        assertFalse("Verification should not be marked as complete yet",
-                state.isVerificationComplete());
-
-        state.setVerifierResponse(REQUIRED_UID, PackageManager.VERIFICATION_ALLOW);
-
-        assertTrue("Verification should be considered complete now",
-                state.isVerificationComplete());
-
-        assertFalse("Installation should be marked as allowed",
-                state.isInstallAllowed());
-    }
-
-    public void testPackageVerificationState_RequiredAndTwoSufficient_OneSufficientIsEnough() {
-        PackageVerificationState state = new PackageVerificationState(REQUIRED_UID, null);
-
-        assertFalse("Verification should not be marked as complete yet",
-                state.isVerificationComplete());
-
-        state.addSufficientVerifier(SUFFICIENT_UID_1);
-        state.addSufficientVerifier(SUFFICIENT_UID_2);
-
-        assertFalse("Verification should not be marked as complete yet",
-                state.isVerificationComplete());
-
-        state.setVerifierResponse(SUFFICIENT_UID_1, PackageManager.VERIFICATION_ALLOW);
-
-        assertFalse("Verification should not be marked as complete yet",
-                state.isVerificationComplete());
-
-        state.setVerifierResponse(REQUIRED_UID, PackageManager.VERIFICATION_ALLOW);
-
-        assertTrue("Verification should be considered complete now",
-                state.isVerificationComplete());
-
-        assertTrue("Installation should be marked as allowed",
-                state.isInstallAllowed());
-    }
-
-    public void testPackageVerificationState_RequiredAndTwoSufficient_SecondSufficientIsEnough() {
-        PackageVerificationState state = new PackageVerificationState(REQUIRED_UID, null);
-
-        assertFalse("Verification should not be marked as complete yet",
-                state.isVerificationComplete());
-
-        state.addSufficientVerifier(SUFFICIENT_UID_1);
-        state.addSufficientVerifier(SUFFICIENT_UID_2);
-
-        assertFalse("Verification should not be marked as complete yet",
-                state.isVerificationComplete());
-
-        state.setVerifierResponse(REQUIRED_UID, PackageManager.VERIFICATION_ALLOW);
-
-        assertFalse("Verification should not be marked as complete yet",
-                state.isVerificationComplete());
-
-        state.setVerifierResponse(SUFFICIENT_UID_1, PackageManager.VERIFICATION_REJECT);
-
-        assertFalse("Verification should not be marked as complete yet",
-                state.isVerificationComplete());
-
-        state.setVerifierResponse(SUFFICIENT_UID_2, PackageManager.VERIFICATION_ALLOW);
-
-        assertTrue("Verification should be considered complete now",
-                state.isVerificationComplete());
-
-        assertTrue("Installation should be marked as allowed",
-                state.isInstallAllowed());
-    }
-
-    public void testPackageVerificationState_RequiredAndTwoSufficient_RequiredOverrides() {
-        PackageVerificationState state = new PackageVerificationState(REQUIRED_UID, null);
-
-        assertFalse("Verification should not be marked as complete yet",
-                state.isVerificationComplete());
-
-        state.addSufficientVerifier(SUFFICIENT_UID_1);
-        state.addSufficientVerifier(SUFFICIENT_UID_2);
-
-        assertFalse("Verification should not be marked as complete yet",
-                state.isVerificationComplete());
-
-        state.setVerifierResponse(REQUIRED_UID,
-                PackageManager.VERIFICATION_ALLOW_WITHOUT_SUFFICIENT);
-
-        assertTrue("Verification should be marked as complete immediately",
-                state.isVerificationComplete());
-
-        assertTrue("Installation should be marked as allowed",
-                state.isInstallAllowed());
-
-        state.setVerifierResponse(SUFFICIENT_UID_1, PackageManager.VERIFICATION_REJECT);
-
-        assertTrue("Verification should still be marked as completed",
-                state.isVerificationComplete());
-
-        assertTrue("Installation should be marked as allowed still",
-                state.isInstallAllowed());
-
-        state.setVerifierResponse(SUFFICIENT_UID_2, PackageManager.VERIFICATION_ALLOW);
-
-        assertTrue("Verification should still be complete",
-                state.isVerificationComplete());
-
-        assertTrue("Installation should be marked as allowed still",
-                state.isInstallAllowed());
-    }
-}
diff --git a/services/tests/servicestests/src/com/android/server/pm/ShortcutManagerTest1.java b/services/tests/servicestests/src/com/android/server/pm/ShortcutManagerTest1.java
deleted file mode 100644
index cd48f36ade5..00000000000
--- a/services/tests/servicestests/src/com/android/server/pm/ShortcutManagerTest1.java
+++ /dev/null
@@ -1,7349 +0,0 @@
-/*
- * Copyright (C) 2016 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.android.server.pm;
-
-import static com.android.server.pm.shortcutmanagertest.ShortcutManagerTestUtils.assertAllDisabled;
-import static com.android.server.pm.shortcutmanagertest.ShortcutManagerTestUtils.assertAllDynamic;
-import static com.android.server.pm.shortcutmanagertest.ShortcutManagerTestUtils.assertAllDynamicOrPinned;
-import static com.android.server.pm.shortcutmanagertest.ShortcutManagerTestUtils.assertAllEnabled;
-import static com.android.server.pm.shortcutmanagertest.ShortcutManagerTestUtils.assertAllHaveIntents;
-import static com.android.server.pm.shortcutmanagertest.ShortcutManagerTestUtils.assertAllHaveTitle;
-import static com.android.server.pm.shortcutmanagertest.ShortcutManagerTestUtils.assertAllImmutable;
-import static com.android.server.pm.shortcutmanagertest.ShortcutManagerTestUtils.assertAllKeyFieldsOnly;
-import static com.android.server.pm.shortcutmanagertest.ShortcutManagerTestUtils.assertAllManifest;
-import static com.android.server.pm.shortcutmanagertest.ShortcutManagerTestUtils.assertAllNotHaveIntents;
-import static com.android.server.pm.shortcutmanagertest.ShortcutManagerTestUtils.assertAllNotHaveTitle;
-import static com.android.server.pm.shortcutmanagertest.ShortcutManagerTestUtils.assertAllNotKeyFieldsOnly;
-import static com.android.server.pm.shortcutmanagertest.ShortcutManagerTestUtils.assertAllNotManifest;
-import static com.android.server.pm.shortcutmanagertest.ShortcutManagerTestUtils.assertAllPinned;
-import static com.android.server.pm.shortcutmanagertest.ShortcutManagerTestUtils.assertAllUnique;
-import static com.android.server.pm.shortcutmanagertest.ShortcutManagerTestUtils.assertBitmapSize;
-import static com.android.server.pm.shortcutmanagertest.ShortcutManagerTestUtils.assertBundleEmpty;
-import static com.android.server.pm.shortcutmanagertest.ShortcutManagerTestUtils.assertCallbackNotReceived;
-import static com.android.server.pm.shortcutmanagertest.ShortcutManagerTestUtils.assertCallbackReceived;
-import static com.android.server.pm.shortcutmanagertest.ShortcutManagerTestUtils.assertCannotUpdateImmutable;
-import static com.android.server.pm.shortcutmanagertest.ShortcutManagerTestUtils.assertDynamicAndPinned;
-import static com.android.server.pm.shortcutmanagertest.ShortcutManagerTestUtils.assertDynamicOnly;
-import static com.android.server.pm.shortcutmanagertest.ShortcutManagerTestUtils.assertDynamicShortcutCountExceeded;
-import static com.android.server.pm.shortcutmanagertest.ShortcutManagerTestUtils.assertEmpty;
-import static com.android.server.pm.shortcutmanagertest.ShortcutManagerTestUtils.assertExpectException;
-import static com.android.server.pm.shortcutmanagertest.ShortcutManagerTestUtils.assertForLauncherCallback;
-import static com.android.server.pm.shortcutmanagertest.ShortcutManagerTestUtils.assertShortcutIds;
-import static com.android.server.pm.shortcutmanagertest.ShortcutManagerTestUtils.assertWith;
-import static com.android.server.pm.shortcutmanagertest.ShortcutManagerTestUtils.filterByActivity;
-import static com.android.server.pm.shortcutmanagertest.ShortcutManagerTestUtils.findShortcut;
-import static com.android.server.pm.shortcutmanagertest.ShortcutManagerTestUtils.hashSet;
-import static com.android.server.pm.shortcutmanagertest.ShortcutManagerTestUtils.list;
-import static com.android.server.pm.shortcutmanagertest.ShortcutManagerTestUtils.makeBundle;
-import static com.android.server.pm.shortcutmanagertest.ShortcutManagerTestUtils.pfdToBitmap;
-import static com.android.server.pm.shortcutmanagertest.ShortcutManagerTestUtils.resetAll;
-import static com.android.server.pm.shortcutmanagertest.ShortcutManagerTestUtils.set;
-import static com.android.server.pm.shortcutmanagertest.ShortcutManagerTestUtils.waitOnMainThread;
-
-import static org.mockito.Matchers.any;
-import static org.mockito.Matchers.anyInt;
-import static org.mockito.Matchers.anyString;
-import static org.mockito.Matchers.eq;
-import static org.mockito.Mockito.doReturn;
-import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.reset;
-import static org.mockito.Mockito.times;
-import static org.mockito.Mockito.verify;
-
-import android.Manifest.permission;
-import android.app.ActivityManager;
-import android.content.ActivityNotFoundException;
-import android.content.ComponentName;
-import android.content.Intent;
-import android.content.pm.ApplicationInfo;
-import android.content.pm.LauncherApps;
-import android.content.pm.LauncherApps.ShortcutQuery;
-import android.content.pm.ShortcutInfo;
-import android.graphics.Bitmap;
-import android.graphics.Bitmap.CompressFormat;
-import android.graphics.BitmapFactory;
-import android.graphics.drawable.Icon;
-import android.net.Uri;
-import android.os.Bundle;
-import android.os.Handler;
-import android.os.Looper;
-import android.os.Process;
-import android.os.UserHandle;
-import android.test.suitebuilder.annotation.SmallTest;
-import android.util.Log;
-import android.util.SparseArray;
-
-import com.android.frameworks.servicestests.R;
-import com.android.server.pm.ShortcutService.ConfigConstants;
-import com.android.server.pm.ShortcutService.FileOutputStreamWithPath;
-import com.android.server.pm.ShortcutUser.PackageWithUser;
-
-import org.mockito.ArgumentCaptor;
-
-import java.io.File;
-import java.io.IOException;
-import java.util.List;
-import java.util.Locale;
-
-/**
- * Tests for ShortcutService and ShortcutManager.
- *
- m FrameworksServicesTests &&
- adb install \
- -r -g ${ANDROID_PRODUCT_OUT}/data/app/FrameworksServicesTests/FrameworksServicesTests.apk &&
- adb shell am instrument -e class com.android.server.pm.ShortcutManagerTest1 \
- -w com.android.frameworks.servicestests/android.support.test.runner.AndroidJUnitRunner
- */
-@SmallTest
-public class ShortcutManagerTest1 extends BaseShortcutManagerTest {
-
-    /**
-     * Test for the first launch path, no settings file available.
-     */
-    public void testFirstInitialize() {
-        assertResetTimes(START_TIME, START_TIME + INTERVAL);
-    }
-
-    /**
-     * Test for {@link ShortcutService#getLastResetTimeLocked()} and
-     * {@link ShortcutService#getNextResetTimeLocked()}.
-     */
-    public void testUpdateAndGetNextResetTimeLocked() {
-        assertResetTimes(START_TIME, START_TIME + INTERVAL);
-
-        // Advance clock.
-        mInjectedCurrentTimeMillis += 100;
-
-        // Shouldn't have changed.
-        assertResetTimes(START_TIME, START_TIME + INTERVAL);
-
-        // Advance clock, almost the reset time.
-        mInjectedCurrentTimeMillis = START_TIME + INTERVAL - 1;
-
-        // Shouldn't have changed.
-        assertResetTimes(START_TIME, START_TIME + INTERVAL);
-
-        // Advance clock.
-        mInjectedCurrentTimeMillis += 1;
-
-        assertResetTimes(START_TIME + INTERVAL, START_TIME + 2 * INTERVAL);
-
-        // Advance further; 4 hours since start.
-        mInjectedCurrentTimeMillis = START_TIME + 4 * INTERVAL + 50;
-
-        assertResetTimes(START_TIME + 4 * INTERVAL, START_TIME + 5 * INTERVAL);
-    }
-
-    /**
-     * Test for the restoration from saved file.
-     */
-    public void testInitializeFromSavedFile() {
-
-        mInjectedCurrentTimeMillis = START_TIME + 4 * INTERVAL + 50;
-        assertResetTimes(START_TIME + 4 * INTERVAL, START_TIME + 5 * INTERVAL);
-
-        mService.saveBaseStateLocked();
-
-        dumpBaseStateFile();
-
-        mService.saveDirtyInfo();
-
-        // Restore.
-        initService();
-
-        assertResetTimes(START_TIME + 4 * INTERVAL, START_TIME + 5 * INTERVAL);
-    }
-
-    /**
-     * Test for the restoration from restored file.
-     */
-    public void testLoadFromBrokenFile() {
-        // TODO Add various broken cases.
-    }
-
-    public void testLoadConfig() {
-        mService.updateConfigurationLocked(
-                ConfigConstants.KEY_RESET_INTERVAL_SEC + "=123,"
-                        + ConfigConstants.KEY_MAX_SHORTCUTS + "=4,"
-                        + ConfigConstants.KEY_MAX_UPDATES_PER_INTERVAL + "=5,"
-                        + ConfigConstants.KEY_MAX_ICON_DIMENSION_DP + "=100,"
-                        + ConfigConstants.KEY_MAX_ICON_DIMENSION_DP_LOWRAM + "=50,"
-                        + ConfigConstants.KEY_ICON_FORMAT + "=WEBP,"
-                        + ConfigConstants.KEY_ICON_QUALITY + "=75");
-        assertEquals(123000, mService.getResetIntervalForTest());
-        assertEquals(4, mService.getMaxShortcutsForTest());
-        assertEquals(5, mService.getMaxUpdatesPerIntervalForTest());
-        assertEquals(100, mService.getMaxIconDimensionForTest());
-        assertEquals(CompressFormat.WEBP, mService.getIconPersistFormatForTest());
-        assertEquals(75, mService.getIconPersistQualityForTest());
-
-        mInjectedIsLowRamDevice = true;
-        mService.updateConfigurationLocked(
-                ConfigConstants.KEY_MAX_ICON_DIMENSION_DP + "=100,"
-                        + ConfigConstants.KEY_MAX_ICON_DIMENSION_DP_LOWRAM + "=50,"
-                        + ConfigConstants.KEY_ICON_FORMAT + "=JPEG");
-        assertEquals(ShortcutService.DEFAULT_RESET_INTERVAL_SEC * 1000,
-                mService.getResetIntervalForTest());
-
-        assertEquals(ShortcutService.DEFAULT_MAX_SHORTCUTS_PER_APP,
-                mService.getMaxShortcutsForTest());
-
-        assertEquals(ShortcutService.DEFAULT_MAX_UPDATES_PER_INTERVAL,
-                mService.getMaxUpdatesPerIntervalForTest());
-
-        assertEquals(50, mService.getMaxIconDimensionForTest());
-
-        assertEquals(CompressFormat.JPEG, mService.getIconPersistFormatForTest());
-
-        assertEquals(ShortcutService.DEFAULT_ICON_PERSIST_QUALITY,
-                mService.getIconPersistQualityForTest());
-    }
-
-    // === Test for app side APIs ===
-
-    /** Test for {@link android.content.pm.ShortcutManager#getMaxShortcutCountForActivity()} */
-    public void testGetMaxDynamicShortcutCount() {
-        assertEquals(MAX_SHORTCUTS, mManager.getMaxShortcutCountForActivity());
-    }
-
-    /** Test for {@link android.content.pm.ShortcutManager#getRemainingCallCount()} */
-    public void testGetRemainingCallCount() {
-        assertEquals(MAX_UPDATES_PER_INTERVAL, mManager.getRemainingCallCount());
-    }
-
-    public void testGetIconMaxDimensions() {
-        assertEquals(MAX_ICON_DIMENSION, mManager.getIconMaxWidth());
-        assertEquals(MAX_ICON_DIMENSION, mManager.getIconMaxHeight());
-    }
-
-    /** Test for {@link android.content.pm.ShortcutManager#getRateLimitResetTime()} */
-    public void testGetRateLimitResetTime() {
-        assertEquals(START_TIME + INTERVAL, mManager.getRateLimitResetTime());
-
-        mInjectedCurrentTimeMillis = START_TIME + 4 * INTERVAL + 50;
-
-        assertEquals(START_TIME + 5 * INTERVAL, mManager.getRateLimitResetTime());
-    }
-
-    public void testSetDynamicShortcuts() {
-        setCaller(CALLING_PACKAGE_1, USER_0);
-
-        final Icon icon1 = Icon.createWithResource(getTestContext(), R.drawable.icon1);
-        final Icon icon2 = Icon.createWithBitmap(BitmapFactory.decodeResource(
-                getTestContext().getResources(), R.drawable.icon2));
-
-        final ShortcutInfo si1 = makeShortcut(
-                "shortcut1",
-                "Title 1",
-                makeComponent(ShortcutActivity.class),
-                icon1,
-                makeIntent(Intent.ACTION_ASSIST, ShortcutActivity2.class,
-                        "key1", "val1", "nest", makeBundle("key", 123)),
-                /* weight */ 10);
-
-        final ShortcutInfo si2 = makeShortcut(
-                "shortcut2",
-                "Title 2",
-                /* activity */ null,
-                icon2,
-                makeIntent(Intent.ACTION_ASSIST, ShortcutActivity3.class),
-                /* weight */ 12);
-        final ShortcutInfo si3 = makeShortcut("shortcut3");
-
-        assertTrue(mManager.setDynamicShortcuts(list(si1, si2)));
-        assertShortcutIds(assertAllNotKeyFieldsOnly(
-                mManager.getDynamicShortcuts()),
-                "shortcut1", "shortcut2");
-        assertEquals(2, mManager.getRemainingCallCount());
-
-        // TODO: Check fields
-
-        assertTrue(mManager.setDynamicShortcuts(list(si1)));
-        assertShortcutIds(assertAllNotKeyFieldsOnly(
-                mManager.getDynamicShortcuts()),
-                "shortcut1");
-        assertEquals(1, mManager.getRemainingCallCount());
-
-        assertTrue(mManager.setDynamicShortcuts(list()));
-        assertEquals(0, mManager.getDynamicShortcuts().size());
-        assertEquals(0, mManager.getRemainingCallCount());
-
-        dumpsysOnLogcat();
-
-        mInjectedCurrentTimeMillis++; // Need to advance the clock for reset to work.
-        mService.resetThrottlingInner(UserHandle.USER_SYSTEM);
-
-        dumpsysOnLogcat();
-
-        assertTrue(mManager.setDynamicShortcuts(list(si2, si3)));
-        assertEquals(2, mManager.getDynamicShortcuts().size());
-
-        // TODO Check max number
-
-        mRunningUsers.put(USER_10, true);
-
-        runWithCaller(CALLING_PACKAGE_2, USER_10, () -> {
-            assertTrue(mManager.setDynamicShortcuts(list(makeShortcut("s1"))));
-        });
-    }
-
-    public void testAddDynamicShortcuts() {
-        setCaller(CALLING_PACKAGE_1, USER_0);
-
-        final ShortcutInfo si1 = makeShortcut("shortcut1");
-        final ShortcutInfo si2 = makeShortcut("shortcut2");
-        final ShortcutInfo si3 = makeShortcut("shortcut3");
-
-        assertEquals(3, mManager.getRemainingCallCount());
-
-        assertTrue(mManager.setDynamicShortcuts(list(si1)));
-        assertEquals(2, mManager.getRemainingCallCount());
-        assertShortcutIds(assertAllNotKeyFieldsOnly(
-                mManager.getDynamicShortcuts()),
-                "shortcut1");
-
-        assertTrue(mManager.addDynamicShortcuts(list(si2, si3)));
-        assertEquals(1, mManager.getRemainingCallCount());
-        assertShortcutIds(assertAllNotKeyFieldsOnly(
-                mManager.getDynamicShortcuts()),
-                "shortcut1", "shortcut2", "shortcut3");
-
-        // This should not crash.  It'll still consume the quota.
-        assertTrue(mManager.addDynamicShortcuts(list()));
-        assertEquals(0, mManager.getRemainingCallCount());
-        assertShortcutIds(assertAllNotKeyFieldsOnly(
-                mManager.getDynamicShortcuts()),
-                "shortcut1", "shortcut2", "shortcut3");
-
-        mInjectedCurrentTimeMillis += INTERVAL; // reset
-
-        // Add with the same ID
-        assertTrue(mManager.addDynamicShortcuts(list(makeShortcut("shortcut1"))));
-        assertEquals(2, mManager.getRemainingCallCount());
-        assertShortcutIds(assertAllNotKeyFieldsOnly(
-                mManager.getDynamicShortcuts()),
-                "shortcut1", "shortcut2", "shortcut3");
-
-        // TODO Check max number
-
-        // TODO Check fields.
-
-        mRunningUsers.put(USER_10, true);
-
-        runWithCaller(CALLING_PACKAGE_2, USER_10, () -> {
-            assertTrue(mManager.addDynamicShortcuts(list(makeShortcut("s1"))));
-        });
-    }
-
-    public void testPublishWithNoActivity() {
-        // If activity is not explicitly set, use the default one.
-
-        mRunningUsers.put(USER_10, true);
-
-        runWithCaller(CALLING_PACKAGE_2, USER_10, () -> {
-            // s1 and s3 has no activities.
-            final ShortcutInfo si1 = new ShortcutInfo.Builder(mClientContext, "si1")
-                    .setShortLabel("label1")
-                    .setIntent(new Intent("action1"))
-                    .build();
-            final ShortcutInfo si2 = new ShortcutInfo.Builder(mClientContext, "si2")
-                    .setShortLabel("label2")
-                    .setActivity(new ComponentName(getCallingPackage(), "abc"))
-                    .setIntent(new Intent("action2"))
-                    .build();
-            final ShortcutInfo si3 = new ShortcutInfo.Builder(mClientContext, "si3")
-                    .setShortLabel("label3")
-                    .setIntent(new Intent("action3"))
-                    .build();
-
-            // Set test 1
-            assertTrue(mManager.setDynamicShortcuts(list(si1)));
-
-            assertWith(getCallerShortcuts())
-                    .haveIds("si1")
-                    .forShortcutWithId("si1", si -> {
-                        assertEquals(new ComponentName(getCallingPackage(),
-                                MAIN_ACTIVITY_CLASS), si.getActivity());
-                    });
-
-            // Set test 2
-            assertTrue(mManager.setDynamicShortcuts(list(si2, si1)));
-
-            assertWith(getCallerShortcuts())
-                    .haveIds("si1", "si2")
-                    .forShortcutWithId("si1", si -> {
-                        assertEquals(new ComponentName(getCallingPackage(),
-                                MAIN_ACTIVITY_CLASS), si.getActivity());
-                    })
-                    .forShortcutWithId("si2", si -> {
-                        assertEquals(new ComponentName(getCallingPackage(),
-                                "abc"), si.getActivity());
-                    });
-
-
-            // Set test 3
-            assertTrue(mManager.setDynamicShortcuts(list(si3, si1)));
-
-            assertWith(getCallerShortcuts())
-                    .haveIds("si1", "si3")
-                    .forShortcutWithId("si1", si -> {
-                        assertEquals(new ComponentName(getCallingPackage(),
-                                MAIN_ACTIVITY_CLASS), si.getActivity());
-                    })
-                    .forShortcutWithId("si3", si -> {
-                        assertEquals(new ComponentName(getCallingPackage(),
-                                MAIN_ACTIVITY_CLASS), si.getActivity());
-                    });
-
-            mInjectedCurrentTimeMillis += INTERVAL; // reset throttling
-
-            // Add test 1
-            mManager.removeAllDynamicShortcuts();
-            assertTrue(mManager.addDynamicShortcuts(list(si1)));
-
-            assertWith(getCallerShortcuts())
-                    .haveIds("si1")
-                    .forShortcutWithId("si1", si -> {
-                        assertEquals(new ComponentName(getCallingPackage(),
-                                MAIN_ACTIVITY_CLASS), si.getActivity());
-                    });
-
-            // Add test 2
-            mManager.removeAllDynamicShortcuts();
-            assertTrue(mManager.addDynamicShortcuts(list(si2, si1)));
-
-            assertWith(getCallerShortcuts())
-                    .haveIds("si1", "si2")
-                    .forShortcutWithId("si1", si -> {
-                        assertEquals(new ComponentName(getCallingPackage(),
-                                MAIN_ACTIVITY_CLASS), si.getActivity());
-                    })
-                    .forShortcutWithId("si2", si -> {
-                        assertEquals(new ComponentName(getCallingPackage(),
-                                "abc"), si.getActivity());
-                    });
-
-
-            // Add test 3
-            mManager.removeAllDynamicShortcuts();
-            assertTrue(mManager.addDynamicShortcuts(list(si3, si1)));
-
-            assertWith(getCallerShortcuts())
-                    .haveIds("si1", "si3")
-                    .forShortcutWithId("si1", si -> {
-                        assertEquals(new ComponentName(getCallingPackage(),
-                                MAIN_ACTIVITY_CLASS), si.getActivity());
-                    })
-                    .forShortcutWithId("si3", si -> {
-                        assertEquals(new ComponentName(getCallingPackage(),
-                                MAIN_ACTIVITY_CLASS), si.getActivity());
-                    });
-        });
-    }
-
-    public void testPublishWithNoActivity_noMainActivityInPackage() {
-        mRunningUsers.put(USER_10, true);
-
-        runWithCaller(CALLING_PACKAGE_2, USER_10, () -> {
-            final ShortcutInfo si1 = new ShortcutInfo.Builder(mClientContext, "si1")
-                    .setShortLabel("label1")
-                    .setIntent(new Intent("action1"))
-                    .build();
-
-            // Returning null means there's no main activity in this package.
-            mMainActivityFetcher = (packageName, userId) -> null;
-
-            assertExpectException(
-                    RuntimeException.class, "Launcher activity not found for", () -> {
-                        assertTrue(mManager.setDynamicShortcuts(list(si1)));
-                    });
-        });
-    }
-
-    public void testDeleteDynamicShortcuts() {
-        final ShortcutInfo si1 = makeShortcut("shortcut1");
-        final ShortcutInfo si2 = makeShortcut("shortcut2");
-        final ShortcutInfo si3 = makeShortcut("shortcut3");
-        final ShortcutInfo si4 = makeShortcut("shortcut4");
-
-        assertTrue(mManager.setDynamicShortcuts(list(si1, si2, si3, si4)));
-        assertShortcutIds(assertAllNotKeyFieldsOnly(
-                mManager.getDynamicShortcuts()),
-                "shortcut1", "shortcut2", "shortcut3", "shortcut4");
-
-        assertEquals(2, mManager.getRemainingCallCount());
-
-        mManager.removeDynamicShortcuts(list("shortcut1"));
-        assertShortcutIds(assertAllNotKeyFieldsOnly(
-                mManager.getDynamicShortcuts()),
-                "shortcut2", "shortcut3", "shortcut4");
-
-        mManager.removeDynamicShortcuts(list("shortcut1"));
-        assertShortcutIds(assertAllNotKeyFieldsOnly(
-                mManager.getDynamicShortcuts()),
-                "shortcut2", "shortcut3", "shortcut4");
-
-        mManager.removeDynamicShortcuts(list("shortcutXXX"));
-        assertShortcutIds(assertAllNotKeyFieldsOnly(
-                mManager.getDynamicShortcuts()),
-                "shortcut2", "shortcut3", "shortcut4");
-
-        mManager.removeDynamicShortcuts(list("shortcut2", "shortcut4"));
-        assertShortcutIds(assertAllNotKeyFieldsOnly(
-                mManager.getDynamicShortcuts()),
-                "shortcut3");
-
-        mManager.removeDynamicShortcuts(list("shortcut3"));
-        assertShortcutIds(assertAllNotKeyFieldsOnly(
-                mManager.getDynamicShortcuts()));
-
-        // Still 2 calls left.
-        assertEquals(2, mManager.getRemainingCallCount());
-    }
-
-    public void testDeleteAllDynamicShortcuts() {
-        final ShortcutInfo si1 = makeShortcut("shortcut1");
-        final ShortcutInfo si2 = makeShortcut("shortcut2");
-        final ShortcutInfo si3 = makeShortcut("shortcut3");
-
-        assertTrue(mManager.setDynamicShortcuts(list(si1, si2, si3)));
-        assertShortcutIds(assertAllNotKeyFieldsOnly(
-                mManager.getDynamicShortcuts()),
-                "shortcut1", "shortcut2", "shortcut3");
-
-        assertEquals(2, mManager.getRemainingCallCount());
-
-        mManager.removeAllDynamicShortcuts();
-        assertEquals(0, mManager.getDynamicShortcuts().size());
-        assertEquals(2, mManager.getRemainingCallCount());
-
-        // Note delete shouldn't affect throttling, so...
-        assertEquals(0, mManager.getDynamicShortcuts().size());
-        assertEquals(0, mManager.getDynamicShortcuts().size());
-        assertEquals(0, mManager.getDynamicShortcuts().size());
-
-        // This should still work.
-        assertTrue(mManager.setDynamicShortcuts(list(si1, si2, si3)));
-        assertEquals(3, mManager.getDynamicShortcuts().size());
-
-        // Still 1 call left
-        assertEquals(1, mManager.getRemainingCallCount());
-    }
-
-    public void testIcons() throws IOException {
-        final Icon res32x32 = Icon.createWithResource(getTestContext(), R.drawable.black_32x32);
-        final Icon res64x64 = Icon.createWithResource(getTestContext(), R.drawable.black_64x64);
-        final Icon res512x512 = Icon.createWithResource(getTestContext(), R.drawable.black_512x512);
-
-        final Icon bmp32x32 = Icon.createWithBitmap(BitmapFactory.decodeResource(
-                getTestContext().getResources(), R.drawable.black_32x32));
-        final Icon bmp64x64 = Icon.createWithBitmap(BitmapFactory.decodeResource(
-                getTestContext().getResources(), R.drawable.black_64x64));
-        final Icon bmp512x512 = Icon.createWithBitmap(BitmapFactory.decodeResource(
-                getTestContext().getResources(), R.drawable.black_512x512));
-
-        // Set from package 1
-        setCaller(CALLING_PACKAGE_1);
-        assertTrue(mManager.setDynamicShortcuts(list(
-                makeShortcutWithIcon("res32x32", res32x32),
-                makeShortcutWithIcon("res64x64", res64x64),
-                makeShortcutWithIcon("bmp32x32", bmp32x32),
-                makeShortcutWithIcon("bmp64x64", bmp64x64),
-                makeShortcutWithIcon("bmp512x512", bmp512x512),
-                makeShortcut("none")
-        )));
-
-        // getDynamicShortcuts() shouldn't return icons, thus assertAllNotHaveIcon().
-        assertShortcutIds(assertAllNotHaveIcon(mManager.getDynamicShortcuts()),
-                "res32x32",
-                "res64x64",
-                "bmp32x32",
-                "bmp64x64",
-                "bmp512x512",
-                "none");
-
-        // Call from another caller with the same ID, just to make sure storage is per-package.
-        setCaller(CALLING_PACKAGE_2);
-        assertTrue(mManager.setDynamicShortcuts(list(
-                makeShortcutWithIcon("res32x32", res512x512),
-                makeShortcutWithIcon("res64x64", res512x512),
-                makeShortcutWithIcon("none", res512x512)
-        )));
-        assertShortcutIds(assertAllNotHaveIcon(mManager.getDynamicShortcuts()),
-                "res32x32",
-                "res64x64",
-                "none");
-
-        // Different profile.  Note the names and the contents don't match.
-        setCaller(CALLING_PACKAGE_1, USER_P0);
-        assertTrue(mManager.setDynamicShortcuts(list(
-                makeShortcutWithIcon("res32x32", res512x512),
-                makeShortcutWithIcon("bmp32x32", bmp512x512)
-        )));
-        assertShortcutIds(assertAllNotHaveIcon(mManager.getDynamicShortcuts()),
-                "res32x32",
-                "bmp32x32");
-
-        // Re-initialize and load from the files.
-        mService.saveDirtyInfo();
-        initService();
-
-        // Load from launcher.
-        Bitmap bmp;
-
-        setCaller(LAUNCHER_1);
-        // Check hasIconResource()/hasIconFile().
-        assertShortcutIds(assertAllHaveIconResId(
-                list(getShortcutInfoAsLauncher(CALLING_PACKAGE_1, "res32x32", USER_0))),
-                "res32x32");
-
-        assertShortcutIds(assertAllHaveIconResId(
-                list(getShortcutInfoAsLauncher(CALLING_PACKAGE_1, "res64x64", USER_0))),
-                "res64x64");
-
-        assertShortcutIds(assertAllHaveIconFile(
-                list(getShortcutInfoAsLauncher(CALLING_PACKAGE_1, "bmp32x32", USER_0))),
-                "bmp32x32");
-
-        assertShortcutIds(assertAllHaveIconFile(
-                list(getShortcutInfoAsLauncher(CALLING_PACKAGE_1, "bmp64x64", USER_0))),
-                "bmp64x64");
-
-        assertShortcutIds(assertAllHaveIconFile(
-                list(getShortcutInfoAsLauncher(CALLING_PACKAGE_1, "bmp512x512", USER_0))),
-                "bmp512x512");
-
-        assertShortcutIds(assertAllHaveIconResId(
-                list(getShortcutInfoAsLauncher(CALLING_PACKAGE_1, "res32x32", USER_P0))),
-                "res32x32");
-        assertShortcutIds(assertAllHaveIconFile(
-                list(getShortcutInfoAsLauncher(CALLING_PACKAGE_1, "bmp32x32", USER_P0))),
-                "bmp32x32");
-
-        // Check
-        assertEquals(
-                R.drawable.black_32x32,
-                mLauncherApps.getShortcutIconResId(
-                        getShortcutInfoAsLauncher(CALLING_PACKAGE_1, "res32x32", USER_0)));
-
-        assertEquals(
-                R.drawable.black_64x64,
-                mLauncherApps.getShortcutIconResId(
-                        getShortcutInfoAsLauncher(CALLING_PACKAGE_1, "res64x64", USER_0)));
-
-        assertEquals(
-                0, // because it's not a resource
-                mLauncherApps.getShortcutIconResId(
-                        getShortcutInfoAsLauncher(CALLING_PACKAGE_1, "bmp32x32", USER_0)));
-        assertEquals(
-                0, // because it's not a resource
-                mLauncherApps.getShortcutIconResId(
-                        getShortcutInfoAsLauncher(CALLING_PACKAGE_1, "bmp64x64", USER_0)));
-        assertEquals(
-                0, // because it's not a resource
-                mLauncherApps.getShortcutIconResId(
-                        getShortcutInfoAsLauncher(CALLING_PACKAGE_1, "bmp512x512", USER_0)));
-
-        bmp = pfdToBitmap(mLauncherApps.getShortcutIconFd(
-                getShortcutInfoAsLauncher(CALLING_PACKAGE_1, "bmp32x32", USER_0)));
-        assertBitmapSize(32, 32, bmp);
-
-        bmp = pfdToBitmap(mLauncherApps.getShortcutIconFd(
-                getShortcutInfoAsLauncher(CALLING_PACKAGE_1, "bmp64x64", USER_0)));
-        assertBitmapSize(64, 64, bmp);
-
-        bmp = pfdToBitmap(mLauncherApps.getShortcutIconFd(
-                getShortcutInfoAsLauncher(CALLING_PACKAGE_1, "bmp512x512", USER_0)));
-        assertBitmapSize(128, 128, bmp);
-
-        assertEquals(
-                R.drawable.black_512x512,
-                mLauncherApps.getShortcutIconResId(
-                        getShortcutInfoAsLauncher(CALLING_PACKAGE_1, "res32x32", USER_P0)));
-        // Should be 512x512, so shrunk.
-        bmp = pfdToBitmap(mLauncherApps.getShortcutIconFd(
-                getShortcutInfoAsLauncher(CALLING_PACKAGE_1, "bmp32x32", USER_P0)));
-        assertBitmapSize(128, 128, bmp);
-
-        // Also check the overload APIs too.
-        assertEquals(
-                R.drawable.black_32x32,
-                mLauncherApps.getShortcutIconResId(CALLING_PACKAGE_1, "res32x32", HANDLE_USER_0));
-        assertEquals(
-                R.drawable.black_64x64,
-                mLauncherApps.getShortcutIconResId(CALLING_PACKAGE_1, "res64x64", HANDLE_USER_0));
-        assertEquals(
-                R.drawable.black_512x512,
-                mLauncherApps.getShortcutIconResId(CALLING_PACKAGE_1, "res32x32", HANDLE_USER_P0));
-        bmp = pfdToBitmap(
-                mLauncherApps.getShortcutIconFd(CALLING_PACKAGE_1, "bmp32x32", HANDLE_USER_P0));
-        assertBitmapSize(128, 128, bmp);
-    }
-
-    public void testCleanupDanglingBitmaps() throws Exception {
-        assertBitmapDirectories(USER_0, EMPTY_STRINGS);
-        assertBitmapDirectories(USER_10, EMPTY_STRINGS);
-
-        // Make some shortcuts with bitmap icons.
-        final Icon bmp32x32 = Icon.createWithBitmap(BitmapFactory.decodeResource(
-                getTestContext().getResources(), R.drawable.black_32x32));
-
-        runWithCaller(CALLING_PACKAGE_1, USER_0, () -> {
-            mManager.setDynamicShortcuts(list(
-                    makeShortcutWithIcon("s1", bmp32x32),
-                    makeShortcutWithIcon("s2", bmp32x32),
-                    makeShortcutWithIcon("s3", bmp32x32)
-            ));
-        });
-
-        // Increment the time (which actually we don't have to), which is used for filenames.
-        mInjectedCurrentTimeMillis++;
-
-        runWithCaller(CALLING_PACKAGE_2, USER_0, () -> {
-            mManager.setDynamicShortcuts(list(
-                    makeShortcutWithIcon("s4", bmp32x32),
-                    makeShortcutWithIcon("s5", bmp32x32),
-                    makeShortcutWithIcon("s6", bmp32x32)
-            ));
-        });
-
-        // Increment the time, which is used for filenames.
-        mInjectedCurrentTimeMillis++;
-
-        runWithCaller(CALLING_PACKAGE_3, USER_0, () -> {
-            mManager.setDynamicShortcuts(list(
-            ));
-        });
-
-        // For USER-10, let's try without updating the times.
-        mRunningUsers.put(USER_10, true);
-
-        runWithCaller(CALLING_PACKAGE_1, USER_10, () -> {
-            mManager.setDynamicShortcuts(list(
-                    makeShortcutWithIcon("10s1", bmp32x32),
-                    makeShortcutWithIcon("10s2", bmp32x32),
-                    makeShortcutWithIcon("10s3", bmp32x32)
-            ));
-        });
-        runWithCaller(CALLING_PACKAGE_2, USER_10, () -> {
-            mManager.setDynamicShortcuts(list(
-                    makeShortcutWithIcon("10s4", bmp32x32),
-                    makeShortcutWithIcon("10s5", bmp32x32),
-                    makeShortcutWithIcon("10s6", bmp32x32)
-            ));
-        });
-        runWithCaller(CALLING_PACKAGE_3, USER_10, () -> {
-            mManager.setDynamicShortcuts(list(
-            ));
-        });
-
-        dumpsysOnLogcat();
-
-        // Check files and directories.
-        // Package 3 has no bitmaps, so we don't create a directory.
-        assertBitmapDirectories(USER_0, CALLING_PACKAGE_1, CALLING_PACKAGE_2);
-        assertBitmapDirectories(USER_10, CALLING_PACKAGE_1, CALLING_PACKAGE_2);
-
-        assertBitmapFiles(USER_0, CALLING_PACKAGE_1,
-                getBitmapFilename(USER_0, CALLING_PACKAGE_1, "s1"),
-                getBitmapFilename(USER_0, CALLING_PACKAGE_1, "s2"),
-                getBitmapFilename(USER_0, CALLING_PACKAGE_1, "s3")
-        );
-        assertBitmapFiles(USER_0, CALLING_PACKAGE_2,
-                getBitmapFilename(USER_0, CALLING_PACKAGE_2, "s4"),
-                getBitmapFilename(USER_0, CALLING_PACKAGE_2, "s5"),
-                getBitmapFilename(USER_0, CALLING_PACKAGE_2, "s6")
-        );
-        assertBitmapFiles(USER_0, CALLING_PACKAGE_3,
-                EMPTY_STRINGS
-        );
-        assertBitmapFiles(USER_10, CALLING_PACKAGE_1,
-                getBitmapFilename(USER_10, CALLING_PACKAGE_1, "10s1"),
-                getBitmapFilename(USER_10, CALLING_PACKAGE_1, "10s2"),
-                getBitmapFilename(USER_10, CALLING_PACKAGE_1, "10s3")
-        );
-        assertBitmapFiles(USER_10, CALLING_PACKAGE_2,
-                getBitmapFilename(USER_10, CALLING_PACKAGE_2, "10s4"),
-                getBitmapFilename(USER_10, CALLING_PACKAGE_2, "10s5"),
-                getBitmapFilename(USER_10, CALLING_PACKAGE_2, "10s6")
-        );
-        assertBitmapFiles(USER_10, CALLING_PACKAGE_3,
-                EMPTY_STRINGS
-        );
-
-        // Then create random directories and files.
-        makeFile(mService.getUserBitmapFilePath(USER_0), "a.b.c").mkdir();
-        makeFile(mService.getUserBitmapFilePath(USER_0), "d.e.f").mkdir();
-        makeFile(mService.getUserBitmapFilePath(USER_0), "d.e.f", "123").createNewFile();
-        makeFile(mService.getUserBitmapFilePath(USER_0), "d.e.f", "456").createNewFile();
-
-        makeFile(mService.getUserBitmapFilePath(USER_0), CALLING_PACKAGE_3).mkdir();
-
-        makeFile(mService.getUserBitmapFilePath(USER_0), CALLING_PACKAGE_1, "1").createNewFile();
-        makeFile(mService.getUserBitmapFilePath(USER_0), CALLING_PACKAGE_1, "2").createNewFile();
-        makeFile(mService.getUserBitmapFilePath(USER_0), CALLING_PACKAGE_1, "3").createNewFile();
-        makeFile(mService.getUserBitmapFilePath(USER_0), CALLING_PACKAGE_1, "4").createNewFile();
-
-        makeFile(mService.getUserBitmapFilePath(USER_10), "10a.b.c").mkdir();
-        makeFile(mService.getUserBitmapFilePath(USER_10), "10d.e.f").mkdir();
-        makeFile(mService.getUserBitmapFilePath(USER_10), "10d.e.f", "123").createNewFile();
-        makeFile(mService.getUserBitmapFilePath(USER_10), "10d.e.f", "456").createNewFile();
-
-        makeFile(mService.getUserBitmapFilePath(USER_10), CALLING_PACKAGE_2, "1").createNewFile();
-        makeFile(mService.getUserBitmapFilePath(USER_10), CALLING_PACKAGE_2, "2").createNewFile();
-        makeFile(mService.getUserBitmapFilePath(USER_10), CALLING_PACKAGE_2, "3").createNewFile();
-        makeFile(mService.getUserBitmapFilePath(USER_10), CALLING_PACKAGE_2, "4").createNewFile();
-
-        assertBitmapDirectories(USER_0, CALLING_PACKAGE_1, CALLING_PACKAGE_2, CALLING_PACKAGE_3,
-                "a.b.c", "d.e.f");
-
-        // Save and load.  When a user is loaded, we do the cleanup.
-        mService.saveDirtyInfo();
-        initService();
-
-        mService.handleUnlockUser(USER_0);
-        mService.handleUnlockUser(USER_10);
-        mService.handleUnlockUser(20); // Make sure the logic will still work for nonexistent user.
-
-        // The below check is the same as above, except this time USER_0 use the CALLING_PACKAGE_3
-        // directory.
-
-        assertBitmapDirectories(USER_0, CALLING_PACKAGE_1, CALLING_PACKAGE_2, CALLING_PACKAGE_3);
-        assertBitmapDirectories(USER_10, CALLING_PACKAGE_1, CALLING_PACKAGE_2);
-
-        assertBitmapFiles(USER_0, CALLING_PACKAGE_1,
-                getBitmapFilename(USER_0, CALLING_PACKAGE_1, "s1"),
-                getBitmapFilename(USER_0, CALLING_PACKAGE_1, "s2"),
-                getBitmapFilename(USER_0, CALLING_PACKAGE_1, "s3")
-        );
-        assertBitmapFiles(USER_0, CALLING_PACKAGE_2,
-                getBitmapFilename(USER_0, CALLING_PACKAGE_2, "s4"),
-                getBitmapFilename(USER_0, CALLING_PACKAGE_2, "s5"),
-                getBitmapFilename(USER_0, CALLING_PACKAGE_2, "s6")
-        );
-        assertBitmapFiles(USER_0, CALLING_PACKAGE_3,
-                EMPTY_STRINGS
-        );
-        assertBitmapFiles(USER_10, CALLING_PACKAGE_1,
-                getBitmapFilename(USER_10, CALLING_PACKAGE_1, "10s1"),
-                getBitmapFilename(USER_10, CALLING_PACKAGE_1, "10s2"),
-                getBitmapFilename(USER_10, CALLING_PACKAGE_1, "10s3")
-        );
-        assertBitmapFiles(USER_10, CALLING_PACKAGE_2,
-                getBitmapFilename(USER_10, CALLING_PACKAGE_2, "10s4"),
-                getBitmapFilename(USER_10, CALLING_PACKAGE_2, "10s5"),
-                getBitmapFilename(USER_10, CALLING_PACKAGE_2, "10s6")
-        );
-        assertBitmapFiles(USER_10, CALLING_PACKAGE_3,
-                EMPTY_STRINGS
-        );
-    }
-
-    protected void checkShrinkBitmap(int expectedWidth, int expectedHeight, int resId, int maxSize) {
-        assertBitmapSize(expectedWidth, expectedHeight,
-                ShortcutService.shrinkBitmap(BitmapFactory.decodeResource(
-                        getTestContext().getResources(), resId),
-                        maxSize));
-    }
-
-    public void testShrinkBitmap() {
-        checkShrinkBitmap(32, 32, R.drawable.black_512x512, 32);
-        checkShrinkBitmap(511, 511, R.drawable.black_512x512, 511);
-        checkShrinkBitmap(512, 512, R.drawable.black_512x512, 512);
-
-        checkShrinkBitmap(1024, 4096, R.drawable.black_1024x4096, 4096);
-        checkShrinkBitmap(1024, 4096, R.drawable.black_1024x4096, 4100);
-        checkShrinkBitmap(512, 2048, R.drawable.black_1024x4096, 2048);
-
-        checkShrinkBitmap(4096, 1024, R.drawable.black_4096x1024, 4096);
-        checkShrinkBitmap(4096, 1024, R.drawable.black_4096x1024, 4100);
-        checkShrinkBitmap(2048, 512, R.drawable.black_4096x1024, 2048);
-    }
-
-    protected File openIconFileForWriteAndGetPath(int userId, String packageName)
-            throws IOException {
-        // Shortcut IDs aren't used in the path, so just pass the same ID.
-        final FileOutputStreamWithPath out =
-                mService.openIconFileForWrite(userId, makePackageShortcut(packageName, "id"));
-        out.close();
-        return out.getFile();
-    }
-
-    public void testOpenIconFileForWrite() throws IOException {
-        mInjectedCurrentTimeMillis = 1000;
-
-        final File p10_1_1 = openIconFileForWriteAndGetPath(10, CALLING_PACKAGE_1);
-        final File p10_1_2 = openIconFileForWriteAndGetPath(10, CALLING_PACKAGE_1);
-
-        final File p10_2_1 = openIconFileForWriteAndGetPath(10, CALLING_PACKAGE_2);
-        final File p10_2_2 = openIconFileForWriteAndGetPath(10, CALLING_PACKAGE_2);
-
-        final File p11_1_1 = openIconFileForWriteAndGetPath(11, CALLING_PACKAGE_1);
-        final File p11_1_2 = openIconFileForWriteAndGetPath(11, CALLING_PACKAGE_1);
-
-        mInjectedCurrentTimeMillis++;
-
-        final File p10_1_3 = openIconFileForWriteAndGetPath(10, CALLING_PACKAGE_1);
-        final File p10_1_4 = openIconFileForWriteAndGetPath(10, CALLING_PACKAGE_1);
-        final File p10_1_5 = openIconFileForWriteAndGetPath(10, CALLING_PACKAGE_1);
-
-        final File p10_2_3 = openIconFileForWriteAndGetPath(10, CALLING_PACKAGE_2);
-        final File p11_1_3 = openIconFileForWriteAndGetPath(11, CALLING_PACKAGE_1);
-
-        // Make sure their paths are all unique
-        assertAllUnique(list(
-                p10_1_1,
-                p10_1_2,
-                p10_1_3,
-                p10_1_4,
-                p10_1_5,
-
-                p10_2_1,
-                p10_2_2,
-                p10_2_3,
-
-                p11_1_1,
-                p11_1_2,
-                p11_1_3
-        ));
-
-        // Check each set has the same parent.
-        assertEquals(p10_1_1.getParent(), p10_1_2.getParent());
-        assertEquals(p10_1_1.getParent(), p10_1_3.getParent());
-        assertEquals(p10_1_1.getParent(), p10_1_4.getParent());
-        assertEquals(p10_1_1.getParent(), p10_1_5.getParent());
-
-        assertEquals(p10_2_1.getParent(), p10_2_2.getParent());
-        assertEquals(p10_2_1.getParent(), p10_2_3.getParent());
-
-        assertEquals(p11_1_1.getParent(), p11_1_2.getParent());
-        assertEquals(p11_1_1.getParent(), p11_1_3.getParent());
-
-        // Check the parents are still unique.
-        assertAllUnique(list(
-                p10_1_1.getParent(),
-                p10_2_1.getParent(),
-                p11_1_1.getParent()
-        ));
-
-        // All files created at the same time for the same package/user, expcet for the first ones,
-        // will have "_" in the path.
-        assertFalse(p10_1_1.getName().contains("_"));
-        assertTrue(p10_1_2.getName().contains("_"));
-        assertFalse(p10_1_3.getName().contains("_"));
-        assertTrue(p10_1_4.getName().contains("_"));
-        assertTrue(p10_1_5.getName().contains("_"));
-
-        assertFalse(p10_2_1.getName().contains("_"));
-        assertTrue(p10_2_2.getName().contains("_"));
-        assertFalse(p10_2_3.getName().contains("_"));
-
-        assertFalse(p11_1_1.getName().contains("_"));
-        assertTrue(p11_1_2.getName().contains("_"));
-        assertFalse(p11_1_3.getName().contains("_"));
-    }
-
-    public void testUpdateShortcuts() {
-        runWithCaller(CALLING_PACKAGE_1, UserHandle.USER_SYSTEM, () -> {
-            assertTrue(mManager.setDynamicShortcuts(list(
-                    makeShortcut("s1"),
-                    makeShortcut("s2"),
-                    makeShortcut("s3"),
-                    makeShortcut("s4"),
-                    makeShortcut("s5")
-            )));
-        });
-        runWithCaller(CALLING_PACKAGE_2, UserHandle.USER_SYSTEM, () -> {
-            assertTrue(mManager.setDynamicShortcuts(list(
-                    makeShortcut("s1"),
-                    makeShortcut("s2"),
-                    makeShortcut("s3"),
-                    makeShortcut("s4"),
-                    makeShortcut("s5")
-            )));
-        });
-        runWithCaller(LAUNCHER_1, UserHandle.USER_SYSTEM, () -> {
-            mLauncherApps.pinShortcuts(CALLING_PACKAGE_1, list("s2", "s3"),
-                    getCallingUser());
-            mLauncherApps.pinShortcuts(CALLING_PACKAGE_2, list("s4", "s5"),
-                    getCallingUser());
-        });
-        runWithCaller(CALLING_PACKAGE_1, UserHandle.USER_SYSTEM, () -> {
-            mManager.removeDynamicShortcuts(list("s1"));
-            mManager.removeDynamicShortcuts(list("s2"));
-        });
-        runWithCaller(CALLING_PACKAGE_2, UserHandle.USER_SYSTEM, () -> {
-            mManager.removeDynamicShortcuts(list("s1"));
-            mManager.removeDynamicShortcuts(list("s3"));
-            mManager.removeDynamicShortcuts(list("s5"));
-        });
-        runWithCaller(CALLING_PACKAGE_1, UserHandle.USER_SYSTEM, () -> {
-            assertShortcutIds(assertAllDynamic(
-                    mManager.getDynamicShortcuts()),
-                    "s3", "s4", "s5");
-            assertShortcutIds(assertAllPinned(
-                    mManager.getPinnedShortcuts()),
-                    "s2", "s3");
-        });
-        runWithCaller(CALLING_PACKAGE_2, UserHandle.USER_SYSTEM, () -> {
-            assertShortcutIds(assertAllDynamic(
-                    mManager.getDynamicShortcuts()),
-                    "s2", "s4");
-            assertShortcutIds(assertAllPinned(
-                    mManager.getPinnedShortcuts()),
-                    "s4", "s5");
-        });
-
-        runWithCaller(CALLING_PACKAGE_1, UserHandle.USER_SYSTEM, () -> {
-            ShortcutInfo s2 = makeShortcutBuilder()
-                    .setId("s2")
-                    .setIcon(Icon.createWithResource(getTestContext(), R.drawable.black_32x32))
-                    .build();
-
-            ShortcutInfo s4 = makeShortcutBuilder()
-                    .setId("s4")
-                    .setTitle("new title")
-                    .build();
-
-            mManager.updateShortcuts(list(s2, s4));
-        });
-        runWithCaller(CALLING_PACKAGE_2, UserHandle.USER_SYSTEM, () -> {
-            ShortcutInfo s2 = makeShortcutBuilder()
-                    .setId("s2")
-                    .setIntent(makeIntent(Intent.ACTION_ANSWER, ShortcutActivity.class,
-                            "key1", "val1"))
-                    .build();
-
-            ShortcutInfo s4 = makeShortcutBuilder()
-                    .setId("s4")
-                    .setIntent(new Intent(Intent.ACTION_ALL_APPS))
-                    .build();
-
-            mManager.updateShortcuts(list(s2, s4));
-        });
-
-        runWithCaller(CALLING_PACKAGE_1, UserHandle.USER_SYSTEM, () -> {
-            assertShortcutIds(assertAllDynamic(
-                    mManager.getDynamicShortcuts()),
-                    "s3", "s4", "s5");
-            assertShortcutIds(assertAllPinned(
-                    mManager.getPinnedShortcuts()),
-                    "s2", "s3");
-
-            ShortcutInfo s = getCallerShortcut("s2");
-            assertTrue(s.hasIconResource());
-            assertEquals(R.drawable.black_32x32, s.getIconResourceId());
-            assertEquals("string/r" + R.drawable.black_32x32, s.getIconResName());
-            assertEquals("Title-s2", s.getTitle());
-
-            s = getCallerShortcut("s4");
-            assertFalse(s.hasIconResource());
-            assertEquals(0, s.getIconResourceId());
-            assertEquals("new title", s.getTitle());
-        });
-        runWithCaller(CALLING_PACKAGE_2, UserHandle.USER_SYSTEM, () -> {
-            assertShortcutIds(assertAllDynamic(
-                    mManager.getDynamicShortcuts()),
-                    "s2", "s4");
-            assertShortcutIds(assertAllPinned(
-                    mManager.getPinnedShortcuts()),
-                    "s4", "s5");
-
-            ShortcutInfo s = getCallerShortcut("s2");
-            assertFalse(s.hasIconResource());
-            assertEquals(0, s.getIconResourceId());
-            assertEquals("Title-s2", s.getTitle());
-            assertEquals(Intent.ACTION_ANSWER, s.getIntent().getAction());
-            assertEquals(1, s.getIntent().getExtras().size());
-
-            s = getCallerShortcut("s4");
-            assertFalse(s.hasIconResource());
-            assertEquals(0, s.getIconResourceId());
-            assertEquals("Title-s4", s.getTitle());
-            assertEquals(Intent.ACTION_ALL_APPS, s.getIntent().getAction());
-            assertBundleEmpty(s.getIntent().getExtras());
-        });
-        // TODO Check with other fields too.
-
-        // TODO Check bitmap removal too.
-
-        mRunningUsers.put(USER_11, true);
-
-        runWithCaller(CALLING_PACKAGE_2, USER_11, () -> {
-            mManager.updateShortcuts(list());
-        });
-    }
-
-    public void testUpdateShortcuts_icons() {
-        runWithCaller(CALLING_PACKAGE_1, UserHandle.USER_SYSTEM, () -> {
-            assertTrue(mManager.setDynamicShortcuts(list(
-                    makeShortcut("s1")
-            )));
-
-            // Set resource icon
-            assertTrue(mManager.updateShortcuts(list(
-                    new ShortcutInfo.Builder(mClientContext, "s1")
-                    .setIcon(Icon.createWithResource(getTestContext(), R.drawable.black_32x32))
-                    .build()
-            )));
-
-            assertWith(getCallerShortcuts())
-                    .forShortcutWithId("s1", si -> {
-                        assertTrue(si.hasIconResource());
-                        assertEquals(R.drawable.black_32x32, si.getIconResourceId());
-                    });
-
-            // Set bitmap icon
-            assertTrue(mManager.updateShortcuts(list(
-                    new ShortcutInfo.Builder(mClientContext, "s1")
-                    .setIcon(Icon.createWithBitmap(BitmapFactory.decodeResource(
-                            getTestContext().getResources(), R.drawable.black_64x64)))
-                    .build()
-            )));
-
-            assertWith(getCallerShortcuts())
-                    .forShortcutWithId("s1", si -> {
-                        assertTrue(si.hasIconFile());
-                    });
-
-            mInjectedCurrentTimeMillis += INTERVAL; // reset throttling
-
-            // Do it again, with the reverse order (bitmap -> icon)
-            assertTrue(mManager.setDynamicShortcuts(list(
-                    makeShortcut("s1")
-            )));
-
-            // Set bitmap icon
-            assertTrue(mManager.updateShortcuts(list(
-                    new ShortcutInfo.Builder(mClientContext, "s1")
-                            .setIcon(Icon.createWithBitmap(BitmapFactory.decodeResource(
-                                    getTestContext().getResources(), R.drawable.black_64x64)))
-                            .build()
-            )));
-
-            assertWith(getCallerShortcuts())
-                    .forShortcutWithId("s1", si -> {
-                        assertTrue(si.hasIconFile());
-                    });
-
-            // Set resource icon
-            assertTrue(mManager.updateShortcuts(list(
-                    new ShortcutInfo.Builder(mClientContext, "s1")
-                            .setIcon(Icon.createWithResource(getTestContext(), R.drawable.black_32x32))
-                            .build()
-            )));
-
-            assertWith(getCallerShortcuts())
-                    .forShortcutWithId("s1", si -> {
-                        assertTrue(si.hasIconResource());
-                        assertEquals(R.drawable.black_32x32, si.getIconResourceId());
-                    });
-        });
-    }
-
-    // === Test for launcher side APIs ===
-
-    public void testGetShortcuts() {
-
-        // Set up shortcuts.
-
-        setCaller(CALLING_PACKAGE_1);
-        final ShortcutInfo s1_1 = makeShortcut("s1");
-        final ShortcutInfo s1_2 = makeShortcut("s2");
-
-        assertTrue(mManager.setDynamicShortcuts(list(s1_1, s1_2)));
-
-        // Because setDynamicShortcuts will update the timestamps when ranks are changing,
-        // we explicitly set timestamps here.
-        getCallerShortcut("s1").setTimestamp(5000);
-        getCallerShortcut("s2").setTimestamp(1000);
-
-        setCaller(CALLING_PACKAGE_2);
-        final ShortcutInfo s2_2 = makeShortcut("s2");
-        final ShortcutInfo s2_3 = makeShortcutWithActivity("s3",
-                makeComponent(ShortcutActivity2.class));
-        final ShortcutInfo s2_4 = makeShortcutWithActivity("s4",
-                makeComponent(ShortcutActivity.class));
-        assertTrue(mManager.setDynamicShortcuts(list(s2_2, s2_3, s2_4)));
-
-        getCallerShortcut("s2").setTimestamp(1500);
-        getCallerShortcut("s3").setTimestamp(3000);
-        getCallerShortcut("s4").setTimestamp(500);
-
-        setCaller(CALLING_PACKAGE_3);
-        final ShortcutInfo s3_2 = makeShortcut("s3");
-        assertTrue(mManager.setDynamicShortcuts(list(s3_2)));
-
-        getCallerShortcut("s3").setTimestamp(START_TIME + 5000);
-
-        setCaller(LAUNCHER_1);
-
-        // Get dynamic
-        assertAllDynamic(assertAllHaveTitle(assertAllNotHaveIntents(assertAllStringsResolved(
-                assertShortcutIds(
-                        assertAllNotKeyFieldsOnly(
-                                mLauncherApps.getShortcuts(buildQuery(/* time =*/ 0, CALLING_PACKAGE_1,
-                        /* activity =*/ null, ShortcutQuery.FLAG_GET_DYNAMIC), getCallingUser())),
-                        "s1", "s2")))));
-
-        // Get pinned
-        assertShortcutIds(
-                mLauncherApps.getShortcuts(buildQuery(/* time =*/ 0, CALLING_PACKAGE_1,
-                        /* activity =*/ null,
-                        ShortcutQuery.FLAG_GET_PINNED), getCallingUser())
-                /* none */);
-
-        // Get both, with timestamp
-        assertAllDynamic(assertAllHaveTitle(assertAllNotHaveIntents(assertShortcutIds(
-                assertAllNotKeyFieldsOnly(mLauncherApps.getShortcuts(buildQuery(
-                        /* time =*/ 1000, CALLING_PACKAGE_2,
-                        /* activity =*/ null,
-                        ShortcutQuery.FLAG_GET_PINNED | ShortcutQuery.FLAG_GET_DYNAMIC),
-                        getCallingUser())),
-                "s2", "s3"))));
-
-        // FLAG_GET_KEY_FIELDS_ONLY
-        assertAllDynamic(assertAllNotHaveTitle(assertAllNotHaveIntents(assertShortcutIds(
-                assertAllKeyFieldsOnly(mLauncherApps.getShortcuts(buildQuery(
-                        /* time =*/ 1000, CALLING_PACKAGE_2,
-                        /* activity =*/ null,
-                        ShortcutQuery.FLAG_GET_DYNAMIC | ShortcutQuery.FLAG_GET_KEY_FIELDS_ONLY),
-                        getCallingUser())),
-                "s2", "s3"))));
-
-        // Filter by activity
-        assertAllDynamic(assertAllHaveTitle(assertAllNotHaveIntents(assertShortcutIds(
-                assertAllNotKeyFieldsOnly(mLauncherApps.getShortcuts(buildQuery(
-                        /* time =*/ 0, CALLING_PACKAGE_2,
-                        new ComponentName(CALLING_PACKAGE_2, ShortcutActivity.class.getName()),
-                        ShortcutQuery.FLAG_GET_PINNED | ShortcutQuery.FLAG_GET_DYNAMIC),
-                        getCallingUser())),
-                "s4"))));
-
-        // With ID.
-        assertAllDynamic(assertAllNotHaveTitle(assertAllNotHaveIntents(assertShortcutIds(
-                assertAllKeyFieldsOnly(mLauncherApps.getShortcuts(buildQuery(
-                        /* time =*/ 1000, CALLING_PACKAGE_2, list("s3"),
-                        /* activity =*/ null,
-                        ShortcutQuery.FLAG_GET_DYNAMIC | ShortcutQuery.FLAG_GET_KEY_FIELDS_ONLY),
-                        getCallingUser())),
-                "s3"))));
-        assertAllDynamic(assertAllNotHaveTitle(assertAllNotHaveIntents(assertShortcutIds(
-                assertAllKeyFieldsOnly(mLauncherApps.getShortcuts(buildQuery(
-                        /* time =*/ 1000, CALLING_PACKAGE_2, list("s3", "s2", "ss"),
-                        /* activity =*/ null,
-                        ShortcutQuery.FLAG_GET_DYNAMIC | ShortcutQuery.FLAG_GET_KEY_FIELDS_ONLY),
-                        getCallingUser())),
-                "s2", "s3"))));
-        assertAllDynamic(assertAllNotHaveTitle(assertAllNotHaveIntents(assertShortcutIds(
-                assertAllKeyFieldsOnly(mLauncherApps.getShortcuts(buildQuery(
-                        /* time =*/ 1000, CALLING_PACKAGE_2, list("s3x", "s2x"),
-                        /* activity =*/ null,
-                        ShortcutQuery.FLAG_GET_DYNAMIC | ShortcutQuery.FLAG_GET_KEY_FIELDS_ONLY),
-                        getCallingUser()))
-                /* empty */))));
-        assertAllDynamic(assertAllNotHaveTitle(assertAllNotHaveIntents(assertShortcutIds(
-                assertAllKeyFieldsOnly(mLauncherApps.getShortcuts(buildQuery(
-                        /* time =*/ 1000, CALLING_PACKAGE_2, list(),
-                        /* activity =*/ null,
-                        ShortcutQuery.FLAG_GET_DYNAMIC | ShortcutQuery.FLAG_GET_KEY_FIELDS_ONLY),
-                        getCallingUser()))
-                /* empty */))));
-
-        // Pin some shortcuts.
-        mLauncherApps.pinShortcuts(CALLING_PACKAGE_2,
-                list("s3", "s4"), getCallingUser());
-
-        // Pinned ones only
-        assertAllPinned(assertAllHaveTitle(assertAllNotHaveIntents(assertShortcutIds(
-                assertAllNotKeyFieldsOnly(mLauncherApps.getShortcuts(buildQuery(
-                        /* time =*/ 1000, CALLING_PACKAGE_2,
-                        /* activity =*/ null,
-                        ShortcutQuery.FLAG_GET_PINNED),
-                        getCallingUser())),
-                "s3"))));
-
-        // All packages.
-        assertShortcutIds(assertAllNotKeyFieldsOnly(
-                mLauncherApps.getShortcuts(buildQuery(
-                        /* time =*/ 5000, /* package= */ null,
-                        /* activity =*/ null,
-                        ShortcutQuery.FLAG_GET_DYNAMIC | ShortcutQuery.FLAG_GET_PINNED),
-                        getCallingUser())),
-                "s1", "s3");
-
-        assertExpectException(
-                IllegalArgumentException.class, "package name must also be set", () -> {
-                    mLauncherApps.getShortcuts(buildQuery(
-                    /* time =*/ 0, /* package= */ null, list("id"),
-                    /* activity =*/ null, /* flags */ 0), getCallingUser());
-                });
-
-        // TODO More tests: pinned but dynamic.
-    }
-
-    public void testGetShortcuts_shortcutKinds() throws Exception {
-        // Create 3 manifest and 3 dynamic shortcuts
-        addManifestShortcutResource(
-                new ComponentName(CALLING_PACKAGE_1, ShortcutActivity.class.getName()),
-                R.xml.shortcut_3);
-        updatePackageVersion(CALLING_PACKAGE_1, 1);
-        mService.mPackageMonitor.onReceive(getTestContext(),
-                genPackageAddIntent(CALLING_PACKAGE_1, USER_0));
-
-        runWithCaller(CALLING_PACKAGE_1, USER_0, () -> {
-            assertTrue(mManager.setDynamicShortcuts(list(
-                    makeShortcut("s1"), makeShortcut("s2"), makeShortcut("s3"))));
-        });
-
-        // Pin 2 and 3
-        runWithCaller(LAUNCHER_1, USER_0, () -> {
-            mLauncherApps.pinShortcuts(CALLING_PACKAGE_1, list("ms2", "ms3", "s2", "s3"),
-                    HANDLE_USER_0);
-        });
-
-        // Remove ms3 and s3
-        addManifestShortcutResource(
-                new ComponentName(CALLING_PACKAGE_1, ShortcutActivity.class.getName()),
-                R.xml.shortcut_2);
-        updatePackageVersion(CALLING_PACKAGE_1, 1);
-        mService.mPackageMonitor.onReceive(getTestContext(),
-                genPackageAddIntent(CALLING_PACKAGE_1, USER_0));
-
-        runWithCaller(CALLING_PACKAGE_1, USER_0, () -> {
-            assertTrue(mManager.setDynamicShortcuts(list(
-                    makeShortcut("s1"), makeShortcut("s2"))));
-        });
-
-        // Check their status.
-        runWithCaller(CALLING_PACKAGE_1, USER_0, () -> {
-            assertWith(getCallerShortcuts())
-                    .haveIds("ms1", "ms2", "ms3", "s1", "s2", "s3")
-
-                    .selectByIds("ms1", "ms2")
-                    .areAllManifest()
-                    .areAllImmutable()
-                    .areAllNotDynamic()
-
-                    .revertToOriginalList()
-                    .selectByIds("ms3")
-                    .areAllNotManifest()
-                    .areAllImmutable()
-                    .areAllDisabled()
-                    .areAllNotDynamic()
-
-                    .revertToOriginalList()
-                    .selectByIds("s1", "s2")
-                    .areAllNotManifest()
-                    .areAllMutable()
-                    .areAllDynamic()
-
-                    .revertToOriginalList()
-                    .selectByIds("s3")
-                    .areAllNotManifest()
-                    .areAllMutable()
-                    .areAllEnabled()
-                    .areAllNotDynamic()
-
-                    .revertToOriginalList()
-                    .selectByIds("s1", "ms1")
-                    .areAllNotPinned()
-
-                    .revertToOriginalList()
-                    .selectByIds("s2", "s3", "ms2", "ms3")
-                    .areAllPinned()
-            ;
-        });
-
-        // Finally, actual tests.
-        runWithCaller(LAUNCHER_1, USER_0, () -> {
-            assertWith(mLauncherApps.getShortcuts(
-                    buildQueryWithFlags(ShortcutQuery.FLAG_GET_DYNAMIC), HANDLE_USER_0))
-                    .haveIds("s1", "s2");
-            assertWith(mLauncherApps.getShortcuts(
-                    buildQueryWithFlags(ShortcutQuery.FLAG_GET_MANIFEST), HANDLE_USER_0))
-                    .haveIds("ms1", "ms2");
-            assertWith(mLauncherApps.getShortcuts(
-                    buildQueryWithFlags(ShortcutQuery.FLAG_GET_PINNED), HANDLE_USER_0))
-                    .haveIds("s2", "s3", "ms2", "ms3");
-
-            assertWith(mLauncherApps.getShortcuts(
-                    buildQueryWithFlags(
-                            ShortcutQuery.FLAG_GET_DYNAMIC | ShortcutQuery.FLAG_GET_PINNED
-                    ), HANDLE_USER_0))
-                    .haveIds("s1", "s2", "s3", "ms2", "ms3");
-
-            assertWith(mLauncherApps.getShortcuts(
-                    buildQueryWithFlags(
-                            ShortcutQuery.FLAG_GET_MANIFEST | ShortcutQuery.FLAG_GET_PINNED
-                    ), HANDLE_USER_0))
-                    .haveIds("ms1", "s2", "s3", "ms2", "ms3");
-
-            assertWith(mLauncherApps.getShortcuts(
-                    buildQueryWithFlags(
-                            ShortcutQuery.FLAG_GET_DYNAMIC | ShortcutQuery.FLAG_GET_MANIFEST
-                    ), HANDLE_USER_0))
-                    .haveIds("ms1", "ms2", "s1", "s2");
-
-            assertWith(mLauncherApps.getShortcuts(
-                    buildQueryWithFlags(
-                            ShortcutQuery.FLAG_GET_ALL_KINDS
-                    ), HANDLE_USER_0))
-                    .haveIds("ms1", "ms2", "ms3", "s1", "s2", "s3");
-        });
-    }
-
-    public void testGetShortcuts_resolveStrings() throws Exception {
-        runWithCaller(CALLING_PACKAGE_1, USER_0, () -> {
-            ShortcutInfo si = new ShortcutInfo.Builder(mClientContext)
-                    .setId("id")
-                    .setActivity(new ComponentName(mClientContext, "dummy"))
-                    .setTitleResId(10)
-                    .setTextResId(11)
-                    .setDisabledMessageResId(12)
-                    .setIntent(makeIntent("action", ShortcutActivity.class))
-                    .build();
-            mManager.setDynamicShortcuts(list(si));
-        });
-        runWithCaller(CALLING_PACKAGE_1, USER_P0, () -> {
-            ShortcutInfo si = new ShortcutInfo.Builder(mClientContext)
-                    .setId("id")
-                    .setActivity(new ComponentName(mClientContext, "dummy"))
-                    .setTitleResId(10)
-                    .setTextResId(11)
-                    .setDisabledMessageResId(12)
-                    .setIntent(makeIntent("action", ShortcutActivity.class))
-                    .build();
-            mManager.setDynamicShortcuts(list(si));
-        });
-
-        runWithCaller(LAUNCHER_1, USER_0, () -> {
-            final ShortcutQuery q = new ShortcutQuery();
-            q.setQueryFlags(ShortcutQuery.FLAG_GET_DYNAMIC);
-
-            // USER 0
-            List<ShortcutInfo> ret = assertShortcutIds(
-                    assertAllStringsResolved(mLauncherApps.getShortcuts(q, HANDLE_USER_0)),
-                    "id");
-            assertEquals("string-com.android.test.1-user:0-res:10/en", ret.get(0).getTitle());
-            assertEquals("string-com.android.test.1-user:0-res:11/en", ret.get(0).getText());
-            assertEquals("string-com.android.test.1-user:0-res:12/en",
-                    ret.get(0).getDisabledMessage());
-
-            // USER P0
-            ret = assertShortcutIds(
-                    assertAllStringsResolved(mLauncherApps.getShortcuts(q, HANDLE_USER_P0)),
-                    "id");
-            assertEquals("string-com.android.test.1-user:20-res:10/en", ret.get(0).getTitle());
-            assertEquals("string-com.android.test.1-user:20-res:11/en", ret.get(0).getText());
-            assertEquals("string-com.android.test.1-user:20-res:12/en",
-                    ret.get(0).getDisabledMessage());
-        });
-    }
-
-    // TODO resource
-    public void testGetShortcutInfo() {
-        // Create shortcuts.
-        setCaller(CALLING_PACKAGE_1);
-        final ShortcutInfo s1_1 = makeShortcut(
-                "s1",
-                "Title 1",
-                makeComponent(ShortcutActivity.class),
-                /* icon =*/ null,
-                makeIntent(Intent.ACTION_ASSIST, ShortcutActivity2.class,
-                        "key1", "val1", "nest", makeBundle("key", 123)),
-                /* weight */ 10);
-
-        final ShortcutInfo s1_2 = makeShortcut(
-                "s2",
-                "Title 2",
-                /* activity */ null,
-                /* icon =*/ null,
-                makeIntent(Intent.ACTION_ASSIST, ShortcutActivity3.class),
-                /* weight */ 12);
-
-        assertTrue(mManager.setDynamicShortcuts(list(s1_1, s1_2)));
-        dumpsysOnLogcat();
-
-        setCaller(CALLING_PACKAGE_2);
-        final ShortcutInfo s2_1 = makeShortcut(
-                "s1",
-                "ABC",
-                makeComponent(ShortcutActivity2.class),
-                /* icon =*/ null,
-                makeIntent(Intent.ACTION_ANSWER, ShortcutActivity2.class,
-                        "key1", "val1", "nest", makeBundle("key", 123)),
-                /* weight */ 10);
-        assertTrue(mManager.setDynamicShortcuts(list(s2_1)));
-        dumpsysOnLogcat();
-
-        // Pin some.
-        setCaller(LAUNCHER_1);
-
-        mLauncherApps.pinShortcuts(CALLING_PACKAGE_1,
-                list("s2"), getCallingUser());
-
-        dumpsysOnLogcat();
-
-        // Delete some.
-        setCaller(CALLING_PACKAGE_1);
-        assertShortcutIds(mManager.getPinnedShortcuts(), "s2");
-        mManager.removeDynamicShortcuts(list("s2"));
-        assertShortcutIds(mManager.getPinnedShortcuts(), "s2");
-
-        dumpsysOnLogcat();
-
-        setCaller(LAUNCHER_1);
-        List<ShortcutInfo> list;
-
-        // Note we don't guarantee the orders.
-        list = assertShortcutIds(assertAllHaveTitle(assertAllNotHaveIntents(
-                assertAllNotKeyFieldsOnly(
-                        mLauncherApps.getShortcutInfo(CALLING_PACKAGE_1,
-                                list("s2", "s1", "s3", null), getCallingUser())))),
-                "s1", "s2");
-        assertEquals("Title 1", findById(list, "s1").getTitle());
-        assertEquals("Title 2", findById(list, "s2").getTitle());
-
-        assertShortcutIds(assertAllHaveTitle(assertAllNotHaveIntents(
-                mLauncherApps.getShortcutInfo(CALLING_PACKAGE_1,
-                        list("s3"), getCallingUser())))
-                /* none */);
-
-        list = assertShortcutIds(assertAllHaveTitle(assertAllNotHaveIntents(
-                mLauncherApps.getShortcutInfo(CALLING_PACKAGE_2,
-                        list("s1", "s2", "s3"), getCallingUser()))),
-                "s1");
-        assertEquals("ABC", findById(list, "s1").getTitle());
-    }
-
-    public void testPinShortcutAndGetPinnedShortcuts() {
-        runWithCaller(CALLING_PACKAGE_1, USER_0, () -> {
-            final ShortcutInfo s1_1 = makeShortcutWithTimestamp("s1", 1000);
-            final ShortcutInfo s1_2 = makeShortcutWithTimestamp("s2", 2000);
-
-            assertTrue(mManager.setDynamicShortcuts(list(s1_1, s1_2)));
-        });
-
-        runWithCaller(CALLING_PACKAGE_2, USER_0, () -> {
-            final ShortcutInfo s2_2 = makeShortcutWithTimestamp("s2", 1500);
-            final ShortcutInfo s2_3 = makeShortcutWithTimestamp("s3", 3000);
-            final ShortcutInfo s2_4 = makeShortcutWithTimestamp("s4", 500);
-            assertTrue(mManager.setDynamicShortcuts(list(s2_2, s2_3, s2_4)));
-        });
-
-        runWithCaller(CALLING_PACKAGE_3, USER_0, () -> {
-            final ShortcutInfo s3_2 = makeShortcutWithTimestamp("s2", 1000);
-            assertTrue(mManager.setDynamicShortcuts(list(s3_2)));
-        });
-
-        // Pin some.
-        runWithCaller(LAUNCHER_1, USER_0, () -> {
-            mLauncherApps.pinShortcuts(CALLING_PACKAGE_1,
-                    list("s2", "s3"), getCallingUser());
-
-            mLauncherApps.pinShortcuts(CALLING_PACKAGE_2,
-                    list("s3", "s4", "s5"), getCallingUser());
-
-            mLauncherApps.pinShortcuts(CALLING_PACKAGE_3,
-                    list("s3"), getCallingUser());  // Note ID doesn't exist
-        });
-
-        // Delete some.
-        runWithCaller(CALLING_PACKAGE_1, USER_0, () -> {
-            assertShortcutIds(mManager.getPinnedShortcuts(), "s2");
-            mManager.removeDynamicShortcuts(list("s2"));
-            assertShortcutIds(mManager.getPinnedShortcuts(), "s2");
-
-            assertShortcutIds(mManager.getDynamicShortcuts(), "s1");
-        });
-
-        runWithCaller(CALLING_PACKAGE_2, USER_0, () -> {
-            assertShortcutIds(mManager.getPinnedShortcuts(), "s3", "s4");
-            mManager.removeDynamicShortcuts(list("s3"));
-            assertShortcutIds(mManager.getPinnedShortcuts(), "s3", "s4");
-
-            assertShortcutIds(mManager.getDynamicShortcuts(), "s2", "s4");
-        });
-
-        runWithCaller(CALLING_PACKAGE_3, USER_0, () -> {
-            assertShortcutIds(mManager.getPinnedShortcuts() /* none */);
-            mManager.removeDynamicShortcuts(list("s2"));
-            assertShortcutIds(mManager.getPinnedShortcuts() /* none */);
-
-            assertEmpty(mManager.getDynamicShortcuts());
-        });
-
-        // Get pinned shortcuts from launcher
-        runWithCaller(LAUNCHER_1, USER_0, () -> {
-            // CALLING_PACKAGE_1 deleted s2, but it's pinned, so it still exists.
-            assertShortcutIds(assertAllPinned(assertAllNotKeyFieldsOnly(assertAllEnabled(
-                    mLauncherApps.getShortcuts(buildQuery(/* time =*/ 0, CALLING_PACKAGE_1,
-                    /* activity =*/ null, ShortcutQuery.FLAG_GET_PINNED), getCallingUser())))),
-                    "s2");
-
-            assertShortcutIds(assertAllPinned(assertAllNotKeyFieldsOnly(assertAllEnabled(
-                    mLauncherApps.getShortcuts(buildQuery(/* time =*/ 0, CALLING_PACKAGE_2,
-                    /* activity =*/ null, ShortcutQuery.FLAG_GET_PINNED), getCallingUser())))),
-                    "s3", "s4");
-
-            assertShortcutIds(assertAllPinned(assertAllNotKeyFieldsOnly(assertAllEnabled(
-                    mLauncherApps.getShortcuts(buildQuery(/* time =*/ 0, CALLING_PACKAGE_3,
-                    /* activity =*/ null, ShortcutQuery.FLAG_GET_PINNED), getCallingUser()))))
-                    /* none */);
-        });
-    }
-
-    /**
-     * This is similar to the above test, except it used "disable" instead of "remove".  It also
-     * does "enable".
-     */
-    public void testDisableAndEnableShortcuts() {
-        runWithCaller(CALLING_PACKAGE_1, USER_0, () -> {
-            final ShortcutInfo s1_1 = makeShortcutWithTimestamp("s1", 1000);
-            final ShortcutInfo s1_2 = makeShortcutWithTimestamp("s2", 2000);
-
-            assertTrue(mManager.setDynamicShortcuts(list(s1_1, s1_2)));
-        });
-
-        runWithCaller(CALLING_PACKAGE_2, USER_0, () -> {
-            final ShortcutInfo s2_2 = makeShortcutWithTimestamp("s2", 1500);
-            final ShortcutInfo s2_3 = makeShortcutWithTimestamp("s3", 3000);
-            final ShortcutInfo s2_4 = makeShortcutWithTimestamp("s4", 500);
-            assertTrue(mManager.setDynamicShortcuts(list(s2_2, s2_3, s2_4)));
-        });
-
-        runWithCaller(CALLING_PACKAGE_3, USER_0, () -> {
-            final ShortcutInfo s3_2 = makeShortcutWithTimestamp("s2", 1000);
-            assertTrue(mManager.setDynamicShortcuts(list(s3_2)));
-        });
-
-        // Pin some.
-        runWithCaller(LAUNCHER_1, USER_0, () -> {
-            mLauncherApps.pinShortcuts(CALLING_PACKAGE_1,
-                    list("s2", "s3"), getCallingUser());
-
-            mLauncherApps.pinShortcuts(CALLING_PACKAGE_2,
-                    list("s3", "s4", "s5"), getCallingUser());
-
-            mLauncherApps.pinShortcuts(CALLING_PACKAGE_3,
-                    list("s3"), getCallingUser());  // Note ID doesn't exist
-        });
-
-        // Disable some.
-        runWithCaller(CALLING_PACKAGE_1, USER_0, () -> {
-            assertShortcutIds(mManager.getPinnedShortcuts(), "s2");
-
-            mManager.disableShortcuts(list("s2"));
-
-            assertShortcutIds(mManager.getPinnedShortcuts(), "s2");
-            assertShortcutIds(mManager.getDynamicShortcuts(), "s1");
-        });
-
-        runWithCaller(CALLING_PACKAGE_2, USER_0, () -> {
-            assertShortcutIds(mManager.getPinnedShortcuts(), "s3", "s4");
-
-            // disable should work even if a shortcut is not dynamic, so try calling "remove" first
-            // here.
-            mManager.removeDynamicShortcuts(list("s3"));
-            mManager.disableShortcuts(list("s3"));
-
-            assertShortcutIds(mManager.getPinnedShortcuts(), "s3", "s4");
-            assertShortcutIds(mManager.getDynamicShortcuts(), "s2", "s4");
-        });
-
-        runWithCaller(CALLING_PACKAGE_3, USER_0, () -> {
-            assertShortcutIds(mManager.getPinnedShortcuts() /* none */);
-
-            mManager.disableShortcuts(list("s2"));
-
-            assertShortcutIds(mManager.getPinnedShortcuts() /* none */);
-
-            assertEmpty(mManager.getDynamicShortcuts());
-            assertEmpty(getCallerShortcuts());
-        });
-
-        // Get pinned shortcuts from launcher
-        runWithCaller(LAUNCHER_1, USER_0, () -> {
-            // CALLING_PACKAGE_1 deleted s2, but it's pinned, so it still exists, and disabled.
-            assertWith(mLauncherApps.getShortcuts(buildQuery(/* time =*/ 0, CALLING_PACKAGE_1,
-                    /* activity =*/ null, ShortcutQuery.FLAG_GET_PINNED), getCallingUser()))
-                    .haveIds("s2")
-                    .areAllPinned()
-                    .areAllNotWithKeyFieldsOnly()
-                    .areAllDisabled();
-            assertStartShortcutThrowsException(CALLING_PACKAGE_1, "s2", USER_0,
-                    ActivityNotFoundException.class);
-
-            // Here, s4 is still enabled and launchable, but s3 is disabled.
-            assertWith(mLauncherApps.getShortcuts(buildQuery(/* time =*/ 0, CALLING_PACKAGE_2,
-                    /* activity =*/ null, ShortcutQuery.FLAG_GET_PINNED), getCallingUser()))
-                    .haveIds("s3", "s4")
-                    .areAllPinned()
-                    .areAllNotWithKeyFieldsOnly()
-
-                    .selectByIds("s3")
-                    .areAllDisabled()
-
-                    .revertToOriginalList()
-                    .selectByIds("s4")
-                    .areAllEnabled();
-
-            assertStartShortcutThrowsException(CALLING_PACKAGE_2, "s3", USER_0,
-                    ActivityNotFoundException.class);
-            assertShortcutLaunchable(CALLING_PACKAGE_2, "s4", USER_0);
-
-            assertShortcutIds(assertAllPinned(assertAllNotKeyFieldsOnly(assertAllEnabled(
-                    mLauncherApps.getShortcuts(buildQuery(/* time =*/ 0, CALLING_PACKAGE_3,
-                    /* activity =*/ null, ShortcutQuery.FLAG_GET_PINNED), getCallingUser()))))
-                    /* none */);
-        });
-
-        runWithCaller(CALLING_PACKAGE_1, USER_0, () -> {
-            mManager.enableShortcuts(list("s2"));
-
-            assertShortcutIds(mManager.getPinnedShortcuts(), "s2");
-            assertShortcutIds(mManager.getDynamicShortcuts(), "s1");
-        });
-        runWithCaller(LAUNCHER_1, USER_0, () -> {
-            // CALLING_PACKAGE_1 deleted s2, but it's pinned, so it still exists.
-            assertShortcutIds(assertAllPinned(assertAllNotKeyFieldsOnly(assertAllEnabled(
-                    mLauncherApps.getShortcuts(buildQuery(/* time =*/ 0, CALLING_PACKAGE_1,
-                    /* activity =*/ null, ShortcutQuery.FLAG_GET_PINNED), getCallingUser())))),
-                    "s2");
-            assertShortcutLaunchable(CALLING_PACKAGE_1, "s2", USER_0);
-        });
-    }
-
-    public void testDisableShortcuts_thenRepublish() {
-        runWithCaller(CALLING_PACKAGE_1, USER_0, () -> {
-            assertTrue(mManager.setDynamicShortcuts(list(
-                    makeShortcut("s1"), makeShortcut("s2"), makeShortcut("s3"))));
-
-            runWithCaller(LAUNCHER_1, USER_0, () -> {
-                mLauncherApps.pinShortcuts(
-                        CALLING_PACKAGE_1, list("s1", "s2", "s3"), HANDLE_USER_0);
-            });
-
-            mManager.disableShortcuts(list("s1", "s2", "s3"));
-
-            assertWith(getCallerShortcuts())
-                    .haveIds("s1", "s2", "s3")
-                    .areAllNotDynamic()
-                    .areAllPinned()
-                    .areAllDisabled();
-
-            // Make sure updateShortcuts() will not re-enable them.
-            assertTrue(mManager.updateShortcuts(list(
-                    makeShortcut("s1"), makeShortcut("s2"), makeShortcut("s3"))));
-
-            assertWith(getCallerShortcuts())
-                    .haveIds("s1", "s2", "s3")
-                    .areAllNotDynamic()
-                    .areAllPinned()
-                    .areAllDisabled();
-
-            // Re-publish s1 with setDynamicShortcuts.
-            mInjectedCurrentTimeMillis += INTERVAL; // reset throttling
-
-            assertTrue(mManager.setDynamicShortcuts(list(
-                    makeShortcut("s1"))));
-
-            assertWith(getCallerShortcuts())
-                    .haveIds("s1", "s2", "s3")
-
-                    .selectByIds("s1")
-                    .areAllDynamic()
-                    .areAllPinned()
-                    .areAllEnabled()
-
-                    .revertToOriginalList()
-                    .selectByIds("s2", "s3")
-                    .areAllNotDynamic()
-                    .areAllPinned()
-                    .areAllDisabled();
-
-            // Re-publish s2 with addDynamicShortcuts.
-            mInjectedCurrentTimeMillis += INTERVAL; // reset throttling
-
-            assertTrue(mManager.addDynamicShortcuts(list(
-                    makeShortcut("s2"))));
-
-            assertWith(getCallerShortcuts())
-                    .haveIds("s1", "s2", "s3")
-
-                    .selectByIds("s1", "s2")
-                    .areAllDynamic()
-                    .areAllPinned()
-                    .areAllEnabled()
-
-                    .revertToOriginalList()
-                    .selectByIds("s3")
-                    .areAllNotDynamic()
-                    .areAllPinned()
-                    .areAllDisabled();
-        });
-    }
-
-    public void testPinShortcutAndGetPinnedShortcuts_multi() {
-        // Create some shortcuts.
-        runWithCaller(CALLING_PACKAGE_1, USER_0, () -> {
-            assertTrue(mManager.setDynamicShortcuts(list(
-                    makeShortcut("s1"), makeShortcut("s2"), makeShortcut("s3"))));
-        });
-
-        runWithCaller(CALLING_PACKAGE_2, USER_0, () -> {
-            assertTrue(mManager.setDynamicShortcuts(list(
-                    makeShortcut("s1"), makeShortcut("s2"), makeShortcut("s3"))));
-        });
-
-        dumpsysOnLogcat();
-
-        // Pin some.
-        runWithCaller(LAUNCHER_1, USER_0, () -> {
-            mLauncherApps.pinShortcuts(CALLING_PACKAGE_1,
-                    list("s3", "s4"), getCallingUser());
-
-            mLauncherApps.pinShortcuts(CALLING_PACKAGE_2,
-                    list("s1", "s2", "s4"), getCallingUser());
-        });
-
-        dumpsysOnLogcat();
-
-        // Delete some.
-        runWithCaller(CALLING_PACKAGE_1, USER_0, () -> {
-            assertShortcutIds(mManager.getPinnedShortcuts(), "s3");
-            mManager.removeDynamicShortcuts(list("s3"));
-            assertShortcutIds(mManager.getPinnedShortcuts(), "s3");
-        });
-
-        dumpsysOnLogcat();
-
-        runWithCaller(CALLING_PACKAGE_2, USER_0, () -> {
-            assertShortcutIds(mManager.getPinnedShortcuts(), "s1", "s2");
-            mManager.removeDynamicShortcuts(list("s1"));
-            mManager.removeDynamicShortcuts(list("s3"));
-            assertShortcutIds(mManager.getPinnedShortcuts(), "s1", "s2");
-        });
-
-        dumpsysOnLogcat();
-
-        // Get pinned shortcuts from launcher
-        runWithCaller(LAUNCHER_1, USER_0, () -> {
-            assertShortcutIds(assertAllPinned(assertAllNotKeyFieldsOnly(
-                    mLauncherApps.getShortcuts(buildQuery(/* time =*/ 0, CALLING_PACKAGE_1,
-                    /* activity =*/ null, ShortcutQuery.FLAG_GET_PINNED), getCallingUser()))),
-                    "s3");
-
-            assertShortcutIds(assertAllPinned(assertAllNotKeyFieldsOnly(
-                    mLauncherApps.getShortcuts(buildQuery(/* time =*/ 0, CALLING_PACKAGE_2,
-                    /* activity =*/ null, ShortcutQuery.FLAG_GET_PINNED), getCallingUser()))),
-                    "s1", "s2");
-
-            assertShortcutIds(assertAllDynamicOrPinned(
-                    mLauncherApps.getShortcuts(buildQuery(/* time =*/ 0, CALLING_PACKAGE_1,
-                    /* activity =*/ null, ShortcutQuery.FLAG_GET_PINNED
-                                    | ShortcutQuery.FLAG_GET_DYNAMIC), getCallingUser())),
-                    "s1", "s2", "s3");
-
-            assertShortcutIds(assertAllDynamicOrPinned(
-                    mLauncherApps.getShortcuts(buildQuery(/* time =*/ 0, CALLING_PACKAGE_2,
-                    /* activity =*/ null, ShortcutQuery.FLAG_GET_PINNED
-                                    | ShortcutQuery.FLAG_GET_DYNAMIC), getCallingUser())),
-                    "s1", "s2");
-        });
-
-        dumpsysOnLogcat();
-
-        runWithCaller(LAUNCHER_2, USER_0, () -> {
-            // Launcher2 still has no pinned ones.
-            assertShortcutIds(assertAllPinned(assertAllNotKeyFieldsOnly(
-                    mLauncherApps.getShortcuts(buildQuery(/* time =*/ 0, CALLING_PACKAGE_1,
-                    /* activity =*/ null, ShortcutQuery.FLAG_GET_PINNED), getCallingUser())))
-                    /* none */);
-            assertShortcutIds(assertAllPinned(assertAllNotKeyFieldsOnly(
-                    mLauncherApps.getShortcuts(buildQuery(/* time =*/ 0, CALLING_PACKAGE_2,
-                    /* activity =*/ null, ShortcutQuery.FLAG_GET_PINNED), getCallingUser())))
-                    /* none */);
-
-            assertShortcutIds(assertAllDynamic(
-                    mLauncherApps.getShortcuts(buildQuery(/* time =*/ 0, CALLING_PACKAGE_1,
-                    /* activity =*/ null, ShortcutQuery.FLAG_GET_PINNED
-                                    | ShortcutQuery.FLAG_GET_DYNAMIC), getCallingUser())),
-                    "s1", "s2");
-            assertShortcutIds(assertAllDynamic(
-                    mLauncherApps.getShortcuts(buildQuery(/* time =*/ 0, CALLING_PACKAGE_2,
-                    /* activity =*/ null, ShortcutQuery.FLAG_GET_PINNED
-                                    | ShortcutQuery.FLAG_GET_DYNAMIC), getCallingUser())),
-                    "s2");
-
-            // Now pin some.
-            mLauncherApps.pinShortcuts(CALLING_PACKAGE_1,
-                    list("s1", "s2"), getCallingUser());
-
-            mLauncherApps.pinShortcuts(CALLING_PACKAGE_2,
-                    list("s1", "s2"), getCallingUser());
-
-            assertShortcutIds(assertAllDynamic(
-                    mLauncherApps.getShortcuts(buildQuery(/* time =*/ 0, CALLING_PACKAGE_1,
-                    /* activity =*/ null, ShortcutQuery.FLAG_GET_PINNED
-                                    | ShortcutQuery.FLAG_GET_DYNAMIC), getCallingUser())),
-                    "s1", "s2");
-
-            // S1 was not visible to it, so shouldn't be pinned.
-            assertShortcutIds(assertAllDynamic(
-                    mLauncherApps.getShortcuts(buildQuery(/* time =*/ 0, CALLING_PACKAGE_2,
-                    /* activity =*/ null, ShortcutQuery.FLAG_GET_PINNED
-                                    | ShortcutQuery.FLAG_GET_DYNAMIC), getCallingUser())),
-                    "s2");
-        });
-
-        // Re-initialize and load from the files.
-        mService.saveDirtyInfo();
-        initService();
-
-        // Load from file.
-        mService.handleUnlockUser(USER_0);
-
-        // Make sure package info is restored too.
-        runWithCaller(LAUNCHER_1, USER_0, () -> {
-            assertShortcutIds(assertAllPinned(assertAllNotKeyFieldsOnly(
-                    mLauncherApps.getShortcuts(buildQuery(/* time =*/ 0, CALLING_PACKAGE_1,
-                    /* activity =*/ null, ShortcutQuery.FLAG_GET_PINNED), getCallingUser()))),
-                    "s3");
-            assertShortcutIds(assertAllPinned(assertAllNotKeyFieldsOnly(
-                    mLauncherApps.getShortcuts(buildQuery(/* time =*/ 0, CALLING_PACKAGE_2,
-                    /* activity =*/ null, ShortcutQuery.FLAG_GET_PINNED), getCallingUser()))),
-                    "s1", "s2");
-        });
-        runWithCaller(LAUNCHER_2, USER_0, () -> {
-            assertShortcutIds(assertAllDynamic(
-                    mLauncherApps.getShortcuts(buildQuery(/* time =*/ 0, CALLING_PACKAGE_1,
-                    /* activity =*/ null, ShortcutQuery.FLAG_GET_PINNED
-                                    | ShortcutQuery.FLAG_GET_DYNAMIC), getCallingUser())),
-                    "s1", "s2");
-            assertShortcutIds(assertAllDynamic(
-                    mLauncherApps.getShortcuts(buildQuery(/* time =*/ 0, CALLING_PACKAGE_2,
-                    /* activity =*/ null, ShortcutQuery.FLAG_GET_PINNED
-                                    | ShortcutQuery.FLAG_GET_DYNAMIC), getCallingUser())),
-                    "s2");
-        });
-
-        // Delete all dynamic.
-        runWithCaller(CALLING_PACKAGE_1, USER_0, () -> {
-            mManager.removeAllDynamicShortcuts();
-
-            assertEquals(0, mManager.getDynamicShortcuts().size());
-            assertShortcutIds(assertAllPinned(mManager.getPinnedShortcuts()), "s1", "s2", "s3");
-        });
-        runWithCaller(CALLING_PACKAGE_2, USER_0, () -> {
-            mManager.removeAllDynamicShortcuts();
-
-            assertEquals(0, mManager.getDynamicShortcuts().size());
-            assertShortcutIds(assertAllPinned(mManager.getPinnedShortcuts()), "s2", "s1");
-        });
-
-        runWithCaller(LAUNCHER_1, USER_0, () -> {
-            assertShortcutIds(assertAllPinned(assertAllNotKeyFieldsOnly(
-                    mLauncherApps.getShortcuts(buildQuery(/* time =*/ 0, CALLING_PACKAGE_1,
-                    /* activity =*/ null, ShortcutQuery.FLAG_GET_PINNED), getCallingUser()))),
-                    "s3");
-
-            assertShortcutIds(assertAllPinned(assertAllNotKeyFieldsOnly(
-                    mLauncherApps.getShortcuts(buildQuery(/* time =*/ 0, CALLING_PACKAGE_2,
-                    /* activity =*/ null, ShortcutQuery.FLAG_GET_PINNED), getCallingUser()))),
-                    "s1", "s2");
-
-            // from all packages.
-            assertShortcutIds(assertAllPinned(assertAllNotKeyFieldsOnly(
-                    mLauncherApps.getShortcuts(buildQuery(/* time =*/ 0, null,
-                    /* activity =*/ null, ShortcutQuery.FLAG_GET_PINNED), getCallingUser()))),
-                    "s1", "s2", "s3");
-
-            // Update pined.  Note s2 and s3 are actually available, but not visible to this
-            // launcher, so still can't be pinned.
-            mLauncherApps.pinShortcuts(CALLING_PACKAGE_1, list("s1", "s2", "s3", "s4"),
-                    getCallingUser());
-
-            assertShortcutIds(assertAllPinned(assertAllNotKeyFieldsOnly(
-                    mLauncherApps.getShortcuts(buildQuery(/* time =*/ 0, CALLING_PACKAGE_1,
-                    /* activity =*/ null, ShortcutQuery.FLAG_GET_PINNED), getCallingUser()))),
-                    "s3");
-        });
-        // Re-publish s1.
-        runWithCaller(CALLING_PACKAGE_1, USER_0, () -> {
-            assertTrue(mManager.addDynamicShortcuts(list(makeShortcut("s1"))));
-
-            assertShortcutIds(assertAllDynamic(mManager.getDynamicShortcuts()), "s1");
-            assertShortcutIds(assertAllPinned(mManager.getPinnedShortcuts()), "s1", "s2", "s3");
-        });
-        runWithCaller(LAUNCHER_1, USER_0, () -> {
-            assertShortcutIds(assertAllPinned(assertAllNotKeyFieldsOnly(
-                    mLauncherApps.getShortcuts(buildQuery(/* time =*/ 0, CALLING_PACKAGE_1,
-                    /* activity =*/ null, ShortcutQuery.FLAG_GET_PINNED), getCallingUser()))),
-                    "s3");
-
-            // Now "s1" is visible, so can be pinned.
-            mLauncherApps.pinShortcuts(CALLING_PACKAGE_1, list("s1", "s2", "s3", "s4"),
-                    getCallingUser());
-
-            assertShortcutIds(assertAllPinned(assertAllNotKeyFieldsOnly(
-                    mLauncherApps.getShortcuts(buildQuery(/* time =*/ 0, CALLING_PACKAGE_1,
-                    /* activity =*/ null, ShortcutQuery.FLAG_GET_PINNED), getCallingUser()))),
-                    "s1", "s3");
-        });
-
-        // Now clear pinned shortcuts.  First, from launcher 1.
-        runWithCaller(LAUNCHER_1, USER_0, () -> {
-            mLauncherApps.pinShortcuts(CALLING_PACKAGE_1, list(), getCallingUser());
-            mLauncherApps.pinShortcuts(CALLING_PACKAGE_2, list(), getCallingUser());
-
-            assertEquals(0,
-                    mLauncherApps.getShortcuts(buildQuery(/* time =*/ 0, CALLING_PACKAGE_1,
-                    /* activity =*/ null, ShortcutQuery.FLAG_GET_PINNED), getCallingUser()).size());
-            assertEquals(0,
-                    mLauncherApps.getShortcuts(buildQuery(/* time =*/ 0, CALLING_PACKAGE_2,
-                    /* activity =*/ null, ShortcutQuery.FLAG_GET_PINNED), getCallingUser()).size());
-        });
-        runWithCaller(CALLING_PACKAGE_1, USER_0, () -> {
-            assertShortcutIds(assertAllDynamic(mManager.getDynamicShortcuts()), "s1");
-            assertShortcutIds(assertAllPinned(mManager.getPinnedShortcuts()), "s1", "s2");
-        });
-        runWithCaller(CALLING_PACKAGE_2, USER_0, () -> {
-            assertEquals(0, mManager.getDynamicShortcuts().size());
-            assertShortcutIds(assertAllPinned(mManager.getPinnedShortcuts()), "s2");
-        });
-
-        // Clear all pins from launcher 2.
-        runWithCaller(LAUNCHER_2, USER_0, () -> {
-            mLauncherApps.pinShortcuts(CALLING_PACKAGE_1, list(), getCallingUser());
-            mLauncherApps.pinShortcuts(CALLING_PACKAGE_2, list(), getCallingUser());
-
-            assertEquals(0,
-                    mLauncherApps.getShortcuts(buildQuery(/* time =*/ 0, CALLING_PACKAGE_1,
-                    /* activity =*/ null, ShortcutQuery.FLAG_GET_PINNED), getCallingUser()).size());
-            assertEquals(0,
-                    mLauncherApps.getShortcuts(buildQuery(/* time =*/ 0, CALLING_PACKAGE_2,
-                    /* activity =*/ null, ShortcutQuery.FLAG_GET_PINNED), getCallingUser()).size());
-        });
-        runWithCaller(CALLING_PACKAGE_1, USER_0, () -> {
-            assertShortcutIds(assertAllDynamic(mManager.getDynamicShortcuts()), "s1");
-            assertEquals(0, mManager.getPinnedShortcuts().size());
-        });
-        runWithCaller(CALLING_PACKAGE_2, USER_0, () -> {
-            assertEquals(0, mManager.getDynamicShortcuts().size());
-            assertEquals(0, mManager.getPinnedShortcuts().size());
-        });
-    }
-
-    public void testPinShortcutAndGetPinnedShortcuts_crossProfile_plusLaunch() {
-        // Create some shortcuts.
-        runWithCaller(CALLING_PACKAGE_1, USER_0, () -> {
-            assertTrue(mManager.setDynamicShortcuts(list(
-                    makeShortcut("s1"), makeShortcut("s2"), makeShortcut("s3"))));
-        });
-        runWithCaller(CALLING_PACKAGE_2, USER_0, () -> {
-            assertTrue(mManager.setDynamicShortcuts(list(
-                    makeShortcut("s1"), makeShortcut("s2"), makeShortcut("s3"))));
-        });
-
-        mRunningUsers.put(USER_10, true);
-
-        runWithCaller(CALLING_PACKAGE_1, USER_10, () -> {
-            assertTrue(mManager.setDynamicShortcuts(list(
-                    makeShortcut("s1"), makeShortcut("s2"), makeShortcut("s3"),
-                    makeShortcut("s4"), makeShortcut("s5"), makeShortcut("s6"))));
-        });
-
-        // Pin some shortcuts and see the result.
-
-        runWithCaller(LAUNCHER_1, USER_0, () -> {
-            mLauncherApps.pinShortcuts(CALLING_PACKAGE_1,
-                    list("s1"), HANDLE_USER_0);
-
-            mLauncherApps.pinShortcuts(CALLING_PACKAGE_2,
-                    list("s1", "s2", "s3"), HANDLE_USER_0);
-        });
-
-        runWithCaller(LAUNCHER_1, USER_P0, () -> {
-            mLauncherApps.pinShortcuts(CALLING_PACKAGE_1,
-                    list("s2"), HANDLE_USER_0);
-
-            mLauncherApps.pinShortcuts(CALLING_PACKAGE_2,
-                    list("s2", "s3"), HANDLE_USER_0);
-        });
-
-        runWithCaller(LAUNCHER_2, USER_P0, () -> {
-            mLauncherApps.pinShortcuts(CALLING_PACKAGE_1,
-                    list("s3"), HANDLE_USER_0);
-
-            mLauncherApps.pinShortcuts(CALLING_PACKAGE_2,
-                    list("s3"), HANDLE_USER_0);
-        });
-
-        runWithCaller(LAUNCHER_2, USER_10, () -> {
-            mLauncherApps.pinShortcuts(CALLING_PACKAGE_1,
-                    list("s1", "s2", "s3"), HANDLE_USER_10);
-        });
-
-        // Cross profile pinning.
-        final int PIN_AND_DYNAMIC = ShortcutQuery.FLAG_GET_PINNED | ShortcutQuery.FLAG_GET_DYNAMIC;
-
-        runWithCaller(LAUNCHER_1, USER_0, () -> {
-            assertShortcutIds(assertAllPinned(
-                    mLauncherApps.getShortcuts(buildQuery(/* time =*/ 0, CALLING_PACKAGE_1,
-                    /* activity =*/ null, ShortcutQuery.FLAG_GET_PINNED), HANDLE_USER_0)),
-                    "s1");
-            assertShortcutIds(assertAllDynamic(
-                    mLauncherApps.getShortcuts(buildQuery(/* time =*/ 0, CALLING_PACKAGE_1,
-                    /* activity =*/ null, ShortcutQuery.FLAG_GET_DYNAMIC), HANDLE_USER_0)),
-                    "s1", "s2", "s3");
-            assertShortcutIds(assertAllDynamicOrPinned(
-                    mLauncherApps.getShortcuts(buildQuery(/* time =*/ 0, CALLING_PACKAGE_1,
-                    /* activity =*/ null, PIN_AND_DYNAMIC), HANDLE_USER_0)),
-                    "s1", "s2", "s3");
-
-            assertShortcutIds(assertAllPinned(
-                    mLauncherApps.getShortcuts(buildQuery(/* time =*/ 0, CALLING_PACKAGE_2,
-                    /* activity =*/ null, ShortcutQuery.FLAG_GET_PINNED), HANDLE_USER_0)),
-                    "s1", "s2", "s3");
-            assertShortcutIds(assertAllDynamic(
-                    mLauncherApps.getShortcuts(buildQuery(/* time =*/ 0, CALLING_PACKAGE_2,
-                    /* activity =*/ null, ShortcutQuery.FLAG_GET_DYNAMIC), HANDLE_USER_0)),
-                    "s1", "s2", "s3");
-            assertShortcutIds(assertAllDynamicOrPinned(
-                    mLauncherApps.getShortcuts(buildQuery(/* time =*/ 0, CALLING_PACKAGE_2,
-                    /* activity =*/ null, PIN_AND_DYNAMIC), HANDLE_USER_0)),
-                    "s1", "s2", "s3");
-
-            assertShortcutLaunchable(CALLING_PACKAGE_1, "s1", USER_0);
-            assertShortcutLaunchable(CALLING_PACKAGE_1, "s2", USER_0);
-            assertShortcutLaunchable(CALLING_PACKAGE_1, "s3", USER_0);
-
-            assertShortcutLaunchable(CALLING_PACKAGE_2, "s1", USER_0);
-            assertShortcutLaunchable(CALLING_PACKAGE_2, "s2", USER_0);
-            assertShortcutLaunchable(CALLING_PACKAGE_2, "s3", USER_0);
-
-            assertStartShortcutThrowsException(CALLING_PACKAGE_1, "s1", USER_10,
-                    SecurityException.class);
-            assertStartShortcutThrowsException(CALLING_PACKAGE_1, "s2", USER_10,
-                    SecurityException.class);
-            assertStartShortcutThrowsException(CALLING_PACKAGE_1, "s3", USER_10,
-                    SecurityException.class);
-            assertStartShortcutThrowsException(CALLING_PACKAGE_1, "s4", USER_10,
-                    SecurityException.class);
-            assertStartShortcutThrowsException(CALLING_PACKAGE_1, "s5", USER_10,
-                    SecurityException.class);
-            assertStartShortcutThrowsException(CALLING_PACKAGE_1, "s6", USER_10,
-                    SecurityException.class);
-        });
-        runWithCaller(LAUNCHER_1, USER_P0, () -> {
-            assertShortcutIds(assertAllPinned(
-                    mLauncherApps.getShortcuts(buildQuery(/* time =*/ 0, CALLING_PACKAGE_1,
-                    /* activity =*/ null, ShortcutQuery.FLAG_GET_PINNED), HANDLE_USER_0)),
-                    "s2");
-            assertShortcutIds(assertAllDynamic(
-                    mLauncherApps.getShortcuts(buildQuery(/* time =*/ 0, CALLING_PACKAGE_1,
-                    /* activity =*/ null, ShortcutQuery.FLAG_GET_DYNAMIC), HANDLE_USER_0)),
-                    "s1", "s2", "s3");
-            assertShortcutIds(assertAllDynamicOrPinned(
-                    mLauncherApps.getShortcuts(buildQuery(/* time =*/ 0, CALLING_PACKAGE_1,
-                    /* activity =*/ null, PIN_AND_DYNAMIC), HANDLE_USER_0)),
-                    "s1", "s2", "s3");
-
-            assertShortcutIds(assertAllPinned(
-                    mLauncherApps.getShortcuts(buildQuery(/* time =*/ 0, CALLING_PACKAGE_2,
-                    /* activity =*/ null, ShortcutQuery.FLAG_GET_PINNED), HANDLE_USER_0)),
-                    "s2", "s3");
-            assertShortcutIds(assertAllDynamic(
-                    mLauncherApps.getShortcuts(buildQuery(/* time =*/ 0, CALLING_PACKAGE_2,
-                    /* activity =*/ null, ShortcutQuery.FLAG_GET_DYNAMIC), HANDLE_USER_0)),
-                    "s1", "s2", "s3");
-            assertShortcutIds(assertAllDynamicOrPinned(
-                    mLauncherApps.getShortcuts(buildQuery(/* time =*/ 0, CALLING_PACKAGE_2,
-                    /* activity =*/ null, PIN_AND_DYNAMIC), HANDLE_USER_0)),
-                    "s1", "s2", "s3");
-
-            assertShortcutLaunchable(CALLING_PACKAGE_1, "s1", USER_0);
-            assertShortcutLaunchable(CALLING_PACKAGE_1, "s2", USER_0);
-            assertShortcutLaunchable(CALLING_PACKAGE_1, "s3", USER_0);
-
-            assertShortcutLaunchable(CALLING_PACKAGE_2, "s1", USER_0);
-            assertShortcutLaunchable(CALLING_PACKAGE_2, "s2", USER_0);
-            assertShortcutLaunchable(CALLING_PACKAGE_2, "s3", USER_0);
-
-            assertStartShortcutThrowsException(CALLING_PACKAGE_1, "s1", USER_10,
-                    SecurityException.class);
-            assertStartShortcutThrowsException(CALLING_PACKAGE_1, "s2", USER_10,
-                    SecurityException.class);
-            assertStartShortcutThrowsException(CALLING_PACKAGE_1, "s3", USER_10,
-                    SecurityException.class);
-            assertStartShortcutThrowsException(CALLING_PACKAGE_1, "s4", USER_10,
-                    SecurityException.class);
-            assertStartShortcutThrowsException(CALLING_PACKAGE_1, "s5", USER_10,
-                    SecurityException.class);
-            assertStartShortcutThrowsException(CALLING_PACKAGE_1, "s6", USER_10,
-                    SecurityException.class);
-        });
-        runWithCaller(LAUNCHER_2, USER_P0, () -> {
-            assertShortcutIds(assertAllPinned(
-                    mLauncherApps.getShortcuts(buildQuery(/* time =*/ 0, CALLING_PACKAGE_1,
-                    /* activity =*/ null, ShortcutQuery.FLAG_GET_PINNED), HANDLE_USER_0)),
-                    "s3");
-            assertShortcutIds(assertAllDynamic(
-                    mLauncherApps.getShortcuts(buildQuery(/* time =*/ 0, CALLING_PACKAGE_1,
-                    /* activity =*/ null, ShortcutQuery.FLAG_GET_DYNAMIC), HANDLE_USER_0)),
-                    "s1", "s2", "s3");
-            assertShortcutIds(assertAllDynamicOrPinned(
-                    mLauncherApps.getShortcuts(buildQuery(/* time =*/ 0, CALLING_PACKAGE_1,
-                    /* activity =*/ null, PIN_AND_DYNAMIC), HANDLE_USER_0)),
-                    "s1", "s2", "s3");
-
-            assertShortcutIds(assertAllPinned(
-                    mLauncherApps.getShortcuts(buildQuery(/* time =*/ 0, CALLING_PACKAGE_2,
-                    /* activity =*/ null, ShortcutQuery.FLAG_GET_PINNED), HANDLE_USER_0)),
-                    "s3");
-            assertShortcutIds(assertAllDynamic(
-                    mLauncherApps.getShortcuts(buildQuery(/* time =*/ 0, CALLING_PACKAGE_2,
-                    /* activity =*/ null, ShortcutQuery.FLAG_GET_DYNAMIC), HANDLE_USER_0)),
-                    "s1", "s2", "s3");
-            assertShortcutIds(assertAllDynamicOrPinned(
-                    mLauncherApps.getShortcuts(buildQuery(/* time =*/ 0, CALLING_PACKAGE_2,
-                    /* activity =*/ null, PIN_AND_DYNAMIC), HANDLE_USER_0)),
-                    "s1", "s2", "s3");
-
-            assertShortcutLaunchable(CALLING_PACKAGE_1, "s1", USER_0);
-            assertShortcutLaunchable(CALLING_PACKAGE_1, "s2", USER_0);
-            assertShortcutLaunchable(CALLING_PACKAGE_1, "s3", USER_0);
-
-            assertShortcutLaunchable(CALLING_PACKAGE_2, "s1", USER_0);
-            assertShortcutLaunchable(CALLING_PACKAGE_2, "s2", USER_0);
-            assertShortcutLaunchable(CALLING_PACKAGE_2, "s3", USER_0);
-
-            assertStartShortcutThrowsException(CALLING_PACKAGE_1, "s1", USER_10,
-                    SecurityException.class);
-            assertStartShortcutThrowsException(CALLING_PACKAGE_1, "s2", USER_10,
-                    SecurityException.class);
-            assertStartShortcutThrowsException(CALLING_PACKAGE_1, "s3", USER_10,
-                    SecurityException.class);
-            assertStartShortcutThrowsException(CALLING_PACKAGE_1, "s4", USER_10,
-                    SecurityException.class);
-            assertStartShortcutThrowsException(CALLING_PACKAGE_1, "s5", USER_10,
-                    SecurityException.class);
-            assertStartShortcutThrowsException(CALLING_PACKAGE_1, "s6", USER_10,
-                    SecurityException.class);
-        });
-        runWithCaller(LAUNCHER_2, USER_10, () -> {
-            assertShortcutIds(assertAllPinned(
-                    mLauncherApps.getShortcuts(buildQuery(/* time =*/ 0, CALLING_PACKAGE_1,
-                    /* activity =*/ null, ShortcutQuery.FLAG_GET_PINNED), HANDLE_USER_10)),
-                    "s1", "s2", "s3");
-            assertShortcutIds(assertAllDynamic(
-                    mLauncherApps.getShortcuts(buildQuery(/* time =*/ 0, CALLING_PACKAGE_1,
-                    /* activity =*/ null, ShortcutQuery.FLAG_GET_DYNAMIC), HANDLE_USER_10)),
-                    "s1", "s2", "s3", "s4", "s5", "s6");
-            assertShortcutIds(assertAllDynamicOrPinned(
-                    mLauncherApps.getShortcuts(buildQuery(/* time =*/ 0, CALLING_PACKAGE_1,
-                    /* activity =*/ null, PIN_AND_DYNAMIC), HANDLE_USER_10)),
-                    "s1", "s2", "s3", "s4", "s5", "s6");
-        });
-
-        // Remove some dynamic shortcuts.
-
-        runWithCaller(CALLING_PACKAGE_1, USER_0, () -> {
-            assertTrue(mManager.setDynamicShortcuts(list(
-                    makeShortcut("s1"))));
-        });
-        runWithCaller(CALLING_PACKAGE_2, USER_0, () -> {
-            assertTrue(mManager.setDynamicShortcuts(list(
-                    makeShortcut("s1"))));
-        });
-        runWithCaller(CALLING_PACKAGE_1, USER_10, () -> {
-            assertTrue(mManager.setDynamicShortcuts(list(
-                    makeShortcut("s1"))));
-        });
-
-        runWithCaller(LAUNCHER_1, USER_0, () -> {
-            assertShortcutIds(assertAllPinned(
-                    mLauncherApps.getShortcuts(buildQuery(/* time =*/ 0, CALLING_PACKAGE_1,
-                    /* activity =*/ null, ShortcutQuery.FLAG_GET_PINNED), HANDLE_USER_0)),
-                    "s1");
-            assertShortcutIds(assertAllDynamic(
-                    mLauncherApps.getShortcuts(buildQuery(/* time =*/ 0, CALLING_PACKAGE_1,
-                    /* activity =*/ null, ShortcutQuery.FLAG_GET_DYNAMIC), HANDLE_USER_0)),
-                    "s1");
-            assertShortcutIds(assertAllDynamicOrPinned(
-                    mLauncherApps.getShortcuts(buildQuery(/* time =*/ 0, CALLING_PACKAGE_1,
-                    /* activity =*/ null, PIN_AND_DYNAMIC), HANDLE_USER_0)),
-                    "s1");
-
-            assertShortcutIds(assertAllPinned(
-                    mLauncherApps.getShortcuts(buildQuery(/* time =*/ 0, CALLING_PACKAGE_2,
-                    /* activity =*/ null, ShortcutQuery.FLAG_GET_PINNED), HANDLE_USER_0)),
-                    "s1", "s2", "s3");
-            assertShortcutIds(assertAllDynamic(
-                    mLauncherApps.getShortcuts(buildQuery(/* time =*/ 0, CALLING_PACKAGE_2,
-                    /* activity =*/ null, ShortcutQuery.FLAG_GET_DYNAMIC), HANDLE_USER_0)),
-                    "s1");
-            assertShortcutIds(assertAllDynamicOrPinned(
-                    mLauncherApps.getShortcuts(buildQuery(/* time =*/ 0, CALLING_PACKAGE_2,
-                    /* activity =*/ null, PIN_AND_DYNAMIC), HANDLE_USER_0)),
-                    "s1", "s2", "s3");
-
-            assertShortcutLaunchable(CALLING_PACKAGE_1, "s1", USER_0);
-            assertStartShortcutThrowsException(CALLING_PACKAGE_1, "s2", USER_0,
-                    ActivityNotFoundException.class);
-            assertStartShortcutThrowsException(CALLING_PACKAGE_1, "s3", USER_0,
-                    ActivityNotFoundException.class);
-
-            assertShortcutLaunchable(CALLING_PACKAGE_2, "s1", USER_0);
-            assertShortcutLaunchable(CALLING_PACKAGE_2, "s2", USER_0);
-            assertShortcutLaunchable(CALLING_PACKAGE_2, "s3", USER_0);
-
-            assertStartShortcutThrowsException(CALLING_PACKAGE_1, "s1", USER_10,
-                    SecurityException.class);
-            assertStartShortcutThrowsException(CALLING_PACKAGE_1, "s2", USER_10,
-                    SecurityException.class);
-            assertStartShortcutThrowsException(CALLING_PACKAGE_1, "s3", USER_10,
-                    SecurityException.class);
-            assertStartShortcutThrowsException(CALLING_PACKAGE_1, "s4", USER_10,
-                    SecurityException.class);
-            assertStartShortcutThrowsException(CALLING_PACKAGE_1, "s5", USER_10,
-                    SecurityException.class);
-            assertStartShortcutThrowsException(CALLING_PACKAGE_1, "s6", USER_10,
-                    SecurityException.class);
-        });
-        runWithCaller(LAUNCHER_1, USER_P0, () -> {
-            assertShortcutIds(assertAllPinned(
-                    mLauncherApps.getShortcuts(buildQuery(/* time =*/ 0, CALLING_PACKAGE_1,
-                    /* activity =*/ null, ShortcutQuery.FLAG_GET_PINNED), HANDLE_USER_0)),
-                    "s2");
-            assertShortcutIds(assertAllDynamic(
-                    mLauncherApps.getShortcuts(buildQuery(/* time =*/ 0, CALLING_PACKAGE_1,
-                    /* activity =*/ null, ShortcutQuery.FLAG_GET_DYNAMIC), HANDLE_USER_0)),
-                    "s1");
-            assertShortcutIds(assertAllDynamicOrPinned(
-                    mLauncherApps.getShortcuts(buildQuery(/* time =*/ 0, CALLING_PACKAGE_1,
-                    /* activity =*/ null, PIN_AND_DYNAMIC), HANDLE_USER_0)),
-                    "s1", "s2");
-
-            assertShortcutIds(assertAllPinned(
-                    mLauncherApps.getShortcuts(buildQuery(/* time =*/ 0, CALLING_PACKAGE_2,
-                    /* activity =*/ null, ShortcutQuery.FLAG_GET_PINNED), HANDLE_USER_0)),
-                    "s2", "s3");
-            assertShortcutIds(assertAllDynamic(
-                    mLauncherApps.getShortcuts(buildQuery(/* time =*/ 0, CALLING_PACKAGE_2,
-                    /* activity =*/ null, ShortcutQuery.FLAG_GET_DYNAMIC), HANDLE_USER_0)),
-                    "s1");
-            assertShortcutIds(assertAllDynamicOrPinned(
-                    mLauncherApps.getShortcuts(buildQuery(/* time =*/ 0, CALLING_PACKAGE_2,
-                    /* activity =*/ null, PIN_AND_DYNAMIC), HANDLE_USER_0)),
-                    "s1", "s2", "s3");
-
-            assertShortcutLaunchable(CALLING_PACKAGE_1, "s1", USER_0);
-            assertShortcutLaunchable(CALLING_PACKAGE_1, "s2", USER_0);
-            assertStartShortcutThrowsException(CALLING_PACKAGE_1, "s3", USER_0,
-                    ActivityNotFoundException.class);
-
-            assertShortcutLaunchable(CALLING_PACKAGE_2, "s1", USER_0);
-            assertShortcutLaunchable(CALLING_PACKAGE_2, "s2", USER_0);
-            assertShortcutLaunchable(CALLING_PACKAGE_2, "s3", USER_0);
-
-            assertStartShortcutThrowsException(CALLING_PACKAGE_1, "s1", USER_10,
-                    SecurityException.class);
-            assertStartShortcutThrowsException(CALLING_PACKAGE_1, "s2", USER_10,
-                    SecurityException.class);
-            assertStartShortcutThrowsException(CALLING_PACKAGE_1, "s3", USER_10,
-                    SecurityException.class);
-            assertStartShortcutThrowsException(CALLING_PACKAGE_1, "s4", USER_10,
-                    SecurityException.class);
-            assertStartShortcutThrowsException(CALLING_PACKAGE_1, "s5", USER_10,
-                    SecurityException.class);
-            assertStartShortcutThrowsException(CALLING_PACKAGE_1, "s6", USER_10,
-                    SecurityException.class);
-        });
-        runWithCaller(LAUNCHER_2, USER_P0, () -> {
-            assertShortcutIds(assertAllPinned(
-                    mLauncherApps.getShortcuts(buildQuery(/* time =*/ 0, CALLING_PACKAGE_1,
-                    /* activity =*/ null, ShortcutQuery.FLAG_GET_PINNED), HANDLE_USER_0)),
-                    "s3");
-            assertShortcutIds(assertAllDynamic(
-                    mLauncherApps.getShortcuts(buildQuery(/* time =*/ 0, CALLING_PACKAGE_1,
-                    /* activity =*/ null, ShortcutQuery.FLAG_GET_DYNAMIC), HANDLE_USER_0)),
-                    "s1");
-            assertShortcutIds(assertAllDynamicOrPinned(
-                    mLauncherApps.getShortcuts(buildQuery(/* time =*/ 0, CALLING_PACKAGE_1,
-                    /* activity =*/ null, PIN_AND_DYNAMIC), HANDLE_USER_0)),
-                    "s1", "s3");
-
-            assertShortcutIds(assertAllPinned(
-                    mLauncherApps.getShortcuts(buildQuery(/* time =*/ 0, CALLING_PACKAGE_2,
-                    /* activity =*/ null, ShortcutQuery.FLAG_GET_PINNED), HANDLE_USER_0)),
-                    "s3");
-            assertShortcutIds(assertAllDynamic(
-                    mLauncherApps.getShortcuts(buildQuery(/* time =*/ 0, CALLING_PACKAGE_2,
-                    /* activity =*/ null, ShortcutQuery.FLAG_GET_DYNAMIC), HANDLE_USER_0)),
-                    "s1");
-            assertShortcutIds(assertAllDynamicOrPinned(
-                    mLauncherApps.getShortcuts(buildQuery(/* time =*/ 0, CALLING_PACKAGE_2,
-                    /* activity =*/ null, PIN_AND_DYNAMIC), HANDLE_USER_0)),
-                    "s1", "s3");
-
-            assertShortcutLaunchable(CALLING_PACKAGE_1, "s1", USER_0);
-            assertStartShortcutThrowsException(CALLING_PACKAGE_1, "s2", USER_0,
-                    ActivityNotFoundException.class);
-            assertShortcutLaunchable(CALLING_PACKAGE_1, "s3", USER_0);
-
-            assertShortcutLaunchable(CALLING_PACKAGE_2, "s1", USER_0);
-            assertStartShortcutThrowsException(CALLING_PACKAGE_2, "s2", USER_0,
-                    ActivityNotFoundException.class);
-            assertShortcutLaunchable(CALLING_PACKAGE_2, "s3", USER_0);
-
-            assertStartShortcutThrowsException(CALLING_PACKAGE_1, "s1", USER_10,
-                    SecurityException.class);
-            assertStartShortcutThrowsException(CALLING_PACKAGE_1, "s2", USER_10,
-                    SecurityException.class);
-            assertStartShortcutThrowsException(CALLING_PACKAGE_1, "s3", USER_10,
-                    SecurityException.class);
-            assertStartShortcutThrowsException(CALLING_PACKAGE_1, "s4", USER_10,
-                    SecurityException.class);
-            assertStartShortcutThrowsException(CALLING_PACKAGE_1, "s5", USER_10,
-                    SecurityException.class);
-            assertStartShortcutThrowsException(CALLING_PACKAGE_1, "s6", USER_10,
-                    SecurityException.class);
-        });
-        runWithCaller(LAUNCHER_2, USER_10, () -> {
-            assertShortcutIds(assertAllPinned(
-                    mLauncherApps.getShortcuts(buildQuery(/* time =*/ 0, CALLING_PACKAGE_1,
-                    /* activity =*/ null, ShortcutQuery.FLAG_GET_PINNED), HANDLE_USER_10)),
-                    "s1", "s2", "s3");
-            assertShortcutIds(assertAllDynamic(
-                    mLauncherApps.getShortcuts(buildQuery(/* time =*/ 0, CALLING_PACKAGE_1,
-                    /* activity =*/ null, ShortcutQuery.FLAG_GET_DYNAMIC), HANDLE_USER_10)),
-                    "s1");
-            assertShortcutIds(assertAllDynamicOrPinned(
-                    mLauncherApps.getShortcuts(buildQuery(/* time =*/ 0, CALLING_PACKAGE_1,
-                    /* activity =*/ null, PIN_AND_DYNAMIC), HANDLE_USER_10)),
-                    "s1", "s2", "s3");
-
-            assertStartShortcutThrowsException(CALLING_PACKAGE_1, "s1", USER_0,
-                    SecurityException.class);
-            assertStartShortcutThrowsException(CALLING_PACKAGE_1, "s2", USER_0,
-                    SecurityException.class);
-            assertStartShortcutThrowsException(CALLING_PACKAGE_1, "s3", USER_0,
-                    SecurityException.class);
-
-            assertStartShortcutThrowsException(CALLING_PACKAGE_2, "s1", USER_0,
-                    SecurityException.class);
-            assertStartShortcutThrowsException(CALLING_PACKAGE_2, "s2", USER_0,
-                    SecurityException.class);
-            assertStartShortcutThrowsException(CALLING_PACKAGE_2, "s3", USER_0,
-                    SecurityException.class);
-
-            assertShortcutLaunchable(CALLING_PACKAGE_1, "s1", USER_10);
-            assertShortcutLaunchable(CALLING_PACKAGE_1, "s2", USER_10);
-            assertShortcutLaunchable(CALLING_PACKAGE_1, "s3", USER_10);
-            assertStartShortcutThrowsException(CALLING_PACKAGE_1, "s4", USER_10,
-                    ActivityNotFoundException.class);
-            assertStartShortcutThrowsException(CALLING_PACKAGE_1, "s5", USER_10,
-                    ActivityNotFoundException.class);
-            assertStartShortcutThrowsException(CALLING_PACKAGE_1, "s6", USER_10,
-                    ActivityNotFoundException.class);
-        });
-
-        // Save & load and make sure we still have the same information.
-        mService.saveDirtyInfo();
-        initService();
-        mService.handleUnlockUser(USER_0);
-
-        runWithCaller(LAUNCHER_1, USER_0, () -> {
-            assertShortcutIds(assertAllPinned(
-                    mLauncherApps.getShortcuts(buildQuery(/* time =*/ 0, CALLING_PACKAGE_1,
-                    /* activity =*/ null, ShortcutQuery.FLAG_GET_PINNED), HANDLE_USER_0)),
-                    "s1");
-            assertShortcutIds(assertAllDynamic(
-                    mLauncherApps.getShortcuts(buildQuery(/* time =*/ 0, CALLING_PACKAGE_1,
-                    /* activity =*/ null, ShortcutQuery.FLAG_GET_DYNAMIC), HANDLE_USER_0)),
-                    "s1");
-            assertShortcutIds(assertAllDynamicOrPinned(
-                    mLauncherApps.getShortcuts(buildQuery(/* time =*/ 0, CALLING_PACKAGE_1,
-                    /* activity =*/ null, PIN_AND_DYNAMIC), HANDLE_USER_0)),
-                    "s1");
-
-            assertShortcutIds(assertAllPinned(
-                    mLauncherApps.getShortcuts(buildQuery(/* time =*/ 0, CALLING_PACKAGE_2,
-                    /* activity =*/ null, ShortcutQuery.FLAG_GET_PINNED), HANDLE_USER_0)),
-                    "s1", "s2", "s3");
-            assertShortcutIds(assertAllDynamic(
-                    mLauncherApps.getShortcuts(buildQuery(/* time =*/ 0, CALLING_PACKAGE_2,
-                    /* activity =*/ null, ShortcutQuery.FLAG_GET_DYNAMIC), HANDLE_USER_0)),
-                    "s1");
-            assertShortcutIds(assertAllDynamicOrPinned(
-                    mLauncherApps.getShortcuts(buildQuery(/* time =*/ 0, CALLING_PACKAGE_2,
-                    /* activity =*/ null, PIN_AND_DYNAMIC), HANDLE_USER_0)),
-                    "s1", "s2", "s3");
-
-            assertShortcutLaunchable(CALLING_PACKAGE_1, "s1", USER_0);
-            assertStartShortcutThrowsException(CALLING_PACKAGE_1, "s2", USER_0,
-                    ActivityNotFoundException.class);
-            assertStartShortcutThrowsException(CALLING_PACKAGE_1, "s3", USER_0,
-                    ActivityNotFoundException.class);
-
-            assertShortcutLaunchable(CALLING_PACKAGE_2, "s1", USER_0);
-            assertShortcutLaunchable(CALLING_PACKAGE_2, "s2", USER_0);
-            assertShortcutLaunchable(CALLING_PACKAGE_2, "s3", USER_0);
-
-            assertStartShortcutThrowsException(CALLING_PACKAGE_1, "s1", USER_10,
-                    SecurityException.class);
-            assertStartShortcutThrowsException(CALLING_PACKAGE_1, "s2", USER_10,
-                    SecurityException.class);
-            assertStartShortcutThrowsException(CALLING_PACKAGE_1, "s3", USER_10,
-                    SecurityException.class);
-            assertStartShortcutThrowsException(CALLING_PACKAGE_1, "s4", USER_10,
-                    SecurityException.class);
-            assertStartShortcutThrowsException(CALLING_PACKAGE_1, "s5", USER_10,
-                    SecurityException.class);
-            assertStartShortcutThrowsException(CALLING_PACKAGE_1, "s6", USER_10,
-                    SecurityException.class);
-        });
-        runWithCaller(LAUNCHER_1, USER_P0, () -> {
-            assertShortcutIds(assertAllPinned(
-                    mLauncherApps.getShortcuts(buildQuery(/* time =*/ 0, CALLING_PACKAGE_1,
-                    /* activity =*/ null, ShortcutQuery.FLAG_GET_PINNED), HANDLE_USER_0)),
-                    "s2");
-            assertShortcutIds(assertAllDynamic(
-                    mLauncherApps.getShortcuts(buildQuery(/* time =*/ 0, CALLING_PACKAGE_1,
-                    /* activity =*/ null, ShortcutQuery.FLAG_GET_DYNAMIC), HANDLE_USER_0)),
-                    "s1");
-            assertShortcutIds(assertAllDynamicOrPinned(
-                    mLauncherApps.getShortcuts(buildQuery(/* time =*/ 0, CALLING_PACKAGE_1,
-                    /* activity =*/ null, PIN_AND_DYNAMIC), HANDLE_USER_0)),
-                    "s1", "s2");
-
-            assertShortcutIds(assertAllPinned(
-                    mLauncherApps.getShortcuts(buildQuery(/* time =*/ 0, CALLING_PACKAGE_2,
-                    /* activity =*/ null, ShortcutQuery.FLAG_GET_PINNED), HANDLE_USER_0)),
-                    "s2", "s3");
-            assertShortcutIds(assertAllDynamic(
-                    mLauncherApps.getShortcuts(buildQuery(/* time =*/ 0, CALLING_PACKAGE_2,
-                    /* activity =*/ null, ShortcutQuery.FLAG_GET_DYNAMIC), HANDLE_USER_0)),
-                    "s1");
-            assertShortcutIds(assertAllDynamicOrPinned(
-                    mLauncherApps.getShortcuts(buildQuery(/* time =*/ 0, CALLING_PACKAGE_2,
-                    /* activity =*/ null, PIN_AND_DYNAMIC), HANDLE_USER_0)),
-                    "s1", "s2", "s3");
-
-            assertShortcutLaunchable(CALLING_PACKAGE_1, "s1", USER_0);
-            assertShortcutLaunchable(CALLING_PACKAGE_1, "s2", USER_0);
-            assertStartShortcutThrowsException(CALLING_PACKAGE_1, "s3", USER_0,
-                    ActivityNotFoundException.class);
-
-            assertShortcutLaunchable(CALLING_PACKAGE_2, "s1", USER_0);
-            assertShortcutLaunchable(CALLING_PACKAGE_2, "s2", USER_0);
-            assertShortcutLaunchable(CALLING_PACKAGE_2, "s3", USER_0);
-
-            assertStartShortcutThrowsException(CALLING_PACKAGE_1, "s1", USER_10,
-                    SecurityException.class);
-            assertStartShortcutThrowsException(CALLING_PACKAGE_1, "s2", USER_10,
-                    SecurityException.class);
-            assertStartShortcutThrowsException(CALLING_PACKAGE_1, "s3", USER_10,
-                    SecurityException.class);
-            assertStartShortcutThrowsException(CALLING_PACKAGE_1, "s4", USER_10,
-                    SecurityException.class);
-            assertStartShortcutThrowsException(CALLING_PACKAGE_1, "s5", USER_10,
-                    SecurityException.class);
-            assertStartShortcutThrowsException(CALLING_PACKAGE_1, "s6", USER_10,
-                    SecurityException.class);
-        });
-        runWithCaller(LAUNCHER_2, USER_P0, () -> {
-            assertShortcutIds(assertAllPinned(
-                    mLauncherApps.getShortcuts(buildQuery(/* time =*/ 0, CALLING_PACKAGE_1,
-                    /* activity =*/ null, ShortcutQuery.FLAG_GET_PINNED), HANDLE_USER_0)),
-                    "s3");
-            assertShortcutIds(assertAllDynamic(
-                    mLauncherApps.getShortcuts(buildQuery(/* time =*/ 0, CALLING_PACKAGE_1,
-                    /* activity =*/ null, ShortcutQuery.FLAG_GET_DYNAMIC), HANDLE_USER_0)),
-                    "s1");
-            assertShortcutIds(assertAllDynamicOrPinned(
-                    mLauncherApps.getShortcuts(buildQuery(/* time =*/ 0, CALLING_PACKAGE_1,
-                    /* activity =*/ null, PIN_AND_DYNAMIC), HANDLE_USER_0)),
-                    "s1", "s3");
-
-            assertShortcutIds(assertAllPinned(
-                    mLauncherApps.getShortcuts(buildQuery(/* time =*/ 0, CALLING_PACKAGE_2,
-                    /* activity =*/ null, ShortcutQuery.FLAG_GET_PINNED), HANDLE_USER_0)),
-                    "s3");
-            assertShortcutIds(assertAllDynamic(
-                    mLauncherApps.getShortcuts(buildQuery(/* time =*/ 0, CALLING_PACKAGE_2,
-                    /* activity =*/ null, ShortcutQuery.FLAG_GET_DYNAMIC), HANDLE_USER_0)),
-                    "s1");
-            assertShortcutIds(assertAllDynamicOrPinned(
-                    mLauncherApps.getShortcuts(buildQuery(/* time =*/ 0, CALLING_PACKAGE_2,
-                    /* activity =*/ null, PIN_AND_DYNAMIC), HANDLE_USER_0)),
-                    "s1", "s3");
-
-            assertShortcutLaunchable(CALLING_PACKAGE_1, "s1", USER_0);
-            assertStartShortcutThrowsException(CALLING_PACKAGE_1, "s2", USER_0,
-                    ActivityNotFoundException.class);
-            assertShortcutLaunchable(CALLING_PACKAGE_1, "s3", USER_0);
-
-            assertShortcutLaunchable(CALLING_PACKAGE_2, "s1", USER_0);
-            assertStartShortcutThrowsException(CALLING_PACKAGE_2, "s2", USER_0,
-                    ActivityNotFoundException.class);
-            assertShortcutLaunchable(CALLING_PACKAGE_2, "s3", USER_0);
-
-            assertStartShortcutThrowsException(CALLING_PACKAGE_1, "s1", USER_10,
-                    SecurityException.class);
-            assertStartShortcutThrowsException(CALLING_PACKAGE_1, "s2", USER_10,
-                    SecurityException.class);
-            assertStartShortcutThrowsException(CALLING_PACKAGE_1, "s3", USER_10,
-                    SecurityException.class);
-            assertStartShortcutThrowsException(CALLING_PACKAGE_1, "s4", USER_10,
-                    SecurityException.class);
-            assertStartShortcutThrowsException(CALLING_PACKAGE_1, "s5", USER_10,
-                    SecurityException.class);
-            assertStartShortcutThrowsException(CALLING_PACKAGE_1, "s6", USER_10,
-                    SecurityException.class);
-        });
-    }
-
-    public void testStartShortcut() {
-        // Create some shortcuts.
-        runWithCaller(CALLING_PACKAGE_1, USER_0, () -> {
-            final ShortcutInfo s1_1 = makeShortcut(
-                    "s1",
-                    "Title 1",
-                    makeComponent(ShortcutActivity.class),
-                    /* icon =*/ null,
-                    new Intent[] {makeIntent(Intent.ACTION_ASSIST, ShortcutActivity2.class,
-                            "key1", "val1", "nest", makeBundle("key", 123))
-                            .setFlags(Intent.FLAG_ACTIVITY_CLEAR_TASK),
-                    new Intent("act2").setFlags(Intent.FLAG_ACTIVITY_NO_ANIMATION)},
-                    /* rank */ 10);
-
-            final ShortcutInfo s1_2 = makeShortcut(
-                    "s2",
-                    "Title 2",
-            /* activity */ null,
-            /* icon =*/ null,
-                    makeIntent(Intent.ACTION_ASSIST, ShortcutActivity3.class),
-            /* rank */ 12);
-
-            final ShortcutInfo s1_3 = makeShortcut("s3");
-
-            assertTrue(mManager.setDynamicShortcuts(list(s1_1, s1_2, s1_3)));
-        });
-
-        runWithCaller(CALLING_PACKAGE_2, USER_0, () -> {
-            final ShortcutInfo s2_1 = makeShortcut(
-                    "s1",
-                    "ABC",
-                    makeComponent(ShortcutActivity.class),
-                    /* icon =*/ null,
-                    makeIntent(Intent.ACTION_ANSWER, ShortcutActivity.class,
-                            "key1", "val1", "nest", makeBundle("key", 123)),
-                    /* weight */ 10);
-            assertTrue(mManager.setDynamicShortcuts(list(s2_1)));
-        });
-
-        // Pin some.
-        runWithCaller(LAUNCHER_1, USER_0, () -> {
-            mLauncherApps.pinShortcuts(CALLING_PACKAGE_1,
-                    list("s1", "s2"), getCallingUser());
-
-            mLauncherApps.pinShortcuts(CALLING_PACKAGE_2,
-                    list("s1"), getCallingUser());
-        });
-
-        // Just to make it complicated, delete some.
-        runWithCaller(CALLING_PACKAGE_1, USER_0, () -> {
-            mManager.removeDynamicShortcuts(list("s2"));
-        });
-
-        runWithCaller(LAUNCHER_1, USER_0, () -> {
-            final Intent[] intents = launchShortcutAndGetIntents(CALLING_PACKAGE_1, "s1", USER_0);
-            assertEquals(ShortcutActivity2.class.getName(),
-                    intents[0].getComponent().getClassName());
-            assertEquals(Intent.ACTION_ASSIST,
-                    intents[0].getAction());
-            assertEquals(Intent.FLAG_ACTIVITY_CLEAR_TASK | Intent.FLAG_ACTIVITY_NEW_TASK,
-                    intents[0].getFlags());
-
-            assertEquals("act2",
-                    intents[1].getAction());
-            assertEquals(Intent.FLAG_ACTIVITY_NO_ANIMATION,
-                    intents[1].getFlags());
-
-            assertEquals(
-                    ShortcutActivity3.class.getName(),
-                    launchShortcutAndGetIntent(CALLING_PACKAGE_1, "s2", USER_0)
-                            .getComponent().getClassName());
-            assertEquals(
-                    ShortcutActivity.class.getName(),
-                    launchShortcutAndGetIntent(CALLING_PACKAGE_2, "s1", USER_0)
-                            .getComponent().getClassName());
-
-            assertShortcutLaunchable(CALLING_PACKAGE_1, "s3", USER_0);
-
-            assertShortcutNotLaunched("no-such-package", "s2", USER_0);
-            assertShortcutNotLaunched(CALLING_PACKAGE_1, "xxxx", USER_0);
-        });
-
-        // LAUNCHER_1 is no longer the default launcher
-        setDefaultLauncherChecker((pkg, userId) -> false);
-
-        runWithCaller(LAUNCHER_1, USER_0, () -> {
-            // Not the default launcher, but pinned shortcuts are still lauchable.
-            final Intent[] intents = launchShortcutAndGetIntents(CALLING_PACKAGE_1, "s1", USER_0);
-            assertEquals(ShortcutActivity2.class.getName(),
-                    intents[0].getComponent().getClassName());
-            assertEquals(Intent.ACTION_ASSIST,
-                    intents[0].getAction());
-            assertEquals(Intent.FLAG_ACTIVITY_CLEAR_TASK | Intent.FLAG_ACTIVITY_NEW_TASK,
-                    intents[0].getFlags());
-
-            assertEquals("act2",
-                    intents[1].getAction());
-            assertEquals(Intent.FLAG_ACTIVITY_NO_ANIMATION,
-                    intents[1].getFlags());
-            assertEquals(
-                    ShortcutActivity3.class.getName(),
-                    launchShortcutAndGetIntent(CALLING_PACKAGE_1, "s2", USER_0)
-                            .getComponent().getClassName());
-            assertEquals(
-                    ShortcutActivity.class.getName(),
-                    launchShortcutAndGetIntent(CALLING_PACKAGE_2, "s1", USER_0)
-                            .getComponent().getClassName());
-
-            // Not pinned, so not lauchable.
-        });
-
-        // Test inner errors.
-        runWithCaller(LAUNCHER_1, USER_0, () -> {
-            // Not launchable.
-            doReturn(ActivityManager.START_CLASS_NOT_FOUND)
-                    .when(mMockActivityManagerInternal).startActivitiesAsPackage(
-                            anyString(), anyInt(), any(Intent[].class), any(Bundle.class));
-            assertStartShortcutThrowsException(CALLING_PACKAGE_1, "s1", USER_0,
-                    ActivityNotFoundException.class);
-
-            // Still not launchable.
-            doReturn(ActivityManager.START_CLASS_NOT_FOUND)
-                    .when(mMockActivityManagerInternal)
-                    .startActivitiesAsPackage(
-                            anyString(), anyInt(), any(Intent[].class), any(Bundle.class));
-            assertStartShortcutThrowsException(CALLING_PACKAGE_1, "s1", USER_0,
-                    ActivityNotFoundException.class);
-        });
-
-
-        // TODO Check extra, etc
-    }
-
-    public void testLauncherCallback() throws Throwable {
-        // Disable throttling for this test.
-        mService.updateConfigurationLocked(
-                ConfigConstants.KEY_MAX_UPDATES_PER_INTERVAL + "=99999999,"
-                        + ConfigConstants.KEY_MAX_SHORTCUTS + "=99999999"
-        );
-
-        setCaller(LAUNCHER_1, USER_0);
-
-        assertForLauncherCallback(mLauncherApps, () -> {
-            runWithCaller(CALLING_PACKAGE_1, USER_0, () -> {
-                assertTrue(mManager.setDynamicShortcuts(list(
-                        makeShortcut("s1"), makeShortcut("s2"), makeShortcut("s3"))));
-            });
-        }).assertCallbackCalledForPackageAndUser(CALLING_PACKAGE_1, HANDLE_USER_0)
-                .haveIds("s1", "s2", "s3")
-                .areAllWithKeyFieldsOnly()
-                .areAllDynamic();
-
-        // From different package.
-        assertForLauncherCallback(mLauncherApps, () -> {
-            runWithCaller(CALLING_PACKAGE_2, USER_0, () -> {
-                assertTrue(mManager.setDynamicShortcuts(list(
-                        makeShortcut("s1"), makeShortcut("s2"), makeShortcut("s3"))));
-            });
-        }).assertCallbackCalledForPackageAndUser(CALLING_PACKAGE_2, HANDLE_USER_0)
-                .haveIds("s1", "s2", "s3")
-                .areAllWithKeyFieldsOnly()
-                .areAllDynamic();
-
-        mRunningUsers.put(USER_10, true);
-
-        // Different user, callback shouldn't be called.
-        assertForLauncherCallback(mLauncherApps, () -> {
-            runWithCaller(CALLING_PACKAGE_1, USER_10, () -> {
-                assertTrue(mManager.setDynamicShortcuts(list(
-                        makeShortcut("s1"), makeShortcut("s2"), makeShortcut("s3"))));
-            });
-        }).assertNoCallbackCalled();
-
-
-        // Test for addDynamicShortcuts.
-        assertForLauncherCallback(mLauncherApps, () -> {
-            runWithCaller(CALLING_PACKAGE_1, USER_0, () -> {
-                assertTrue(mManager.addDynamicShortcuts(list(makeShortcut("s4"))));
-            });
-        }).assertCallbackCalledForPackageAndUser(CALLING_PACKAGE_1, HANDLE_USER_0)
-                .haveIds("s1", "s2", "s3", "s4")
-                .areAllWithKeyFieldsOnly()
-                .areAllDynamic();
-
-        // Test for remove
-        assertForLauncherCallback(mLauncherApps, () -> {
-            runWithCaller(CALLING_PACKAGE_1, USER_0, () -> {
-                mManager.removeDynamicShortcuts(list("s1"));
-            });
-        }).assertCallbackCalledForPackageAndUser(CALLING_PACKAGE_1, HANDLE_USER_0)
-                .haveIds("s2", "s3", "s4")
-                .areAllWithKeyFieldsOnly()
-                .areAllDynamic();
-
-        // Test for update
-        assertForLauncherCallback(mLauncherApps, () -> {
-            runWithCaller(CALLING_PACKAGE_1, USER_0, () -> {
-                assertTrue(mManager.updateShortcuts(list(
-                        makeShortcut("s1"), makeShortcut("s2"))));
-            });
-        }).assertCallbackCalledForPackageAndUser(CALLING_PACKAGE_1, HANDLE_USER_0)
-                // All remaining shortcuts will be passed regardless of what's been updated.
-                .haveIds("s2", "s3", "s4")
-                .areAllWithKeyFieldsOnly()
-                .areAllDynamic();
-
-        // Test for deleteAll
-        assertForLauncherCallback(mLauncherApps, () -> {
-            runWithCaller(CALLING_PACKAGE_1, USER_0, () -> {
-                mManager.removeAllDynamicShortcuts();
-            });
-        }).assertCallbackCalledForPackageAndUser(CALLING_PACKAGE_1, HANDLE_USER_0)
-                .isEmpty();
-
-        // Update package1 with manifest shortcuts
-        assertForLauncherCallback(mLauncherApps, () -> {
-            addManifestShortcutResource(
-                    new ComponentName(CALLING_PACKAGE_1, ShortcutActivity.class.getName()),
-                    R.xml.shortcut_2);
-            updatePackageVersion(CALLING_PACKAGE_1, 1);
-            mService.mPackageMonitor.onReceive(getTestContext(),
-                    genPackageAddIntent(CALLING_PACKAGE_1, USER_0));
-        }).assertCallbackCalledForPackageAndUser(CALLING_PACKAGE_1, HANDLE_USER_0)
-                .areAllManifest()
-                .areAllWithKeyFieldsOnly()
-                .haveIds("ms1", "ms2");
-
-        // Make sure pinned shortcuts are passed too.
-        // 1. Add dynamic shortcuts.
-        runWithCaller(CALLING_PACKAGE_1, UserHandle.USER_SYSTEM, () -> {
-            assertTrue(mManager.setDynamicShortcuts(list(
-                    makeShortcut("s1"), makeShortcut("s2"))));
-        });
-
-        // 2. Pin some.
-        runWithCaller(LAUNCHER_1, UserHandle.USER_SYSTEM, () -> {
-            mLauncherApps.pinShortcuts(CALLING_PACKAGE_1, list("ms2", "s2"), HANDLE_USER_0);
-        });
-        runWithCaller(CALLING_PACKAGE_1, UserHandle.USER_SYSTEM, () -> {
-            assertWith(getCallerShortcuts())
-                    .haveIds("ms1", "ms2", "s1", "s2")
-                    .areAllEnabled()
-
-                    .selectByIds("ms1", "ms2")
-                    .areAllManifest()
-
-                    .revertToOriginalList()
-                    .selectByIds("s1", "s2")
-                    .areAllDynamic()
-                    ;
-        });
-
-        // 3 Update the app with no manifest shortcuts.  (Pinned one will survive.)
-        addManifestShortcutResource(
-                new ComponentName(CALLING_PACKAGE_1, ShortcutActivity.class.getName()),
-                R.xml.shortcut_0);
-        updatePackageVersion(CALLING_PACKAGE_1, 1);
-        mService.mPackageMonitor.onReceive(getTestContext(),
-                genPackageAddIntent(CALLING_PACKAGE_1, USER_0));
-
-        assertForLauncherCallback(mLauncherApps, () -> {
-            runWithCaller(CALLING_PACKAGE_1, USER_0, () -> {
-                mManager.removeDynamicShortcuts(list("s2"));
-
-                assertWith(getCallerShortcuts())
-                        .haveIds("ms2", "s1", "s2")
-
-                        .selectByIds("ms2")
-                        .areAllNotManifest()
-                        .areAllPinned()
-                        .areAllImmutable()
-                        .areAllDisabled()
-
-                        .revertToOriginalList()
-                        .selectByIds("s1")
-                        .areAllDynamic()
-                        .areAllNotPinned()
-                        .areAllEnabled()
-
-                        .revertToOriginalList()
-                        .selectByIds("s2")
-                        .areAllNotDynamic()
-                        .areAllPinned()
-                        .areAllEnabled()
-                ;
-            });
-        }).assertCallbackCalledForPackageAndUser(CALLING_PACKAGE_1, HANDLE_USER_0)
-                .haveIds("ms2", "s1", "s2")
-                .areAllWithKeyFieldsOnly();
-
-        // Remove CALLING_PACKAGE_2
-        assertForLauncherCallback(mLauncherApps, () -> {
-            uninstallPackage(USER_0, CALLING_PACKAGE_2);
-            mService.cleanUpPackageLocked(CALLING_PACKAGE_2, USER_0, USER_0,
-                    /* appStillExists = */ false);
-        }).assertCallbackCalledForPackageAndUser(CALLING_PACKAGE_2, HANDLE_USER_0)
-                .isEmpty();
-    }
-
-    public void testLauncherCallback_crossProfile() throws Throwable {
-        prepareCrossProfileDataSet();
-
-        final Handler h = new Handler(Looper.getMainLooper());
-
-        final LauncherApps.Callback c0_1 = mock(LauncherApps.Callback.class);
-        final LauncherApps.Callback c0_2 = mock(LauncherApps.Callback.class);
-        final LauncherApps.Callback c0_3 = mock(LauncherApps.Callback.class);
-        final LauncherApps.Callback c0_4 = mock(LauncherApps.Callback.class);
-
-        final LauncherApps.Callback cP0_1 = mock(LauncherApps.Callback.class);
-        final LauncherApps.Callback c10_1 = mock(LauncherApps.Callback.class);
-        final LauncherApps.Callback c10_2 = mock(LauncherApps.Callback.class);
-        final LauncherApps.Callback c11_1 = mock(LauncherApps.Callback.class);
-
-        final List<LauncherApps.Callback> all =
-                list(c0_1, c0_2, c0_3, c0_4, cP0_1, c10_1, c11_1);
-
-        setDefaultLauncherChecker((pkg, userId) -> {
-            switch (userId) {
-                case USER_0:
-                    return LAUNCHER_2.equals(pkg);
-                case USER_P0:
-                    return LAUNCHER_1.equals(pkg);
-                case USER_10:
-                    return LAUNCHER_1.equals(pkg);
-                case USER_11:
-                    return LAUNCHER_1.equals(pkg);
-                default:
-                    return false;
-            }
-        });
-
-        runWithCaller(LAUNCHER_1, USER_0, () -> mLauncherApps.registerCallback(c0_1, h));
-        runWithCaller(LAUNCHER_2, USER_0, () -> mLauncherApps.registerCallback(c0_2, h));
-        runWithCaller(LAUNCHER_3, USER_0, () -> mLauncherApps.registerCallback(c0_3, h));
-        runWithCaller(LAUNCHER_4, USER_0, () -> mLauncherApps.registerCallback(c0_4, h));
-        runWithCaller(LAUNCHER_1, USER_P0, () -> mLauncherApps.registerCallback(cP0_1, h));
-        runWithCaller(LAUNCHER_1, USER_10, () -> mLauncherApps.registerCallback(c10_1, h));
-        runWithCaller(LAUNCHER_2, USER_10, () -> mLauncherApps.registerCallback(c10_2, h));
-        runWithCaller(LAUNCHER_1, USER_11, () -> mLauncherApps.registerCallback(c11_1, h));
-
-        // User 0.
-
-        resetAll(all);
-        runWithCaller(CALLING_PACKAGE_1, USER_0, () -> {
-            mManager.removeDynamicShortcuts(list());
-        });
-        waitOnMainThread();
-
-        assertCallbackNotReceived(c0_1);
-        assertCallbackNotReceived(c0_3);
-        assertCallbackNotReceived(c0_4);
-        assertCallbackNotReceived(c10_1);
-        assertCallbackNotReceived(c10_2);
-        assertCallbackNotReceived(c11_1);
-        assertCallbackReceived(c0_2, HANDLE_USER_0, CALLING_PACKAGE_1, "s1", "s2", "s3");
-        assertCallbackReceived(cP0_1, HANDLE_USER_0, CALLING_PACKAGE_1, "s1", "s2", "s3", "s4");
-
-        // User 0, different package.
-
-        resetAll(all);
-        runWithCaller(CALLING_PACKAGE_3, USER_0, () -> {
-            mManager.removeDynamicShortcuts(list());
-        });
-        waitOnMainThread();
-
-        assertCallbackNotReceived(c0_1);
-        assertCallbackNotReceived(c0_3);
-        assertCallbackNotReceived(c0_4);
-        assertCallbackNotReceived(c10_1);
-        assertCallbackNotReceived(c10_2);
-        assertCallbackNotReceived(c11_1);
-        assertCallbackReceived(c0_2, HANDLE_USER_0, CALLING_PACKAGE_3, "s1", "s2", "s3", "s4");
-        assertCallbackReceived(cP0_1, HANDLE_USER_0, CALLING_PACKAGE_3,
-                "s1", "s2", "s3", "s4", "s5", "s6");
-
-        // Work profile.
-        resetAll(all);
-        runWithCaller(CALLING_PACKAGE_1, USER_P0, () -> {
-            mManager.removeDynamicShortcuts(list());
-        });
-        waitOnMainThread();
-
-        assertCallbackNotReceived(c0_1);
-        assertCallbackNotReceived(c0_3);
-        assertCallbackNotReceived(c0_4);
-        assertCallbackNotReceived(c10_1);
-        assertCallbackNotReceived(c10_2);
-        assertCallbackNotReceived(c11_1);
-        assertCallbackReceived(c0_2, HANDLE_USER_P0, CALLING_PACKAGE_1, "s1", "s2", "s3", "s5");
-        assertCallbackReceived(cP0_1, HANDLE_USER_P0, CALLING_PACKAGE_1, "s1", "s2", "s3", "s4");
-
-        // Normal secondary user.
-        mRunningUsers.put(USER_10, true);
-
-        resetAll(all);
-        runWithCaller(CALLING_PACKAGE_1, USER_10, () -> {
-            mManager.removeDynamicShortcuts(list());
-        });
-        waitOnMainThread();
-
-        assertCallbackNotReceived(c0_1);
-        assertCallbackNotReceived(c0_2);
-        assertCallbackNotReceived(c0_3);
-        assertCallbackNotReceived(c0_4);
-        assertCallbackNotReceived(cP0_1);
-        assertCallbackNotReceived(c10_2);
-        assertCallbackNotReceived(c11_1);
-        assertCallbackReceived(c10_1, HANDLE_USER_10, CALLING_PACKAGE_1,
-                "x1", "x2", "x3", "x4", "x5");
-    }
-
-    // === Test for persisting ===
-
-    public void testSaveAndLoadUser_empty() {
-        assertTrue(mManager.setDynamicShortcuts(list()));
-
-        Log.i(TAG, "Saved state");
-        dumpsysOnLogcat();
-        dumpUserFile(0);
-
-        // Restore.
-        mService.saveDirtyInfo();
-        initService();
-
-        assertEquals(0, mManager.getDynamicShortcuts().size());
-    }
-
-    /**
-     * Try save and load, also stop/start the user.
-     */
-    public void testSaveAndLoadUser() {
-        // First, create some shortcuts and save.
-        runWithCaller(CALLING_PACKAGE_1, UserHandle.USER_SYSTEM, () -> {
-            final Icon icon1 = Icon.createWithResource(getTestContext(), R.drawable.black_64x16);
-            final Icon icon2 = Icon.createWithBitmap(BitmapFactory.decodeResource(
-                    getTestContext().getResources(), R.drawable.icon2));
-
-            final ShortcutInfo si1 = makeShortcut(
-                    "s1",
-                    "title1-1",
-                    makeComponent(ShortcutActivity.class),
-                    icon1,
-                    makeIntent(Intent.ACTION_ASSIST, ShortcutActivity2.class,
-                            "key1", "val1", "nest", makeBundle("key", 123)),
-                        /* weight */ 10);
-
-            final ShortcutInfo si2 = makeShortcut(
-                    "s2",
-                    "title1-2",
-                        /* activity */ null,
-                    icon2,
-                    makeIntent(Intent.ACTION_ASSIST, ShortcutActivity3.class),
-                        /* weight */ 12);
-
-            assertTrue(mManager.setDynamicShortcuts(list(si1, si2)));
-
-            assertEquals(START_TIME + INTERVAL, mManager.getRateLimitResetTime());
-            assertEquals(2, mManager.getRemainingCallCount());
-        });
-        runWithCaller(CALLING_PACKAGE_2, UserHandle.USER_SYSTEM, () -> {
-            final Icon icon1 = Icon.createWithResource(getTestContext(), R.drawable.black_16x64);
-            final Icon icon2 = Icon.createWithBitmap(BitmapFactory.decodeResource(
-                    getTestContext().getResources(), R.drawable.icon2));
-
-            final ShortcutInfo si1 = makeShortcut(
-                    "s1",
-                    "title2-1",
-                    makeComponent(ShortcutActivity.class),
-                    icon1,
-                    makeIntent(Intent.ACTION_ASSIST, ShortcutActivity2.class,
-                            "key1", "val1", "nest", makeBundle("key", 123)),
-                        /* weight */ 10);
-
-            final ShortcutInfo si2 = makeShortcut(
-                    "s2",
-                    "title2-2",
-                        /* activity */ null,
-                    icon2,
-                    makeIntent(Intent.ACTION_ASSIST, ShortcutActivity3.class),
-                        /* weight */ 12);
-
-            assertTrue(mManager.setDynamicShortcuts(list(si1, si2)));
-
-            assertEquals(START_TIME + INTERVAL, mManager.getRateLimitResetTime());
-            assertEquals(2, mManager.getRemainingCallCount());
-        });
-
-        mRunningUsers.put(USER_10, true);
-
-        runWithCaller(CALLING_PACKAGE_1, USER_10, () -> {
-            final Icon icon1 = Icon.createWithResource(getTestContext(), R.drawable.black_64x64);
-            final Icon icon2 = Icon.createWithBitmap(BitmapFactory.decodeResource(
-                    getTestContext().getResources(), R.drawable.icon2));
-
-            final ShortcutInfo si1 = makeShortcut(
-                    "s1",
-                    "title10-1-1",
-                    makeComponent(ShortcutActivity.class),
-                    icon1,
-                    makeIntent(Intent.ACTION_ASSIST, ShortcutActivity2.class,
-                            "key1", "val1", "nest", makeBundle("key", 123)),
-                        /* weight */ 10);
-
-            final ShortcutInfo si2 = makeShortcut(
-                    "s2",
-                    "title10-1-2",
-                        /* activity */ null,
-                    icon2,
-                    makeIntent(Intent.ACTION_ASSIST, ShortcutActivity3.class),
-                        /* weight */ 12);
-
-            assertTrue(mManager.setDynamicShortcuts(list(si1, si2)));
-
-            assertEquals(START_TIME + INTERVAL, mManager.getRateLimitResetTime());
-            assertEquals(2, mManager.getRemainingCallCount());
-        });
-
-        mService.getShortcutsForTest().get(UserHandle.USER_SYSTEM).setLauncher(
-                new ComponentName("pkg1", "class"));
-
-        // Restore.
-        mService.saveDirtyInfo();
-        initService();
-
-        // Before the load, the map should be empty.
-        assertEquals(0, mService.getShortcutsForTest().size());
-
-        // this will pre-load the per-user info.
-        mService.handleUnlockUser(UserHandle.USER_SYSTEM);
-
-        // Now it's loaded.
-        assertEquals(1, mService.getShortcutsForTest().size());
-
-        runWithCaller(CALLING_PACKAGE_1, UserHandle.USER_SYSTEM, () -> {
-            assertShortcutIds(assertAllDynamic(assertAllHaveIntents(assertAllHaveIcon(
-                    mManager.getDynamicShortcuts()))), "s1", "s2");
-            assertEquals(2, mManager.getRemainingCallCount());
-
-            assertEquals("title1-1", getCallerShortcut("s1").getTitle());
-            assertEquals("title1-2", getCallerShortcut("s2").getTitle());
-        });
-        runWithCaller(CALLING_PACKAGE_2, UserHandle.USER_SYSTEM, () -> {
-            assertShortcutIds(assertAllDynamic(assertAllHaveIntents(assertAllHaveIcon(
-                    mManager.getDynamicShortcuts()))), "s1", "s2");
-            assertEquals(2, mManager.getRemainingCallCount());
-
-            assertEquals("title2-1", getCallerShortcut("s1").getTitle());
-            assertEquals("title2-2", getCallerShortcut("s2").getTitle());
-        });
-
-        assertEquals("pkg1", mService.getShortcutsForTest().get(UserHandle.USER_SYSTEM)
-                .getLastKnownLauncher().getPackageName());
-
-        // Start another user
-        mService.handleUnlockUser(USER_10);
-
-        // Now the size is 2.
-        assertEquals(2, mService.getShortcutsForTest().size());
-
-        runWithCaller(CALLING_PACKAGE_1, USER_10, () -> {
-            assertShortcutIds(assertAllDynamic(assertAllHaveIntents(assertAllHaveIcon(
-                    mManager.getDynamicShortcuts()))), "s1", "s2");
-            assertEquals(2, mManager.getRemainingCallCount());
-
-            assertEquals("title10-1-1", getCallerShortcut("s1").getTitle());
-            assertEquals("title10-1-2", getCallerShortcut("s2").getTitle());
-        });
-        assertNull(mService.getShortcutsForTest().get(USER_10).getLastKnownLauncher());
-
-        // Try stopping the user
-        mService.handleCleanupUser(USER_10);
-
-        // Now it's unloaded.
-        assertEquals(1, mService.getShortcutsForTest().size());
-
-        // TODO Check all other fields
-    }
-
-    public void testCleanupPackage() {
-        runWithCaller(CALLING_PACKAGE_1, USER_0, () -> {
-            assertTrue(mManager.setDynamicShortcuts(list(
-                    makeShortcut("s0_1"))));
-        });
-        runWithCaller(CALLING_PACKAGE_2, USER_0, () -> {
-            assertTrue(mManager.setDynamicShortcuts(list(
-                    makeShortcut("s0_2"))));
-        });
-        runWithCaller(LAUNCHER_1, USER_0, () -> {
-            mLauncherApps.pinShortcuts(CALLING_PACKAGE_1, list("s0_1"),
-                    HANDLE_USER_0);
-            mLauncherApps.pinShortcuts(CALLING_PACKAGE_2, list("s0_2"),
-                    HANDLE_USER_0);
-        });
-        runWithCaller(LAUNCHER_2, USER_0, () -> {
-            mLauncherApps.pinShortcuts(CALLING_PACKAGE_1, list("s0_1"),
-                    HANDLE_USER_0);
-            mLauncherApps.pinShortcuts(CALLING_PACKAGE_2, list("s0_2"),
-                    HANDLE_USER_0);
-        });
-
-        mRunningUsers.put(USER_10, true);
-
-        runWithCaller(CALLING_PACKAGE_1, USER_10, () -> {
-            assertTrue(mManager.setDynamicShortcuts(list(
-                    makeShortcut("s10_1"))));
-        });
-        runWithCaller(CALLING_PACKAGE_2, USER_10, () -> {
-            assertTrue(mManager.setDynamicShortcuts(list(
-                    makeShortcut("s10_2"))));
-        });
-        runWithCaller(LAUNCHER_1, USER_10, () -> {
-            mLauncherApps.pinShortcuts(CALLING_PACKAGE_1, list("s10_1"),
-                    HANDLE_USER_10);
-            mLauncherApps.pinShortcuts(CALLING_PACKAGE_2, list("s10_2"),
-                    HANDLE_USER_10);
-        });
-        runWithCaller(LAUNCHER_2, USER_10, () -> {
-            mLauncherApps.pinShortcuts(CALLING_PACKAGE_1, list("s10_1"),
-                    HANDLE_USER_10);
-            mLauncherApps.pinShortcuts(CALLING_PACKAGE_2, list("s10_2"),
-                    HANDLE_USER_10);
-        });
-
-        // Remove all dynamic shortcuts; now all shortcuts are just pinned.
-        runWithCaller(CALLING_PACKAGE_1, USER_0, () -> {
-            mManager.removeAllDynamicShortcuts();
-        });
-        runWithCaller(CALLING_PACKAGE_2, USER_0, () -> {
-            mManager.removeAllDynamicShortcuts();
-        });
-        runWithCaller(CALLING_PACKAGE_1, USER_10, () -> {
-            mManager.removeAllDynamicShortcuts();
-        });
-        runWithCaller(CALLING_PACKAGE_2, USER_10, () -> {
-            mManager.removeAllDynamicShortcuts();
-        });
-
-
-        final SparseArray<ShortcutUser> users =  mService.getShortcutsForTest();
-        assertEquals(2, users.size());
-        assertEquals(USER_0, users.keyAt(0));
-        assertEquals(USER_10, users.keyAt(1));
-
-        final ShortcutUser user0 =  users.get(USER_0);
-        final ShortcutUser user10 =  users.get(USER_10);
-
-
-        // Check the registered packages.
-        dumpsysOnLogcat();
-        assertEquals(set(CALLING_PACKAGE_1, CALLING_PACKAGE_2),
-                hashSet(user0.getAllPackagesForTest().keySet()));
-        assertEquals(set(CALLING_PACKAGE_1, CALLING_PACKAGE_2),
-                hashSet(user10.getAllPackagesForTest().keySet()));
-        assertEquals(
-                set(PackageWithUser.of(USER_0, LAUNCHER_1),
-                        PackageWithUser.of(USER_0, LAUNCHER_2)),
-                hashSet(user0.getAllLaunchersForTest().keySet()));
-        assertEquals(
-                set(PackageWithUser.of(USER_10, LAUNCHER_1),
-                        PackageWithUser.of(USER_10, LAUNCHER_2)),
-                hashSet(user10.getAllLaunchersForTest().keySet()));
-        assertShortcutIds(getLauncherPinnedShortcuts(LAUNCHER_1, USER_0),
-                "s0_1", "s0_2");
-        assertShortcutIds(getLauncherPinnedShortcuts(LAUNCHER_2, USER_0),
-                "s0_1", "s0_2");
-        assertShortcutIds(getLauncherPinnedShortcuts(LAUNCHER_1, USER_10),
-                "s10_1", "s10_2");
-        assertShortcutIds(getLauncherPinnedShortcuts(LAUNCHER_2, USER_10),
-                "s10_1", "s10_2");
-        assertShortcutExists(CALLING_PACKAGE_1, "s0_1", USER_0);
-        assertShortcutExists(CALLING_PACKAGE_2, "s0_2", USER_0);
-        assertShortcutExists(CALLING_PACKAGE_1, "s10_1", USER_10);
-        assertShortcutExists(CALLING_PACKAGE_2, "s10_2", USER_10);
-
-        mService.saveDirtyInfo();
-
-        // Nonexistent package.
-        uninstallPackage(USER_0, "abc");
-        mService.cleanUpPackageLocked("abc", USER_0, USER_0, /* appStillExists = */ false);
-
-        // No changes.
-        assertEquals(set(CALLING_PACKAGE_1, CALLING_PACKAGE_2),
-                hashSet(user0.getAllPackagesForTest().keySet()));
-        assertEquals(set(CALLING_PACKAGE_1, CALLING_PACKAGE_2),
-                hashSet(user10.getAllPackagesForTest().keySet()));
-        assertEquals(
-                set(PackageWithUser.of(USER_0, LAUNCHER_1),
-                        PackageWithUser.of(USER_0, LAUNCHER_2)),
-                hashSet(user0.getAllLaunchersForTest().keySet()));
-        assertEquals(
-                set(PackageWithUser.of(USER_10, LAUNCHER_1),
-                        PackageWithUser.of(USER_10, LAUNCHER_2)),
-                hashSet(user10.getAllLaunchersForTest().keySet()));
-        assertShortcutIds(getLauncherPinnedShortcuts(LAUNCHER_1, USER_0),
-                "s0_1", "s0_2");
-        assertShortcutIds(getLauncherPinnedShortcuts(LAUNCHER_2, USER_0),
-                "s0_1", "s0_2");
-        assertShortcutIds(getLauncherPinnedShortcuts(LAUNCHER_1, USER_10),
-                "s10_1", "s10_2");
-        assertShortcutIds(getLauncherPinnedShortcuts(LAUNCHER_2, USER_10),
-                "s10_1", "s10_2");
-        assertShortcutExists(CALLING_PACKAGE_1, "s0_1", USER_0);
-        assertShortcutExists(CALLING_PACKAGE_2, "s0_2", USER_0);
-        assertShortcutExists(CALLING_PACKAGE_1, "s10_1", USER_10);
-        assertShortcutExists(CALLING_PACKAGE_2, "s10_2", USER_10);
-
-        mService.saveDirtyInfo();
-
-        // Remove a package.
-        uninstallPackage(USER_0, CALLING_PACKAGE_1);
-        mService.cleanUpPackageLocked(CALLING_PACKAGE_1, USER_0, USER_0,
-                /* appStillExists = */ false);
-
-        assertEquals(set(CALLING_PACKAGE_2),
-                hashSet(user0.getAllPackagesForTest().keySet()));
-        assertEquals(set(CALLING_PACKAGE_1, CALLING_PACKAGE_2),
-                hashSet(user10.getAllPackagesForTest().keySet()));
-        assertEquals(
-                set(PackageWithUser.of(USER_0, LAUNCHER_1),
-                        PackageWithUser.of(USER_0, LAUNCHER_2)),
-                hashSet(user0.getAllLaunchersForTest().keySet()));
-        assertEquals(
-                set(PackageWithUser.of(USER_10, LAUNCHER_1),
-                        PackageWithUser.of(USER_10, LAUNCHER_2)),
-                hashSet(user10.getAllLaunchersForTest().keySet()));
-        assertShortcutIds(getLauncherPinnedShortcuts(LAUNCHER_1, USER_0),
-                "s0_2");
-        assertShortcutIds(getLauncherPinnedShortcuts(LAUNCHER_2, USER_0),
-                "s0_2");
-        assertShortcutIds(getLauncherPinnedShortcuts(LAUNCHER_1, USER_10),
-                "s10_1", "s10_2");
-        assertShortcutIds(getLauncherPinnedShortcuts(LAUNCHER_2, USER_10),
-                "s10_1", "s10_2");
-        assertShortcutNotExists(CALLING_PACKAGE_1, "s0_1", USER_0);
-        assertShortcutExists(CALLING_PACKAGE_2, "s0_2", USER_0);
-        assertShortcutExists(CALLING_PACKAGE_1, "s10_1", USER_10);
-        assertShortcutExists(CALLING_PACKAGE_2, "s10_2", USER_10);
-
-        mService.saveDirtyInfo();
-
-        // Remove a launcher.
-        uninstallPackage(USER_10, LAUNCHER_1);
-        mService.cleanUpPackageLocked(LAUNCHER_1, USER_10, USER_10, /* appStillExists = */ false);
-
-        assertEquals(set(CALLING_PACKAGE_2),
-                hashSet(user0.getAllPackagesForTest().keySet()));
-        assertEquals(set(CALLING_PACKAGE_1, CALLING_PACKAGE_2),
-                hashSet(user10.getAllPackagesForTest().keySet()));
-        assertEquals(
-                set(PackageWithUser.of(USER_0, LAUNCHER_1),
-                        PackageWithUser.of(USER_0, LAUNCHER_2)),
-                hashSet(user0.getAllLaunchersForTest().keySet()));
-        assertEquals(
-                set(PackageWithUser.of(USER_10, LAUNCHER_2)),
-                hashSet(user10.getAllLaunchersForTest().keySet()));
-        assertShortcutIds(getLauncherPinnedShortcuts(LAUNCHER_1, USER_0),
-                "s0_2");
-        assertShortcutIds(getLauncherPinnedShortcuts(LAUNCHER_2, USER_0),
-                "s0_2");
-        assertShortcutIds(getLauncherPinnedShortcuts(LAUNCHER_2, USER_10),
-                "s10_1", "s10_2");
-        assertShortcutNotExists(CALLING_PACKAGE_1, "s0_1", USER_0);
-        assertShortcutExists(CALLING_PACKAGE_2, "s0_2", USER_0);
-        assertShortcutExists(CALLING_PACKAGE_1, "s10_1", USER_10);
-        assertShortcutExists(CALLING_PACKAGE_2, "s10_2", USER_10);
-
-        mService.saveDirtyInfo();
-
-        // Remove a package.
-        uninstallPackage(USER_10, CALLING_PACKAGE_2);
-        mService.cleanUpPackageLocked(CALLING_PACKAGE_2, USER_10, USER_10,
-                /* appStillExists = */ false);
-
-        assertEquals(set(CALLING_PACKAGE_2),
-                hashSet(user0.getAllPackagesForTest().keySet()));
-        assertEquals(set(CALLING_PACKAGE_1),
-                hashSet(user10.getAllPackagesForTest().keySet()));
-        assertEquals(
-                set(PackageWithUser.of(USER_0, LAUNCHER_1),
-                        PackageWithUser.of(USER_0, LAUNCHER_2)),
-                hashSet(user0.getAllLaunchersForTest().keySet()));
-        assertEquals(
-                set(PackageWithUser.of(USER_10, LAUNCHER_2)),
-                hashSet(user10.getAllLaunchersForTest().keySet()));
-        assertShortcutIds(getLauncherPinnedShortcuts(LAUNCHER_1, USER_0),
-                "s0_2");
-        assertShortcutIds(getLauncherPinnedShortcuts(LAUNCHER_2, USER_0),
-                "s0_2");
-        assertShortcutIds(getLauncherPinnedShortcuts(LAUNCHER_2, USER_10),
-                "s10_1");
-        assertShortcutNotExists(CALLING_PACKAGE_1, "s0_1", USER_0);
-        assertShortcutExists(CALLING_PACKAGE_2, "s0_2", USER_0);
-        assertShortcutExists(CALLING_PACKAGE_1, "s10_1", USER_10);
-        assertShortcutNotExists(CALLING_PACKAGE_2, "s10_2", USER_10);
-
-        mService.saveDirtyInfo();
-
-        // Remove the other launcher from user 10 too.
-        uninstallPackage(USER_10, LAUNCHER_2);
-        mService.cleanUpPackageLocked(LAUNCHER_2, USER_10, USER_10,
-                /* appStillExists = */ false);
-
-        assertEquals(set(CALLING_PACKAGE_2),
-                hashSet(user0.getAllPackagesForTest().keySet()));
-        assertEquals(set(CALLING_PACKAGE_1),
-                hashSet(user10.getAllPackagesForTest().keySet()));
-        assertEquals(
-                set(PackageWithUser.of(USER_0, LAUNCHER_1),
-                        PackageWithUser.of(USER_0, LAUNCHER_2)),
-                hashSet(user0.getAllLaunchersForTest().keySet()));
-        assertEquals(
-                set(),
-                hashSet(user10.getAllLaunchersForTest().keySet()));
-        assertShortcutIds(getLauncherPinnedShortcuts(LAUNCHER_1, USER_0),
-                "s0_2");
-        assertShortcutIds(getLauncherPinnedShortcuts(LAUNCHER_2, USER_0),
-                "s0_2");
-
-        // Note the pinned shortcuts on user-10 no longer referred, so they should both be removed.
-        assertShortcutNotExists(CALLING_PACKAGE_1, "s0_1", USER_0);
-        assertShortcutExists(CALLING_PACKAGE_2, "s0_2", USER_0);
-        assertShortcutNotExists(CALLING_PACKAGE_1, "s10_1", USER_10);
-        assertShortcutNotExists(CALLING_PACKAGE_2, "s10_2", USER_10);
-
-        mService.saveDirtyInfo();
-
-        // More remove.
-        uninstallPackage(USER_10, CALLING_PACKAGE_1);
-        mService.cleanUpPackageLocked(CALLING_PACKAGE_1, USER_10, USER_10,
-                /* appStillExists = */ false);
-
-        assertEquals(set(CALLING_PACKAGE_2),
-                hashSet(user0.getAllPackagesForTest().keySet()));
-        assertEquals(set(),
-                hashSet(user10.getAllPackagesForTest().keySet()));
-        assertEquals(
-                set(PackageWithUser.of(USER_0, LAUNCHER_1),
-                        PackageWithUser.of(USER_0, LAUNCHER_2)),
-                hashSet(user0.getAllLaunchersForTest().keySet()));
-        assertEquals(set(),
-                hashSet(user10.getAllLaunchersForTest().keySet()));
-        assertShortcutIds(getLauncherPinnedShortcuts(LAUNCHER_1, USER_0),
-                "s0_2");
-        assertShortcutIds(getLauncherPinnedShortcuts(LAUNCHER_2, USER_0),
-                "s0_2");
-
-        // Note the pinned shortcuts on user-10 no longer referred, so they should both be removed.
-        assertShortcutNotExists(CALLING_PACKAGE_1, "s0_1", USER_0);
-        assertShortcutExists(CALLING_PACKAGE_2, "s0_2", USER_0);
-        assertShortcutNotExists(CALLING_PACKAGE_1, "s10_1", USER_10);
-        assertShortcutNotExists(CALLING_PACKAGE_2, "s10_2", USER_10);
-
-        mService.saveDirtyInfo();
-    }
-
-    public void testCleanupPackage_republishManifests() {
-        addManifestShortcutResource(
-                new ComponentName(CALLING_PACKAGE_1, ShortcutActivity.class.getName()),
-                R.xml.shortcut_2);
-        updatePackageVersion(CALLING_PACKAGE_1, 1);
-                mService.mPackageMonitor.onReceive(getTestContext(),
-                genPackageAddIntent(CALLING_PACKAGE_1, USER_0));
-
-        runWithCaller(CALLING_PACKAGE_1, USER_0, () -> {
-            assertTrue(mManager.setDynamicShortcuts(list(
-                    makeShortcut("s1"), makeShortcut("s2"), makeShortcut("s3"))));
-        });
-        runWithCaller(LAUNCHER_1, USER_0, () -> {
-            mLauncherApps.pinShortcuts(CALLING_PACKAGE_1,
-                    list("s2", "s3", "ms1", "ms2"), HANDLE_USER_0);
-        });
-
-        // Remove ms2 from manifest.
-        addManifestShortcutResource(
-                new ComponentName(CALLING_PACKAGE_1, ShortcutActivity.class.getName()),
-                R.xml.shortcut_1);
-        updatePackageVersion(CALLING_PACKAGE_1, 1);
-                mService.mPackageMonitor.onReceive(getTestContext(),
-                genPackageAddIntent(CALLING_PACKAGE_1, USER_0));
-
-        runWithCaller(CALLING_PACKAGE_1, USER_0, () -> {
-            assertTrue(mManager.setDynamicShortcuts(list(
-                    makeShortcut("s1"), makeShortcut("s2"))));
-
-            // Make sure the shortcuts are in the intended state.
-            assertWith(getCallerShortcuts())
-                    .haveIds("ms1", "ms2", "s1", "s2", "s3")
-
-                    .selectByIds("ms1")
-                    .areAllManifest()
-                    .areAllPinned()
-
-                    .revertToOriginalList()
-                    .selectByIds("ms2")
-                    .areAllNotManifest()
-                    .areAllPinned()
-
-                    .revertToOriginalList()
-                    .selectByIds("s1")
-                    .areAllDynamic()
-                    .areAllNotPinned()
-
-                    .revertToOriginalList()
-                    .selectByIds("s2")
-                    .areAllDynamic()
-                    .areAllPinned()
-
-                    .revertToOriginalList()
-                    .selectByIds("s3")
-                    .areAllNotDynamic()
-                    .areAllPinned();
-        });
-
-        // Clean up + re-publish manifests.
-        mService.cleanUpPackageLocked(CALLING_PACKAGE_1, USER_0, USER_0,
-                /* appStillExists = */ true);
-        runWithCaller(CALLING_PACKAGE_1, USER_0, () -> {
-            assertWith(getCallerShortcuts())
-                    .haveIds("ms1")
-                    .areAllManifest();
-        });
-    }
-
-    public void testHandleGonePackage_crossProfile() {
-        // Create some shortcuts.
-        runWithCaller(CALLING_PACKAGE_1, USER_0, () -> {
-            assertTrue(mManager.setDynamicShortcuts(list(
-                    makeShortcut("s1"), makeShortcut("s2"), makeShortcut("s3"))));
-        });
-        runWithCaller(CALLING_PACKAGE_1, USER_P0, () -> {
-            assertTrue(mManager.setDynamicShortcuts(list(
-                    makeShortcut("s1"), makeShortcut("s2"), makeShortcut("s3"))));
-        });
-        runWithCaller(CALLING_PACKAGE_2, USER_0, () -> {
-            assertTrue(mManager.setDynamicShortcuts(list(
-                    makeShortcut("s1"), makeShortcut("s2"), makeShortcut("s3"))));
-        });
-
-        mRunningUsers.put(USER_10, true);
-
-        runWithCaller(CALLING_PACKAGE_1, USER_10, () -> {
-            assertTrue(mManager.setDynamicShortcuts(list(
-                    makeShortcut("s1"), makeShortcut("s2"), makeShortcut("s3"))));
-        });
-
-        assertDynamicOnly(getPackageShortcut(CALLING_PACKAGE_1, "s1", USER_0));
-        assertDynamicOnly(getPackageShortcut(CALLING_PACKAGE_1, "s2", USER_0));
-        assertDynamicOnly(getPackageShortcut(CALLING_PACKAGE_1, "s3", USER_0));
-
-        assertDynamicOnly(getPackageShortcut(CALLING_PACKAGE_1, "s1", USER_P0));
-        assertDynamicOnly(getPackageShortcut(CALLING_PACKAGE_1, "s2", USER_P0));
-        assertDynamicOnly(getPackageShortcut(CALLING_PACKAGE_1, "s3", USER_P0));
-
-        assertDynamicOnly(getPackageShortcut(CALLING_PACKAGE_2, "s1", USER_0));
-        assertDynamicOnly(getPackageShortcut(CALLING_PACKAGE_2, "s2", USER_0));
-        assertDynamicOnly(getPackageShortcut(CALLING_PACKAGE_2, "s3", USER_0));
-
-        assertDynamicOnly(getPackageShortcut(CALLING_PACKAGE_1, "s1", USER_10));
-        assertDynamicOnly(getPackageShortcut(CALLING_PACKAGE_1, "s2", USER_10));
-        assertDynamicOnly(getPackageShortcut(CALLING_PACKAGE_1, "s3", USER_10));
-
-        // Pin some.
-
-        runWithCaller(LAUNCHER_1, USER_0, () -> {
-            mLauncherApps.pinShortcuts(CALLING_PACKAGE_1,
-                    list("s1"), HANDLE_USER_0);
-
-            mLauncherApps.pinShortcuts(CALLING_PACKAGE_1,
-                    list("s2"), UserHandle.of(USER_P0));
-
-            mLauncherApps.pinShortcuts(CALLING_PACKAGE_2,
-                    list("s3"), HANDLE_USER_0);
-        });
-
-        runWithCaller(LAUNCHER_1, USER_P0, () -> {
-            mLauncherApps.pinShortcuts(CALLING_PACKAGE_1,
-                    list("s2"), HANDLE_USER_0);
-
-            mLauncherApps.pinShortcuts(CALLING_PACKAGE_1,
-                    list("s3"), UserHandle.of(USER_P0));
-
-            mLauncherApps.pinShortcuts(CALLING_PACKAGE_2,
-                    list("s1"), HANDLE_USER_0);
-        });
-
-        runWithCaller(LAUNCHER_1, USER_10, () -> {
-            mLauncherApps.pinShortcuts(CALLING_PACKAGE_1,
-                    list("s3"), HANDLE_USER_10);
-        });
-
-        // Check the state.
-
-        assertDynamicAndPinned(getPackageShortcut(CALLING_PACKAGE_1, "s1", USER_0));
-        assertDynamicAndPinned(getPackageShortcut(CALLING_PACKAGE_1, "s2", USER_0));
-        assertDynamicOnly(getPackageShortcut(CALLING_PACKAGE_1, "s3", USER_0));
-
-        assertDynamicOnly(getPackageShortcut(CALLING_PACKAGE_1, "s1", USER_P0));
-        assertDynamicAndPinned(getPackageShortcut(CALLING_PACKAGE_1, "s2", USER_P0));
-        assertDynamicAndPinned(getPackageShortcut(CALLING_PACKAGE_1, "s3", USER_P0));
-
-        assertDynamicAndPinned(getPackageShortcut(CALLING_PACKAGE_2, "s1", USER_0));
-        assertDynamicOnly(getPackageShortcut(CALLING_PACKAGE_2, "s2", USER_0));
-        assertDynamicAndPinned(getPackageShortcut(CALLING_PACKAGE_2, "s3", USER_0));
-
-        assertDynamicOnly(getPackageShortcut(CALLING_PACKAGE_1, "s1", USER_10));
-        assertDynamicOnly(getPackageShortcut(CALLING_PACKAGE_1, "s2", USER_10));
-        assertDynamicAndPinned(getPackageShortcut(CALLING_PACKAGE_1, "s3", USER_10));
-
-        // Make sure all the information is persisted.
-        mService.saveDirtyInfo();
-        initService();
-        mService.handleUnlockUser(USER_0);
-        mService.handleUnlockUser(USER_P0);
-        mService.handleUnlockUser(USER_10);
-
-        assertDynamicAndPinned(getPackageShortcut(CALLING_PACKAGE_1, "s1", USER_0));
-        assertDynamicAndPinned(getPackageShortcut(CALLING_PACKAGE_1, "s2", USER_0));
-        assertDynamicOnly(getPackageShortcut(CALLING_PACKAGE_1, "s3", USER_0));
-
-        assertDynamicOnly(getPackageShortcut(CALLING_PACKAGE_1, "s1", USER_P0));
-        assertDynamicAndPinned(getPackageShortcut(CALLING_PACKAGE_1, "s2", USER_P0));
-        assertDynamicAndPinned(getPackageShortcut(CALLING_PACKAGE_1, "s3", USER_P0));
-
-        assertDynamicAndPinned(getPackageShortcut(CALLING_PACKAGE_2, "s1", USER_0));
-        assertDynamicOnly(getPackageShortcut(CALLING_PACKAGE_2, "s2", USER_0));
-        assertDynamicAndPinned(getPackageShortcut(CALLING_PACKAGE_2, "s3", USER_0));
-
-        assertDynamicOnly(getPackageShortcut(CALLING_PACKAGE_1, "s1", USER_10));
-        assertDynamicOnly(getPackageShortcut(CALLING_PACKAGE_1, "s2", USER_10));
-        assertDynamicAndPinned(getPackageShortcut(CALLING_PACKAGE_1, "s3", USER_10));
-
-        // Start uninstalling.
-        uninstallPackage(USER_10, LAUNCHER_1);
-        mService.checkPackageChanges(USER_10);
-
-        assertDynamicAndPinned(getPackageShortcut(CALLING_PACKAGE_1, "s1", USER_0));
-        assertDynamicAndPinned(getPackageShortcut(CALLING_PACKAGE_1, "s2", USER_0));
-        assertDynamicOnly(getPackageShortcut(CALLING_PACKAGE_1, "s3", USER_0));
-
-        assertDynamicOnly(getPackageShortcut(CALLING_PACKAGE_1, "s1", USER_P0));
-        assertDynamicAndPinned(getPackageShortcut(CALLING_PACKAGE_1, "s2", USER_P0));
-        assertDynamicAndPinned(getPackageShortcut(CALLING_PACKAGE_1, "s3", USER_P0));
-
-        assertDynamicAndPinned(getPackageShortcut(CALLING_PACKAGE_2, "s1", USER_0));
-        assertDynamicOnly(getPackageShortcut(CALLING_PACKAGE_2, "s2", USER_0));
-        assertDynamicAndPinned(getPackageShortcut(CALLING_PACKAGE_2, "s3", USER_0));
-
-        assertDynamicOnly(getPackageShortcut(CALLING_PACKAGE_1, "s1", USER_10));
-        assertDynamicOnly(getPackageShortcut(CALLING_PACKAGE_1, "s2", USER_10));
-        assertDynamicOnly(getPackageShortcut(CALLING_PACKAGE_1, "s3", USER_10));
-
-        // Uninstall.
-        uninstallPackage(USER_10, CALLING_PACKAGE_1);
-        mService.checkPackageChanges(USER_10);
-
-        assertDynamicAndPinned(getPackageShortcut(CALLING_PACKAGE_1, "s1", USER_0));
-        assertDynamicAndPinned(getPackageShortcut(CALLING_PACKAGE_1, "s2", USER_0));
-        assertDynamicOnly(getPackageShortcut(CALLING_PACKAGE_1, "s3", USER_0));
-
-        assertDynamicOnly(getPackageShortcut(CALLING_PACKAGE_1, "s1", USER_P0));
-        assertDynamicAndPinned(getPackageShortcut(CALLING_PACKAGE_1, "s2", USER_P0));
-        assertDynamicAndPinned(getPackageShortcut(CALLING_PACKAGE_1, "s3", USER_P0));
-
-        assertDynamicAndPinned(getPackageShortcut(CALLING_PACKAGE_2, "s1", USER_0));
-        assertDynamicOnly(getPackageShortcut(CALLING_PACKAGE_2, "s2", USER_0));
-        assertDynamicAndPinned(getPackageShortcut(CALLING_PACKAGE_2, "s3", USER_0));
-
-        assertNull(getPackageShortcut(CALLING_PACKAGE_1, "s1", USER_10));
-        assertNull(getPackageShortcut(CALLING_PACKAGE_1, "s2", USER_10));
-        assertNull(getPackageShortcut(CALLING_PACKAGE_1, "s3", USER_10));
-
-        uninstallPackage(USER_P0, LAUNCHER_1);
-        mService.checkPackageChanges(USER_0);
-
-        assertDynamicAndPinned(getPackageShortcut(CALLING_PACKAGE_1, "s1", USER_0));
-        assertDynamicOnly(getPackageShortcut(CALLING_PACKAGE_1, "s2", USER_0));
-        assertDynamicOnly(getPackageShortcut(CALLING_PACKAGE_1, "s3", USER_0));
-
-        assertDynamicOnly(getPackageShortcut(CALLING_PACKAGE_1, "s1", USER_P0));
-        assertDynamicAndPinned(getPackageShortcut(CALLING_PACKAGE_1, "s2", USER_P0));
-        assertDynamicAndPinned(getPackageShortcut(CALLING_PACKAGE_1, "s3", USER_P0));
-
-        assertDynamicOnly(getPackageShortcut(CALLING_PACKAGE_2, "s1", USER_0));
-        assertDynamicOnly(getPackageShortcut(CALLING_PACKAGE_2, "s2", USER_0));
-        assertDynamicAndPinned(getPackageShortcut(CALLING_PACKAGE_2, "s3", USER_0));
-
-        assertNull(getPackageShortcut(CALLING_PACKAGE_1, "s1", USER_10));
-        assertNull(getPackageShortcut(CALLING_PACKAGE_1, "s2", USER_10));
-        assertNull(getPackageShortcut(CALLING_PACKAGE_1, "s3", USER_10));
-
-        mService.checkPackageChanges(USER_P0);
-
-        assertDynamicAndPinned(getPackageShortcut(CALLING_PACKAGE_1, "s1", USER_0));
-        assertDynamicOnly(getPackageShortcut(CALLING_PACKAGE_1, "s2", USER_0));
-        assertDynamicOnly(getPackageShortcut(CALLING_PACKAGE_1, "s3", USER_0));
-
-        assertDynamicOnly(getPackageShortcut(CALLING_PACKAGE_1, "s1", USER_P0));
-        assertDynamicAndPinned(getPackageShortcut(CALLING_PACKAGE_1, "s2", USER_P0));
-        assertDynamicOnly(getPackageShortcut(CALLING_PACKAGE_1, "s3", USER_P0));
-
-        assertDynamicOnly(getPackageShortcut(CALLING_PACKAGE_2, "s1", USER_0));
-        assertDynamicOnly(getPackageShortcut(CALLING_PACKAGE_2, "s2", USER_0));
-        assertDynamicAndPinned(getPackageShortcut(CALLING_PACKAGE_2, "s3", USER_0));
-
-        assertNull(getPackageShortcut(CALLING_PACKAGE_1, "s1", USER_10));
-        assertNull(getPackageShortcut(CALLING_PACKAGE_1, "s2", USER_10));
-        assertNull(getPackageShortcut(CALLING_PACKAGE_1, "s3", USER_10));
-
-        uninstallPackage(USER_P0, CALLING_PACKAGE_1);
-
-        mService.saveDirtyInfo();
-        initService();
-        mService.handleUnlockUser(USER_0);
-        mService.handleUnlockUser(USER_P0);
-        mService.handleUnlockUser(USER_10);
-
-        assertDynamicAndPinned(getPackageShortcut(CALLING_PACKAGE_1, "s1", USER_0));
-        assertDynamicOnly(getPackageShortcut(CALLING_PACKAGE_1, "s2", USER_0));
-        assertDynamicOnly(getPackageShortcut(CALLING_PACKAGE_1, "s3", USER_0));
-
-        assertNull(getPackageShortcut(CALLING_PACKAGE_1, "s1", USER_P0));
-        assertNull(getPackageShortcut(CALLING_PACKAGE_1, "s2", USER_P0));
-        assertNull(getPackageShortcut(CALLING_PACKAGE_1, "s3", USER_P0));
-
-        assertDynamicOnly(getPackageShortcut(CALLING_PACKAGE_2, "s1", USER_0));
-        assertDynamicOnly(getPackageShortcut(CALLING_PACKAGE_2, "s2", USER_0));
-        assertDynamicAndPinned(getPackageShortcut(CALLING_PACKAGE_2, "s3", USER_0));
-
-        assertNull(getPackageShortcut(CALLING_PACKAGE_1, "s1", USER_10));
-        assertNull(getPackageShortcut(CALLING_PACKAGE_1, "s2", USER_10));
-        assertNull(getPackageShortcut(CALLING_PACKAGE_1, "s3", USER_10));
-
-        // Uninstall
-        uninstallPackage(USER_0, LAUNCHER_1);
-
-        mService.saveDirtyInfo();
-        initService();
-        mService.handleUnlockUser(USER_0);
-        mService.handleUnlockUser(USER_P0);
-        mService.handleUnlockUser(USER_10);
-
-        assertDynamicOnly(getPackageShortcut(CALLING_PACKAGE_1, "s1", USER_0));
-        assertDynamicOnly(getPackageShortcut(CALLING_PACKAGE_1, "s2", USER_0));
-        assertDynamicOnly(getPackageShortcut(CALLING_PACKAGE_1, "s3", USER_0));
-
-        assertNull(getPackageShortcut(CALLING_PACKAGE_1, "s1", USER_P0));
-        assertNull(getPackageShortcut(CALLING_PACKAGE_1, "s2", USER_P0));
-        assertNull(getPackageShortcut(CALLING_PACKAGE_1, "s3", USER_P0));
-
-        assertDynamicOnly(getPackageShortcut(CALLING_PACKAGE_2, "s1", USER_0));
-        assertDynamicOnly(getPackageShortcut(CALLING_PACKAGE_2, "s2", USER_0));
-        assertDynamicOnly(getPackageShortcut(CALLING_PACKAGE_2, "s3", USER_0));
-
-        assertNull(getPackageShortcut(CALLING_PACKAGE_1, "s1", USER_10));
-        assertNull(getPackageShortcut(CALLING_PACKAGE_1, "s2", USER_10));
-        assertNull(getPackageShortcut(CALLING_PACKAGE_1, "s3", USER_10));
-
-        uninstallPackage(USER_0, CALLING_PACKAGE_2);
-
-        mService.saveDirtyInfo();
-        initService();
-        mService.handleUnlockUser(USER_0);
-        mService.handleUnlockUser(USER_P0);
-        mService.handleUnlockUser(USER_10);
-
-        assertDynamicOnly(getPackageShortcut(CALLING_PACKAGE_1, "s1", USER_0));
-        assertDynamicOnly(getPackageShortcut(CALLING_PACKAGE_1, "s2", USER_0));
-        assertDynamicOnly(getPackageShortcut(CALLING_PACKAGE_1, "s3", USER_0));
-
-        assertNull(getPackageShortcut(CALLING_PACKAGE_1, "s1", USER_P0));
-        assertNull(getPackageShortcut(CALLING_PACKAGE_1, "s2", USER_P0));
-        assertNull(getPackageShortcut(CALLING_PACKAGE_1, "s3", USER_P0));
-
-        assertNull(getPackageShortcut(CALLING_PACKAGE_2, "s1", USER_0));
-        assertNull(getPackageShortcut(CALLING_PACKAGE_2, "s2", USER_0));
-        assertNull(getPackageShortcut(CALLING_PACKAGE_2, "s3", USER_0));
-
-        assertNull(getPackageShortcut(CALLING_PACKAGE_1, "s1", USER_10));
-        assertNull(getPackageShortcut(CALLING_PACKAGE_1, "s2", USER_10));
-        assertNull(getPackageShortcut(CALLING_PACKAGE_1, "s3", USER_10));
-    }
-
-    protected void checkCanRestoreTo(boolean expected, ShortcutPackageInfo spi,
-            int version, String... signatures) {
-        assertEquals(expected, spi.canRestoreTo(mService, genPackage(
-                "dummy", /* uid */ 0, version, signatures)));
-    }
-
-    public void testCanRestoreTo() {
-        addPackage(CALLING_PACKAGE_1, CALLING_UID_1, 10, "sig1");
-        addPackage(CALLING_PACKAGE_2, CALLING_UID_1, 10, "sig1", "sig2");
-
-        final ShortcutPackageInfo spi1 = ShortcutPackageInfo.generateForInstalledPackageForTest(
-                mService, CALLING_PACKAGE_1, USER_0);
-        final ShortcutPackageInfo spi2 = ShortcutPackageInfo.generateForInstalledPackageForTest(
-                mService, CALLING_PACKAGE_2, USER_0);
-
-        checkCanRestoreTo(true, spi1, 10, "sig1");
-        checkCanRestoreTo(true, spi1, 10, "x", "sig1");
-        checkCanRestoreTo(true, spi1, 10, "sig1", "y");
-        checkCanRestoreTo(true, spi1, 10, "x", "sig1", "y");
-        checkCanRestoreTo(true, spi1, 11, "sig1");
-
-        checkCanRestoreTo(false, spi1, 10 /* empty */);
-        checkCanRestoreTo(false, spi1, 10, "x");
-        checkCanRestoreTo(false, spi1, 10, "x", "y");
-        checkCanRestoreTo(false, spi1, 10, "x");
-        checkCanRestoreTo(false, spi1, 9, "sig1");
-
-        checkCanRestoreTo(true, spi2, 10, "sig1", "sig2");
-        checkCanRestoreTo(true, spi2, 10, "sig2", "sig1");
-        checkCanRestoreTo(true, spi2, 10, "x", "sig1", "sig2");
-        checkCanRestoreTo(true, spi2, 10, "x", "sig2", "sig1");
-        checkCanRestoreTo(true, spi2, 10, "sig1", "sig2", "y");
-        checkCanRestoreTo(true, spi2, 10, "sig2", "sig1", "y");
-        checkCanRestoreTo(true, spi2, 10, "x", "sig1", "sig2", "y");
-        checkCanRestoreTo(true, spi2, 10, "x", "sig2", "sig1", "y");
-        checkCanRestoreTo(true, spi2, 11, "x", "sig2", "sig1", "y");
-
-        checkCanRestoreTo(false, spi2, 10, "sig1", "sig2x");
-        checkCanRestoreTo(false, spi2, 10, "sig2", "sig1x");
-        checkCanRestoreTo(false, spi2, 10, "x", "sig1x", "sig2");
-        checkCanRestoreTo(false, spi2, 10, "x", "sig2x", "sig1");
-        checkCanRestoreTo(false, spi2, 10, "sig1", "sig2x", "y");
-        checkCanRestoreTo(false, spi2, 10, "sig2", "sig1x", "y");
-        checkCanRestoreTo(false, spi2, 10, "x", "sig1x", "sig2", "y");
-        checkCanRestoreTo(false, spi2, 10, "x", "sig2x", "sig1", "y");
-        checkCanRestoreTo(false, spi2, 11, "x", "sig2x", "sig1", "y");
-    }
-
-    public void testHandlePackageDelete() {
-        final Icon bmp32x32 = Icon.createWithBitmap(BitmapFactory.decodeResource(
-                getTestContext().getResources(), R.drawable.black_32x32));
-        setCaller(CALLING_PACKAGE_1, USER_0);
-        assertTrue(mManager.addDynamicShortcuts(list(
-                makeShortcutWithIcon("s1", bmp32x32), makeShortcutWithIcon("s2", bmp32x32)
-        )));
-        // Also add a manifest shortcut, which should be removed too.
-        addManifestShortcutResource(
-                new ComponentName(CALLING_PACKAGE_1, ShortcutActivity.class.getName()),
-                R.xml.shortcut_1);
-        updatePackageVersion(CALLING_PACKAGE_1, 1);
-                mService.mPackageMonitor.onReceive(getTestContext(),
-                genPackageAddIntent(CALLING_PACKAGE_1, USER_0));
-        runWithCaller(CALLING_PACKAGE_1, USER_0, () -> {
-            assertWith(getCallerShortcuts())
-                    .haveIds("s1", "s2", "ms1")
-
-                    .selectManifest()
-                    .haveIds("ms1");
-        });
-
-        setCaller(CALLING_PACKAGE_2, USER_0);
-        assertTrue(mManager.addDynamicShortcuts(list(makeShortcutWithIcon("s1", bmp32x32))));
-
-        setCaller(CALLING_PACKAGE_3, USER_0);
-        assertTrue(mManager.addDynamicShortcuts(list(makeShortcutWithIcon("s1", bmp32x32))));
-
-        mRunningUsers.put(USER_10, true);
-
-        setCaller(CALLING_PACKAGE_1, USER_10);
-        assertTrue(mManager.addDynamicShortcuts(list(makeShortcutWithIcon("s1", bmp32x32))));
-
-        setCaller(CALLING_PACKAGE_2, USER_10);
-        assertTrue(mManager.addDynamicShortcuts(list(makeShortcutWithIcon("s1", bmp32x32))));
-
-        setCaller(CALLING_PACKAGE_3, USER_10);
-        assertTrue(mManager.addDynamicShortcuts(list(makeShortcutWithIcon("s1", bmp32x32))));
-
-        assertNotNull(mService.getPackageShortcutForTest(CALLING_PACKAGE_1, "s1", USER_0));
-        assertNotNull(mService.getPackageShortcutForTest(CALLING_PACKAGE_2, "s1", USER_0));
-        assertNotNull(mService.getPackageShortcutForTest(CALLING_PACKAGE_3, "s1", USER_0));
-        assertNotNull(mService.getPackageShortcutForTest(CALLING_PACKAGE_1, "s1", USER_10));
-        assertNotNull(mService.getPackageShortcutForTest(CALLING_PACKAGE_2, "s1", USER_10));
-        assertNotNull(mService.getPackageShortcutForTest(CALLING_PACKAGE_3, "s1", USER_10));
-
-        assertTrue(bitmapDirectoryExists(CALLING_PACKAGE_1, USER_0));
-        assertTrue(bitmapDirectoryExists(CALLING_PACKAGE_2, USER_0));
-        assertTrue(bitmapDirectoryExists(CALLING_PACKAGE_3, USER_0));
-        assertTrue(bitmapDirectoryExists(CALLING_PACKAGE_1, USER_10));
-        assertTrue(bitmapDirectoryExists(CALLING_PACKAGE_2, USER_10));
-        assertTrue(bitmapDirectoryExists(CALLING_PACKAGE_3, USER_10));
-
-        uninstallPackage(USER_0, CALLING_PACKAGE_1);
-                mService.mPackageMonitor.onReceive(getTestContext(),
-                genPackageDeleteIntent(CALLING_PACKAGE_1, USER_0));
-
-        assertNull(mService.getPackageShortcutForTest(CALLING_PACKAGE_1, "s1", USER_0));
-        assertNotNull(mService.getPackageShortcutForTest(CALLING_PACKAGE_2, "s1", USER_0));
-        assertNotNull(mService.getPackageShortcutForTest(CALLING_PACKAGE_3, "s1", USER_0));
-        assertNotNull(mService.getPackageShortcutForTest(CALLING_PACKAGE_1, "s1", USER_10));
-        assertNotNull(mService.getPackageShortcutForTest(CALLING_PACKAGE_2, "s1", USER_10));
-        assertNotNull(mService.getPackageShortcutForTest(CALLING_PACKAGE_3, "s1", USER_10));
-
-        assertFalse(bitmapDirectoryExists(CALLING_PACKAGE_1, USER_0));
-        assertTrue(bitmapDirectoryExists(CALLING_PACKAGE_2, USER_0));
-        assertTrue(bitmapDirectoryExists(CALLING_PACKAGE_3, USER_0));
-        assertTrue(bitmapDirectoryExists(CALLING_PACKAGE_1, USER_10));
-        assertTrue(bitmapDirectoryExists(CALLING_PACKAGE_2, USER_10));
-        assertTrue(bitmapDirectoryExists(CALLING_PACKAGE_3, USER_10));
-
-        mRunningUsers.put(USER_10, true);
-
-        uninstallPackage(USER_10, CALLING_PACKAGE_2);
-                mService.mPackageMonitor.onReceive(getTestContext(),
-                genPackageDeleteIntent(CALLING_PACKAGE_2, USER_10));
-
-        assertNull(mService.getPackageShortcutForTest(CALLING_PACKAGE_1, "s1", USER_0));
-        assertNotNull(mService.getPackageShortcutForTest(CALLING_PACKAGE_2, "s1", USER_0));
-        assertNotNull(mService.getPackageShortcutForTest(CALLING_PACKAGE_3, "s1", USER_0));
-        assertNotNull(mService.getPackageShortcutForTest(CALLING_PACKAGE_1, "s1", USER_10));
-        assertNull(mService.getPackageShortcutForTest(CALLING_PACKAGE_2, "s1", USER_10));
-        assertNotNull(mService.getPackageShortcutForTest(CALLING_PACKAGE_3, "s1", USER_10));
-
-        assertFalse(bitmapDirectoryExists(CALLING_PACKAGE_1, USER_0));
-        assertTrue(bitmapDirectoryExists(CALLING_PACKAGE_2, USER_0));
-        assertTrue(bitmapDirectoryExists(CALLING_PACKAGE_3, USER_0));
-        assertTrue(bitmapDirectoryExists(CALLING_PACKAGE_1, USER_10));
-        assertFalse(bitmapDirectoryExists(CALLING_PACKAGE_2, USER_10));
-        assertTrue(bitmapDirectoryExists(CALLING_PACKAGE_3, USER_10));
-
-        mInjectedPackages.remove(CALLING_PACKAGE_1);
-        mInjectedPackages.remove(CALLING_PACKAGE_3);
-
-        mService.checkPackageChanges(USER_0);
-
-        assertNull(mService.getPackageShortcutForTest(CALLING_PACKAGE_1, "s1", USER_0));
-        assertNotNull(mService.getPackageShortcutForTest(CALLING_PACKAGE_2, "s1", USER_0));
-        assertNull(mService.getPackageShortcutForTest(CALLING_PACKAGE_3, "s1", USER_0));  // ---------------
-        assertNotNull(mService.getPackageShortcutForTest(CALLING_PACKAGE_1, "s1", USER_10));
-        assertNull(mService.getPackageShortcutForTest(CALLING_PACKAGE_2, "s1", USER_10));
-        assertNotNull(mService.getPackageShortcutForTest(CALLING_PACKAGE_3, "s1", USER_10));
-
-        assertFalse(bitmapDirectoryExists(CALLING_PACKAGE_1, USER_0));
-        assertTrue(bitmapDirectoryExists(CALLING_PACKAGE_2, USER_0));
-        assertFalse(bitmapDirectoryExists(CALLING_PACKAGE_3, USER_0));
-        assertTrue(bitmapDirectoryExists(CALLING_PACKAGE_1, USER_10));
-        assertFalse(bitmapDirectoryExists(CALLING_PACKAGE_2, USER_10));
-        assertTrue(bitmapDirectoryExists(CALLING_PACKAGE_3, USER_10));
-
-        mService.checkPackageChanges(USER_10);
-
-        assertNull(mService.getPackageShortcutForTest(CALLING_PACKAGE_1, "s1", USER_0));
-        assertNotNull(mService.getPackageShortcutForTest(CALLING_PACKAGE_2, "s1", USER_0));
-        assertNull(mService.getPackageShortcutForTest(CALLING_PACKAGE_3, "s1", USER_0));
-        assertNull(mService.getPackageShortcutForTest(CALLING_PACKAGE_1, "s1", USER_10));
-        assertNull(mService.getPackageShortcutForTest(CALLING_PACKAGE_2, "s1", USER_10));
-        assertNull(mService.getPackageShortcutForTest(CALLING_PACKAGE_3, "s1", USER_10));
-
-        assertFalse(bitmapDirectoryExists(CALLING_PACKAGE_1, USER_0));
-        assertTrue(bitmapDirectoryExists(CALLING_PACKAGE_2, USER_0));
-        assertFalse(bitmapDirectoryExists(CALLING_PACKAGE_3, USER_0));
-        assertFalse(bitmapDirectoryExists(CALLING_PACKAGE_1, USER_10));
-        assertFalse(bitmapDirectoryExists(CALLING_PACKAGE_2, USER_10));
-        assertFalse(bitmapDirectoryExists(CALLING_PACKAGE_3, USER_10));
-    }
-
-    /** Almost ame as testHandlePackageDelete, except it doesn't uninstall packages. */
-    public void testHandlePackageClearData() {
-        final Icon bmp32x32 = Icon.createWithBitmap(BitmapFactory.decodeResource(
-                getTestContext().getResources(), R.drawable.black_32x32));
-        setCaller(CALLING_PACKAGE_1, USER_0);
-        assertTrue(mManager.addDynamicShortcuts(list(
-                makeShortcutWithIcon("s1", bmp32x32), makeShortcutWithIcon("s2", bmp32x32)
-        )));
-
-        setCaller(CALLING_PACKAGE_2, USER_0);
-        assertTrue(mManager.addDynamicShortcuts(list(makeShortcutWithIcon("s1", bmp32x32))));
-
-        setCaller(CALLING_PACKAGE_3, USER_0);
-        assertTrue(mManager.addDynamicShortcuts(list(makeShortcutWithIcon("s1", bmp32x32))));
-
-        mRunningUsers.put(USER_10, true);
-
-        setCaller(CALLING_PACKAGE_1, USER_10);
-        assertTrue(mManager.addDynamicShortcuts(list(makeShortcutWithIcon("s1", bmp32x32))));
-
-        setCaller(CALLING_PACKAGE_2, USER_10);
-        assertTrue(mManager.addDynamicShortcuts(list(makeShortcutWithIcon("s1", bmp32x32))));
-
-        setCaller(CALLING_PACKAGE_3, USER_10);
-        assertTrue(mManager.addDynamicShortcuts(list(makeShortcutWithIcon("s1", bmp32x32))));
-
-        assertNotNull(mService.getPackageShortcutForTest(CALLING_PACKAGE_1, "s1", USER_0));
-        assertNotNull(mService.getPackageShortcutForTest(CALLING_PACKAGE_2, "s1", USER_0));
-        assertNotNull(mService.getPackageShortcutForTest(CALLING_PACKAGE_3, "s1", USER_0));
-        assertNotNull(mService.getPackageShortcutForTest(CALLING_PACKAGE_1, "s1", USER_10));
-        assertNotNull(mService.getPackageShortcutForTest(CALLING_PACKAGE_2, "s1", USER_10));
-        assertNotNull(mService.getPackageShortcutForTest(CALLING_PACKAGE_3, "s1", USER_10));
-
-        assertTrue(bitmapDirectoryExists(CALLING_PACKAGE_1, USER_0));
-        assertTrue(bitmapDirectoryExists(CALLING_PACKAGE_2, USER_0));
-        assertTrue(bitmapDirectoryExists(CALLING_PACKAGE_3, USER_0));
-        assertTrue(bitmapDirectoryExists(CALLING_PACKAGE_1, USER_10));
-        assertTrue(bitmapDirectoryExists(CALLING_PACKAGE_2, USER_10));
-        assertTrue(bitmapDirectoryExists(CALLING_PACKAGE_3, USER_10));
-
-                mService.mPackageMonitor.onReceive(getTestContext(),
-                genPackageDataClear(CALLING_PACKAGE_1, USER_0));
-
-        assertNull(mService.getPackageShortcutForTest(CALLING_PACKAGE_1, "s1", USER_0));
-        assertNotNull(mService.getPackageShortcutForTest(CALLING_PACKAGE_2, "s1", USER_0));
-        assertNotNull(mService.getPackageShortcutForTest(CALLING_PACKAGE_3, "s1", USER_0));
-        assertNotNull(mService.getPackageShortcutForTest(CALLING_PACKAGE_1, "s1", USER_10));
-        assertNotNull(mService.getPackageShortcutForTest(CALLING_PACKAGE_2, "s1", USER_10));
-        assertNotNull(mService.getPackageShortcutForTest(CALLING_PACKAGE_3, "s1", USER_10));
-
-        assertFalse(bitmapDirectoryExists(CALLING_PACKAGE_1, USER_0));
-        assertTrue(bitmapDirectoryExists(CALLING_PACKAGE_2, USER_0));
-        assertTrue(bitmapDirectoryExists(CALLING_PACKAGE_3, USER_0));
-        assertTrue(bitmapDirectoryExists(CALLING_PACKAGE_1, USER_10));
-        assertTrue(bitmapDirectoryExists(CALLING_PACKAGE_2, USER_10));
-        assertTrue(bitmapDirectoryExists(CALLING_PACKAGE_3, USER_10));
-
-        mRunningUsers.put(USER_10, true);
-
-                mService.mPackageMonitor.onReceive(getTestContext(),
-                genPackageDataClear(CALLING_PACKAGE_2, USER_10));
-
-        assertNull(mService.getPackageShortcutForTest(CALLING_PACKAGE_1, "s1", USER_0));
-        assertNotNull(mService.getPackageShortcutForTest(CALLING_PACKAGE_2, "s1", USER_0));
-        assertNotNull(mService.getPackageShortcutForTest(CALLING_PACKAGE_3, "s1", USER_0));
-        assertNotNull(mService.getPackageShortcutForTest(CALLING_PACKAGE_1, "s1", USER_10));
-        assertNull(mService.getPackageShortcutForTest(CALLING_PACKAGE_2, "s1", USER_10));
-        assertNotNull(mService.getPackageShortcutForTest(CALLING_PACKAGE_3, "s1", USER_10));
-
-        assertFalse(bitmapDirectoryExists(CALLING_PACKAGE_1, USER_0));
-        assertTrue(bitmapDirectoryExists(CALLING_PACKAGE_2, USER_0));
-        assertTrue(bitmapDirectoryExists(CALLING_PACKAGE_3, USER_0));
-        assertTrue(bitmapDirectoryExists(CALLING_PACKAGE_1, USER_10));
-        assertFalse(bitmapDirectoryExists(CALLING_PACKAGE_2, USER_10));
-        assertTrue(bitmapDirectoryExists(CALLING_PACKAGE_3, USER_10));
-    }
-
-    public void testHandlePackageClearData_manifestRepublished() {
-
-        mRunningUsers.put(USER_10, true);
-
-        // Add two manifests and two dynamics.
-        addManifestShortcutResource(
-                new ComponentName(CALLING_PACKAGE_1, ShortcutActivity.class.getName()),
-                R.xml.shortcut_2);
-        updatePackageVersion(CALLING_PACKAGE_1, 1);
-                mService.mPackageMonitor.onReceive(getTestContext(),
-                genPackageAddIntent(CALLING_PACKAGE_1, USER_10));
-
-        runWithCaller(CALLING_PACKAGE_1, USER_10, () -> {
-            assertTrue(mManager.addDynamicShortcuts(list(
-                    makeShortcut("s1"), makeShortcut("s2"))));
-        });
-        runWithCaller(LAUNCHER_1, USER_10, () -> {
-            mLauncherApps.pinShortcuts(CALLING_PACKAGE_1, list("ms2", "s2"), HANDLE_USER_10);
-        });
-
-        runWithCaller(CALLING_PACKAGE_1, USER_10, () -> {
-            assertWith(getCallerShortcuts())
-                    .haveIds("ms1", "ms2", "s1", "s2")
-                    .areAllEnabled()
-
-                    .selectPinned()
-                    .haveIds("ms2", "s2");
-        });
-
-        // Clear data
-        mService.mPackageMonitor.onReceive(getTestContext(),
-                genPackageDataClear(CALLING_PACKAGE_1, USER_10));
-
-        // Only manifest shortcuts will remain, and are no longer pinned.
-        runWithCaller(CALLING_PACKAGE_1, USER_10, () -> {
-            assertWith(getCallerShortcuts())
-                    .haveIds("ms1", "ms2")
-                    .areAllEnabled()
-                    .areAllNotPinned();
-        });
-    }
-
-    public void testHandlePackageUpdate() throws Throwable {
-        // Set up shortcuts and launchers.
-
-        final Icon res32x32 = Icon.createWithResource(getTestContext(), R.drawable.black_32x32);
-        final Icon bmp32x32 = Icon.createWithBitmap(BitmapFactory.decodeResource(
-                getTestContext().getResources(), R.drawable.black_32x32));
-
-        runWithCaller(CALLING_PACKAGE_1, USER_0, () -> {
-            assertTrue(mManager.setDynamicShortcuts(list(
-                    makeShortcut("s1"),
-                    makeShortcutWithIcon("s2", res32x32),
-                    makeShortcutWithIcon("s3", res32x32),
-                    makeShortcutWithIcon("s4", bmp32x32))));
-        });
-        runWithCaller(CALLING_PACKAGE_2, USER_0, () -> {
-            assertTrue(mManager.setDynamicShortcuts(list(
-                    makeShortcut("s1"),
-                    makeShortcutWithIcon("s2", bmp32x32))));
-        });
-        runWithCaller(CALLING_PACKAGE_3, USER_0, () -> {
-            assertTrue(mManager.setDynamicShortcuts(list(
-                    makeShortcutWithIcon("s1", res32x32))));
-        });
-
-        mRunningUsers.put(USER_10, true);
-
-        runWithCaller(CALLING_PACKAGE_1, USER_10, () -> {
-            assertTrue(mManager.setDynamicShortcuts(list(
-                    makeShortcutWithIcon("s1", res32x32),
-                    makeShortcutWithIcon("s2", res32x32))));
-        });
-        runWithCaller(CALLING_PACKAGE_2, USER_10, () -> {
-            assertTrue(mManager.setDynamicShortcuts(list(
-                    makeShortcutWithIcon("s1", bmp32x32),
-                    makeShortcutWithIcon("s2", bmp32x32))));
-        });
-
-        LauncherApps.Callback c0 = mock(LauncherApps.Callback.class);
-        LauncherApps.Callback c10 = mock(LauncherApps.Callback.class);
-
-        runWithCaller(LAUNCHER_1, USER_0, () -> {
-            mLauncherApps.registerCallback(c0, new Handler(Looper.getMainLooper()));
-        });
-        runWithCaller(LAUNCHER_1, USER_10, () -> {
-            mLauncherApps.registerCallback(c10, new Handler(Looper.getMainLooper()));
-        });
-
-        mInjectedCurrentTimeMillis = START_TIME + 100;
-
-        ArgumentCaptor<List> shortcuts;
-
-        // Update the version info for package 1.
-        reset(c0);
-        reset(c10);
-        updatePackageVersion(CALLING_PACKAGE_1, 1);
-
-        // Then send the broadcast, to only user-0.
-        mService.mPackageMonitor.onReceive(getTestContext(),
-                genPackageUpdateIntent(CALLING_PACKAGE_1, USER_0));
-
-        waitOnMainThread();
-
-        // User-0 should get the notification.
-        shortcuts = ArgumentCaptor.forClass(List.class);
-        verify(c0).onShortcutsChanged(
-                eq(CALLING_PACKAGE_1),
-                shortcuts.capture(),
-                eq(HANDLE_USER_0));
-
-        // User-10 shouldn't yet get the notification.
-        verify(c10, times(0)).onShortcutsChanged(
-                eq(CALLING_PACKAGE_1),
-                any(List.class),
-                any(UserHandle.class));
-        assertShortcutIds(shortcuts.getValue(), "s1", "s2", "s3", "s4");
-        assertEquals(START_TIME,
-                findShortcut(shortcuts.getValue(), "s1").getLastChangedTimestamp());
-        assertEquals(START_TIME + 100,
-                findShortcut(shortcuts.getValue(), "s2").getLastChangedTimestamp());
-        assertEquals(START_TIME + 100,
-                findShortcut(shortcuts.getValue(), "s3").getLastChangedTimestamp());
-        assertEquals(START_TIME,
-                findShortcut(shortcuts.getValue(), "s4").getLastChangedTimestamp());
-
-        // Next, send unlock even on user-10.  Now we scan packages on this user and send a
-        // notification to the launcher.
-        mInjectedCurrentTimeMillis = START_TIME + 200;
-
-        mRunningUsers.put(USER_10, true);
-        mUnlockedUsers.put(USER_10, true);
-
-        reset(c0);
-        reset(c10);
-        setPackageLastUpdateTime(CALLING_PACKAGE_1, mInjectedCurrentTimeMillis);
-        mService.handleUnlockUser(USER_10);
-        mService.checkPackageChanges(USER_10);
-
-        waitOnMainThread();
-
-        shortcuts = ArgumentCaptor.forClass(List.class);
-        verify(c0, times(0)).onShortcutsChanged(
-                eq(CALLING_PACKAGE_1),
-                any(List.class),
-                any(UserHandle.class));
-
-        verify(c10).onShortcutsChanged(
-                eq(CALLING_PACKAGE_1),
-                shortcuts.capture(),
-                eq(HANDLE_USER_10));
-
-        assertShortcutIds(shortcuts.getValue(), "s1", "s2");
-        assertEquals(START_TIME + 200,
-                findShortcut(shortcuts.getValue(), "s1").getLastChangedTimestamp());
-        assertEquals(START_TIME + 200,
-                findShortcut(shortcuts.getValue(), "s2").getLastChangedTimestamp());
-
-
-        // Do the same thing for package 2, which doesn't have resource icons.
-        mInjectedCurrentTimeMillis = START_TIME + 300;
-
-        reset(c0);
-        reset(c10);
-        updatePackageVersion(CALLING_PACKAGE_2, 10);
-
-        // Then send the broadcast, to only user-0.
-                mService.mPackageMonitor.onReceive(getTestContext(),
-                genPackageUpdateIntent(CALLING_PACKAGE_2, USER_0));
-        mService.checkPackageChanges(USER_10);
-
-        waitOnMainThread();
-
-        verify(c0, times(0)).onShortcutsChanged(
-                eq(CALLING_PACKAGE_1),
-                any(List.class),
-                any(UserHandle.class));
-
-        verify(c10, times(0)).onShortcutsChanged(
-                eq(CALLING_PACKAGE_1),
-                any(List.class),
-                any(UserHandle.class));
-
-        // Do the same thing for package 3
-        mInjectedCurrentTimeMillis = START_TIME + 400;
-
-        reset(c0);
-        reset(c10);
-        updatePackageVersion(CALLING_PACKAGE_3, 100);
-
-        // Then send the broadcast, to only user-0.
-        mService.mPackageMonitor.onReceive(getTestContext(),
-                genPackageUpdateIntent(CALLING_PACKAGE_3, USER_0));
-        mService.checkPackageChanges(USER_10);
-
-        waitOnMainThread();
-
-        shortcuts = ArgumentCaptor.forClass(List.class);
-        verify(c0).onShortcutsChanged(
-                eq(CALLING_PACKAGE_3),
-                shortcuts.capture(),
-                eq(HANDLE_USER_0));
-
-        // User 10 doesn't have package 3, so no callback.
-        verify(c10, times(0)).onShortcutsChanged(
-                eq(CALLING_PACKAGE_3),
-                any(List.class),
-                any(UserHandle.class));
-
-        assertShortcutIds(shortcuts.getValue(), "s1");
-        assertEquals(START_TIME + 400,
-                findShortcut(shortcuts.getValue(), "s1").getLastChangedTimestamp());
-    }
-
-    /**
-     * Test the case where an updated app has resource IDs changed.
-     */
-    public void testHandlePackageUpdate_resIdChanged() throws Exception {
-        final Icon icon1 = Icon.createWithResource(getTestContext(), /* res ID */ 1000);
-        final Icon icon2 = Icon.createWithResource(getTestContext(), /* res ID */ 1001);
-
-        // Set up shortcuts.
-        runWithCaller(CALLING_PACKAGE_1, USER_0, () -> {
-            // Note resource strings are not officially supported (they're hidden), but
-            // should work.
-
-            final ShortcutInfo s1 = new ShortcutInfo.Builder(mClientContext)
-                    .setId("s1")
-                    .setActivity(makeComponent(ShortcutActivity.class))
-                    .setIntent(new Intent(Intent.ACTION_VIEW))
-                    .setIcon(icon1)
-                    .setTitleResId(10000)
-                    .setTextResId(10001)
-                    .setDisabledMessageResId(10002)
-                    .build();
-
-            final ShortcutInfo s2 = new ShortcutInfo.Builder(mClientContext)
-                    .setId("s2")
-                    .setActivity(makeComponent(ShortcutActivity.class))
-                    .setIntent(new Intent(Intent.ACTION_VIEW))
-                    .setIcon(icon2)
-                    .setTitleResId(20000)
-                    .build();
-
-            assertTrue(mManager.setDynamicShortcuts(list(s1, s2)));
-        });
-
-        // Verify.
-        runWithCaller(CALLING_PACKAGE_1, USER_0, () -> {
-            final ShortcutInfo s1 = getCallerShortcut("s1");
-            final ShortcutInfo s2 = getCallerShortcut("s2");
-
-            assertEquals(1000, s1.getIconResourceId());
-            assertEquals(10000, s1.getTitleResId());
-            assertEquals(10001, s1.getTextResId());
-            assertEquals(10002, s1.getDisabledMessageResourceId());
-
-            assertEquals(1001, s2.getIconResourceId());
-            assertEquals(20000, s2.getTitleResId());
-            assertEquals(0, s2.getTextResId());
-            assertEquals(0, s2.getDisabledMessageResourceId());
-        });
-
-        mService.saveDirtyInfo();
-        initService();
-
-        // Set up the mock resources again, with an "adjustment".
-        // When the package is updated, the service will fetch the updated res-IDs with res-names,
-        // and the new IDs will have this offset.
-        setUpAppResources(10);
-
-        // Update the package.
-        updatePackageVersion(CALLING_PACKAGE_1, 1);
-                mService.mPackageMonitor.onReceive(getTestContext(),
-                genPackageUpdateIntent(CALLING_PACKAGE_1, USER_0));
-
-        runWithCaller(CALLING_PACKAGE_1, USER_0, () -> {
-            final ShortcutInfo s1 = getCallerShortcut("s1");
-            final ShortcutInfo s2 = getCallerShortcut("s2");
-
-            assertEquals(1010, s1.getIconResourceId());
-            assertEquals(10010, s1.getTitleResId());
-            assertEquals(10011, s1.getTextResId());
-            assertEquals(10012, s1.getDisabledMessageResourceId());
-
-            assertEquals(1011, s2.getIconResourceId());
-            assertEquals(20010, s2.getTitleResId());
-            assertEquals(0, s2.getTextResId());
-            assertEquals(0, s2.getDisabledMessageResourceId());
-        });
-    }
-
-    public void testHandlePackageUpdate_systemAppUpdate() {
-
-        // Package1 is a system app.  Package 2 is not a system app, so it's not scanned
-        // in this test at all.
-        mSystemPackages.add(CALLING_PACKAGE_1);
-
-        // Initial state: no shortcuts.
-        mService.checkPackageChanges(USER_0);
-
-        assertEquals(mInjectedCurrentTimeMillis,
-                mService.getUserShortcutsLocked(USER_0).getLastAppScanTime());
-        assertEquals(mInjectedBuildFingerprint,
-                mService.getUserShortcutsLocked(USER_0).getLastAppScanOsFingerprint());
-
-        // They have no shortcuts.
-        runWithCaller(CALLING_PACKAGE_1, USER_0, () -> {
-            assertWith(getCallerShortcuts())
-                    .isEmpty();
-        });
-
-        runWithCaller(CALLING_PACKAGE_2, USER_0, () -> {
-            assertWith(getCallerShortcuts())
-                    .isEmpty();
-        });
-
-        // Next.
-        // Update the packages -- now they have 1 manifest shortcut.
-        // But checkPackageChanges() don't notice it, since their version code / timestamp haven't
-        // changed.
-        addManifestShortcutResource(
-                new ComponentName(CALLING_PACKAGE_1, ShortcutActivity.class.getName()),
-                R.xml.shortcut_1);
-        addManifestShortcutResource(
-                new ComponentName(CALLING_PACKAGE_2, ShortcutActivity.class.getName()),
-                R.xml.shortcut_1);
-        mInjectedCurrentTimeMillis += 1000;
-        mService.checkPackageChanges(USER_0);
-
-        runWithCaller(CALLING_PACKAGE_1, USER_0, () -> {
-            assertWith(getCallerShortcuts())
-                    .isEmpty();
-        });
-        runWithCaller(CALLING_PACKAGE_2, USER_0, () -> {
-            assertWith(getCallerShortcuts())
-                    .isEmpty();
-        });
-
-        // Next.
-        // Update the build finger print.  All system apps will be scanned now.
-        mInjectedBuildFingerprint = "update1";
-        mInjectedCurrentTimeMillis += 1000;
-        mService.checkPackageChanges(USER_0);
-
-        runWithCaller(CALLING_PACKAGE_1, USER_0, () -> {
-            assertWith(getCallerShortcuts())
-                    .haveIds("ms1");
-        });
-        runWithCaller(CALLING_PACKAGE_2, USER_0, () -> {
-            assertWith(getCallerShortcuts())
-                    .isEmpty();
-        });
-
-        // Next.
-        // Update manifest shortcuts.
-        mInjectedBuildFingerprint = "update2";
-        addManifestShortcutResource(
-                new ComponentName(CALLING_PACKAGE_1, ShortcutActivity.class.getName()),
-                R.xml.shortcut_2);
-        addManifestShortcutResource(
-                new ComponentName(CALLING_PACKAGE_2, ShortcutActivity.class.getName()),
-                R.xml.shortcut_2);
-        mInjectedCurrentTimeMillis += 1000;
-        mService.checkPackageChanges(USER_0);
-
-        // Fingerprint hasn't changed, so CALLING_PACKAGE_1 wasn't scanned.
-        runWithCaller(CALLING_PACKAGE_1, USER_0, () -> {
-            assertWith(getCallerShortcuts())
-                    .haveIds("ms1");
-        });
-        runWithCaller(CALLING_PACKAGE_2, USER_0, () -> {
-            assertWith(getCallerShortcuts())
-                    .isEmpty();
-        });
-
-        // Update the fingerprint, but CALLING_PACKAGE_1's version code hasn't changed, so
-        // still not scanned.
-        mInjectedBuildFingerprint = "update2";
-        mInjectedCurrentTimeMillis += 1000;
-        mService.checkPackageChanges(USER_0);
-
-        runWithCaller(CALLING_PACKAGE_1, USER_0, () -> {
-            assertWith(getCallerShortcuts())
-                    .haveIds("ms1");
-        });
-        runWithCaller(CALLING_PACKAGE_2, USER_0, () -> {
-            assertWith(getCallerShortcuts())
-                    .isEmpty();
-        });
-
-        // Now update the version code, so CALLING_PACKAGE_1 is scanned again.
-        mInjectedBuildFingerprint = "update3";
-        mInjectedCurrentTimeMillis += 1000;
-        updatePackageVersion(CALLING_PACKAGE_1, 1);
-        mService.checkPackageChanges(USER_0);
-
-        runWithCaller(CALLING_PACKAGE_1, USER_0, () -> {
-            assertWith(getCallerShortcuts())
-                    .haveIds("ms1", "ms2");
-        });
-        runWithCaller(CALLING_PACKAGE_2, USER_0, () -> {
-            assertWith(getCallerShortcuts())
-                    .isEmpty();
-        });
-
-        // Make sure getLastAppScanTime / getLastAppScanOsFingerprint are persisted.
-        initService();
-        assertEquals(mInjectedCurrentTimeMillis,
-                mService.getUserShortcutsLocked(USER_0).getLastAppScanTime());
-        assertEquals(mInjectedBuildFingerprint,
-                mService.getUserShortcutsLocked(USER_0).getLastAppScanOsFingerprint());
-    }
-
-    public void testHandlePackageChanged() {
-        final ComponentName ACTIVITY1 = new ComponentName(CALLING_PACKAGE_1, "act1");
-        final ComponentName ACTIVITY2 = new ComponentName(CALLING_PACKAGE_1, "act2");
-
-        addManifestShortcutResource(ACTIVITY1, R.xml.shortcut_1);
-        addManifestShortcutResource(ACTIVITY2, R.xml.shortcut_1_alt);
-
-        mRunningUsers.put(USER_10, true);
-
-        updatePackageVersion(CALLING_PACKAGE_1, 1);
-                mService.mPackageMonitor.onReceive(getTestContext(),
-                genPackageAddIntent(CALLING_PACKAGE_1, USER_10));
-
-        runWithCaller(CALLING_PACKAGE_1, USER_10, () -> {
-            assertTrue(mManager.addDynamicShortcuts(list(
-                    makeShortcutWithActivity("s1", ACTIVITY1),
-                    makeShortcutWithActivity("s2", ACTIVITY2)
-            )));
-        });
-        runWithCaller(LAUNCHER_1, USER_10, () -> {
-            mLauncherApps.pinShortcuts(CALLING_PACKAGE_1, list("ms1-alt", "s2"), HANDLE_USER_10);
-        });
-
-        runWithCaller(CALLING_PACKAGE_1, USER_10, () -> {
-            assertWith(getCallerShortcuts())
-                    .haveIds("ms1", "ms1-alt", "s1", "s2")
-                    .areAllEnabled()
-
-                    .selectPinned()
-                    .haveIds("ms1-alt", "s2")
-
-                    .revertToOriginalList()
-                    .selectByIds("ms1", "s1")
-                    .areAllWithActivity(ACTIVITY1)
-
-                    .revertToOriginalList()
-                    .selectByIds("ms1-alt", "s2")
-                    .areAllWithActivity(ACTIVITY2)
-                    ;
-        });
-
-        // First, no changes.
-                mService.mPackageMonitor.onReceive(getTestContext(),
-                genPackageChangedIntent(CALLING_PACKAGE_1, USER_10));
-
-        runWithCaller(CALLING_PACKAGE_1, USER_10, () -> {
-            assertWith(getCallerShortcuts())
-                    .haveIds("ms1", "ms1-alt", "s1", "s2")
-                    .areAllEnabled()
-
-                    .selectPinned()
-                    .haveIds("ms1-alt", "s2")
-
-                    .revertToOriginalList()
-                    .selectByIds("ms1", "s1")
-                    .areAllWithActivity(ACTIVITY1)
-
-                    .revertToOriginalList()
-                    .selectByIds("ms1-alt", "s2")
-                    .areAllWithActivity(ACTIVITY2)
-            ;
-        });
-
-        // Disable activity 1
-        mEnabledActivityChecker = (activity, userId) -> !ACTIVITY1.equals(activity);
-                mService.mPackageMonitor.onReceive(getTestContext(),
-                genPackageChangedIntent(CALLING_PACKAGE_1, USER_10));
-
-        runWithCaller(CALLING_PACKAGE_1, USER_10, () -> {
-            assertWith(getCallerShortcuts())
-                    .haveIds("ms1-alt", "s2")
-                    .areAllEnabled()
-
-                    .selectPinned()
-                    .haveIds("ms1-alt", "s2")
-
-                    .revertToOriginalList()
-                    .selectByIds("ms1-alt", "s2")
-                    .areAllWithActivity(ACTIVITY2)
-            ;
-        });
-
-        // Re-enable activity 1.
-        // Manifest shortcuts will be re-published, but dynamic ones are not.
-        mEnabledActivityChecker = (activity, userId) -> true;
-                mService.mPackageMonitor.onReceive(getTestContext(),
-                genPackageChangedIntent(CALLING_PACKAGE_1, USER_10));
-
-        runWithCaller(CALLING_PACKAGE_1, USER_10, () -> {
-            assertWith(getCallerShortcuts())
-                    .haveIds("ms1", "ms1-alt", "s2")
-                    .areAllEnabled()
-
-                    .selectPinned()
-                    .haveIds("ms1-alt", "s2")
-
-                    .revertToOriginalList()
-                    .selectByIds("ms1")
-                    .areAllWithActivity(ACTIVITY1)
-
-                    .revertToOriginalList()
-                    .selectByIds("ms1-alt", "s2")
-                    .areAllWithActivity(ACTIVITY2)
-                    ;
-        });
-
-        // Disable activity 2
-        // Because "ms1-alt" and "s2" are both pinned, they will remain, but disabled.
-        mEnabledActivityChecker = (activity, userId) -> !ACTIVITY2.equals(activity);
-                mService.mPackageMonitor.onReceive(getTestContext(),
-                genPackageChangedIntent(CALLING_PACKAGE_1, USER_10));
-
-        runWithCaller(CALLING_PACKAGE_1, USER_10, () -> {
-            assertWith(getCallerShortcuts())
-                    .haveIds("ms1", "ms1-alt", "s2")
-
-                    .selectDynamic().isEmpty().revertToOriginalList() // no dynamics.
-
-                    .selectPinned()
-                    .haveIds("ms1-alt", "s2")
-                    .areAllDisabled()
-
-                    .revertToOriginalList()
-                    .selectByIds("ms1")
-                    .areAllWithActivity(ACTIVITY1)
-                    .areAllEnabled()
-            ;
-        });
-    }
-
-    public void testHandlePackageUpdate_activityNoLongerMain() throws Throwable {
-        runWithCaller(CALLING_PACKAGE_1, USER_0, () -> {
-            assertTrue(mManager.setDynamicShortcuts(list(
-                    makeShortcutWithActivity("s1a",
-                            new ComponentName(getCallingPackage(), "act1")),
-                    makeShortcutWithActivity("s1b",
-                            new ComponentName(getCallingPackage(), "act1")),
-                    makeShortcutWithActivity("s2a",
-                            new ComponentName(getCallingPackage(), "act2")),
-                    makeShortcutWithActivity("s2b",
-                            new ComponentName(getCallingPackage(), "act2")),
-                    makeShortcutWithActivity("s3a",
-                            new ComponentName(getCallingPackage(), "act3")),
-                    makeShortcutWithActivity("s3b",
-                            new ComponentName(getCallingPackage(), "act3"))
-            )));
-            assertWith(getCallerShortcuts())
-                    .haveIds("s1a", "s1b", "s2a", "s2b", "s3a", "s3b")
-                    .areAllDynamic();
-        });
-        runWithCaller(LAUNCHER_1, USER_0, () -> {
-            mLauncherApps.pinShortcuts(CALLING_PACKAGE_1,
-                    list("s1b", "s2b", "s3b"),
-                    HANDLE_USER_0);
-        });
-        runWithCaller(CALLING_PACKAGE_1, USER_0, () -> {
-            assertWith(getCallerShortcuts())
-                    .haveIds("s1a", "s1b", "s2a", "s2b", "s3a", "s3b")
-                    .areAllDynamic()
-
-                    .selectByIds("s1b", "s2b", "s3b")
-                    .areAllPinned();
-        });
-
-        // Update the app and act2 and act3 are no longer main.
-        mMainActivityChecker = (activity, userId) -> {
-            return activity.getClassName().equals("act1");
-        };
-
-        setCaller(LAUNCHER_1, USER_0);
-        assertForLauncherCallback(mLauncherApps, () -> {
-            updatePackageVersion(CALLING_PACKAGE_1, 1);
-                    mService.mPackageMonitor.onReceive(getTestContext(),
-                    genPackageUpdateIntent(CALLING_PACKAGE_1, USER_0));
-        }).assertCallbackCalledForPackageAndUser(CALLING_PACKAGE_1, HANDLE_USER_0)
-                // Make sure the launcher gets callbacks.
-                .haveIds("s1a", "s1b", "s2b", "s3b")
-                .areAllWithKeyFieldsOnly();
-
-        runWithCaller(CALLING_PACKAGE_1, USER_0, () -> {
-            // s2a and s3a are gone, but s2b and s3b will remain because they're pinned, and
-            // disabled.
-            assertWith(getCallerShortcuts())
-                    .haveIds("s1a", "s1b", "s2b", "s3b")
-
-                    .selectByIds("s1a", "s1b")
-                    .areAllDynamic()
-                    .areAllEnabled()
-
-                    .revertToOriginalList()
-                    .selectByIds("s2b", "s3b")
-                    .areAllNotDynamic()
-                    .areAllDisabled()
-                    .areAllPinned()
-                    ;
-        });
-    }
-
-    protected void prepareForBackupTest() {
-
-        prepareCrossProfileDataSet();
-
-        backupAndRestore();
-    }
-
-    /**
-     * Make sure the backup data doesn't have the following information:
-     * - Launchers on other users.
-     * - Non-backup app information.
-     *
-     * But restores all other infomation.
-     *
-     * It also omits the following pieces of information, but that's tested in
-     * {@link ShortcutManagerTest2#testShortcutInfoSaveAndLoad_forBackup}.
-     * - Unpinned dynamic shortcuts
-     * - Bitmaps
-     */
-    public void testBackupAndRestore() {
-        prepareForBackupTest();
-
-        checkBackupAndRestore_success();
-    }
-
-    public void testBackupAndRestore_backupRestoreTwice() {
-        prepareForBackupTest();
-
-        // Note doing a backup & restore again here shouldn't affect the result.
-        dumpsysOnLogcat("Before second backup");
-
-        backupAndRestore();
-
-        dumpsysOnLogcat("After second backup");
-
-        checkBackupAndRestore_success();
-    }
-
-    public void testBackupAndRestore_backupRestoreMultiple() {
-        prepareForBackupTest();
-
-        // Note doing a backup & restore again here shouldn't affect the result.
-        backupAndRestore();
-
-        // This also shouldn't affect the result.
-        runWithCaller(CALLING_PACKAGE_1, USER_0, () -> {
-            assertTrue(mManager.setDynamicShortcuts(list(
-                    makeShortcut("s1"), makeShortcut("s2"), makeShortcut("s3"),
-                    makeShortcut("s4"), makeShortcut("s5"), makeShortcut("s6"))));
-        });
-
-        backupAndRestore();
-
-        checkBackupAndRestore_success();
-    }
-
-    public void testBackupAndRestore_restoreToNewVersion() {
-        prepareForBackupTest();
-
-        // Note doing a backup & restore again here shouldn't affect the result.
-        backupAndRestore();
-
-        addPackage(CALLING_PACKAGE_1, CALLING_UID_1, 2);
-        addPackage(LAUNCHER_1, LAUNCHER_UID_1, 5);
-
-        checkBackupAndRestore_success();
-    }
-
-    public void testBackupAndRestore_restoreToSuperSetSignatures() {
-        prepareForBackupTest();
-
-        // Note doing a backup & restore again here shouldn't affect the result.
-        backupAndRestore();
-
-        // Change package signatures.
-        addPackage(CALLING_PACKAGE_1, CALLING_UID_1, 1, "sigx", CALLING_PACKAGE_1);
-        addPackage(LAUNCHER_1, LAUNCHER_UID_1, 4, LAUNCHER_1, "sigy");
-
-        checkBackupAndRestore_success();
-    }
-
-    protected void checkBackupAndRestore_success() {
-        // Make sure non-system user is not restored.
-        final ShortcutUser userP0 = mService.getUserShortcutsLocked(USER_P0);
-        assertEquals(0, userP0.getAllPackagesForTest().size());
-        assertEquals(0, userP0.getAllLaunchersForTest().size());
-
-        // Make sure only "allowBackup" apps are restored, and are shadow.
-        final ShortcutUser user0 = mService.getUserShortcutsLocked(USER_0);
-        assertExistsAndShadow(user0.getAllPackagesForTest().get(CALLING_PACKAGE_1));
-        assertExistsAndShadow(user0.getAllPackagesForTest().get(CALLING_PACKAGE_2));
-        assertExistsAndShadow(user0.getAllLaunchersForTest().get(
-                PackageWithUser.of(USER_0, LAUNCHER_1)));
-        assertExistsAndShadow(user0.getAllLaunchersForTest().get(
-                PackageWithUser.of(USER_0, LAUNCHER_2)));
-
-        assertNull(user0.getAllPackagesForTest().get(CALLING_PACKAGE_3));
-        assertNull(user0.getAllLaunchersForTest().get(PackageWithUser.of(USER_0, LAUNCHER_3)));
-        assertNull(user0.getAllLaunchersForTest().get(PackageWithUser.of(USER_P0, LAUNCHER_1)));
-
-        installPackage(USER_0, CALLING_PACKAGE_1);
-        runWithCaller(CALLING_PACKAGE_1, USER_0, () -> {
-            assertWith(getCallerVisibleShortcuts())
-                    .selectDynamic()
-                    .isEmpty()
-
-                    .revertToOriginalList()
-                    .selectPinned()
-                    .haveIds("s1", "s2");
-        });
-
-        installPackage(USER_0, LAUNCHER_1);
-        runWithCaller(LAUNCHER_1, USER_0, () -> {
-            assertWith(mLauncherApps.getShortcuts(buildAllQuery(CALLING_PACKAGE_1), HANDLE_USER_0))
-                    .areAllPinned()
-                    .haveIds("s1");
-
-            assertWith(mLauncherApps.getShortcuts(buildAllQuery(CALLING_PACKAGE_2), HANDLE_USER_0))
-                    .isEmpty();
-
-            assertWith(mLauncherApps.getShortcuts(buildAllQuery(CALLING_PACKAGE_3), HANDLE_USER_0))
-                    .isEmpty();
-
-            assertWith(mLauncherApps.getShortcuts(QUERY_ALL, HANDLE_USER_P0))
-                    .isEmpty();
-        });
-
-        installPackage(USER_0, CALLING_PACKAGE_2);
-        runWithCaller(CALLING_PACKAGE_2, USER_0, () -> {
-            assertWith(getCallerVisibleShortcuts())
-                    .selectDynamic()
-                    .isEmpty()
-
-                    .revertToOriginalList()
-                    .selectPinned()
-                    .haveIds("s1", "s2", "s3");
-        });
-
-        runWithCaller(LAUNCHER_1, USER_0, () -> {
-            assertWith(mLauncherApps.getShortcuts(buildAllQuery(CALLING_PACKAGE_1), HANDLE_USER_0))
-                    .areAllPinned()
-                    .haveIds("s1");
-
-            assertWith(mLauncherApps.getShortcuts(buildAllQuery(CALLING_PACKAGE_2), HANDLE_USER_0))
-                    .areAllPinned()
-                    .haveIds("s1", "s2");
-
-            assertWith(mLauncherApps.getShortcuts(buildAllQuery(CALLING_PACKAGE_3), HANDLE_USER_0))
-                    .isEmpty();
-
-            assertWith(mLauncherApps.getShortcuts(QUERY_ALL, HANDLE_USER_P0))
-                    .isEmpty();
-        });
-
-        // 3 shouldn't be backed up, so no pinned shortcuts.
-        installPackage(USER_0, CALLING_PACKAGE_3);
-        runWithCaller(CALLING_PACKAGE_3, USER_0, () -> {
-            assertWith(getCallerVisibleShortcuts())
-                    .isEmpty();
-        });
-
-        // Launcher on a different profile shouldn't be restored.
-        runWithCaller(LAUNCHER_1, USER_P0, () -> {
-            assertWith(mLauncherApps.getShortcuts(buildAllQuery(CALLING_PACKAGE_1), HANDLE_USER_0))
-                    .isEmpty();
-            assertWith(mLauncherApps.getShortcuts(buildAllQuery(CALLING_PACKAGE_2), HANDLE_USER_0))
-                    .isEmpty();
-            assertWith(mLauncherApps.getShortcuts(buildAllQuery(CALLING_PACKAGE_3), HANDLE_USER_0))
-                    .isEmpty();
-        });
-
-        // Package on a different profile, no restore.
-        installPackage(USER_P0, CALLING_PACKAGE_1);
-        runWithCaller(CALLING_PACKAGE_1, USER_P0, () -> {
-            assertWith(getCallerVisibleShortcuts())
-                    .isEmpty();
-        });
-
-        // Restore launcher 2 on user 0.
-        installPackage(USER_0, LAUNCHER_2);
-        runWithCaller(LAUNCHER_2, USER_0, () -> {
-            assertWith(mLauncherApps.getShortcuts(buildAllQuery(CALLING_PACKAGE_1), HANDLE_USER_0))
-                    .areAllPinned()
-                    .haveIds("s2");
-
-            assertWith(mLauncherApps.getShortcuts(buildAllQuery(CALLING_PACKAGE_2), HANDLE_USER_0))
-                    .areAllPinned()
-                    .haveIds("s2", "s3");
-
-            assertWith(mLauncherApps.getShortcuts(buildAllQuery(CALLING_PACKAGE_3), HANDLE_USER_0))
-                    .isEmpty();
-
-            assertWith(mLauncherApps.getShortcuts(QUERY_ALL, HANDLE_USER_P0))
-                    .isEmpty();
-        });
-
-
-        // Restoration of launcher2 shouldn't affect other packages; so do the same checks and
-        // make sure they still have the same result.
-        installPackage(USER_0, CALLING_PACKAGE_1);
-        runWithCaller(CALLING_PACKAGE_1, USER_0, () -> {
-            assertWith(getCallerVisibleShortcuts())
-                    .areAllPinned()
-                    .haveIds("s1", "s2");
-        });
-
-        installPackage(USER_0, LAUNCHER_1);
-        runWithCaller(LAUNCHER_1, USER_0, () -> {
-            assertWith(mLauncherApps.getShortcuts(buildAllQuery(CALLING_PACKAGE_1), HANDLE_USER_0))
-                    .areAllPinned()
-                    .haveIds("s1");
-
-            assertWith(mLauncherApps.getShortcuts(buildAllQuery(CALLING_PACKAGE_2), HANDLE_USER_0))
-                    .areAllPinned()
-                    .haveIds("s1", "s2");
-
-            assertWith(mLauncherApps.getShortcuts(buildAllQuery(CALLING_PACKAGE_3), HANDLE_USER_0))
-                    .isEmpty();
-
-            assertWith(mLauncherApps.getShortcuts(QUERY_ALL, HANDLE_USER_P0))
-                    .isEmpty();
-        });
-
-        installPackage(USER_0, CALLING_PACKAGE_2);
-        runWithCaller(CALLING_PACKAGE_2, USER_0, () -> {
-            assertWith(getCallerVisibleShortcuts())
-                    .areAllPinned()
-                    .haveIds("s1", "s2", "s3");
-        });
-    }
-
-    public void testBackupAndRestore_publisherLowerVersion() {
-        prepareForBackupTest();
-
-        // Note doing a backup & restore again here shouldn't affect the result.
-        backupAndRestore();
-
-        addPackage(CALLING_PACKAGE_1, CALLING_UID_1, 0); // Lower version
-
-        checkBackupAndRestore_publisherNotRestored();
-    }
-
-    public void testBackupAndRestore_publisherWrongSignature() {
-        prepareForBackupTest();
-
-        // Note doing a backup & restore again here shouldn't affect the result.
-        backupAndRestore();
-
-        addPackage(CALLING_PACKAGE_1, CALLING_UID_1, 10, "sigx"); // different signature
-
-        checkBackupAndRestore_publisherNotRestored();
-    }
-
-    public void testBackupAndRestore_publisherNoLongerBackupTarget() {
-        prepareForBackupTest();
-
-        // Note doing a backup & restore again here shouldn't affect the result.
-        backupAndRestore();
-
-        updatePackageInfo(CALLING_PACKAGE_1,
-                pi -> pi.applicationInfo.flags &= ~ApplicationInfo.FLAG_ALLOW_BACKUP);
-
-        checkBackupAndRestore_publisherNotRestored();
-    }
-
-    protected void checkBackupAndRestore_publisherNotRestored() {
-        installPackage(USER_0, CALLING_PACKAGE_1);
-        runWithCaller(CALLING_PACKAGE_1, USER_0, () -> {
-            assertEquals(0, mManager.getDynamicShortcuts().size());
-            assertEquals(0, mManager.getPinnedShortcuts().size());
-        });
-        assertFalse(mService.getPackageShortcutForTest(CALLING_PACKAGE_1, USER_0)
-                .getPackageInfo().isShadow());
-
-
-        installPackage(USER_0, CALLING_PACKAGE_2);
-        runWithCaller(CALLING_PACKAGE_2, USER_0, () -> {
-            assertEquals(0, mManager.getDynamicShortcuts().size());
-            assertShortcutIds(assertAllPinned(
-                    mManager.getPinnedShortcuts()),
-                    "s1", "s2", "s3");
-        });
-        assertFalse(mService.getPackageShortcutForTest(CALLING_PACKAGE_2, USER_0)
-                .getPackageInfo().isShadow());
-
-        installPackage(USER_0, LAUNCHER_1);
-        runWithCaller(LAUNCHER_1, USER_0, () -> {
-            assertShortcutIds(assertAllPinned(
-                    mLauncherApps.getShortcuts(buildAllQuery(CALLING_PACKAGE_1), HANDLE_USER_0))
-                    /* empty */);
-            assertShortcutIds(assertAllPinned(
-                    mLauncherApps.getShortcuts(buildAllQuery(CALLING_PACKAGE_2), HANDLE_USER_0)),
-                    "s1", "s2");
-            assertShortcutIds(assertAllPinned(
-                    mLauncherApps.getShortcuts(buildAllQuery(CALLING_PACKAGE_3), HANDLE_USER_0))
-                    /* empty */);
-        });
-        installPackage(USER_0, LAUNCHER_2);
-        runWithCaller(LAUNCHER_2, USER_0, () -> {
-            assertShortcutIds(assertAllPinned(
-                    mLauncherApps.getShortcuts(buildAllQuery(CALLING_PACKAGE_1), HANDLE_USER_0))
-                    /* empty */);
-            assertShortcutIds(assertAllPinned(
-                    mLauncherApps.getShortcuts(buildAllQuery(CALLING_PACKAGE_2), HANDLE_USER_0)),
-                    "s2", "s3");
-            assertShortcutIds(assertAllPinned(
-                    mLauncherApps.getShortcuts(buildAllQuery(CALLING_PACKAGE_3), HANDLE_USER_0))
-                    /* empty */);
-        });
-
-        installPackage(USER_0, CALLING_PACKAGE_3);
-        runWithCaller(CALLING_PACKAGE_3, USER_0, () -> {
-            assertEquals(0, mManager.getDynamicShortcuts().size());
-            assertEquals(0, mManager.getPinnedShortcuts().size());
-        });
-
-        runWithCaller(LAUNCHER_1, USER_0, () -> {
-            assertShortcutIds(assertAllPinned(
-                    mLauncherApps.getShortcuts(buildAllQuery(CALLING_PACKAGE_1), HANDLE_USER_0))
-                    /* empty */);
-            assertShortcutIds(assertAllPinned(
-                    mLauncherApps.getShortcuts(buildAllQuery(CALLING_PACKAGE_2), HANDLE_USER_0)),
-                    "s1", "s2");
-            assertShortcutIds(assertAllPinned(
-                    mLauncherApps.getShortcuts(buildAllQuery(CALLING_PACKAGE_3), HANDLE_USER_0))
-                    /* empty */);
-        });
-        runWithCaller(LAUNCHER_2, USER_0, () -> {
-            assertShortcutIds(assertAllPinned(
-                    mLauncherApps.getShortcuts(buildAllQuery(CALLING_PACKAGE_1), HANDLE_USER_0))
-                    /* empty */);
-            assertShortcutIds(assertAllPinned(
-                    mLauncherApps.getShortcuts(buildAllQuery(CALLING_PACKAGE_2), HANDLE_USER_0)),
-                    "s2", "s3");
-            assertShortcutIds(assertAllPinned(
-                    mLauncherApps.getShortcuts(buildAllQuery(CALLING_PACKAGE_3), HANDLE_USER_0))
-                    /* empty */);
-        });
-    }
-
-    public void testBackupAndRestore_launcherLowerVersion() {
-        prepareForBackupTest();
-
-        // Note doing a backup & restore again here shouldn't affect the result.
-        backupAndRestore();
-
-        addPackage(LAUNCHER_1, LAUNCHER_UID_1, 0); // Lower version
-
-        checkBackupAndRestore_launcherNotRestored();
-    }
-
-    public void testBackupAndRestore_launcherWrongSignature() {
-        prepareForBackupTest();
-
-        // Note doing a backup & restore again here shouldn't affect the result.
-        backupAndRestore();
-
-        addPackage(LAUNCHER_1, LAUNCHER_UID_1, 10, "sigx"); // different signature
-
-        checkBackupAndRestore_launcherNotRestored();
-    }
-
-    public void testBackupAndRestore_launcherNoLongerBackupTarget() {
-        prepareForBackupTest();
-
-        // Note doing a backup & restore again here shouldn't affect the result.
-        backupAndRestore();
-
-        updatePackageInfo(LAUNCHER_1,
-                pi -> pi.applicationInfo.flags &= ~ApplicationInfo.FLAG_ALLOW_BACKUP);
-
-        checkBackupAndRestore_launcherNotRestored();
-    }
-
-    protected void checkBackupAndRestore_launcherNotRestored() {
-        installPackage(USER_0, CALLING_PACKAGE_1);
-        runWithCaller(CALLING_PACKAGE_1, USER_0, () -> {
-            assertEquals(0, mManager.getDynamicShortcuts().size());
-
-            // s1 was pinned by launcher 1, which is not restored, yet, so we still see "s1" here.
-            assertShortcutIds(assertAllPinned(
-                    mManager.getPinnedShortcuts()),
-                    "s1", "s2");
-        });
-
-        installPackage(USER_0, CALLING_PACKAGE_2);
-        runWithCaller(CALLING_PACKAGE_2, USER_0, () -> {
-            assertEquals(0, mManager.getDynamicShortcuts().size());
-            assertShortcutIds(assertAllPinned(
-                    mManager.getPinnedShortcuts()),
-                    "s1", "s2", "s3");
-        });
-
-        // Now we try to restore launcher 1.  Then we realize it's not restorable, so L1 has no pinned
-        // shortcuts.
-        installPackage(USER_0, LAUNCHER_1);
-        runWithCaller(LAUNCHER_1, USER_0, () -> {
-            assertShortcutIds(assertAllPinned(
-                    mLauncherApps.getShortcuts(buildAllQuery(CALLING_PACKAGE_1), HANDLE_USER_0))
-                    /* empty */);
-            assertShortcutIds(assertAllPinned(
-                    mLauncherApps.getShortcuts(buildAllQuery(CALLING_PACKAGE_2), HANDLE_USER_0))
-                    /* empty */);
-            assertShortcutIds(assertAllPinned(
-                    mLauncherApps.getShortcuts(buildAllQuery(CALLING_PACKAGE_3), HANDLE_USER_0))
-                    /* empty */);
-        });
-        assertFalse(mService.getLauncherShortcutForTest(LAUNCHER_1, USER_0)
-                .getPackageInfo().isShadow());
-
-        runWithCaller(CALLING_PACKAGE_1, USER_0, () -> {
-            assertEquals(0, mManager.getDynamicShortcuts().size());
-
-            // Now CALLING_PACKAGE_1 realizes "s1" is no longer pinned.
-            assertShortcutIds(assertAllPinned(
-                    mManager.getPinnedShortcuts()),
-                    "s2");
-        });
-
-        installPackage(USER_0, LAUNCHER_2);
-        runWithCaller(LAUNCHER_2, USER_0, () -> {
-            assertShortcutIds(assertAllPinned(
-                    mLauncherApps.getShortcuts(buildAllQuery(CALLING_PACKAGE_1), HANDLE_USER_0)),
-                    "s2");
-            assertShortcutIds(assertAllPinned(
-                    mLauncherApps.getShortcuts(buildAllQuery(CALLING_PACKAGE_2), HANDLE_USER_0)),
-                    "s2", "s3");
-            assertShortcutIds(assertAllPinned(
-                    mLauncherApps.getShortcuts(buildAllQuery(CALLING_PACKAGE_3), HANDLE_USER_0))
-                    /* empty */);
-        });
-        assertFalse(mService.getLauncherShortcutForTest(LAUNCHER_2, USER_0)
-                .getPackageInfo().isShadow());
-
-        installPackage(USER_0, CALLING_PACKAGE_3);
-        runWithCaller(CALLING_PACKAGE_3, USER_0, () -> {
-            assertEquals(0, mManager.getDynamicShortcuts().size());
-            assertEquals(0, mManager.getPinnedShortcuts().size());
-        });
-
-        runWithCaller(LAUNCHER_1, USER_0, () -> {
-            assertShortcutIds(assertAllPinned(
-                    mLauncherApps.getShortcuts(buildAllQuery(CALLING_PACKAGE_1), HANDLE_USER_0))
-                    /* empty */);
-            assertShortcutIds(assertAllPinned(
-                    mLauncherApps.getShortcuts(buildAllQuery(CALLING_PACKAGE_2), HANDLE_USER_0))
-                    /* empty */);
-            assertShortcutIds(assertAllPinned(
-                    mLauncherApps.getShortcuts(buildAllQuery(CALLING_PACKAGE_3), HANDLE_USER_0))
-                    /* empty */);
-        });
-        runWithCaller(LAUNCHER_2, USER_0, () -> {
-            assertShortcutIds(assertAllPinned(
-                    mLauncherApps.getShortcuts(buildAllQuery(CALLING_PACKAGE_1), HANDLE_USER_0)),
-                    "s2");
-            assertShortcutIds(assertAllPinned(
-                    mLauncherApps.getShortcuts(buildAllQuery(CALLING_PACKAGE_2), HANDLE_USER_0)),
-                    "s2", "s3");
-            assertShortcutIds(assertAllPinned(
-                    mLauncherApps.getShortcuts(buildAllQuery(CALLING_PACKAGE_3), HANDLE_USER_0))
-                    /* empty */);
-        });
-    }
-
-    public void testBackupAndRestore_launcherAndPackageNoLongerBackupTarget() {
-        prepareForBackupTest();
-
-        // Note doing a backup & restore again here shouldn't affect the result.
-        backupAndRestore();
-
-        updatePackageInfo(CALLING_PACKAGE_1,
-                pi -> pi.applicationInfo.flags &= ~ApplicationInfo.FLAG_ALLOW_BACKUP);
-
-        updatePackageInfo(LAUNCHER_1,
-                pi -> pi.applicationInfo.flags &= ~ApplicationInfo.FLAG_ALLOW_BACKUP);
-
-        checkBackupAndRestore_publisherAndLauncherNotRestored();
-    }
-
-    protected void checkBackupAndRestore_publisherAndLauncherNotRestored() {
-        installPackage(USER_0, CALLING_PACKAGE_1);
-        runWithCaller(CALLING_PACKAGE_1, USER_0, () -> {
-            assertEquals(0, mManager.getDynamicShortcuts().size());
-            assertEquals(0, mManager.getPinnedShortcuts().size());
-        });
-
-        installPackage(USER_0, CALLING_PACKAGE_2);
-        runWithCaller(CALLING_PACKAGE_2, USER_0, () -> {
-            assertEquals(0, mManager.getDynamicShortcuts().size());
-            assertShortcutIds(assertAllPinned(
-                    mManager.getPinnedShortcuts()),
-                    "s1", "s2", "s3");
-        });
-
-        installPackage(USER_0, LAUNCHER_1);
-        runWithCaller(LAUNCHER_1, USER_0, () -> {
-            assertShortcutIds(assertAllPinned(
-                    mLauncherApps.getShortcuts(buildAllQuery(CALLING_PACKAGE_1), HANDLE_USER_0))
-                    /* empty */);
-            assertShortcutIds(assertAllPinned(
-                    mLauncherApps.getShortcuts(buildAllQuery(CALLING_PACKAGE_2), HANDLE_USER_0))
-                    /* empty */);
-            assertShortcutIds(assertAllPinned(
-                    mLauncherApps.getShortcuts(buildAllQuery(CALLING_PACKAGE_3), HANDLE_USER_0))
-                    /* empty */);
-        });
-        installPackage(USER_0, LAUNCHER_2);
-        runWithCaller(LAUNCHER_2, USER_0, () -> {
-            assertShortcutIds(assertAllPinned(
-                    mLauncherApps.getShortcuts(buildAllQuery(CALLING_PACKAGE_1), HANDLE_USER_0))
-                    /* empty */);
-            assertShortcutIds(assertAllPinned(
-                    mLauncherApps.getShortcuts(buildAllQuery(CALLING_PACKAGE_2), HANDLE_USER_0)),
-                    "s2", "s3");
-            assertShortcutIds(assertAllPinned(
-                    mLauncherApps.getShortcuts(buildAllQuery(CALLING_PACKAGE_3), HANDLE_USER_0))
-                    /* empty */);
-        });
-
-        // Because launcher 1 wasn't restored, "s1" is no longer pinned.
-        runWithCaller(CALLING_PACKAGE_2, USER_0, () -> {
-            assertEquals(0, mManager.getDynamicShortcuts().size());
-            assertShortcutIds(assertAllPinned(
-                    mManager.getPinnedShortcuts()),
-                    "s2", "s3");
-        });
-
-        installPackage(USER_0, CALLING_PACKAGE_3);
-        runWithCaller(CALLING_PACKAGE_3, USER_0, () -> {
-            assertEquals(0, mManager.getDynamicShortcuts().size());
-            assertEquals(0, mManager.getPinnedShortcuts().size());
-        });
-
-        runWithCaller(LAUNCHER_1, USER_0, () -> {
-            assertShortcutIds(assertAllPinned(
-                    mLauncherApps.getShortcuts(buildAllQuery(CALLING_PACKAGE_1), HANDLE_USER_0))
-                    /* empty */);
-            assertShortcutIds(assertAllPinned(
-                    mLauncherApps.getShortcuts(buildAllQuery(CALLING_PACKAGE_2), HANDLE_USER_0))
-                    /* empty */);
-            assertShortcutIds(assertAllPinned(
-                    mLauncherApps.getShortcuts(buildAllQuery(CALLING_PACKAGE_3), HANDLE_USER_0))
-                    /* empty */);
-        });
-        runWithCaller(LAUNCHER_2, USER_0, () -> {
-            assertShortcutIds(assertAllPinned(
-                    mLauncherApps.getShortcuts(buildAllQuery(CALLING_PACKAGE_1), HANDLE_USER_0))
-                    /* empty */);
-            assertShortcutIds(assertAllPinned(
-                    mLauncherApps.getShortcuts(buildAllQuery(CALLING_PACKAGE_2), HANDLE_USER_0)),
-                    "s2", "s3");
-            assertShortcutIds(assertAllPinned(
-                    mLauncherApps.getShortcuts(buildAllQuery(CALLING_PACKAGE_3), HANDLE_USER_0))
-                    /* empty */);
-        });
-    }
-
-    public void testBackupAndRestore_disabled() {
-        prepareCrossProfileDataSet();
-
-        // Before doing backup & restore, disable s1.
-        runWithCaller(CALLING_PACKAGE_1, USER_0, () -> {
-            mManager.disableShortcuts(list("s1"));
-        });
-
-        backupAndRestore();
-
-        // Below is copied from checkBackupAndRestore_success.
-
-        // Make sure non-system user is not restored.
-        final ShortcutUser userP0 = mService.getUserShortcutsLocked(USER_P0);
-        assertEquals(0, userP0.getAllPackagesForTest().size());
-        assertEquals(0, userP0.getAllLaunchersForTest().size());
-
-        // Make sure only "allowBackup" apps are restored, and are shadow.
-        final ShortcutUser user0 = mService.getUserShortcutsLocked(USER_0);
-        assertExistsAndShadow(user0.getAllPackagesForTest().get(CALLING_PACKAGE_1));
-        assertExistsAndShadow(user0.getAllPackagesForTest().get(CALLING_PACKAGE_2));
-        assertExistsAndShadow(user0.getAllLaunchersForTest().get(
-                PackageWithUser.of(USER_0, LAUNCHER_1)));
-        assertExistsAndShadow(user0.getAllLaunchersForTest().get(
-                PackageWithUser.of(USER_0, LAUNCHER_2)));
-
-        assertNull(user0.getAllPackagesForTest().get(CALLING_PACKAGE_3));
-        assertNull(user0.getAllLaunchersForTest().get(PackageWithUser.of(USER_0, LAUNCHER_3)));
-        assertNull(user0.getAllLaunchersForTest().get(PackageWithUser.of(USER_P0, LAUNCHER_1)));
-
-        installPackage(USER_0, CALLING_PACKAGE_1);
-        runWithCaller(CALLING_PACKAGE_1, USER_0, () -> {
-            assertWith(getCallerVisibleShortcuts())
-                    .areAllEnabled() // disabled shortcuts shouldn't be restored.
-
-                    .selectDynamic()
-                    .isEmpty()
-
-                    .revertToOriginalList()
-                    .selectPinned()
-                    // s1 is not restored.
-                    .haveIds("s2");
-        });
-
-        installPackage(USER_0, LAUNCHER_1);
-        runWithCaller(LAUNCHER_1, USER_0, () -> {
-            // Note, s1 was pinned by launcher 1, but was disabled, so isn't restored.
-            assertWith(mLauncherApps.getShortcuts(buildAllQuery(CALLING_PACKAGE_1), HANDLE_USER_0))
-                    .isEmpty();
-
-            assertWith(mLauncherApps.getShortcuts(buildAllQuery(CALLING_PACKAGE_2), HANDLE_USER_0))
-                    .isEmpty();
-
-            assertWith(mLauncherApps.getShortcuts(buildAllQuery(CALLING_PACKAGE_3), HANDLE_USER_0))
-                    .isEmpty();
-
-            assertWith(mLauncherApps.getShortcuts(QUERY_ALL, HANDLE_USER_P0))
-                    .isEmpty();
-        });
-    }
-
-
-    public void testBackupAndRestore_manifestRePublished() {
-        // Publish two manifest shortcuts.
-        addManifestShortcutResource(
-                new ComponentName(CALLING_PACKAGE_1, ShortcutActivity.class.getName()),
-                R.xml.shortcut_2);
-        updatePackageVersion(CALLING_PACKAGE_1, 1);
-        mService.mPackageMonitor.onReceive(mServiceContext,
-                genPackageAddIntent(CALLING_PACKAGE_1, USER_0));
-
-        runWithCaller(CALLING_PACKAGE_1, USER_0, () -> {
-            assertTrue(mManager.setDynamicShortcuts(list(
-                    makeShortcut("s1"), makeShortcut("s2"), makeShortcut("s3"))));
-        });
-
-        // Pin from launcher 1.
-        runWithCaller(LAUNCHER_1, USER_0, () -> {
-            mLauncherApps.pinShortcuts(CALLING_PACKAGE_1,
-                    list("ms1", "ms2", "s1", "s2"), HANDLE_USER_0);
-        });
-
-        // Update and now ms2 is gone -> disabled.
-        addManifestShortcutResource(
-                new ComponentName(CALLING_PACKAGE_1, ShortcutActivity.class.getName()),
-                R.xml.shortcut_1);
-        updatePackageVersion(CALLING_PACKAGE_1, 1);
-        mService.mPackageMonitor.onReceive(mServiceContext,
-                genPackageAddIntent(CALLING_PACKAGE_1, USER_0));
-
-        // Make sure the manifest shortcuts have been published.
-        runWithCaller(CALLING_PACKAGE_1, USER_0, () -> {
-            assertWith(getCallerShortcuts())
-                    .selectManifest()
-                    .haveIds("ms1")
-
-                    .revertToOriginalList()
-                    .selectDynamic()
-                    .haveIds("s1", "s2", "s3")
-
-                    .revertToOriginalList()
-                    .selectPinned()
-                    .haveIds("ms1", "ms2", "s1", "s2")
-
-                    .revertToOriginalList()
-                    .selectByIds("ms1")
-                    .areAllManifest()
-                    .areAllEnabled()
-
-                    .revertToOriginalList()
-                    .selectByIds("ms2")
-                    .areAllNotManifest()
-                    .areAllDisabled();
-        });
-
-        backupAndRestore();
-
-        // When re-installing the app, the manifest shortcut should be re-published.
-        mService.mPackageMonitor.onReceive(mServiceContext,
-                genPackageAddIntent(CALLING_PACKAGE_1, USER_0));
-        mService.mPackageMonitor.onReceive(mServiceContext,
-                genPackageAddIntent(LAUNCHER_1, USER_0));
-
-        runWithCaller(CALLING_PACKAGE_1, USER_0, () -> {
-            assertWith(getCallerVisibleShortcuts())
-                    .selectPinned()
-                    // ms2 was disabled, so not restored.
-                    .haveIds("ms1", "s1", "s2")
-                    .areAllEnabled()
-
-                    .revertToOriginalList()
-                    .selectByIds("ms1")
-                    .areAllManifest()
-
-                    .revertToOriginalList()
-                    .selectByIds("s1", "s2")
-                    .areAllNotDynamic()
-                    ;
-        });
-    }
-
-    /**
-     * It's the case with preintalled apps -- when applyRestore() is called, the system
-     * apps are already installed, so manifest shortcuts need to be re-published.
-     *
-     * Also, when a restore target app is already installed, and
-     * - if it has allowBackup=true, we'll restore normally, so all existing shortcuts will be
-     * replaced. (but manifest shortcuts will be re-published anyway.)  We log a warning on
-     * logcat.
-     * - if it has allowBackup=false, we don't touch any of the existing shortcuts.
-     */
-    public void testBackupAndRestore_appAlreadyInstalledWhenRestored() {
-        // Pre-backup.  Same as testBackupAndRestore_manifestRePublished().
-
-        // Publish two manifest shortcuts.
-        addManifestShortcutResource(
-                new ComponentName(CALLING_PACKAGE_1, ShortcutActivity.class.getName()),
-                R.xml.shortcut_2);
-        updatePackageVersion(CALLING_PACKAGE_1, 1);
-        mService.mPackageMonitor.onReceive(mServiceContext,
-                genPackageAddIntent(CALLING_PACKAGE_1, USER_0));
-
-        runWithCaller(CALLING_PACKAGE_1, USER_0, () -> {
-            assertTrue(mManager.setDynamicShortcuts(list(
-                    makeShortcut("s1"), makeShortcut("s2"), makeShortcut("s3"))));
-        });
-
-        // Pin from launcher 1.
-        runWithCaller(LAUNCHER_1, USER_0, () -> {
-            mLauncherApps.pinShortcuts(CALLING_PACKAGE_1,
-                    list("ms1", "ms2", "s1", "s2"), HANDLE_USER_0);
-        });
-
-        // Update and now ms2 is gone -> disabled.
-        addManifestShortcutResource(
-                new ComponentName(CALLING_PACKAGE_1, ShortcutActivity.class.getName()),
-                R.xml.shortcut_1);
-        updatePackageVersion(CALLING_PACKAGE_1, 1);
-        mService.mPackageMonitor.onReceive(mServiceContext,
-                genPackageAddIntent(CALLING_PACKAGE_1, USER_0));
-
-        // Set up shortcuts for package 3, which won't be backed up / restored.
-        addManifestShortcutResource(
-                new ComponentName(CALLING_PACKAGE_3, ShortcutActivity.class.getName()),
-                R.xml.shortcut_1);
-        updatePackageVersion(CALLING_PACKAGE_3, 1);
-        mService.mPackageMonitor.onReceive(mServiceContext,
-                genPackageAddIntent(CALLING_PACKAGE_3, USER_0));
-
-        runWithCaller(CALLING_PACKAGE_3, USER_0, () -> {
-            assertTrue(getManager().setDynamicShortcuts(list(
-                    makeShortcut("s1"))));
-        });
-
-        // Make sure the manifest shortcuts have been published.
-        runWithCaller(CALLING_PACKAGE_1, USER_0, () -> {
-            assertWith(getCallerShortcuts())
-                    .selectManifest()
-                    .haveIds("ms1")
-
-                    .revertToOriginalList()
-                    .selectDynamic()
-                    .haveIds("s1", "s2", "s3")
-
-                    .revertToOriginalList()
-                    .selectPinned()
-                    .haveIds("ms1", "ms2", "s1", "s2")
-
-                    .revertToOriginalList()
-                    .selectByIds("ms1")
-                    .areAllManifest()
-                    .areAllEnabled()
-
-                    .revertToOriginalList()
-                    .selectByIds("ms2")
-                    .areAllNotManifest()
-                    .areAllDisabled();
-        });
-
-        runWithCaller(CALLING_PACKAGE_3, USER_0, () -> {
-            assertWith(getCallerShortcuts())
-                    .haveIds("s1", "ms1");
-        });
-
-        // Backup and *without restarting the service, just call applyRestore()*.
-        {
-            int prevUid = mInjectedCallingUid;
-            mInjectedCallingUid = Process.SYSTEM_UID; // Only system can call it.
-
-            dumpsysOnLogcat("Before backup");
-
-            final byte[] payload = mService.getBackupPayload(USER_0);
-            if (ENABLE_DUMP) {
-                final String xml = new String(payload);
-                Log.v(TAG, "Backup payload:");
-                for (String line : xml.split("\n")) {
-                    Log.v(TAG, line);
-                }
-            }
-            mService.applyRestore(payload, USER_0);
-
-            dumpsysOnLogcat("After restore");
-
-            mInjectedCallingUid = prevUid;
-        }
-
-        // The check is also the same as testBackupAndRestore_manifestRePublished().
-        runWithCaller(CALLING_PACKAGE_1, USER_0, () -> {
-            assertWith(getCallerVisibleShortcuts())
-                    .selectPinned()
-                    // ms2 was disabled, so not restored.
-                    .haveIds("ms1", "s1", "s2")
-                    .areAllEnabled()
-
-                    .revertToOriginalList()
-                    .selectByIds("ms1")
-                    .areAllManifest()
-
-                    .revertToOriginalList()
-                    .selectByIds("s1", "s2")
-                    .areAllNotDynamic()
-            ;
-        });
-
-        // Package 3 still has the same shortcuts.
-        runWithCaller(CALLING_PACKAGE_3, USER_0, () -> {
-            assertWith(getCallerShortcuts())
-                    .haveIds("s1", "ms1");
-        });
-    }
-
-    public void testSaveAndLoad_crossProfile() {
-        prepareCrossProfileDataSet();
-
-        dumpsysOnLogcat("Before save & load");
-
-        mService.saveDirtyInfo();
-        initService();
-
-        runWithCaller(CALLING_PACKAGE_1, USER_0, () -> {
-            assertShortcutIds(assertAllDynamic(mManager.getDynamicShortcuts()),
-                    "s1", "s2", "s3");
-            assertShortcutIds(assertAllPinned(mManager.getPinnedShortcuts()),
-                    "s1", "s2", "s3", "s4");
-        });
-        runWithCaller(CALLING_PACKAGE_2, USER_0, () -> {
-            assertShortcutIds(assertAllDynamic(mManager.getDynamicShortcuts()),
-                    "s1", "s2", "s3");
-            assertShortcutIds(assertAllPinned(mManager.getPinnedShortcuts()),
-                    "s1", "s2", "s3", "s4", "s5");
-        });
-        runWithCaller(CALLING_PACKAGE_3, USER_0, () -> {
-            assertShortcutIds(assertAllDynamic(mManager.getDynamicShortcuts()),
-                    "s1", "s2", "s3");
-            assertShortcutIds(assertAllPinned(mManager.getPinnedShortcuts()),
-                    "s1", "s2", "s3", "s4", "s5", "s6");
-        });
-        runWithCaller(CALLING_PACKAGE_4, USER_0, () -> {
-            assertShortcutIds(assertAllDynamic(mManager.getDynamicShortcuts())
-                    /* empty */);
-            assertShortcutIds(assertAllPinned(mManager.getPinnedShortcuts())
-                    /* empty */);
-        });
-        runWithCaller(CALLING_PACKAGE_1, USER_P0, () -> {
-            assertShortcutIds(assertAllDynamic(mManager.getDynamicShortcuts()),
-                    "s1", "s2", "s3");
-            assertShortcutIds(assertAllPinned(mManager.getPinnedShortcuts()),
-                    "s1", "s2", "s3", "s4", "s5", "s6");
-        });
-        runWithCaller(CALLING_PACKAGE_2, USER_P0, () -> {
-            assertShortcutIds(assertAllDynamic(mManager.getDynamicShortcuts())
-                    /* empty */);
-            assertShortcutIds(assertAllPinned(mManager.getPinnedShortcuts())
-                    /* empty */);
-        });
-        runWithCaller(CALLING_PACKAGE_1, USER_10, () -> {
-            assertShortcutIds(assertAllDynamic(mManager.getDynamicShortcuts()),
-                    "x1", "x2", "x3");
-            assertShortcutIds(assertAllPinned(mManager.getPinnedShortcuts()),
-                    "x4", "x5");
-        });
-        runWithCaller(LAUNCHER_1, USER_0, () -> {
-            assertShortcutIds(
-                    mLauncherApps.getShortcuts(buildPinnedQuery(CALLING_PACKAGE_1), HANDLE_USER_0),
-                    "s1");
-            assertShortcutIds(
-                    mLauncherApps.getShortcuts(buildPinnedQuery(CALLING_PACKAGE_2), HANDLE_USER_0),
-                    "s1", "s2");
-            assertShortcutIds(
-                    mLauncherApps.getShortcuts(buildPinnedQuery(CALLING_PACKAGE_3), HANDLE_USER_0),
-                    "s1", "s2", "s3");
-            assertShortcutIds(
-                    mLauncherApps.getShortcuts(buildPinnedQuery(CALLING_PACKAGE_4), HANDLE_USER_0)
-                    /* empty */);
-            assertShortcutIds(
-                    mLauncherApps.getShortcuts(buildPinnedQuery(CALLING_PACKAGE_1), HANDLE_USER_P0),
-                    "s1", "s4");
-            assertShortcutIds(
-                    mLauncherApps.getShortcuts(buildPinnedQuery(CALLING_PACKAGE_2), HANDLE_USER_P0)
-                    /* empty */);
-            assertExpectException(
-                    SecurityException.class, "", () -> {
-                        mLauncherApps.getShortcuts(
-                                buildAllQuery(CALLING_PACKAGE_1), HANDLE_USER_10);
-                    });
-        });
-        runWithCaller(LAUNCHER_2, USER_0, () -> {
-            assertShortcutIds(
-                    mLauncherApps.getShortcuts(buildPinnedQuery(CALLING_PACKAGE_1), HANDLE_USER_0),
-                    "s2");
-            assertShortcutIds(
-                    mLauncherApps.getShortcuts(buildPinnedQuery(CALLING_PACKAGE_2), HANDLE_USER_0),
-                    "s2", "s3");
-            assertShortcutIds(
-                    mLauncherApps.getShortcuts(buildPinnedQuery(CALLING_PACKAGE_3), HANDLE_USER_0),
-                    "s2", "s3", "s4");
-            assertShortcutIds(
-                    mLauncherApps.getShortcuts(buildPinnedQuery(CALLING_PACKAGE_4), HANDLE_USER_0)
-                    /* empty */);
-            assertShortcutIds(
-                    mLauncherApps.getShortcuts(buildPinnedQuery(CALLING_PACKAGE_1), HANDLE_USER_P0),
-                    "s2", "s5");
-            assertShortcutIds(
-                    mLauncherApps.getShortcuts(buildPinnedQuery(CALLING_PACKAGE_2), HANDLE_USER_P0)
-                    /* empty */);
-        });
-        runWithCaller(LAUNCHER_3, USER_0, () -> {
-            assertShortcutIds(
-                    mLauncherApps.getShortcuts(buildPinnedQuery(CALLING_PACKAGE_1), HANDLE_USER_0),
-                    "s3");
-            assertShortcutIds(
-                    mLauncherApps.getShortcuts(buildPinnedQuery(CALLING_PACKAGE_2), HANDLE_USER_0),
-                    "s3", "s4");
-            assertShortcutIds(
-                    mLauncherApps.getShortcuts(buildPinnedQuery(CALLING_PACKAGE_3), HANDLE_USER_0),
-                    "s3", "s4", "s5");
-            assertShortcutIds(
-                    mLauncherApps.getShortcuts(buildPinnedQuery(CALLING_PACKAGE_4), HANDLE_USER_0)
-                    /* empty */);
-            assertShortcutIds(
-                    mLauncherApps.getShortcuts(buildPinnedQuery(CALLING_PACKAGE_1), HANDLE_USER_P0),
-                    "s3", "s6");
-            assertShortcutIds(
-                    mLauncherApps.getShortcuts(buildPinnedQuery(CALLING_PACKAGE_2), HANDLE_USER_P0)
-                    /* empty */);
-        });
-        runWithCaller(LAUNCHER_4, USER_0, () -> {
-            assertShortcutIds(
-                    mLauncherApps.getShortcuts(buildPinnedQuery(CALLING_PACKAGE_1), HANDLE_USER_0)
-                    /* empty */);
-            assertShortcutIds(
-                    mLauncherApps.getShortcuts(buildPinnedQuery(CALLING_PACKAGE_2), HANDLE_USER_0)
-                    /* empty */);
-            assertShortcutIds(
-                    mLauncherApps.getShortcuts(buildPinnedQuery(CALLING_PACKAGE_3), HANDLE_USER_0)
-                    /* empty */);
-            assertShortcutIds(
-                    mLauncherApps.getShortcuts(buildPinnedQuery(CALLING_PACKAGE_4), HANDLE_USER_0)
-                    /* empty */);
-            assertShortcutIds(
-                    mLauncherApps.getShortcuts(buildPinnedQuery(CALLING_PACKAGE_1), HANDLE_USER_P0)
-                    /* empty */);
-            assertShortcutIds(
-                    mLauncherApps.getShortcuts(buildPinnedQuery(CALLING_PACKAGE_2), HANDLE_USER_P0)
-                    /* empty */);
-        });
-        runWithCaller(LAUNCHER_1, USER_P0, () -> {
-            assertShortcutIds(
-                    mLauncherApps.getShortcuts(buildPinnedQuery(CALLING_PACKAGE_1), HANDLE_USER_0),
-                    "s3", "s4");
-            assertShortcutIds(
-                    mLauncherApps.getShortcuts(buildPinnedQuery(CALLING_PACKAGE_2), HANDLE_USER_0),
-                    "s3", "s4", "s5");
-            assertShortcutIds(
-                    mLauncherApps.getShortcuts(buildPinnedQuery(CALLING_PACKAGE_3), HANDLE_USER_0),
-                    "s3", "s4", "s5", "s6");
-            assertShortcutIds(
-                    mLauncherApps.getShortcuts(buildPinnedQuery(CALLING_PACKAGE_1), HANDLE_USER_P0),
-                    "s1", "s4");
-            assertExpectException(
-                    SecurityException.class, "unrelated profile", () -> {
-                        mLauncherApps.getShortcuts(
-                                buildAllQuery(CALLING_PACKAGE_1), HANDLE_USER_10);
-                    });
-        });
-        runWithCaller(LAUNCHER_1, USER_10, () -> {
-            assertShortcutIds(
-                    mLauncherApps.getShortcuts(buildPinnedQuery(CALLING_PACKAGE_1), HANDLE_USER_10),
-                    "x4", "x5");
-            assertShortcutIds(
-                    mLauncherApps.getShortcuts(buildPinnedQuery(CALLING_PACKAGE_2), HANDLE_USER_10)
-                    /* empty */);
-            assertShortcutIds(
-                    mLauncherApps.getShortcuts(buildPinnedQuery(CALLING_PACKAGE_3), HANDLE_USER_10)
-                    /* empty */);
-            assertExpectException(
-                    SecurityException.class, "unrelated profile", () -> {
-                        mLauncherApps.getShortcuts(
-                                buildAllQuery(CALLING_PACKAGE_1), HANDLE_USER_0);
-                    });
-            assertExpectException(
-                    SecurityException.class, "unrelated profile", () -> {
-                        mLauncherApps.getShortcuts(
-                                buildAllQuery(CALLING_PACKAGE_1), HANDLE_USER_P0);
-                    });
-        });
-        // Check the user-IDs.
-        assertEquals(USER_0,
-                mService.getUserShortcutsLocked(USER_0).getPackageShortcuts(CALLING_PACKAGE_1)
-                        .getOwnerUserId());
-        assertEquals(USER_0,
-                mService.getUserShortcutsLocked(USER_0).getPackageShortcuts(CALLING_PACKAGE_1)
-                        .getPackageUserId());
-        assertEquals(USER_P0,
-                mService.getUserShortcutsLocked(USER_P0).getPackageShortcuts(CALLING_PACKAGE_1)
-                        .getOwnerUserId());
-        assertEquals(USER_P0,
-                mService.getUserShortcutsLocked(USER_P0).getPackageShortcuts(CALLING_PACKAGE_1)
-                        .getPackageUserId());
-
-        assertEquals(USER_0,
-                mService.getUserShortcutsLocked(USER_0).getLauncherShortcuts(LAUNCHER_1, USER_0)
-                        .getOwnerUserId());
-        assertEquals(USER_0,
-                mService.getUserShortcutsLocked(USER_0).getLauncherShortcuts(LAUNCHER_1, USER_0)
-                        .getPackageUserId());
-        assertEquals(USER_P0,
-                mService.getUserShortcutsLocked(USER_P0).getLauncherShortcuts(LAUNCHER_1, USER_0)
-                        .getOwnerUserId());
-        assertEquals(USER_0,
-                mService.getUserShortcutsLocked(USER_P0).getLauncherShortcuts(LAUNCHER_1, USER_0)
-                        .getPackageUserId());
-    }
-
-    public void testOnApplicationActive_permission() {
-        assertExpectException(SecurityException.class, "Missing permission", () ->
-                mManager.onApplicationActive(CALLING_PACKAGE_1, USER_0));
-
-        // Has permission, now it should pass.
-        mCallerPermissions.add(permission.RESET_SHORTCUT_MANAGER_THROTTLING);
-        mManager.onApplicationActive(CALLING_PACKAGE_1, USER_0);
-    }
-
-    public void testDumpsys_crossProfile() {
-        prepareCrossProfileDataSet();
-        dumpsysOnLogcat("test1", /* force= */ true);
-    }
-
-    public void testDumpsys_withIcons() throws IOException {
-        testIcons();
-        // Dump after having some icons.
-        dumpsysOnLogcat("test1", /* force= */ true);
-    }
-
-    public void testManifestShortcut_publishOnUnlockUser() {
-        addManifestShortcutResource(
-                new ComponentName(CALLING_PACKAGE_1, ShortcutActivity.class.getName()),
-                R.xml.shortcut_1);
-        addManifestShortcutResource(
-                new ComponentName(CALLING_PACKAGE_2, ShortcutActivity.class.getName()),
-                R.xml.shortcut_2);
-        addManifestShortcutResource(
-                new ComponentName(CALLING_PACKAGE_3, ShortcutActivity.class.getName()),
-                R.xml.shortcut_5);
-
-        // Unlock user-0.
-        mService.handleUnlockUser(USER_0);
-
-        runWithCaller(CALLING_PACKAGE_1, USER_0, () -> {
-            assertShortcutIds(assertAllManifest(assertAllImmutable(assertAllEnabled(
-                    mManager.getManifestShortcuts()))),
-                    "ms1");
-            assertEmpty(mManager.getPinnedShortcuts());
-        });
-
-        runWithCaller(CALLING_PACKAGE_2, USER_0, () -> {
-            assertShortcutIds(assertAllManifest(assertAllImmutable(assertAllEnabled(
-                    mManager.getManifestShortcuts()))),
-                    "ms1", "ms2");
-            assertEmpty(mManager.getPinnedShortcuts());
-        });
-
-        runWithCaller(CALLING_PACKAGE_3, USER_0, () -> {
-            assertShortcutIds(assertAllManifest(assertAllImmutable(assertAllEnabled(
-                    mManager.getManifestShortcuts()))),
-                    "ms1", "ms2", "ms3", "ms4", "ms5");
-            assertEmpty(mManager.getPinnedShortcuts());
-        });
-
-        // Try on another user, with some packages uninstalled.
-        mRunningUsers.put(USER_10, true);
-
-        uninstallPackage(USER_10, CALLING_PACKAGE_1);
-        uninstallPackage(USER_10, CALLING_PACKAGE_3);
-
-        mService.handleUnlockUser(USER_10);
-
-        runWithCaller(CALLING_PACKAGE_1, USER_10, () -> {
-            assertEmpty(mManager.getManifestShortcuts());
-            assertEmpty(mManager.getPinnedShortcuts());
-        });
-
-        runWithCaller(CALLING_PACKAGE_2, USER_10, () -> {
-            assertShortcutIds(assertAllManifest(assertAllImmutable(assertAllEnabled(
-                    mManager.getManifestShortcuts()))),
-                    "ms1", "ms2");
-            assertEmpty(mManager.getPinnedShortcuts());
-        });
-
-        runWithCaller(CALLING_PACKAGE_3, USER_10, () -> {
-            assertEmpty(mManager.getManifestShortcuts());
-            assertEmpty(mManager.getPinnedShortcuts());
-        });
-
-        // Now change the resources for package 1, and unlock again.
-        // But we still see *old* shortcuts, because the package version and install time
-        // hasn't changed.
-        shutdownServices();
-
-        addManifestShortcutResource(
-                new ComponentName(CALLING_PACKAGE_1, ShortcutActivity.class.getName()),
-                R.xml.shortcut_5);
-        addManifestShortcutResource(
-                new ComponentName(CALLING_PACKAGE_3, ShortcutActivity.class.getName()),
-                R.xml.shortcut_1);
-
-        initService();
-        mService.handleUnlockUser(USER_0);
-
-        runWithCaller(CALLING_PACKAGE_1, USER_0, () -> {
-            assertShortcutIds(assertAllManifest(assertAllImmutable(assertAllEnabled(
-                    mManager.getManifestShortcuts()))),
-                    "ms1");
-            assertEmpty(mManager.getPinnedShortcuts());
-        });
-
-        runWithCaller(CALLING_PACKAGE_2, USER_0, () -> {
-            assertShortcutIds(assertAllManifest(assertAllImmutable(assertAllEnabled(
-                    mManager.getManifestShortcuts()))),
-                    "ms1", "ms2");
-            assertEmpty(mManager.getPinnedShortcuts());
-        });
-
-        runWithCaller(CALLING_PACKAGE_3, USER_0, () -> {
-            assertShortcutIds(assertAllManifest(assertAllImmutable(assertAllEnabled(
-                    mManager.getManifestShortcuts()))),
-                    "ms1", "ms2", "ms3", "ms4", "ms5");
-            assertEmpty(mManager.getPinnedShortcuts());
-        });
-
-        // Do it again, but this time we change the app version, so we do detect the changes.
-        shutdownServices();
-
-        updatePackageVersion(CALLING_PACKAGE_1, 1);
-        updatePackageLastUpdateTime(CALLING_PACKAGE_3, 1);
-
-        initService();
-        mService.handleUnlockUser(USER_0);
-
-        runWithCaller(CALLING_PACKAGE_1, USER_0, () -> {
-            assertShortcutIds(assertAllManifest(assertAllImmutable(assertAllEnabled(
-                    mManager.getManifestShortcuts()))),
-                    "ms1", "ms2", "ms3", "ms4", "ms5");
-            assertEmpty(mManager.getPinnedShortcuts());
-        });
-
-        runWithCaller(CALLING_PACKAGE_2, USER_0, () -> {
-            assertShortcutIds(assertAllManifest(assertAllImmutable(assertAllEnabled(
-                    mManager.getManifestShortcuts()))),
-                    "ms1", "ms2");
-            assertEmpty(mManager.getPinnedShortcuts());
-        });
-
-        runWithCaller(CALLING_PACKAGE_3, USER_0, () -> {
-            assertShortcutIds(assertAllManifest(assertAllImmutable(assertAllEnabled(
-                    mManager.getManifestShortcuts()))),
-                    "ms1");
-            assertEmpty(mManager.getPinnedShortcuts());
-        });
-
-        // Next, try removing all shortcuts, with some of them pinned.
-        runWithCaller(LAUNCHER_1, USER_0, () -> {
-            mLauncherApps.pinShortcuts(CALLING_PACKAGE_1, list("ms3"), HANDLE_USER_0);
-            mLauncherApps.pinShortcuts(CALLING_PACKAGE_2, list("ms2"), HANDLE_USER_0);
-            mLauncherApps.pinShortcuts(CALLING_PACKAGE_3, list("ms1"), HANDLE_USER_0);
-        });
-        runWithCaller(CALLING_PACKAGE_1, USER_0, () -> {
-            assertShortcutIds(assertAllManifest(assertAllImmutable(assertAllEnabled(
-                    mManager.getManifestShortcuts()))),
-                    "ms1", "ms2", "ms3", "ms4", "ms5");
-            assertShortcutIds(assertAllImmutable(assertAllPinned(assertAllManifest(
-                    assertAllEnabled(mManager.getPinnedShortcuts())))),
-                    "ms3");
-        });
-
-        runWithCaller(CALLING_PACKAGE_2, USER_0, () -> {
-            assertShortcutIds(assertAllManifest(assertAllImmutable(assertAllEnabled(
-                    mManager.getManifestShortcuts()))),
-                    "ms1", "ms2");
-            assertShortcutIds(assertAllImmutable(assertAllPinned(assertAllManifest(
-                    assertAllEnabled(mManager.getPinnedShortcuts())))),
-                    "ms2");
-        });
-
-        runWithCaller(CALLING_PACKAGE_3, USER_0, () -> {
-            assertShortcutIds(assertAllManifest(assertAllImmutable(assertAllEnabled(
-                    mManager.getManifestShortcuts()))),
-                    "ms1");
-            assertShortcutIds(assertAllImmutable(assertAllPinned(assertAllManifest(
-                    assertAllEnabled(mManager.getPinnedShortcuts())))),
-                    "ms1");
-        });
-
-        shutdownServices();
-
-        addManifestShortcutResource(
-                new ComponentName(CALLING_PACKAGE_1, ShortcutActivity.class.getName()),
-                R.xml.shortcut_0);
-        addManifestShortcutResource(
-                new ComponentName(CALLING_PACKAGE_2, ShortcutActivity.class.getName()),
-                R.xml.shortcut_1);
-        addManifestShortcutResource(
-                new ComponentName(CALLING_PACKAGE_3, ShortcutActivity.class.getName()),
-                R.xml.shortcut_0);
-
-        updatePackageVersion(CALLING_PACKAGE_1, 1);
-        updatePackageVersion(CALLING_PACKAGE_2, 1);
-        updatePackageVersion(CALLING_PACKAGE_3, 1);
-
-        initService();
-        mService.handleUnlockUser(USER_0);
-
-        runWithCaller(CALLING_PACKAGE_1, USER_0, () -> {
-            assertEmpty(mManager.getManifestShortcuts());
-            assertShortcutIds(assertAllImmutable(assertAllPinned(assertAllNotManifest(
-                    assertAllDisabled(mManager.getPinnedShortcuts())))),
-                    "ms3");
-        });
-
-        runWithCaller(CALLING_PACKAGE_2, USER_0, () -> {
-            assertShortcutIds(assertAllManifest(assertAllImmutable(assertAllEnabled(
-                    mManager.getManifestShortcuts()))),
-                    "ms1");
-            assertShortcutIds(assertAllImmutable(assertAllPinned(assertAllNotManifest(
-                    assertAllDisabled(mManager.getPinnedShortcuts())))),
-                    "ms2");
-        });
-
-        runWithCaller(CALLING_PACKAGE_3, USER_0, () -> {
-            assertEmpty(mManager.getManifestShortcuts());
-            assertShortcutIds(assertAllImmutable(assertAllPinned(assertAllNotManifest(
-                    assertAllDisabled(mManager.getPinnedShortcuts())))),
-                    "ms1");
-        });
-
-        // Make sure we don't have ShortcutPackage for packages that don't have shortcuts.
-        assertNull(mService.getPackageShortcutForTest(CALLING_PACKAGE_4, USER_0));
-        assertNull(mService.getPackageShortcutForTest(LAUNCHER_1, USER_0));
-    }
-
-    public void testManifestShortcut_publishOnBroadcast() {
-        // First, no packages are installed.
-        uninstallPackage(USER_0, CALLING_PACKAGE_1);
-        uninstallPackage(USER_0, CALLING_PACKAGE_2);
-        uninstallPackage(USER_0, CALLING_PACKAGE_3);
-        uninstallPackage(USER_0, CALLING_PACKAGE_4);
-        uninstallPackage(USER_10, CALLING_PACKAGE_1);
-        uninstallPackage(USER_10, CALLING_PACKAGE_2);
-        uninstallPackage(USER_10, CALLING_PACKAGE_3);
-        uninstallPackage(USER_10, CALLING_PACKAGE_4);
-
-        mService.handleUnlockUser(USER_0);
-
-        mRunningUsers.put(USER_10, true);
-        mService.handleUnlockUser(USER_10);
-
-        // Originally no manifest shortcuts.
-        runWithCaller(CALLING_PACKAGE_1, USER_0, () -> {
-            assertEmpty(mManager.getManifestShortcuts());
-            assertEmpty(mManager.getPinnedShortcuts());
-        });
-
-        runWithCaller(CALLING_PACKAGE_2, USER_0, () -> {
-            assertEmpty(mManager.getManifestShortcuts());
-            assertEmpty(mManager.getPinnedShortcuts());
-        });
-
-        runWithCaller(CALLING_PACKAGE_3, USER_0, () -> {
-            assertEmpty(mManager.getManifestShortcuts());
-            assertEmpty(mManager.getPinnedShortcuts());
-        });
-
-        // Package 1 updated, with manifest shortcuts.
-        addManifestShortcutResource(
-                new ComponentName(CALLING_PACKAGE_1, ShortcutActivity.class.getName()),
-                R.xml.shortcut_1);
-        updatePackageVersion(CALLING_PACKAGE_1, 1);
-                mService.mPackageMonitor.onReceive(getTestContext(),
-                genPackageAddIntent(CALLING_PACKAGE_1, USER_0));
-
-        runWithCaller(CALLING_PACKAGE_1, USER_0, () -> {
-            assertShortcutIds(assertAllManifest(assertAllImmutable(assertAllEnabled(
-                    mManager.getManifestShortcuts()))),
-                    "ms1");
-            assertEmpty(mManager.getPinnedShortcuts());
-        });
-
-        runWithCaller(CALLING_PACKAGE_2, USER_0, () -> {
-            assertEmpty(mManager.getManifestShortcuts());
-            assertEmpty(mManager.getPinnedShortcuts());
-        });
-
-        // Package 2 updated, with manifest shortcuts.
-
-        addManifestShortcutResource(
-                new ComponentName(CALLING_PACKAGE_2, ShortcutActivity.class.getName()),
-                R.xml.shortcut_5);
-        updatePackageVersion(CALLING_PACKAGE_2, 1);
-                mService.mPackageMonitor.onReceive(getTestContext(),
-                genPackageAddIntent(CALLING_PACKAGE_2, USER_0));
-
-        runWithCaller(CALLING_PACKAGE_1, USER_0, () -> {
-            assertShortcutIds(assertAllManifest(assertAllImmutable(assertAllEnabled(
-                    mManager.getManifestShortcuts()))),
-                    "ms1");
-            assertEmpty(mManager.getPinnedShortcuts());
-        });
-
-        runWithCaller(CALLING_PACKAGE_2, USER_0, () -> {
-            assertShortcutIds(assertAllManifest(assertAllImmutable(assertAllEnabled(
-                    mManager.getManifestShortcuts()))),
-                    "ms1", "ms2", "ms3", "ms4", "ms5");
-            assertWith(getCallerShortcuts()).selectManifest()
-                    .selectByActivity(
-                            new ComponentName(CALLING_PACKAGE_2, ShortcutActivity.class.getName()))
-                    .haveRanksInOrder("ms1", "ms2", "ms3", "ms4", "ms5");
-            assertEmpty(mManager.getPinnedShortcuts());
-        });
-
-        // Package 2 updated, with less manifest shortcuts.
-        // This time we use updatePackageLastUpdateTime() instead of updatePackageVersion().
-
-        dumpsysOnLogcat("Before pinning");
-
-        // Also pin some.
-        runWithCaller(LAUNCHER_1, USER_0, () -> {
-            mLauncherApps.pinShortcuts(CALLING_PACKAGE_2, list("ms2", "ms3"), HANDLE_USER_0);
-        });
-
-        dumpsysOnLogcat("After pinning");
-
-        addManifestShortcutResource(
-                new ComponentName(CALLING_PACKAGE_2, ShortcutActivity.class.getName()),
-                R.xml.shortcut_2);
-        updatePackageLastUpdateTime(CALLING_PACKAGE_2, 1);
-                mService.mPackageMonitor.onReceive(getTestContext(),
-                genPackageAddIntent(CALLING_PACKAGE_2, USER_0));
-
-        runWithCaller(CALLING_PACKAGE_1, USER_0, () -> {
-            assertShortcutIds(assertAllManifest(assertAllImmutable(assertAllEnabled(
-                    mManager.getManifestShortcuts()))),
-                    "ms1");
-            assertEmpty(mManager.getPinnedShortcuts());
-        });
-
-        runWithCaller(CALLING_PACKAGE_2, USER_0, () -> {
-            assertShortcutIds(assertAllManifest(assertAllImmutable(assertAllEnabled(
-                    mManager.getManifestShortcuts()))),
-                    "ms1", "ms2");
-            assertWith(getCallerShortcuts()).selectManifest()
-                    .selectByActivity(
-                            new ComponentName(CALLING_PACKAGE_2, ShortcutActivity.class.getName()))
-                    .haveRanksInOrder("ms1", "ms2");
-            assertShortcutIds(assertAllImmutable(assertAllPinned(
-                    mManager.getPinnedShortcuts())),
-                    "ms2", "ms3");
-            // ms3 is no longer in manifest, so should be disabled.
-            // but ms1 and ms2 should be enabled.
-            assertAllEnabled(list(getCallerShortcut("ms1")));
-            assertAllEnabled(list(getCallerShortcut("ms2")));
-            assertAllDisabled(list(getCallerShortcut("ms3")));
-        });
-
-        // Package 2 on user 10 has no shortcuts yet.
-        runWithCaller(CALLING_PACKAGE_2, USER_10, () -> {
-            assertEmpty(mManager.getManifestShortcuts());
-            assertEmpty(mManager.getPinnedShortcuts());
-        });
-        // Send add broadcast, but the user is not running, so should be ignored.
-        mService.handleCleanupUser(USER_10);
-        mRunningUsers.put(USER_10, false);
-        mUnlockedUsers.put(USER_10, false);
-
-        mService.mPackageMonitor.onReceive(getTestContext(),
-                genPackageAddIntent(CALLING_PACKAGE_2, USER_10));
-        runWithCaller(CALLING_PACKAGE_2, USER_10, () -> {
-            // Don't use the mManager APIs to get shortcuts, because they'll trigger the package
-            // update check.
-            // So look the internal data directly using getCallerShortcuts().
-            assertEmpty(getCallerShortcuts());
-        });
-
-        // Try again, but the user is locked, so still ignored.
-        mRunningUsers.put(USER_10, true);
-                mService.mPackageMonitor.onReceive(getTestContext(),
-                genPackageAddIntent(CALLING_PACKAGE_2, USER_10));
-        runWithCaller(CALLING_PACKAGE_2, USER_10, () -> {
-            // Don't use the mManager APIs to get shortcuts, because they'll trigger the package
-            // update check.
-            // So look the internal data directly using getCallerShortcuts().
-            assertEmpty(getCallerShortcuts());
-        });
-
-        // Unlock the user, now it should work.
-        mUnlockedUsers.put(USER_10, true);
-
-        // Send PACKAGE_ADD broadcast to have Package 2 on user-10 publish manifest shortcuts.
-                mService.mPackageMonitor.onReceive(getTestContext(),
-                genPackageAddIntent(CALLING_PACKAGE_2, USER_10));
-
-        runWithCaller(CALLING_PACKAGE_2, USER_10, () -> {
-            assertShortcutIds(assertAllManifest(assertAllImmutable(assertAllEnabled(
-                    mManager.getManifestShortcuts()))),
-                    "ms1", "ms2");
-            assertWith(getCallerShortcuts()).selectManifest()
-                    .selectByActivity(
-                            new ComponentName(CALLING_PACKAGE_2, ShortcutActivity.class.getName()))
-                    .haveRanksInOrder("ms1", "ms2");
-            assertEmpty(mManager.getPinnedShortcuts());
-        });
-
-        // But it shouldn't affect user-0.
-        runWithCaller(CALLING_PACKAGE_2, USER_0, () -> {
-            assertShortcutIds(assertAllManifest(assertAllImmutable(assertAllEnabled(
-                    mManager.getManifestShortcuts()))),
-                    "ms1", "ms2");
-            assertWith(getCallerShortcuts()).selectManifest()
-                    .selectByActivity(
-                            new ComponentName(CALLING_PACKAGE_2, ShortcutActivity.class.getName()))
-                    .haveRanksInOrder("ms1", "ms2");
-            assertShortcutIds(assertAllImmutable(assertAllPinned(
-                    mManager.getPinnedShortcuts())),
-                    "ms2", "ms3");
-            assertAllEnabled(list(getCallerShortcut("ms1")));
-            assertAllEnabled(list(getCallerShortcut("ms2")));
-            assertAllDisabled(list(getCallerShortcut("ms3")));
-        });
-
-        // Multiple activities.
-        // Add shortcuts on activity 2 for package 2.
-        addManifestShortcutResource(
-                new ComponentName(CALLING_PACKAGE_2, ShortcutActivity.class.getName()),
-                R.xml.shortcut_5_alt);
-        addManifestShortcutResource(
-                new ComponentName(CALLING_PACKAGE_2, ShortcutActivity2.class.getName()),
-                R.xml.shortcut_5_reverse);
-
-        updatePackageLastUpdateTime(CALLING_PACKAGE_2, 1);
-                mService.mPackageMonitor.onReceive(getTestContext(),
-                genPackageAddIntent(CALLING_PACKAGE_2, USER_0));
-
-        runWithCaller(CALLING_PACKAGE_2, USER_0, () -> {
-            assertShortcutIds(assertAllManifest(assertAllImmutable(assertAllEnabled(
-                    mManager.getManifestShortcuts()))),
-                    "ms1", "ms2", "ms3", "ms4", "ms5",
-                    "ms1_alt", "ms2_alt", "ms3_alt", "ms4_alt", "ms5_alt");
-
-            // Make sure they have the correct ranks, regardless of their ID's alphabetical order.
-            assertWith(getCallerShortcuts()).selectManifest()
-                    .selectByActivity(
-                            new ComponentName(CALLING_PACKAGE_2, ShortcutActivity.class.getName()))
-                    .haveRanksInOrder("ms1_alt", "ms2_alt", "ms3_alt", "ms4_alt", "ms5_alt");
-            assertWith(getCallerShortcuts()).selectManifest()
-                    .selectByActivity(
-                            new ComponentName(CALLING_PACKAGE_2, ShortcutActivity2.class.getName()))
-                    .haveRanksInOrder("ms5", "ms4", "ms3", "ms2", "ms1");
-        });
-
-        // Package 2 now has no manifest shortcuts.
-        addManifestShortcutResource(
-                new ComponentName(CALLING_PACKAGE_2, ShortcutActivity.class.getName()),
-                R.xml.shortcut_0);
-        addManifestShortcutResource(
-                new ComponentName(CALLING_PACKAGE_2, ShortcutActivity2.class.getName()),
-                R.xml.shortcut_0);
-        updatePackageLastUpdateTime(CALLING_PACKAGE_2, 1);
-                mService.mPackageMonitor.onReceive(getTestContext(),
-                genPackageAddIntent(CALLING_PACKAGE_2, USER_0));
-
-        // No manifest shortcuts, and pinned ones are disabled.
-        runWithCaller(CALLING_PACKAGE_2, USER_0, () -> {
-            assertEmpty(mManager.getManifestShortcuts());
-            assertShortcutIds(assertAllImmutable(assertAllPinned(assertAllDisabled(
-                    mManager.getPinnedShortcuts()))),
-                    "ms2", "ms3");
-        });
-    }
-
-    public void testManifestShortcuts_missingMandatoryFields() {
-        // Start with no apps installed.
-        uninstallPackage(USER_0, CALLING_PACKAGE_1);
-        uninstallPackage(USER_0, CALLING_PACKAGE_2);
-        uninstallPackage(USER_0, CALLING_PACKAGE_3);
-        uninstallPackage(USER_0, CALLING_PACKAGE_4);
-
-        mService.handleUnlockUser(USER_0);
-
-        // Make sure no manifest shortcuts.
-        runWithCaller(CALLING_PACKAGE_1, USER_0, () -> {
-            assertEmpty(mManager.getManifestShortcuts());
-        });
-
-        // Package 1 updated, which has one valid manifest shortcut and one invalid.
-        addManifestShortcutResource(
-                new ComponentName(CALLING_PACKAGE_1, ShortcutActivity.class.getName()),
-                R.xml.shortcut_error_1);
-        updatePackageVersion(CALLING_PACKAGE_1, 1);
-                mService.mPackageMonitor.onReceive(getTestContext(),
-                genPackageAddIntent(CALLING_PACKAGE_1, USER_0));
-
-        // Only the valid one is published.
-        runWithCaller(CALLING_PACKAGE_1, USER_0, () -> {
-            assertWith(getCallerShortcuts())
-                    .areAllManifest()
-                    .areAllImmutable()
-                    .areAllEnabled()
-                    .haveIds("x1");
-        });
-
-        // Package 1 updated, which has one valid manifest shortcut and one invalid.
-        addManifestShortcutResource(
-                new ComponentName(CALLING_PACKAGE_1, ShortcutActivity.class.getName()),
-                R.xml.shortcut_error_2);
-        updatePackageVersion(CALLING_PACKAGE_1, 1);
-                mService.mPackageMonitor.onReceive(getTestContext(),
-                genPackageAddIntent(CALLING_PACKAGE_1, USER_0));
-
-        // Only the valid one is published.
-        runWithCaller(CALLING_PACKAGE_1, USER_0, () -> {
-            assertWith(getCallerShortcuts())
-                    .areAllManifest()
-                    .areAllImmutable()
-                    .areAllEnabled()
-                    .haveIds("x2");
-        });
-
-        // Package 1 updated, which has one valid manifest shortcut and one invalid.
-        addManifestShortcutResource(
-                new ComponentName(CALLING_PACKAGE_1, ShortcutActivity.class.getName()),
-                R.xml.shortcut_error_3);
-        updatePackageVersion(CALLING_PACKAGE_1, 1);
-                mService.mPackageMonitor.onReceive(getTestContext(),
-                genPackageAddIntent(CALLING_PACKAGE_1, USER_0));
-
-        // Only the valid one is published.
-        runWithCaller(CALLING_PACKAGE_1, USER_0, () -> {
-            assertWith(getCallerShortcuts())
-                    .areAllManifest()
-                    .areAllImmutable()
-                    .areAllEnabled()
-                    .haveIds("x3")
-                    .forShortcutWithId("x3", si -> {
-                        assertEquals(set("cat2"), si.getCategories());
-                     });
-        });
-    }
-
-    public void testManifestShortcuts_intentDefinitions() {
-        addManifestShortcutResource(
-                new ComponentName(CALLING_PACKAGE_1, ShortcutActivity.class.getName()),
-                R.xml.shortcut_error_4);
-        updatePackageVersion(CALLING_PACKAGE_1, 1);
-                mService.mPackageMonitor.onReceive(getTestContext(),
-                genPackageAddIntent(CALLING_PACKAGE_1, USER_0));
-
-        runWithCaller(CALLING_PACKAGE_1, USER_0, () -> {
-            // Make sure invalid ones are not published.
-            // Note that at this point disabled ones don't show up because they weren't pinned.
-            assertWith(getCallerShortcuts())
-                    .haveIds("ms1", "ms2")
-                    .areAllManifest()
-                    .areAllNotDynamic()
-                    .areAllNotPinned()
-                    .areAllImmutable()
-                    .areAllEnabled()
-                    .forShortcutWithId("ms1", si -> {
-                        assertTrue(si.isEnabled());
-                        assertEquals(1, si.getIntents().length);
-
-                        assertEquals("action1", si.getIntent().getAction());
-                        assertEquals("value1", si.getIntent().getStringExtra("key1"));
-                        assertEquals(Intent.FLAG_ACTIVITY_NEW_TASK |
-                                Intent.FLAG_ACTIVITY_CLEAR_TASK |
-                                Intent.FLAG_ACTIVITY_TASK_ON_HOME, si.getIntent().getFlags());
-
-                        assertEquals("action1", si.getIntents()[0].getAction());
-                        assertEquals("value1", si.getIntents()[0].getStringExtra("key1"));
-                        assertEquals(Intent.FLAG_ACTIVITY_NEW_TASK |
-                                Intent.FLAG_ACTIVITY_CLEAR_TASK |
-                                Intent.FLAG_ACTIVITY_TASK_ON_HOME, si.getIntents()[0].getFlags());
-                    })
-                    .forShortcutWithId("ms2", si -> {
-                        assertTrue(si.isEnabled());
-                        assertEquals(2, si.getIntents().length);
-
-                        // getIntent will return the last one.
-                        assertEquals("action2_2", si.getIntent().getAction());
-                        assertEquals("value2", si.getIntent().getStringExtra("key2"));
-                        assertEquals(0, si.getIntent().getFlags());
-
-                        final Intent i1 = si.getIntents()[0];
-                        final Intent i2 = si.getIntents()[1];
-
-                        assertEquals("action2_1", i1.getAction());
-                        assertEquals("value1", i1.getStringExtra("key1"));
-                        assertEquals(Intent.FLAG_ACTIVITY_NEW_TASK |
-                                        Intent.FLAG_ACTIVITY_CLEAR_TASK |
-                                        Intent.FLAG_ACTIVITY_TASK_ON_HOME, i1.getFlags());
-
-                        assertEquals("action2_2", i2.getAction());
-                        assertEquals("value2", i2.getStringExtra("key2"));
-                        assertEquals(0, i2.getFlags());
-                    });
-        });
-
-        // Publish 5 enabled to pin some, so we can later test disabled manfiest shortcuts..
-        addManifestShortcutResource(
-                new ComponentName(CALLING_PACKAGE_1, ShortcutActivity.class.getName()),
-                R.xml.shortcut_5);
-        updatePackageVersion(CALLING_PACKAGE_1, 1);
-                mService.mPackageMonitor.onReceive(getTestContext(),
-                genPackageAddIntent(CALLING_PACKAGE_1, USER_0));
-
-        runWithCaller(CALLING_PACKAGE_1, USER_0, () -> {
-            // Make sure 5 manifest shortcuts are published.
-            assertWith(getCallerShortcuts())
-                    .haveIds("ms1", "ms2", "ms3", "ms4", "ms5")
-                    .areAllManifest()
-                    .areAllNotDynamic()
-                    .areAllNotPinned()
-                    .areAllImmutable()
-                    .areAllEnabled();
-        });
-
-        runWithCaller(LAUNCHER_1, USER_0, () -> {
-            mLauncherApps.pinShortcuts(CALLING_PACKAGE_1,
-                    list("ms3", "ms4", "ms5"), HANDLE_USER_0);
-        });
-
-        // Make sure they're pinned.
-        runWithCaller(CALLING_PACKAGE_1, USER_0, () -> {
-            assertWith(getCallerShortcuts())
-                    .haveIds("ms1", "ms2", "ms3", "ms4", "ms5")
-                    .selectByIds("ms1", "ms2")
-                    .areAllNotPinned()
-                    .areAllEnabled()
-
-                    .revertToOriginalList()
-                    .selectByIds("ms3", "ms4", "ms5")
-                    .areAllPinned()
-                    .areAllEnabled();
-        });
-
-        // Update the app.
-        addManifestShortcutResource(
-                new ComponentName(CALLING_PACKAGE_1, ShortcutActivity.class.getName()),
-                R.xml.shortcut_error_4);
-        updatePackageVersion(CALLING_PACKAGE_1, 1);
-                mService.mPackageMonitor.onReceive(getTestContext(),
-                genPackageAddIntent(CALLING_PACKAGE_1, USER_0));
-
-        // Make sure 3, 4 and 5 still exist but disabled.
-        runWithCaller(CALLING_PACKAGE_1, USER_0, () -> {
-            assertWith(getCallerShortcuts())
-                    .haveIds("ms1", "ms2", "ms3", "ms4", "ms5")
-                    .areAllNotDynamic()
-                    .areAllImmutable()
-
-                    .selectByIds("ms1", "ms2")
-                    .areAllManifest()
-                    .areAllNotPinned()
-                    .areAllEnabled()
-
-                    .revertToOriginalList()
-                    .selectByIds("ms3", "ms4", "ms5")
-                    .areAllNotManifest()
-                    .areAllPinned()
-                    .areAllDisabled()
-
-                    .revertToOriginalList()
-                    .forShortcutWithId("ms1", si -> {
-                        assertEquals(si.getId(), "action1", si.getIntent().getAction());
-                    })
-                    .forShortcutWithId("ms2", si -> {
-                        // getIntent returns the last one.
-                        assertEquals(si.getId(), "action2_2", si.getIntent().getAction());
-                    })
-                    .forShortcutWithId("ms3", si -> {
-                        assertEquals(si.getId(), Intent.ACTION_VIEW, si.getIntent().getAction());
-                    })
-                    .forShortcutWithId("ms4", si -> {
-                        assertEquals(si.getId(), Intent.ACTION_VIEW, si.getIntent().getAction());
-                    })
-                    .forShortcutWithId("ms5", si -> {
-                        assertEquals(si.getId(), "action", si.getIntent().getAction());
-                    });
-        });
-    }
-
-    public void testManifestShortcuts_checkAllFields() {
-        mService.handleUnlockUser(USER_0);
-
-        // Package 1 updated, which has one valid manifest shortcut and one invalid.
-        addManifestShortcutResource(
-                new ComponentName(CALLING_PACKAGE_1, ShortcutActivity.class.getName()),
-                R.xml.shortcut_5);
-        updatePackageVersion(CALLING_PACKAGE_1, 1);
-                mService.mPackageMonitor.onReceive(getTestContext(),
-                genPackageAddIntent(CALLING_PACKAGE_1, USER_0));
-
-        // Only the valid one is published.
-        runWithCaller(CALLING_PACKAGE_1, USER_0, () -> {
-            assertWith(getCallerShortcuts())
-                    .haveIds("ms1", "ms2", "ms3", "ms4", "ms5")
-                    .areAllManifest()
-                    .areAllImmutable()
-                    .areAllEnabled()
-                    .areAllNotPinned()
-                    .areAllNotDynamic()
-
-                    .forShortcutWithId("ms1", si -> {
-                        assertEquals(R.drawable.icon1, si.getIconResourceId());
-                        assertEquals(new ComponentName(CALLING_PACKAGE_1,
-                                ShortcutActivity.class.getName()),
-                                si.getActivity());
-
-                        assertEquals(R.string.shortcut_title1, si.getTitleResId());
-                        assertEquals("r" + R.string.shortcut_title1, si.getTitleResName());
-                        assertEquals(R.string.shortcut_text1, si.getTextResId());
-                        assertEquals("r" + R.string.shortcut_text1, si.getTextResName());
-                        assertEquals(R.string.shortcut_disabled_message1,
-                                si.getDisabledMessageResourceId());
-                        assertEquals("r" + R.string.shortcut_disabled_message1,
-                                si.getDisabledMessageResName());
-
-                        assertEquals(set("android.shortcut.conversation", "android.shortcut.media"),
-                                si.getCategories());
-                        assertEquals("action1", si.getIntent().getAction());
-                        assertEquals(Uri.parse("http://a.b.c/1"), si.getIntent().getData());
-                    })
-
-                    .forShortcutWithId("ms2", si -> {
-                        assertEquals("ms2", si.getId());
-                        assertEquals(R.drawable.icon2, si.getIconResourceId());
-
-                        assertEquals(R.string.shortcut_title2, si.getTitleResId());
-                        assertEquals("r" + R.string.shortcut_title2, si.getTitleResName());
-                        assertEquals(R.string.shortcut_text2, si.getTextResId());
-                        assertEquals("r" + R.string.shortcut_text2, si.getTextResName());
-                        assertEquals(R.string.shortcut_disabled_message2,
-                                si.getDisabledMessageResourceId());
-                        assertEquals("r" + R.string.shortcut_disabled_message2,
-                                si.getDisabledMessageResName());
-
-                        assertEquals(set("android.shortcut.conversation"), si.getCategories());
-                        assertEquals("action2", si.getIntent().getAction());
-                        assertEquals(null, si.getIntent().getData());
-                    })
-
-                    .forShortcutWithId("ms3", si -> {
-                        assertEquals(0, si.getIconResourceId());
-                        assertEquals(R.string.shortcut_title1, si.getTitleResId());
-                        assertEquals("r" + R.string.shortcut_title1, si.getTitleResName());
-
-                        assertEquals(0, si.getTextResId());
-                        assertEquals(null, si.getTextResName());
-                        assertEquals(0, si.getDisabledMessageResourceId());
-                        assertEquals(null, si.getDisabledMessageResName());
-
-                        assertEmpty(si.getCategories());
-                        assertEquals("android.intent.action.VIEW", si.getIntent().getAction());
-                        assertEquals(null, si.getIntent().getData());
-                    })
-
-                    .forShortcutWithId("ms4", si -> {
-                        assertEquals(0, si.getIconResourceId());
-                        assertEquals(R.string.shortcut_title2, si.getTitleResId());
-                        assertEquals("r" + R.string.shortcut_title2, si.getTitleResName());
-
-                        assertEquals(0, si.getTextResId());
-                        assertEquals(null, si.getTextResName());
-                        assertEquals(0, si.getDisabledMessageResourceId());
-                        assertEquals(null, si.getDisabledMessageResName());
-
-                        assertEquals(set("cat"), si.getCategories());
-                        assertEquals("android.intent.action.VIEW2", si.getIntent().getAction());
-                        assertEquals(null, si.getIntent().getData());
-                    })
-
-                    .forShortcutWithId("ms5", si -> {
-                        si = getCallerShortcut("ms5");
-                        assertEquals("action", si.getIntent().getAction());
-                        assertEquals("http://www/", si.getIntent().getData().toString());
-                        assertEquals("foo/bar", si.getIntent().getType());
-                        assertEquals(
-                                new ComponentName("abc", ".xyz"), si.getIntent().getComponent());
-
-                        assertEquals(set("cat1", "cat2"), si.getIntent().getCategories());
-                        assertEquals("value1", si.getIntent().getStringExtra("key1"));
-                        assertEquals("value2", si.getIntent().getStringExtra("key2"));
-                    });
-        });
-    }
-
-    public void testManifestShortcuts_localeChange() throws InterruptedException {
-        mService.handleUnlockUser(USER_0);
-
-        // Package 1 updated, which has one valid manifest shortcut and one invalid.
-        addManifestShortcutResource(
-                new ComponentName(CALLING_PACKAGE_1, ShortcutActivity.class.getName()),
-                R.xml.shortcut_2);
-        updatePackageVersion(CALLING_PACKAGE_1, 1);
-                mService.mPackageMonitor.onReceive(getTestContext(),
-                genPackageAddIntent(CALLING_PACKAGE_1, USER_0));
-
-        runWithCaller(CALLING_PACKAGE_1, USER_0, () -> {
-            mManager.setDynamicShortcuts(list(makeShortcutWithTitle("s1", "title")));
-
-            assertShortcutIds(assertAllManifest(assertAllImmutable(assertAllEnabled(
-                    mManager.getManifestShortcuts()))),
-                    "ms1", "ms2");
-
-            // check first shortcut.
-            ShortcutInfo si = getCallerShortcut("ms1");
-
-            assertEquals("ms1", si.getId());
-            assertEquals("string-com.android.test.1-user:0-res:" + R.string.shortcut_title1 + "/en",
-                    si.getTitle());
-            assertEquals("string-com.android.test.1-user:0-res:" + R.string.shortcut_text1 + "/en",
-                    si.getText());
-            assertEquals("string-com.android.test.1-user:0-res:"
-                            + R.string.shortcut_disabled_message1 + "/en",
-                    si.getDisabledMessage());
-            assertEquals(START_TIME, si.getLastChangedTimestamp());
-
-            // check another
-            si = getCallerShortcut("ms2");
-
-            assertEquals("ms2", si.getId());
-            assertEquals("string-com.android.test.1-user:0-res:" + R.string.shortcut_title2 + "/en",
-                    si.getTitle());
-            assertEquals("string-com.android.test.1-user:0-res:" + R.string.shortcut_text2 + "/en",
-                    si.getText());
-            assertEquals("string-com.android.test.1-user:0-res:"
-                            + R.string.shortcut_disabled_message2 + "/en",
-                    si.getDisabledMessage());
-            assertEquals(START_TIME, si.getLastChangedTimestamp());
-
-            // Check the dynamic one.
-            si = getCallerShortcut("s1");
-
-            assertEquals("s1", si.getId());
-            assertEquals("title", si.getTitle());
-            assertEquals(null, si.getText());
-            assertEquals(null, si.getDisabledMessage());
-            assertEquals(START_TIME, si.getLastChangedTimestamp());
-        });
-
-        mInjectedCurrentTimeMillis++;
-
-        // Change the locale and send the broadcast, make sure the launcher gets a callback too.
-        mInjectedLocale = Locale.JAPANESE;
-
-        setCaller(LAUNCHER_1, USER_0);
-
-        assertForLauncherCallback(mLauncherApps, () -> {
-            mService.mReceiver.onReceive(mServiceContext, new Intent(Intent.ACTION_LOCALE_CHANGED));
-        }).assertCallbackCalledForPackageAndUser(CALLING_PACKAGE_1, HANDLE_USER_0)
-                .haveIds("ms1", "ms2", "s1");
-
-        runWithCaller(CALLING_PACKAGE_1, USER_0, () -> {
-            // check first shortcut.
-            ShortcutInfo si = getCallerShortcut("ms1");
-
-            assertEquals("ms1", si.getId());
-            assertEquals("string-com.android.test.1-user:0-res:" + R.string.shortcut_title1 + "/ja",
-                    si.getTitle());
-            assertEquals("string-com.android.test.1-user:0-res:" + R.string.shortcut_text1 + "/ja",
-                    si.getText());
-            assertEquals("string-com.android.test.1-user:0-res:"
-                            + R.string.shortcut_disabled_message1 + "/ja",
-                    si.getDisabledMessage());
-            assertEquals(START_TIME + 1, si.getLastChangedTimestamp());
-
-            // check another
-            si = getCallerShortcut("ms2");
-
-            assertEquals("ms2", si.getId());
-            assertEquals("string-com.android.test.1-user:0-res:" + R.string.shortcut_title2 + "/ja",
-                    si.getTitle());
-            assertEquals("string-com.android.test.1-user:0-res:" + R.string.shortcut_text2 + "/ja",
-                    si.getText());
-            assertEquals("string-com.android.test.1-user:0-res:"
-                            + R.string.shortcut_disabled_message2 + "/ja",
-                    si.getDisabledMessage());
-            assertEquals(START_TIME + 1, si.getLastChangedTimestamp());
-
-            // Check the dynamic one.  (locale change shouldn't affect.)
-            si = getCallerShortcut("s1");
-
-            assertEquals("s1", si.getId());
-            assertEquals("title", si.getTitle());
-            assertEquals(null, si.getText());
-            assertEquals(null, si.getDisabledMessage());
-            assertEquals(START_TIME, si.getLastChangedTimestamp()); // Not changed.
-        });
-    }
-
-    public void testManifestShortcuts_updateAndDisabled_notPinned() {
-        mService.handleUnlockUser(USER_0);
-
-        // First, just publish a manifest shortcut.
-        addManifestShortcutResource(
-                new ComponentName(CALLING_PACKAGE_1, ShortcutActivity.class.getName()),
-                R.xml.shortcut_1);
-        updatePackageVersion(CALLING_PACKAGE_1, 1);
-                mService.mPackageMonitor.onReceive(getTestContext(),
-                genPackageAddIntent(CALLING_PACKAGE_1, USER_0));
-
-        // Only the valid one is published.
-        runWithCaller(CALLING_PACKAGE_1, USER_0, () -> {
-            assertShortcutIds(assertAllManifest(assertAllImmutable(assertAllEnabled(
-                    mManager.getManifestShortcuts()))),
-                    "ms1");
-            assertEmpty(mManager.getPinnedShortcuts());
-
-            // Make sure there's no other dangling shortcuts.
-            assertShortcutIds(getCallerShortcuts(), "ms1");
-        });
-
-        // Now version up, the manifest shortcut is disabled now.
-        addManifestShortcutResource(
-                new ComponentName(CALLING_PACKAGE_1, ShortcutActivity.class.getName()),
-                R.xml.shortcut_1_disable);
-        updatePackageVersion(CALLING_PACKAGE_1, 1);
-                mService.mPackageMonitor.onReceive(getTestContext(),
-                genPackageAddIntent(CALLING_PACKAGE_1, USER_0));
-
-        // Because shortcut 1 wasn't pinned, it'll just go away.
-        runWithCaller(CALLING_PACKAGE_1, USER_0, () -> {
-            assertEmpty(mManager.getManifestShortcuts());
-            assertEmpty(mManager.getPinnedShortcuts());
-
-            // Make sure there's no other dangling shortcuts.
-            assertEmpty(getCallerShortcuts());
-        });
-    }
-
-    public void testManifestShortcuts_updateAndDisabled_pinned() {
-        mService.handleUnlockUser(USER_0);
-
-        // First, just publish a manifest shortcut.
-        addManifestShortcutResource(
-                new ComponentName(CALLING_PACKAGE_1, ShortcutActivity.class.getName()),
-                R.xml.shortcut_1);
-        updatePackageVersion(CALLING_PACKAGE_1, 1);
-                mService.mPackageMonitor.onReceive(getTestContext(),
-                genPackageAddIntent(CALLING_PACKAGE_1, USER_0));
-
-        // Only the valid one is published.
-        runWithCaller(CALLING_PACKAGE_1, USER_0, () -> {
-            assertShortcutIds(assertAllManifest(assertAllImmutable(assertAllEnabled(
-                    mManager.getManifestShortcuts()))),
-                    "ms1");
-            assertEmpty(mManager.getPinnedShortcuts());
-
-            // Make sure there's no other dangling shortcuts.
-            assertShortcutIds(getCallerShortcuts(), "ms1");
-        });
-
-        runWithCaller(LAUNCHER_1, USER_0, () -> {
-            mLauncherApps.pinShortcuts(CALLING_PACKAGE_1, list("ms1"), HANDLE_USER_0);
-        });
-
-        // Now upgrade, the manifest shortcut is disabled now.
-        addManifestShortcutResource(
-                new ComponentName(CALLING_PACKAGE_1, ShortcutActivity.class.getName()),
-                R.xml.shortcut_1_disable);
-        updatePackageVersion(CALLING_PACKAGE_1, 1);
-                mService.mPackageMonitor.onReceive(getTestContext(),
-                genPackageAddIntent(CALLING_PACKAGE_1, USER_0));
-
-        // Because shortcut 1 was pinned, it'll still exist as pinned, but disabled.
-        runWithCaller(CALLING_PACKAGE_1, USER_0, () -> {
-            assertEmpty(mManager.getManifestShortcuts());
-            assertShortcutIds(assertAllNotManifest(assertAllImmutable(assertAllDisabled(
-                    mManager.getPinnedShortcuts()))),
-                    "ms1");
-
-            // Make sure the fields are updated.
-            ShortcutInfo si = getCallerShortcut("ms1");
-
-            assertEquals("ms1", si.getId());
-            assertEquals(R.drawable.icon2, si.getIconResourceId());
-            assertEquals(R.string.shortcut_title2, si.getTitleResId());
-            assertEquals(R.string.shortcut_text2, si.getTextResId());
-            assertEquals(R.string.shortcut_disabled_message2, si.getDisabledMessageResourceId());
-            assertEquals(Intent.ACTION_VIEW, si.getIntent().getAction());
-
-            // Make sure there's no other dangling shortcuts.
-            assertShortcutIds(getCallerShortcuts(), "ms1");
-        });
-    }
-
-    public void testManifestShortcuts_duplicateInSingleActivity() {
-        mService.handleUnlockUser(USER_0);
-
-        // The XML has two shortcuts with the same ID.
-        addManifestShortcutResource(
-                new ComponentName(CALLING_PACKAGE_1, ShortcutActivity.class.getName()),
-                R.xml.shortcut_2_duplicate);
-        updatePackageVersion(CALLING_PACKAGE_1, 1);
-                mService.mPackageMonitor.onReceive(getTestContext(),
-                genPackageAddIntent(CALLING_PACKAGE_1, USER_0));
-
-        runWithCaller(CALLING_PACKAGE_1, USER_0, () -> {
-            assertShortcutIds(assertAllManifest(assertAllImmutable(assertAllEnabled(
-                    mManager.getManifestShortcuts()))),
-                    "ms1");
-
-            // Make sure the first one has survived.  (the second one has a different title.)
-            ShortcutInfo si = getCallerShortcut("ms1");
-            assertEquals(R.string.shortcut_title1, si.getTitleResId());
-
-            // Make sure there's no other dangling shortcuts.
-            assertShortcutIds(getCallerShortcuts(), "ms1");
-        });
-    }
-
-    public void testManifestShortcuts_duplicateInTwoActivities() {
-        mService.handleUnlockUser(USER_0);
-
-        // ShortcutActivity has shortcut ms1
-        addManifestShortcutResource(
-                new ComponentName(CALLING_PACKAGE_1, ShortcutActivity.class.getName()),
-                R.xml.shortcut_1);
-
-        // ShortcutActivity2 has two shortcuts, ms1 and ms2.
-        addManifestShortcutResource(
-                new ComponentName(CALLING_PACKAGE_1, ShortcutActivity2.class.getName()),
-                R.xml.shortcut_5);
-        updatePackageVersion(CALLING_PACKAGE_1, 1);
-                mService.mPackageMonitor.onReceive(getTestContext(),
-                genPackageAddIntent(CALLING_PACKAGE_1, USER_0));
-
-        runWithCaller(CALLING_PACKAGE_1, USER_0, () -> {
-            assertShortcutIds(assertAllManifest(assertAllImmutable(assertAllEnabled(
-                    mManager.getManifestShortcuts()))),
-                    "ms1", "ms2", "ms3", "ms4", "ms5");
-
-            // ms1 should belong to ShortcutActivity.
-            ShortcutInfo si = getCallerShortcut("ms1");
-            assertEquals(R.string.shortcut_title1, si.getTitleResId());
-            assertEquals(new ComponentName(CALLING_PACKAGE_1, ShortcutActivity.class.getName()),
-                    si.getActivity());
-            assertEquals(0, si.getRank());
-
-            // ms2 should belong to ShortcutActivity*2*.
-            si = getCallerShortcut("ms2");
-            assertEquals(R.string.shortcut_title2, si.getTitleResId());
-            assertEquals(new ComponentName(CALLING_PACKAGE_1, ShortcutActivity2.class.getName()),
-                    si.getActivity());
-
-            // Also check the ranks
-            assertWith(getCallerShortcuts()).selectManifest()
-                    .selectByActivity(
-                            new ComponentName(CALLING_PACKAGE_1, ShortcutActivity.class.getName()))
-                    .haveRanksInOrder("ms1");
-            assertWith(getCallerShortcuts()).selectManifest()
-                    .selectByActivity(
-                            new ComponentName(CALLING_PACKAGE_1, ShortcutActivity2.class.getName()))
-                    .haveRanksInOrder("ms2", "ms3", "ms4", "ms5");
-
-            // Make sure there's no other dangling shortcuts.
-            assertShortcutIds(getCallerShortcuts(), "ms1", "ms2", "ms3", "ms4", "ms5");
-        });
-    }
-
-    /**
-     * Manifest shortcuts cannot override shortcuts that were published via the APIs.
-     */
-    public void testManifestShortcuts_cannotOverrideNonManifest() {
-        mService.handleUnlockUser(USER_0);
-
-        // Create a non-pinned dynamic shortcut and a non-dynamic pinned shortcut.
-
-        runWithCaller(CALLING_PACKAGE_1, USER_0, () -> {
-            mManager.setDynamicShortcuts(list(
-                    makeShortcut("ms1", "title1",
-                            new ComponentName(CALLING_PACKAGE_1, ShortcutActivity.class.getName()),
-                    /* icon */ null, new Intent("action1"), /* rank */ 0),
-                    makeShortcut("ms2", "title2",
-                            new ComponentName(CALLING_PACKAGE_1, ShortcutActivity.class.getName()),
-                    /* icon */ null, new Intent("action1"), /* rank */ 0)));
-        });
-
-        runWithCaller(LAUNCHER_1, USER_0, () -> {
-            mLauncherApps.pinShortcuts(CALLING_PACKAGE_1, list("ms2"), HANDLE_USER_0);
-        });
-
-        runWithCaller(CALLING_PACKAGE_1, USER_0, () -> {
-            mManager.removeDynamicShortcuts(list("ms2"));
-
-            assertShortcutIds(mManager.getDynamicShortcuts(), "ms1");
-            assertShortcutIds(mManager.getPinnedShortcuts(), "ms2");
-            assertEmpty(mManager.getManifestShortcuts());
-        });
-
-        // Then update the app with 5 manifest shortcuts.
-        // Make sure "ms1" and "ms2" won't be replaced.
-        addManifestShortcutResource(
-                new ComponentName(CALLING_PACKAGE_1, ShortcutActivity.class.getName()),
-                R.xml.shortcut_5);
-        updatePackageVersion(CALLING_PACKAGE_1, 1);
-                mService.mPackageMonitor.onReceive(getTestContext(),
-                genPackageAddIntent(CALLING_PACKAGE_1, USER_0));
-
-        runWithCaller(CALLING_PACKAGE_1, USER_0, () -> {
-            assertShortcutIds(assertAllNotManifest(mManager.getDynamicShortcuts()), "ms1");
-            assertShortcutIds(assertAllNotManifest(mManager.getPinnedShortcuts()), "ms2");
-            assertShortcutIds(assertAllManifest(mManager.getManifestShortcuts()),
-                    "ms3", "ms4", "ms5");
-
-            // ms1 and ms2 shouold keep the original title.
-            ShortcutInfo si = getCallerShortcut("ms1");
-            assertEquals("title1", si.getTitle());
-
-            si = getCallerShortcut("ms2");
-            assertEquals("title2", si.getTitle());
-        });
-    }
-
-    protected void checkManifestShortcuts_immutable_verify() {
-        runWithCaller(CALLING_PACKAGE_1, USER_0, () -> {
-            assertShortcutIds(assertAllNotManifest(assertAllEnabled(
-                    mManager.getDynamicShortcuts())),
-                    "s1");
-            assertShortcutIds(assertAllManifest(assertAllEnabled(
-                    mManager.getManifestShortcuts())),
-                    "ms1");
-            assertShortcutIds(assertAllNotManifest(assertAllDisabled(
-                    mManager.getPinnedShortcuts())),
-                    "ms2");
-
-            assertEquals("t1", getCallerShortcut("s1").getTitle());
-
-            // Make sure there are no other shortcuts.
-            assertShortcutIds(getCallerShortcuts(), "s1", "ms1", "ms2");
-        });
-    }
-
-    /**
-     * Make sure the APIs won't work on manifest shortcuts.
-     */
-    public void testManifestShortcuts_immutable() {
-        mService.handleUnlockUser(USER_0);
-
-        // Create a non-pinned manifest shortcut, a pinned shortcut that was originally
-        // a manifest shortcut, as well as a dynamic shortcut.
-
-        addManifestShortcutResource(
-                new ComponentName(CALLING_PACKAGE_1, ShortcutActivity.class.getName()),
-                R.xml.shortcut_2);
-        updatePackageVersion(CALLING_PACKAGE_1, 1);
-                mService.mPackageMonitor.onReceive(getTestContext(),
-                genPackageAddIntent(CALLING_PACKAGE_1, USER_0));
-
-        runWithCaller(LAUNCHER_1, USER_0, () -> {
-            mLauncherApps.pinShortcuts(CALLING_PACKAGE_1, list("ms2"), HANDLE_USER_0);
-        });
-
-        addManifestShortcutResource(
-                new ComponentName(CALLING_PACKAGE_1, ShortcutActivity.class.getName()),
-                R.xml.shortcut_1);
-        updatePackageVersion(CALLING_PACKAGE_1, 1);
-                mService.mPackageMonitor.onReceive(getTestContext(),
-                genPackageAddIntent(CALLING_PACKAGE_1, USER_0));
-
-        runWithCaller(CALLING_PACKAGE_1, USER_0, () -> {
-            mManager.addDynamicShortcuts(list(makeShortcutWithTitle("s1", "t1")));
-        });
-
-        checkManifestShortcuts_immutable_verify();
-
-        // Note that even though the first argument is not immutable and only the second one
-        // is immutable, the first argument should not be executed either.
-
-        runWithCaller(CALLING_PACKAGE_1, USER_0, () -> {
-            assertCannotUpdateImmutable(() -> {
-                mManager.setDynamicShortcuts(list(makeShortcut("xx"), makeShortcut("ms1")));
-            });
-            assertCannotUpdateImmutable(() -> {
-                mManager.setDynamicShortcuts(list(makeShortcut("xx"), makeShortcut("ms2")));
-            });
-        });
-        checkManifestShortcuts_immutable_verify();
-
-        runWithCaller(CALLING_PACKAGE_1, USER_0, () -> {
-            assertCannotUpdateImmutable(() -> {
-                mManager.addDynamicShortcuts(list(makeShortcut("xx"), makeShortcut("ms1")));
-            });
-            assertCannotUpdateImmutable(() -> {
-                mManager.addDynamicShortcuts(list(makeShortcut("xx"), makeShortcut("ms2")));
-            });
-        });
-        checkManifestShortcuts_immutable_verify();
-
-
-        runWithCaller(CALLING_PACKAGE_1, USER_0, () -> {
-            assertCannotUpdateImmutable(() -> {
-                mManager.updateShortcuts(list(makeShortcut("s1"), makeShortcut("ms1")));
-            });
-            assertCannotUpdateImmutable(() -> {
-                mManager.updateShortcuts(list(makeShortcut("s1"), makeShortcut("ms2")));
-            });
-        });
-        checkManifestShortcuts_immutable_verify();
-
-        runWithCaller(CALLING_PACKAGE_1, USER_0, () -> {
-            assertCannotUpdateImmutable(() -> {
-                mManager.removeDynamicShortcuts(list("s1", "ms1"));
-            });
-            assertCannotUpdateImmutable(() -> {
-                mManager.removeDynamicShortcuts(list("s2", "ms2"));
-            });
-        });
-        checkManifestShortcuts_immutable_verify();
-
-        runWithCaller(CALLING_PACKAGE_1, USER_0, () -> {
-            assertCannotUpdateImmutable(() -> {
-                mManager.disableShortcuts(list("s1", "ms1"));
-            });
-        });
-        checkManifestShortcuts_immutable_verify();
-
-        runWithCaller(CALLING_PACKAGE_1, USER_0, () -> {
-            assertCannotUpdateImmutable(() -> {
-                mManager.enableShortcuts(list("s1", "ms2"));
-            });
-        });
-        checkManifestShortcuts_immutable_verify();
-    }
-
-
-    /**
-     * Make sure the APIs won't work on manifest shortcuts.
-     */
-    public void testManifestShortcuts_tooMany() {
-        // Change the max number of shortcuts.
-        mService.updateConfigurationLocked(ConfigConstants.KEY_MAX_SHORTCUTS + "=3");
-
-        mService.handleUnlockUser(USER_0);
-
-        addManifestShortcutResource(
-                new ComponentName(CALLING_PACKAGE_1, ShortcutActivity.class.getName()),
-                R.xml.shortcut_5);
-        updatePackageVersion(CALLING_PACKAGE_1, 1);
-                mService.mPackageMonitor.onReceive(getTestContext(),
-                genPackageAddIntent(CALLING_PACKAGE_1, USER_0));
-
-        runWithCaller(CALLING_PACKAGE_1, USER_0, () -> {
-            // Only the first 3 should be published.
-            assertShortcutIds(mManager.getManifestShortcuts(), "ms1", "ms2", "ms3");
-        });
-    }
-
-    public void testMaxShortcutCount_set() {
-        // Change the max number of shortcuts.
-        mService.updateConfigurationLocked(ConfigConstants.KEY_MAX_SHORTCUTS + "=3");
-
-        runWithCaller(CALLING_PACKAGE_1, USER_0, () -> {
-            final ComponentName a1 = new ComponentName(mClientContext, ShortcutActivity.class);
-            final ComponentName a2 = new ComponentName(mClientContext, ShortcutActivity2.class);
-            final ShortcutInfo s1_1 = makeShortcutWithActivity("s11", a1);
-            final ShortcutInfo s1_2 = makeShortcutWithActivity("s12", a1);
-            final ShortcutInfo s1_3 = makeShortcutWithActivity("s13", a1);
-            final ShortcutInfo s1_4 = makeShortcutWithActivity("s14", a1);
-            final ShortcutInfo s1_5 = makeShortcutWithActivity("s15", a1);
-            final ShortcutInfo s1_6 = makeShortcutWithActivity("s16", a1);
-            final ShortcutInfo s2_1 = makeShortcutWithActivity("s21", a2);
-            final ShortcutInfo s2_2 = makeShortcutWithActivity("s22", a2);
-            final ShortcutInfo s2_3 = makeShortcutWithActivity("s23", a2);
-            final ShortcutInfo s2_4 = makeShortcutWithActivity("s24", a2);
-
-            // 3 shortcuts for 2 activities -> okay
-            mManager.setDynamicShortcuts(list(s1_1, s1_2, s1_3, s2_1, s2_2, s2_3));
-            assertShortcutIds(mManager.getDynamicShortcuts(),
-                    "s11", "s12", "s13", "s21", "s22", "s23");
-
-            mManager.removeAllDynamicShortcuts();
-
-            // 4 shortcut for activity 1 -> too many.
-            assertDynamicShortcutCountExceeded(() -> {
-                mManager.setDynamicShortcuts(list(s1_1, s1_2, s1_3, s1_4, s2_1, s2_2, s2_3));
-            });
-            assertEmpty(mManager.getDynamicShortcuts());
-
-            // 4 shortcut for activity 2 -> too many.
-            assertDynamicShortcutCountExceeded(() -> {
-                mManager.setDynamicShortcuts(list(s1_1, s1_2, s1_3, s2_1, s2_2, s2_3, s2_4));
-            });
-            assertEmpty(mManager.getDynamicShortcuts());
-
-            // First, set 3.  Then set 4, which should be ignored.
-            mManager.setDynamicShortcuts(list(s1_1, s1_2, s1_3));
-            assertShortcutIds(mManager.getDynamicShortcuts(),
-                    "s11", "s12", "s13");
-            assertDynamicShortcutCountExceeded(() -> {
-                mManager.setDynamicShortcuts(list(s2_1, s2_2, s2_3, s2_4));
-            });
-            assertShortcutIds(mManager.getDynamicShortcuts(),
-                    "s11", "s12", "s13");
-
-            // Set will remove the old dynamic set, unlike add, so the following should pass.
-            mManager.setDynamicShortcuts(list(s1_1, s1_2, s1_3));
-            assertShortcutIds(mManager.getDynamicShortcuts(),
-                    "s11", "s12", "s13");
-            mManager.setDynamicShortcuts(list(s1_4, s1_5, s1_6));
-            assertShortcutIds(mManager.getDynamicShortcuts(),
-                    "s14", "s15", "s16");
-
-            // Now, test with 2 manifest shortcuts.
-            mManager.removeAllDynamicShortcuts();
-            addManifestShortcutResource(
-                    new ComponentName(CALLING_PACKAGE_1, ShortcutActivity.class.getName()),
-                    R.xml.shortcut_2);
-            updatePackageVersion(CALLING_PACKAGE_1, 1);
-                    mService.mPackageMonitor.onReceive(getTestContext(),
-                    genPackageAddIntent(CALLING_PACKAGE_1, USER_0));
-            assertEquals(2, mManager.getManifestShortcuts().size());
-
-            // Setting 1 to activity 1 will work.
-            mManager.setDynamicShortcuts(list(s1_1, s2_1, s2_2, s2_3));
-            assertShortcutIds(mManager.getDynamicShortcuts(),
-                    "s11", "s21", "s22", "s23");
-            assertEquals(2, mManager.getManifestShortcuts().size());
-
-            // But setting 2 will not.
-            mManager.removeAllDynamicShortcuts();
-            assertDynamicShortcutCountExceeded(() -> {
-                mManager.setDynamicShortcuts(list(s1_1, s1_2, s2_1, s2_2, s2_3));
-            });
-            assertEmpty(mManager.getDynamicShortcuts());
-            assertEquals(2, mManager.getManifestShortcuts().size());
-        });
-    }
-
-    public void testMaxShortcutCount_add() {
-        // Change the max number of shortcuts.
-        mService.updateConfigurationLocked(ConfigConstants.KEY_MAX_SHORTCUTS + "=3");
-
-        runWithCaller(CALLING_PACKAGE_1, USER_0, () -> {
-            final ComponentName a1 = new ComponentName(mClientContext, ShortcutActivity.class);
-            final ComponentName a2 = new ComponentName(mClientContext, ShortcutActivity2.class);
-            final ShortcutInfo s1_1 = makeShortcutWithActivity("s11", a1);
-            final ShortcutInfo s1_2 = makeShortcutWithActivity("s12", a1);
-            final ShortcutInfo s1_3 = makeShortcutWithActivity("s13", a1);
-            final ShortcutInfo s1_4 = makeShortcutWithActivity("s14", a1);
-            final ShortcutInfo s2_1 = makeShortcutWithActivity("s21", a2);
-            final ShortcutInfo s2_2 = makeShortcutWithActivity("s22", a2);
-            final ShortcutInfo s2_3 = makeShortcutWithActivity("s23", a2);
-            final ShortcutInfo s2_4 = makeShortcutWithActivity("s24", a2);
-
-            // 3 shortcuts for 2 activities -> okay
-            mManager.addDynamicShortcuts(list(s1_1, s1_2, s1_3, s2_1, s2_2, s2_3));
-            assertShortcutIds(mManager.getDynamicShortcuts(),
-                    "s11", "s12", "s13", "s21", "s22", "s23");
-
-            mManager.removeAllDynamicShortcuts();
-
-            // 4 shortcut for activity 1 -> too many.
-            assertDynamicShortcutCountExceeded(() -> {
-                mManager.addDynamicShortcuts(list(s1_1, s1_2, s1_3, s1_4, s2_1, s2_2, s2_3));
-            });
-            assertEmpty(mManager.getDynamicShortcuts());
-
-            // 4 shortcut for activity 2 -> too many.
-            assertDynamicShortcutCountExceeded(() -> {
-                mManager.addDynamicShortcuts(list(s1_1, s1_2, s1_3, s2_1, s2_2, s2_3, s2_4));
-            });
-            assertEmpty(mManager.getDynamicShortcuts());
-
-            // First, set 3.  Then add 1 more, which should be ignored.
-            mManager.setDynamicShortcuts(list(s1_1, s1_2, s1_3));
-            assertShortcutIds(mManager.getDynamicShortcuts(),
-                    "s11", "s12", "s13");
-            assertDynamicShortcutCountExceeded(() -> {
-                mManager.addDynamicShortcuts(list(s1_4, s2_1));
-            });
-            assertShortcutIds(mManager.getDynamicShortcuts(),
-                    "s11", "s12", "s13");
-
-            // Update existing one, which should work.
-            mManager.addDynamicShortcuts(list(makeShortcutWithActivityAndTitle(
-                    "s11", a1, "xxx"), s2_1));
-            assertShortcutIds(mManager.getDynamicShortcuts(),
-                    "s11", "s12", "s13", "s21");
-            assertEquals("xxx", getCallerShortcut("s11").getTitle());
-
-            // Make sure pinned shortcuts won't affect.
-            // - Pin s11 - s13, and remove all dynamic.
-            runWithCaller(LAUNCHER_1, USER_0, () -> {
-                mLauncherApps.pinShortcuts(CALLING_PACKAGE_1, list("s11", "s12", "s13"),
-                        HANDLE_USER_0);
-            });
-            mManager.removeAllDynamicShortcuts();
-
-            assertEmpty(mManager.getDynamicShortcuts());
-            assertShortcutIds(mManager.getPinnedShortcuts(),
-                    "s11", "s12", "s13");
-
-            // Then add dynamic.
-            mManager.addDynamicShortcuts(list(s1_4, s2_1, s2_2, s2_3));
-
-            assertShortcutIds(mManager.getDynamicShortcuts(),
-                    "s14", "s21", "s22", "s23");
-            assertShortcutIds(mManager.getPinnedShortcuts(),
-                    "s11", "s12", "s13");
-
-            // Adding "s11" and "s12" back, should work
-            mManager.addDynamicShortcuts(list(s1_1, s1_2));
-
-            assertShortcutIds(mManager.getDynamicShortcuts(),
-                    "s14", "s11", "s12", "s21", "s22", "s23");
-            assertShortcutIds(mManager.getPinnedShortcuts(),
-                    "s11", "s12", "s13");
-
-            // Adding back s13 doesn't work.
-            assertDynamicShortcutCountExceeded(() -> {
-                mManager.addDynamicShortcuts(list(s1_3));
-            });
-
-            assertShortcutIds(filterByActivity(mManager.getDynamicShortcuts(), a1),
-                    "s11", "s12", "s14");
-            assertShortcutIds(filterByActivity(mManager.getDynamicShortcuts(), a2),
-                    "s21", "s22", "s23");
-
-            // Now swap the activities.
-            mManager.updateShortcuts(list(
-                    makeShortcutWithActivity("s11", a2),
-                    makeShortcutWithActivity("s21", a1)));
-
-            assertShortcutIds(filterByActivity(mManager.getDynamicShortcuts(), a1),
-                    "s21", "s12", "s14");
-            assertShortcutIds(filterByActivity(mManager.getDynamicShortcuts(), a2),
-                    "s11", "s22", "s23");
-
-            // Now, test with 2 manifest shortcuts.
-            mManager.removeAllDynamicShortcuts();
-            addManifestShortcutResource(
-                    new ComponentName(CALLING_PACKAGE_1, ShortcutActivity.class.getName()),
-                    R.xml.shortcut_2);
-            updatePackageVersion(CALLING_PACKAGE_1, 1);
-                    mService.mPackageMonitor.onReceive(getTestContext(),
-                    genPackageAddIntent(CALLING_PACKAGE_1, USER_0));
-
-            assertEquals(2, mManager.getManifestShortcuts().size());
-
-            // Adding one shortcut to activity 1 works fine.
-            mManager.addDynamicShortcuts(list(s1_1, s2_1, s2_2, s2_3));
-            assertShortcutIds(mManager.getDynamicShortcuts(),
-                    "s11", "s21", "s22", "s23");
-            assertEquals(2, mManager.getManifestShortcuts().size());
-
-            // But adding one more doesn't.
-            assertDynamicShortcutCountExceeded(() -> {
-                mManager.addDynamicShortcuts(list(s1_4, s2_1));
-            });
-            assertShortcutIds(mManager.getDynamicShortcuts(),
-                    "s11", "s21", "s22", "s23");
-            assertEquals(2, mManager.getManifestShortcuts().size());
-        });
-    }
-
-    public void testMaxShortcutCount_update() {
-        // Change the max number of shortcuts.
-        mService.updateConfigurationLocked(ConfigConstants.KEY_MAX_SHORTCUTS + "=3");
-
-        runWithCaller(CALLING_PACKAGE_1, USER_0, () -> {
-            final ComponentName a1 = new ComponentName(mClientContext, ShortcutActivity.class);
-            final ComponentName a2 = new ComponentName(mClientContext, ShortcutActivity2.class);
-            final ShortcutInfo s1_1 = makeShortcutWithActivity("s11", a1);
-            final ShortcutInfo s1_2 = makeShortcutWithActivity("s12", a1);
-            final ShortcutInfo s1_3 = makeShortcutWithActivity("s13", a1);
-            final ShortcutInfo s1_4 = makeShortcutWithActivity("s14", a1);
-            final ShortcutInfo s1_5 = makeShortcutWithActivity("s15", a1);
-            final ShortcutInfo s2_1 = makeShortcutWithActivity("s21", a2);
-            final ShortcutInfo s2_2 = makeShortcutWithActivity("s22", a2);
-            final ShortcutInfo s2_3 = makeShortcutWithActivity("s23", a2);
-            final ShortcutInfo s2_4 = makeShortcutWithActivity("s24", a2);
-
-            // 3 shortcuts for 2 activities -> okay
-            mManager.setDynamicShortcuts(list(s1_1, s1_2, s1_3, s2_1, s2_2, s2_3));
-            assertShortcutIds(mManager.getDynamicShortcuts(),
-                    "s11", "s12", "s13", "s21", "s22", "s23");
-
-            // Trying to move s11 from a1 to a2 should fail.
-            assertDynamicShortcutCountExceeded(() -> {
-                mManager.updateShortcuts(list(makeShortcutWithActivity("s11", a2)));
-            });
-            assertShortcutIds(mManager.getDynamicShortcuts(),
-                    "s11", "s12", "s13", "s21", "s22", "s23");
-
-            // Trying to move s21 from a2 to a1 should also fail.
-            assertDynamicShortcutCountExceeded(() -> {
-                mManager.updateShortcuts(list(makeShortcutWithActivity("s21", a1)));
-            });
-            assertShortcutIds(mManager.getDynamicShortcuts(),
-                    "s11", "s12", "s13", "s21", "s22", "s23");
-
-            // But, if we do these two at the same time, it should work.
-            mManager.updateShortcuts(list(
-                    makeShortcutWithActivity("s11", a2),
-                    makeShortcutWithActivity("s21", a1)));
-            assertShortcutIds(mManager.getDynamicShortcuts(),
-                    "s11", "s12", "s13", "s21", "s22", "s23");
-            assertShortcutIds(filterByActivity(mManager.getDynamicShortcuts(), a1),
-                    "s21", "s12", "s13");
-            assertShortcutIds(filterByActivity(mManager.getDynamicShortcuts(), a2),
-                    "s11", "s22", "s23");
-
-            // Then reset.
-            mManager.setDynamicShortcuts(list(s1_1, s1_2, s1_3, s2_1, s2_2, s2_3));
-            assertShortcutIds(mManager.getDynamicShortcuts(),
-                    "s11", "s12", "s13", "s21", "s22", "s23");
-
-            // Pin some to have more shortcuts for a1.
-            runWithCaller(LAUNCHER_1, USER_0, () -> {
-                mLauncherApps.pinShortcuts(CALLING_PACKAGE_1, list("s11", "s12", "s13"),
-                        HANDLE_USER_0);
-            });
-            mManager.setDynamicShortcuts(list(s1_4, s1_5, s2_1, s2_2, s2_3));
-            assertShortcutIds(mManager.getDynamicShortcuts(),
-                    "s14", "s15", "s21", "s22", "s23");
-            assertShortcutIds(mManager.getPinnedShortcuts(),
-                    "s11", "s12", "s13");
-
-            // a1 already has 2 dynamic shortcuts (and 3 pinned shortcuts that used to belong on it)
-            // But that doesn't matter for update -- the following should still work.
-            mManager.updateShortcuts(list(
-                    makeShortcutWithActivityAndTitle("s11", a1, "xxx1"),
-                    makeShortcutWithActivityAndTitle("s12", a1, "xxx2"),
-                    makeShortcutWithActivityAndTitle("s13", a1, "xxx3"),
-                    makeShortcutWithActivityAndTitle("s14", a1, "xxx4"),
-                    makeShortcutWithActivityAndTitle("s15", a1, "xxx5")));
-            // All the shortcuts should still exist they all belong on same activities,
-            // with the updated titles.
-            assertShortcutIds(mManager.getDynamicShortcuts(),
-                    "s14", "s15", "s21", "s22", "s23");
-            assertShortcutIds(mManager.getPinnedShortcuts(),
-                    "s11", "s12", "s13");
-
-            assertShortcutIds(filterByActivity(mManager.getDynamicShortcuts(), a1),
-                    "s14", "s15");
-            assertShortcutIds(filterByActivity(mManager.getDynamicShortcuts(), a2),
-                    "s21", "s22", "s23");
-
-            assertEquals("xxx1", getCallerShortcut("s11").getTitle());
-            assertEquals("xxx2", getCallerShortcut("s12").getTitle());
-            assertEquals("xxx3", getCallerShortcut("s13").getTitle());
-            assertEquals("xxx4", getCallerShortcut("s14").getTitle());
-            assertEquals("xxx5", getCallerShortcut("s15").getTitle());
-        });
-    }
-
-    public void testShortcutsPushedOutByManifest() {
-        // Change the max number of shortcuts.
-        mService.updateConfigurationLocked(ConfigConstants.KEY_MAX_SHORTCUTS + "=3");
-
-        runWithCaller(CALLING_PACKAGE_1, USER_0, () -> {
-            final ComponentName a1 = new ComponentName(mClientContext, ShortcutActivity.class);
-            final ComponentName a2 = new ComponentName(mClientContext, ShortcutActivity2.class);
-            final ShortcutInfo s1_1 = makeShortcutWithActivityAndRank("s11", a1, 4);
-            final ShortcutInfo s1_2 = makeShortcutWithActivityAndRank("s12", a1, 3);
-            final ShortcutInfo s1_3 = makeShortcutWithActivityAndRank("s13", a1, 2);
-            final ShortcutInfo s1_4 = makeShortcutWithActivityAndRank("s14", a1, 1);
-            final ShortcutInfo s1_5 = makeShortcutWithActivityAndRank("s15", a1, 0);
-            final ShortcutInfo s2_1 = makeShortcutWithActivityAndRank("s21", a2, 0);
-            final ShortcutInfo s2_2 = makeShortcutWithActivityAndRank("s22", a2, 1);
-            final ShortcutInfo s2_3 = makeShortcutWithActivityAndRank("s23", a2, 2);
-            final ShortcutInfo s2_4 = makeShortcutWithActivityAndRank("s24", a2, 3);
-            final ShortcutInfo s2_5 = makeShortcutWithActivityAndRank("s25", a2, 4);
-
-            // Initial state.
-            mManager.setDynamicShortcuts(list(s1_1, s1_2, s1_3, s2_1, s2_2, s2_3));
-            runWithCaller(LAUNCHER_1, USER_0, () -> {
-                mLauncherApps.pinShortcuts(CALLING_PACKAGE_1, list("s11", "s12", "s21", "s22"),
-                        HANDLE_USER_0);
-            });
-            mManager.setDynamicShortcuts(list(s1_2, s1_3, s1_4, s2_2, s2_3, s2_4));
-            assertShortcutIds(assertAllEnabled(mManager.getDynamicShortcuts()),
-                    "s12", "s13", "s14",
-                    "s22", "s23", "s24");
-            assertShortcutIds(assertAllEnabled(mManager.getPinnedShortcuts()),
-                    "s11", "s12",
-                    "s21", "s22");
-
-            // Add 1 manifest shortcut to a1.
-            addManifestShortcutResource(
-                    new ComponentName(CALLING_PACKAGE_1, ShortcutActivity.class.getName()),
-                    R.xml.shortcut_1);
-            updatePackageVersion(CALLING_PACKAGE_1, 1);
-                    mService.mPackageMonitor.onReceive(getTestContext(),
-                    genPackageAddIntent(CALLING_PACKAGE_1, USER_0));
-            assertEquals(1, mManager.getManifestShortcuts().size());
-
-            // s12 removed.
-            assertShortcutIds(assertAllEnabled(mManager.getDynamicShortcuts()),
-                    "s13", "s14",
-                    "s22", "s23", "s24");
-            assertShortcutIds(assertAllEnabled(mManager.getPinnedShortcuts()),
-                    "s11", "s12",
-                    "s21", "s22");
-
-            // Add more manifest shortcuts.
-            addManifestShortcutResource(
-                    new ComponentName(CALLING_PACKAGE_1, ShortcutActivity.class.getName()),
-                    R.xml.shortcut_2);
-            addManifestShortcutResource(
-                    new ComponentName(CALLING_PACKAGE_1, ShortcutActivity2.class.getName()),
-                    R.xml.shortcut_1_alt);
-            updatePackageVersion(CALLING_PACKAGE_1, 1);
-                    mService.mPackageMonitor.onReceive(getTestContext(),
-                    genPackageAddIntent(CALLING_PACKAGE_1, USER_0));
-            assertEquals(3, mManager.getManifestShortcuts().size());
-
-            // Note the ones with the highest rank values (== least important) will be removed.
-            assertShortcutIds(assertAllEnabled(mManager.getDynamicShortcuts()),
-                    "s14",
-                    "s22", "s23");
-            assertShortcutIds(assertAllEnabled(mManager.getPinnedShortcuts()),
-                    "s11", "s12",
-                    "s21", "s22");
-
-            // Add more manifest shortcuts.
-            addManifestShortcutResource(
-                    new ComponentName(CALLING_PACKAGE_1, ShortcutActivity.class.getName()),
-                    R.xml.shortcut_2);
-            addManifestShortcutResource(
-                    new ComponentName(CALLING_PACKAGE_1, ShortcutActivity2.class.getName()),
-                    R.xml.shortcut_5_alt); // manifest has 5, but max is 3, so a2 will have 3.
-            updatePackageVersion(CALLING_PACKAGE_1, 1);
-                    mService.mPackageMonitor.onReceive(getTestContext(),
-                    genPackageAddIntent(CALLING_PACKAGE_1, USER_0));
-            assertEquals(5, mManager.getManifestShortcuts().size());
-
-            assertShortcutIds(assertAllEnabled(mManager.getDynamicShortcuts()),
-                    "s14" // a1 has 1 dynamic
-            ); // a2 has no dynamic
-            assertShortcutIds(assertAllEnabled(mManager.getPinnedShortcuts()),
-                    "s11", "s12",
-                    "s21", "s22");
-
-            // Update, no manifest shortucts.  This doesn't affect anything.
-            addManifestShortcutResource(
-                    new ComponentName(CALLING_PACKAGE_1, ShortcutActivity.class.getName()),
-                    R.xml.shortcut_0);
-            addManifestShortcutResource(
-                    new ComponentName(CALLING_PACKAGE_1, ShortcutActivity2.class.getName()),
-                    R.xml.shortcut_0);
-            updatePackageVersion(CALLING_PACKAGE_1, 1);
-                    mService.mPackageMonitor.onReceive(getTestContext(),
-                    genPackageAddIntent(CALLING_PACKAGE_1, USER_0));
-            assertEquals(0, mManager.getManifestShortcuts().size());
-
-            assertShortcutIds(assertAllEnabled(mManager.getDynamicShortcuts()),
-                    "s14");
-            assertShortcutIds(assertAllEnabled(mManager.getPinnedShortcuts()),
-                    "s11", "s12",
-                    "s21", "s22");
-        });
-    }
-}
diff --git a/services/tests/servicestests/src/com/android/server/pm/ShortcutManagerTest2.java b/services/tests/servicestests/src/com/android/server/pm/ShortcutManagerTest2.java
deleted file mode 100644
index d25923c019c..00000000000
--- a/services/tests/servicestests/src/com/android/server/pm/ShortcutManagerTest2.java
+++ /dev/null
@@ -1,2040 +0,0 @@
-/*
- * Copyright (C) 2016 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.android.server.pm;
-
-import static com.android.server.pm.shortcutmanagertest.ShortcutManagerTestUtils.assertBundlesEqual;
-import static com.android.server.pm.shortcutmanagertest.ShortcutManagerTestUtils.assertExpectException;
-import static com.android.server.pm.shortcutmanagertest.ShortcutManagerTestUtils.assertWith;
-import static com.android.server.pm.shortcutmanagertest.ShortcutManagerTestUtils.list;
-import static com.android.server.pm.shortcutmanagertest.ShortcutManagerTestUtils.makeBundle;
-import static com.android.server.pm.shortcutmanagertest.ShortcutManagerTestUtils.parceled;
-import static com.android.server.pm.shortcutmanagertest.ShortcutManagerTestUtils.set;
-
-import static org.mockito.Matchers.anyInt;
-import static org.mockito.Matchers.anyString;
-import static org.mockito.Matchers.eq;
-import static org.mockito.Mockito.reset;
-import static org.mockito.Mockito.times;
-import static org.mockito.Mockito.verify;
-
-import android.Manifest.permission;
-import android.app.ActivityManager;
-import android.content.ComponentName;
-import android.content.Intent;
-import android.content.pm.ShortcutInfo;
-import android.content.res.Resources;
-import android.graphics.BitmapFactory;
-import android.graphics.drawable.Icon;
-import android.net.Uri;
-import android.os.PersistableBundle;
-import android.os.UserHandle;
-import android.test.MoreAsserts;
-import android.test.suitebuilder.annotation.SmallTest;
-
-import com.android.frameworks.servicestests.R;
-import com.android.server.pm.ShortcutService.ConfigConstants;
-
-import java.io.File;
-import java.io.FileWriter;
-import java.io.IOException;
-import java.io.PrintWriter;
-import java.io.StringWriter;
-import java.io.Writer;
-import java.util.Locale;
-
-/**
- * Tests for ShortcutService and ShortcutManager.
- *
- m FrameworksServicesTests &&
- adb install \
- -r -g ${ANDROID_PRODUCT_OUT}/data/app/FrameworksServicesTests/FrameworksServicesTests.apk &&
- adb shell am instrument -e class com.android.server.pm.ShortcutManagerTest2 \
- -w com.android.frameworks.servicestests/android.support.test.runner.AndroidJUnitRunner
- */
-@SmallTest
-public class ShortcutManagerTest2 extends BaseShortcutManagerTest {
-    // ShortcutInfo tests
-
-    public void testShortcutInfoMissingMandatoryFields() {
-        // Disable throttling.
-        mService.updateConfigurationLocked(
-                ShortcutService.ConfigConstants.KEY_MAX_UPDATES_PER_INTERVAL + "=99999999,"
-                + ShortcutService.ConfigConstants.KEY_MAX_SHORTCUTS + "=99999999"
-        );
-
-        assertExpectException(
-                IllegalArgumentException.class,
-                "ID must be provided",
-                () -> new ShortcutInfo.Builder(getTestContext()).build());
-
-        assertExpectException(
-                RuntimeException.class,
-                "id cannot be empty",
-                () -> new ShortcutInfo.Builder(getTestContext(), null));
-
-        assertExpectException(
-                RuntimeException.class,
-                "id cannot be empty",
-                () -> new ShortcutInfo.Builder(getTestContext(), ""));
-
-        assertExpectException(
-                RuntimeException.class,
-                "intents cannot contain null",
-                () -> new ShortcutInfo.Builder(getTestContext(), "id").setIntent(null));
-
-        assertExpectException(
-                RuntimeException.class,
-                "action must be set",
-                () -> new ShortcutInfo.Builder(getTestContext(), "id").setIntent(new Intent()));
-
-        assertExpectException(
-                RuntimeException.class,
-                "action must be set",
-                () -> new ShortcutInfo.Builder(getTestContext(), "id")
-                        .setIntents(new Intent[]{new Intent("action"), new Intent()}));
-
-        assertExpectException(
-                RuntimeException.class,
-                "activity cannot be null",
-                () -> new ShortcutInfo.Builder(getTestContext(), "id").setActivity(null));
-
-        assertExpectException(
-                RuntimeException.class,
-                "shortLabel cannot be empty",
-                () -> new ShortcutInfo.Builder(getTestContext(), "id").setShortLabel(null));
-
-        assertExpectException(
-                RuntimeException.class,
-                "shortLabel cannot be empty",
-                () -> new ShortcutInfo.Builder(getTestContext(), "id").setShortLabel(""));
-
-        assertExpectException(
-                RuntimeException.class,
-                "longLabel cannot be empty",
-                () -> new ShortcutInfo.Builder(getTestContext(), "id").setLongLabel(null));
-
-        assertExpectException(
-                RuntimeException.class,
-                "longLabel cannot be empty",
-                () -> new ShortcutInfo.Builder(getTestContext(), "id").setLongLabel(""));
-
-        assertExpectException(
-                RuntimeException.class,
-                "disabledMessage cannot be empty",
-                () -> new ShortcutInfo.Builder(getTestContext(), "id").setDisabledMessage(null));
-
-        assertExpectException(
-                RuntimeException.class,
-                "disabledMessage cannot be empty",
-                () -> new ShortcutInfo.Builder(getTestContext(), "id").setDisabledMessage(""));
-
-        assertExpectException(NullPointerException.class, "action must be set",
-                () -> new ShortcutInfo.Builder(getTestContext(), "id").setIntent(new Intent()));
-
-        assertExpectException(
-                IllegalArgumentException.class, "Short label must be provided", () -> {
-            ShortcutInfo si = new ShortcutInfo.Builder(getTestContext(), "id")
-                    .setActivity(new ComponentName(getTestContext().getPackageName(), "s"))
-                    .build();
-            assertTrue(getManager().setDynamicShortcuts(list(si)));
-        });
-
-        // same for add.
-        assertExpectException(
-                IllegalArgumentException.class, "Short label must be provided", () -> {
-            ShortcutInfo si = new ShortcutInfo.Builder(getTestContext(), "id")
-                    .setActivity(new ComponentName(getTestContext().getPackageName(), "s"))
-                    .build();
-            assertTrue(getManager().addDynamicShortcuts(list(si)));
-        });
-
-        assertExpectException(NullPointerException.class, "Intent must be provided", () -> {
-            ShortcutInfo si = new ShortcutInfo.Builder(getTestContext(), "id")
-                    .setActivity(new ComponentName(getTestContext().getPackageName(), "s"))
-                    .setShortLabel("x")
-                    .build();
-            assertTrue(getManager().setDynamicShortcuts(list(si)));
-        });
-
-        // same for add.
-        assertExpectException(NullPointerException.class, "Intent must be provided", () -> {
-            ShortcutInfo si = new ShortcutInfo.Builder(getTestContext(), "id")
-                    .setActivity(new ComponentName(getTestContext().getPackageName(), "s"))
-                    .setShortLabel("x")
-                    .build();
-            assertTrue(getManager().addDynamicShortcuts(list(si)));
-        });
-
-        assertExpectException(
-                IllegalStateException.class, "does not belong to package", () -> {
-            ShortcutInfo si = new ShortcutInfo.Builder(getTestContext(), "id")
-                    .setActivity(new ComponentName("xxx", "s"))
-                    .build();
-            assertTrue(getManager().setDynamicShortcuts(list(si)));
-        });
-
-        // same for add.
-        assertExpectException(
-                IllegalStateException.class, "does not belong to package", () -> {
-            ShortcutInfo si = new ShortcutInfo.Builder(getTestContext(), "id")
-                    .setActivity(new ComponentName("xxx", "s"))
-                    .build();
-            assertTrue(getManager().addDynamicShortcuts(list(si)));
-        });
-
-        // Now all activities are not main.
-        mMainActivityChecker = (component, userId) -> false;
-
-        assertExpectException(
-                IllegalStateException.class, "is not main", () -> {
-                    ShortcutInfo si = new ShortcutInfo.Builder(getTestContext(), "id")
-                            .setActivity(new ComponentName(getTestContext(), "s"))
-                            .build();
-                    assertTrue(getManager().setDynamicShortcuts(list(si)));
-                });
-        // For add
-        assertExpectException(
-                IllegalStateException.class, "is not main", () -> {
-                    ShortcutInfo si = new ShortcutInfo.Builder(getTestContext(), "id")
-                            .setActivity(new ComponentName(getTestContext(), "s"))
-                            .build();
-                    assertTrue(getManager().addDynamicShortcuts(list(si)));
-                });
-        // For update
-        assertExpectException(
-                IllegalStateException.class, "is not main", () -> {
-                    ShortcutInfo si = new ShortcutInfo.Builder(getTestContext(), "id")
-                            .setActivity(new ComponentName(getTestContext(), "s"))
-                            .build();
-                    assertTrue(getManager().updateShortcuts(list(si)));
-                });
-    }
-
-    public void testShortcutInfoParcel() {
-        setCaller(CALLING_PACKAGE_1, USER_10);
-        ShortcutInfo si = parceled(new ShortcutInfo.Builder(mClientContext)
-                .setId("id")
-                .setTitle("title")
-                .setIntent(makeIntent("action", ShortcutActivity.class))
-                .build());
-        assertEquals(mClientContext.getPackageName(), si.getPackage());
-        assertEquals(USER_10, si.getUserId());
-        assertEquals(HANDLE_USER_10, si.getUserHandle());
-        assertEquals("id", si.getId());
-        assertEquals("title", si.getTitle());
-        assertEquals("action", si.getIntent().getAction());
-
-        PersistableBundle pb = new PersistableBundle();
-        pb.putInt("k", 1);
-
-        si = new ShortcutInfo.Builder(getTestContext())
-                .setId("id")
-                .setActivity(new ComponentName("a", "b"))
-                .setIcon(Icon.createWithResource(mClientContext, 123))
-                .setTitle("title")
-                .setText("text")
-                .setDisabledMessage("dismes")
-                .setIntent(makeIntent("action", ShortcutActivity.class, "key", "val"))
-                .setCategories(set(ShortcutInfo.SHORTCUT_CATEGORY_CONVERSATION, "xyz"))
-                .setRank(123)
-                .setExtras(pb)
-                .build();
-        si.addFlags(ShortcutInfo.FLAG_PINNED);
-        si.setBitmapPath("abc");
-        si.setIconResourceId(456);
-
-        si = parceled(si);
-
-        assertEquals(getTestContext().getPackageName(), si.getPackage());
-        assertEquals("id", si.getId());
-        assertEquals(new ComponentName("a", "b"), si.getActivity());
-        assertEquals(123, si.getIcon().getResId());
-        assertEquals("title", si.getTitle());
-        assertEquals("text", si.getText());
-        assertEquals("dismes", si.getDisabledMessage());
-        assertEquals(set(ShortcutInfo.SHORTCUT_CATEGORY_CONVERSATION, "xyz"), si.getCategories());
-        assertEquals("action", si.getIntent().getAction());
-        assertEquals("val", si.getIntent().getStringExtra("key"));
-        assertEquals(123, si.getRank());
-        assertEquals(1, si.getExtras().getInt("k"));
-
-        assertEquals(ShortcutInfo.FLAG_PINNED, si.getFlags());
-        assertEquals("abc", si.getBitmapPath());
-        assertEquals(456, si.getIconResourceId());
-
-        assertEquals(0, si.getTitleResId());
-        assertEquals(null, si.getTitleResName());
-        assertEquals(0, si.getTextResId());
-        assertEquals(null, si.getTextResName());
-        assertEquals(0, si.getDisabledMessageResourceId());
-        assertEquals(null, si.getDisabledMessageResName());
-    }
-
-    public void testShortcutInfoParcel_resId() {
-        setCaller(CALLING_PACKAGE_1, USER_10);
-        ShortcutInfo si;
-
-        PersistableBundle pb = new PersistableBundle();
-        pb.putInt("k", 1);
-
-        si = new ShortcutInfo.Builder(getTestContext())
-                .setId("id")
-                .setActivity(new ComponentName("a", "b"))
-                .setIcon(Icon.createWithResource(mClientContext, 123))
-                .setTitleResId(10)
-                .setTextResId(11)
-                .setDisabledMessageResId(12)
-                .setIntent(makeIntent("action", ShortcutActivity.class, "key", "val"))
-                .setCategories(set(ShortcutInfo.SHORTCUT_CATEGORY_CONVERSATION, "xyz"))
-                .setRank(123)
-                .setExtras(pb)
-                .build();
-        si.addFlags(ShortcutInfo.FLAG_PINNED);
-        si.setBitmapPath("abc");
-        si.setIconResourceId(456);
-
-        lookupAndFillInResourceNames(si);
-
-        si = parceled(si);
-
-        assertEquals(getTestContext().getPackageName(), si.getPackage());
-        assertEquals("id", si.getId());
-        assertEquals(new ComponentName("a", "b"), si.getActivity());
-        assertEquals(123, si.getIcon().getResId());
-        assertEquals(10, si.getTitleResId());
-        assertEquals("r10", si.getTitleResName());
-        assertEquals(11, si.getTextResId());
-        assertEquals("r11", si.getTextResName());
-        assertEquals(12, si.getDisabledMessageResourceId());
-        assertEquals("r12", si.getDisabledMessageResName());
-        assertEquals(set(ShortcutInfo.SHORTCUT_CATEGORY_CONVERSATION, "xyz"), si.getCategories());
-        assertEquals("action", si.getIntent().getAction());
-        assertEquals("val", si.getIntent().getStringExtra("key"));
-        assertEquals(123, si.getRank());
-        assertEquals(1, si.getExtras().getInt("k"));
-
-        assertEquals(ShortcutInfo.FLAG_PINNED, si.getFlags());
-        assertEquals("abc", si.getBitmapPath());
-        assertEquals(456, si.getIconResourceId());
-        assertEquals("string/r456", si.getIconResName());
-    }
-
-    public void testShortcutInfoClone() {
-        setCaller(CALLING_PACKAGE_1, USER_11);
-
-        PersistableBundle pb = new PersistableBundle();
-        pb.putInt("k", 1);
-        ShortcutInfo sorig = new ShortcutInfo.Builder(mClientContext)
-                .setId("id")
-                .setActivity(new ComponentName("a", "b"))
-                .setIcon(Icon.createWithResource(mClientContext, 123))
-                .setTitle("title")
-                .setText("text")
-                .setDisabledMessage("dismes")
-                .setCategories(set(ShortcutInfo.SHORTCUT_CATEGORY_CONVERSATION, "xyz"))
-                .setIntent(makeIntent("action", ShortcutActivity.class, "key", "val"))
-                .setRank(123)
-                .setExtras(pb)
-                .build();
-        sorig.addFlags(ShortcutInfo.FLAG_PINNED);
-        sorig.setBitmapPath("abc");
-        sorig.setIconResourceId(456);
-
-        lookupAndFillInResourceNames(sorig);
-
-        ShortcutInfo si = sorig.clone(/* clone flags*/ 0);
-
-        assertEquals(USER_11, si.getUserId());
-        assertEquals(HANDLE_USER_11, si.getUserHandle());
-        assertEquals(mClientContext.getPackageName(), si.getPackage());
-        assertEquals("id", si.getId());
-        assertEquals(new ComponentName("a", "b"), si.getActivity());
-        assertEquals(123, si.getIcon().getResId());
-        assertEquals("title", si.getTitle());
-        assertEquals("text", si.getText());
-        assertEquals("dismes", si.getDisabledMessage());
-        assertEquals(set(ShortcutInfo.SHORTCUT_CATEGORY_CONVERSATION, "xyz"), si.getCategories());
-        assertEquals("action", si.getIntent().getAction());
-        assertEquals("val", si.getIntent().getStringExtra("key"));
-        assertEquals(123, si.getRank());
-        assertEquals(1, si.getExtras().getInt("k"));
-
-        assertEquals(ShortcutInfo.FLAG_PINNED, si.getFlags());
-        assertEquals("abc", si.getBitmapPath());
-        assertEquals(456, si.getIconResourceId());
-        assertEquals("string/r456", si.getIconResName());
-
-        si = sorig.clone(ShortcutInfo.CLONE_REMOVE_FOR_CREATOR);
-
-        assertEquals(mClientContext.getPackageName(), si.getPackage());
-        assertEquals("id", si.getId());
-        assertEquals(new ComponentName("a", "b"), si.getActivity());
-        assertEquals(null, si.getIcon());
-        assertEquals("title", si.getTitle());
-        assertEquals("text", si.getText());
-        assertEquals("dismes", si.getDisabledMessage());
-        assertEquals(set(ShortcutInfo.SHORTCUT_CATEGORY_CONVERSATION, "xyz"), si.getCategories());
-        assertEquals("action", si.getIntent().getAction());
-        assertEquals("val", si.getIntent().getStringExtra("key"));
-        assertEquals(123, si.getRank());
-        assertEquals(1, si.getExtras().getInt("k"));
-
-        assertEquals(ShortcutInfo.FLAG_PINNED, si.getFlags());
-        assertEquals(null, si.getBitmapPath());
-
-        assertEquals(456, si.getIconResourceId());
-        assertEquals(null, si.getIconResName());
-
-        si = sorig.clone(ShortcutInfo.CLONE_REMOVE_FOR_LAUNCHER);
-
-        assertEquals(mClientContext.getPackageName(), si.getPackage());
-        assertEquals("id", si.getId());
-        assertEquals(new ComponentName("a", "b"), si.getActivity());
-        assertEquals(null, si.getIcon());
-        assertEquals("title", si.getTitle());
-        assertEquals("text", si.getText());
-        assertEquals("dismes", si.getDisabledMessage());
-        assertEquals(set(ShortcutInfo.SHORTCUT_CATEGORY_CONVERSATION, "xyz"), si.getCategories());
-        assertEquals(null, si.getIntent());
-        assertEquals(123, si.getRank());
-        assertEquals(1, si.getExtras().getInt("k"));
-
-        assertEquals(ShortcutInfo.FLAG_PINNED, si.getFlags());
-        assertEquals(null, si.getBitmapPath());
-
-        assertEquals(456, si.getIconResourceId());
-        assertEquals(null, si.getIconResName());
-
-        si = sorig.clone(ShortcutInfo.CLONE_REMOVE_NON_KEY_INFO);
-
-        assertEquals(mClientContext.getPackageName(), si.getPackage());
-        assertEquals("id", si.getId());
-        assertEquals(new ComponentName("a", "b"), si.getActivity());
-        assertEquals(null, si.getIcon());
-        assertEquals(null, si.getTitle());
-        assertEquals(null, si.getText());
-        assertEquals(null, si.getDisabledMessage());
-        assertEquals(null, si.getCategories());
-        assertEquals(null, si.getIntent());
-        assertEquals(0, si.getRank());
-        assertEquals(null, si.getExtras());
-
-        assertEquals(ShortcutInfo.FLAG_PINNED | ShortcutInfo.FLAG_KEY_FIELDS_ONLY, si.getFlags());
-        assertEquals(null, si.getBitmapPath());
-
-        assertEquals(456, si.getIconResourceId());
-        assertEquals(null, si.getIconResName());
-    }
-
-    public void testShortcutInfoClone_resId() {
-        setCaller(CALLING_PACKAGE_1, USER_11);
-
-        PersistableBundle pb = new PersistableBundle();
-        pb.putInt("k", 1);
-        ShortcutInfo sorig = new ShortcutInfo.Builder(mClientContext)
-                .setId("id")
-                .setActivity(new ComponentName("a", "b"))
-                .setIcon(Icon.createWithResource(mClientContext, 123))
-                .setTitleResId(10)
-                .setTextResId(11)
-                .setDisabledMessageResId(12)
-                .setCategories(set(ShortcutInfo.SHORTCUT_CATEGORY_CONVERSATION, "xyz"))
-                .setIntent(makeIntent("action", ShortcutActivity.class, "key", "val"))
-                .setRank(123)
-                .setExtras(pb)
-                .build();
-        sorig.addFlags(ShortcutInfo.FLAG_PINNED);
-        sorig.setBitmapPath("abc");
-        sorig.setIconResourceId(456);
-
-        lookupAndFillInResourceNames(sorig);
-
-        ShortcutInfo si = sorig.clone(/* clone flags*/ 0);
-
-        assertEquals(USER_11, si.getUserId());
-        assertEquals(HANDLE_USER_11, si.getUserHandle());
-        assertEquals(mClientContext.getPackageName(), si.getPackage());
-        assertEquals("id", si.getId());
-        assertEquals(new ComponentName("a", "b"), si.getActivity());
-        assertEquals(123, si.getIcon().getResId());
-        assertEquals(10, si.getTitleResId());
-        assertEquals("r10", si.getTitleResName());
-        assertEquals(11, si.getTextResId());
-        assertEquals("r11", si.getTextResName());
-        assertEquals(12, si.getDisabledMessageResourceId());
-        assertEquals("r12", si.getDisabledMessageResName());
-        assertEquals(set(ShortcutInfo.SHORTCUT_CATEGORY_CONVERSATION, "xyz"), si.getCategories());
-        assertEquals("action", si.getIntent().getAction());
-        assertEquals("val", si.getIntent().getStringExtra("key"));
-        assertEquals(123, si.getRank());
-        assertEquals(1, si.getExtras().getInt("k"));
-
-        assertEquals(ShortcutInfo.FLAG_PINNED, si.getFlags());
-        assertEquals("abc", si.getBitmapPath());
-        assertEquals(456, si.getIconResourceId());
-        assertEquals("string/r456", si.getIconResName());
-
-        si = sorig.clone(ShortcutInfo.CLONE_REMOVE_FOR_CREATOR);
-
-        assertEquals(mClientContext.getPackageName(), si.getPackage());
-        assertEquals("id", si.getId());
-        assertEquals(new ComponentName("a", "b"), si.getActivity());
-        assertEquals(null, si.getIcon());
-        assertEquals(10, si.getTitleResId());
-        assertEquals(null, si.getTitleResName());
-        assertEquals(11, si.getTextResId());
-        assertEquals(null, si.getTextResName());
-        assertEquals(12, si.getDisabledMessageResourceId());
-        assertEquals(null, si.getDisabledMessageResName());
-        assertEquals(set(ShortcutInfo.SHORTCUT_CATEGORY_CONVERSATION, "xyz"), si.getCategories());
-        assertEquals("action", si.getIntent().getAction());
-        assertEquals("val", si.getIntent().getStringExtra("key"));
-        assertEquals(123, si.getRank());
-        assertEquals(1, si.getExtras().getInt("k"));
-
-        assertEquals(ShortcutInfo.FLAG_PINNED, si.getFlags());
-        assertEquals(null, si.getBitmapPath());
-
-        assertEquals(456, si.getIconResourceId());
-        assertEquals(null, si.getIconResName());
-
-        si = sorig.clone(ShortcutInfo.CLONE_REMOVE_FOR_LAUNCHER);
-
-        assertEquals(mClientContext.getPackageName(), si.getPackage());
-        assertEquals("id", si.getId());
-        assertEquals(new ComponentName("a", "b"), si.getActivity());
-        assertEquals(null, si.getIcon());
-        assertEquals(10, si.getTitleResId());
-        assertEquals(null, si.getTitleResName());
-        assertEquals(11, si.getTextResId());
-        assertEquals(null, si.getTextResName());
-        assertEquals(12, si.getDisabledMessageResourceId());
-        assertEquals(null, si.getDisabledMessageResName());
-        assertEquals(set(ShortcutInfo.SHORTCUT_CATEGORY_CONVERSATION, "xyz"), si.getCategories());
-        assertEquals(null, si.getIntent());
-        assertEquals(123, si.getRank());
-        assertEquals(1, si.getExtras().getInt("k"));
-
-        assertEquals(ShortcutInfo.FLAG_PINNED, si.getFlags());
-        assertEquals(null, si.getBitmapPath());
-
-        assertEquals(456, si.getIconResourceId());
-        assertEquals(null, si.getIconResName());
-
-        si = sorig.clone(ShortcutInfo.CLONE_REMOVE_NON_KEY_INFO);
-
-        assertEquals(mClientContext.getPackageName(), si.getPackage());
-        assertEquals("id", si.getId());
-        assertEquals(new ComponentName("a", "b"), si.getActivity());
-        assertEquals(null, si.getIcon());
-        assertEquals(0, si.getTitleResId());
-        assertEquals(null, si.getTitleResName());
-        assertEquals(0, si.getTextResId());
-        assertEquals(null, si.getTextResName());
-        assertEquals(0, si.getDisabledMessageResourceId());
-        assertEquals(null, si.getDisabledMessageResName());
-        assertEquals(null, si.getCategories());
-        assertEquals(null, si.getIntent());
-        assertEquals(0, si.getRank());
-        assertEquals(null, si.getExtras());
-
-        assertEquals(ShortcutInfo.FLAG_PINNED | ShortcutInfo.FLAG_KEY_FIELDS_ONLY, si.getFlags());
-        assertEquals(null, si.getBitmapPath());
-
-        assertEquals(456, si.getIconResourceId());
-        assertEquals(null, si.getIconResName());
-    }
-
-    public void testShortcutInfoClone_minimum() {
-        PersistableBundle pb = new PersistableBundle();
-        pb.putInt("k", 1);
-        ShortcutInfo sorig = new ShortcutInfo.Builder(getTestContext())
-                .setId("id")
-                .setTitle("title")
-                .setIntent(makeIntent("action", ShortcutActivity.class))
-                .build();
-        ShortcutInfo si = sorig.clone(/* clone flags*/ 0);
-
-        assertEquals(getTestContext().getPackageName(), si.getPackage());
-        assertEquals("id", si.getId());
-        assertEquals("title", si.getTitle());
-        assertEquals("action", si.getIntent().getAction());
-        assertEquals(null, si.getCategories());
-
-        si = sorig.clone(ShortcutInfo.CLONE_REMOVE_FOR_CREATOR);
-
-        assertEquals(getTestContext().getPackageName(), si.getPackage());
-        assertEquals("id", si.getId());
-        assertEquals("title", si.getTitle());
-        assertEquals("action", si.getIntent().getAction());
-        assertEquals(null, si.getCategories());
-
-        si = sorig.clone(ShortcutInfo.CLONE_REMOVE_FOR_LAUNCHER);
-
-        assertEquals(getTestContext().getPackageName(), si.getPackage());
-        assertEquals("id", si.getId());
-        assertEquals("title", si.getTitle());
-        assertEquals(null, si.getIntent());
-        assertEquals(null, si.getCategories());
-
-        si = sorig.clone(ShortcutInfo.CLONE_REMOVE_NON_KEY_INFO);
-
-        assertEquals(getTestContext().getPackageName(), si.getPackage());
-        assertEquals("id", si.getId());
-        assertEquals(null, si.getTitle());
-        assertEquals(null, si.getIntent());
-        assertEquals(null, si.getCategories());
-    }
-
-    public void testShortcutInfoCopyNonNullFieldsFrom() throws InterruptedException {
-        PersistableBundle pb = new PersistableBundle();
-        pb.putInt("k", 1);
-        ShortcutInfo sorig = new ShortcutInfo.Builder(getTestContext())
-                .setId("id")
-                .setActivity(new ComponentName("a", "b"))
-                .setIcon(Icon.createWithResource(mClientContext, 123))
-                .setTitle("title")
-                .setText("text")
-                .setDisabledMessage("dismes")
-                .setCategories(set(ShortcutInfo.SHORTCUT_CATEGORY_CONVERSATION, "xyz"))
-                .setIntent(makeIntent("action", ShortcutActivity.class, "key", "val"))
-                .setRank(123)
-                .setExtras(pb)
-                .build();
-        sorig.addFlags(ShortcutInfo.FLAG_PINNED);
-        sorig.setBitmapPath("abc");
-        sorig.setIconResourceId(456);
-
-        lookupAndFillInResourceNames(sorig);
-
-        ShortcutInfo si;
-
-        si = sorig.clone(/* flags=*/ 0);
-        si.copyNonNullFieldsFrom(new ShortcutInfo.Builder(getTestContext()).setId("id")
-                .setActivity(new ComponentName("x", "y")).build());
-        assertEquals("text", si.getText());
-        assertEquals(123, si.getRank());
-        assertEquals(new ComponentName("x", "y"), si.getActivity());
-
-        si = sorig.clone(/* flags=*/ 0);
-        si.copyNonNullFieldsFrom(new ShortcutInfo.Builder(getTestContext()).setId("id")
-                .setIcon(Icon.createWithResource(mClientContext, 456)).build());
-        assertEquals("text", si.getText());
-        assertEquals(456, si.getIcon().getResId());
-        assertEquals(0, si.getIconResourceId());
-        assertEquals(null, si.getIconResName());
-        assertEquals(null, si.getBitmapPath());
-
-        si = sorig.clone(/* flags=*/ 0);
-        si.copyNonNullFieldsFrom(new ShortcutInfo.Builder(getTestContext()).setId("id")
-                .setTitle("xyz").build());
-        assertEquals("text", si.getText());
-        assertEquals("xyz", si.getTitle());
-        assertEquals(0, si.getTitleResId());
-
-        si = sorig.clone(/* flags=*/ 0);
-        si.copyNonNullFieldsFrom(new ShortcutInfo.Builder(getTestContext()).setId("id")
-                .setTitleResId(123).build());
-        assertEquals("text", si.getText());
-        assertEquals(null, si.getTitle());
-        assertEquals(123, si.getTitleResId());
-
-        si = sorig.clone(/* flags=*/ 0);
-        si.copyNonNullFieldsFrom(new ShortcutInfo.Builder(getTestContext()).setId("id")
-                .setText("xxx").build());
-        assertEquals(123, si.getRank());
-        assertEquals("xxx", si.getText());
-        assertEquals(0, si.getTextResId());
-
-        si = sorig.clone(/* flags=*/ 0);
-        si.copyNonNullFieldsFrom(new ShortcutInfo.Builder(getTestContext()).setId("id")
-                .setTextResId(1111).build());
-        assertEquals(123, si.getRank());
-        assertEquals(null, si.getText());
-        assertEquals(1111, si.getTextResId());
-
-        si = sorig.clone(/* flags=*/ 0);
-        si.copyNonNullFieldsFrom(new ShortcutInfo.Builder(getTestContext()).setId("id")
-                .setDisabledMessage("xxx").build());
-        assertEquals(123, si.getRank());
-        assertEquals("xxx", si.getDisabledMessage());
-        assertEquals(0, si.getDisabledMessageResourceId());
-
-        si = sorig.clone(/* flags=*/ 0);
-        si.copyNonNullFieldsFrom(new ShortcutInfo.Builder(getTestContext()).setId("id")
-                .setDisabledMessageResId(11111).build());
-        assertEquals(123, si.getRank());
-        assertEquals(null, si.getDisabledMessage());
-        assertEquals(11111, si.getDisabledMessageResourceId());
-
-        si = sorig.clone(/* flags=*/ 0);
-        si.copyNonNullFieldsFrom(new ShortcutInfo.Builder(getTestContext()).setId("id")
-                .setCategories(set()).build());
-        assertEquals("text", si.getText());
-        assertEquals(set(), si.getCategories());
-
-        si = sorig.clone(/* flags=*/ 0);
-        si.copyNonNullFieldsFrom(new ShortcutInfo.Builder(getTestContext()).setId("id")
-                .setCategories(set("x")).build());
-        assertEquals("text", si.getText());
-        assertEquals(set("x"), si.getCategories());
-
-        si = sorig.clone(/* flags=*/ 0);
-        si.copyNonNullFieldsFrom(new ShortcutInfo.Builder(getTestContext()).setId("id")
-                .setIntent(makeIntent("action2", ShortcutActivity.class)).build());
-        assertEquals("text", si.getText());
-        assertEquals("action2", si.getIntent().getAction());
-        assertEquals(null, si.getIntent().getStringExtra("key"));
-
-        si = sorig.clone(/* flags=*/ 0);
-        si.copyNonNullFieldsFrom(new ShortcutInfo.Builder(getTestContext()).setId("id")
-                .setIntent(makeIntent("action3", ShortcutActivity.class, "key", "x")).build());
-        assertEquals("text", si.getText());
-        assertEquals("action3", si.getIntent().getAction());
-        assertEquals("x", si.getIntent().getStringExtra("key"));
-
-        si = sorig.clone(/* flags=*/ 0);
-        si.copyNonNullFieldsFrom(new ShortcutInfo.Builder(getTestContext()).setId("id")
-                .setRank(999).build());
-        assertEquals("text", si.getText());
-        assertEquals(999, si.getRank());
-
-
-        PersistableBundle pb2 = new PersistableBundle();
-        pb2.putInt("x", 99);
-
-        si = sorig.clone(/* flags=*/ 0);
-        si.copyNonNullFieldsFrom(new ShortcutInfo.Builder(getTestContext()).setId("id")
-                .setExtras(pb2).build());
-        assertEquals("text", si.getText());
-        assertEquals(99, si.getExtras().getInt("x"));
-    }
-
-    public void testShortcutInfoCopyNonNullFieldsFrom_resId() throws InterruptedException {
-        PersistableBundle pb = new PersistableBundle();
-        pb.putInt("k", 1);
-        ShortcutInfo sorig = new ShortcutInfo.Builder(getTestContext())
-                .setId("id")
-                .setActivity(new ComponentName("a", "b"))
-                .setIcon(Icon.createWithResource(mClientContext, 123))
-                .setTitleResId(10)
-                .setTextResId(11)
-                .setDisabledMessageResId(12)
-                .setCategories(set(ShortcutInfo.SHORTCUT_CATEGORY_CONVERSATION, "xyz"))
-                .setIntent(makeIntent("action", ShortcutActivity.class, "key", "val"))
-                .setRank(123)
-                .setExtras(pb)
-                .build();
-        sorig.addFlags(ShortcutInfo.FLAG_PINNED);
-        sorig.setBitmapPath("abc");
-        sorig.setIconResourceId(456);
-
-        ShortcutInfo si;
-
-        si = sorig.clone(/* flags=*/ 0);
-        si.copyNonNullFieldsFrom(new ShortcutInfo.Builder(getTestContext()).setId("id")
-                .setActivity(new ComponentName("x", "y")).build());
-        assertEquals(11, si.getTextResId());
-        assertEquals(new ComponentName("x", "y"), si.getActivity());
-
-        si = sorig.clone(/* flags=*/ 0);
-        si.copyNonNullFieldsFrom(new ShortcutInfo.Builder(getTestContext()).setId("id")
-                .setIcon(Icon.createWithResource(mClientContext, 456)).build());
-        assertEquals(11, si.getTextResId());
-        assertEquals(456, si.getIcon().getResId());
-        assertEquals(0, si.getIconResourceId());
-        assertEquals(null, si.getIconResName());
-        assertEquals(null, si.getBitmapPath());
-
-        si = sorig.clone(/* flags=*/ 0);
-        si.copyNonNullFieldsFrom(new ShortcutInfo.Builder(getTestContext()).setId("id")
-                .setTitle("xyz").build());
-        assertEquals(11, si.getTextResId());
-        assertEquals("xyz", si.getTitle());
-        assertEquals(0, si.getTitleResId());
-        assertEquals(null, si.getTitleResName());
-
-        si = sorig.clone(/* flags=*/ 0);
-        si.copyNonNullFieldsFrom(new ShortcutInfo.Builder(getTestContext()).setId("id")
-                .setTitleResId(123).build());
-        assertEquals(11, si.getTextResId());
-        assertEquals(null, si.getTitle());
-        assertEquals(123, si.getTitleResId());
-        assertEquals(null, si.getTitleResName());
-
-        si = sorig.clone(/* flags=*/ 0);
-        si.copyNonNullFieldsFrom(new ShortcutInfo.Builder(getTestContext()).setId("id")
-                .setText("xxx").build());
-        assertEquals(123, si.getRank());
-        assertEquals("xxx", si.getText());
-        assertEquals(0, si.getTextResId());
-        assertEquals(null, si.getTextResName());
-
-        si = sorig.clone(/* flags=*/ 0);
-        si.copyNonNullFieldsFrom(new ShortcutInfo.Builder(getTestContext()).setId("id")
-                .setTextResId(1111).build());
-        assertEquals(123, si.getRank());
-        assertEquals(null, si.getText());
-        assertEquals(1111, si.getTextResId());
-        assertEquals(null, si.getTextResName());
-
-        si = sorig.clone(/* flags=*/ 0);
-        si.copyNonNullFieldsFrom(new ShortcutInfo.Builder(getTestContext()).setId("id")
-                .setDisabledMessage("xxx").build());
-        assertEquals(123, si.getRank());
-        assertEquals("xxx", si.getDisabledMessage());
-        assertEquals(0, si.getDisabledMessageResourceId());
-        assertEquals(null, si.getDisabledMessageResName());
-
-        si = sorig.clone(/* flags=*/ 0);
-        si.copyNonNullFieldsFrom(new ShortcutInfo.Builder(getTestContext()).setId("id")
-                .setDisabledMessageResId(11111).build());
-        assertEquals(123, si.getRank());
-        assertEquals(null, si.getDisabledMessage());
-        assertEquals(11111, si.getDisabledMessageResourceId());
-        assertEquals(null, si.getDisabledMessageResName());
-
-        si = sorig.clone(/* flags=*/ 0);
-        si.copyNonNullFieldsFrom(new ShortcutInfo.Builder(getTestContext()).setId("id")
-                .setCategories(set()).build());
-        assertEquals(11, si.getTextResId());
-        assertEquals(set(), si.getCategories());
-
-        si = sorig.clone(/* flags=*/ 0);
-        si.copyNonNullFieldsFrom(new ShortcutInfo.Builder(getTestContext()).setId("id")
-                .setCategories(set("x")).build());
-        assertEquals(11, si.getTextResId());
-        assertEquals(set("x"), si.getCategories());
-
-        si = sorig.clone(/* flags=*/ 0);
-        si.copyNonNullFieldsFrom(new ShortcutInfo.Builder(getTestContext()).setId("id")
-                .setIntent(makeIntent("action2", ShortcutActivity.class)).build());
-        assertEquals(11, si.getTextResId());
-        assertEquals("action2", si.getIntent().getAction());
-        assertEquals(null, si.getIntent().getStringExtra("key"));
-
-        si = sorig.clone(/* flags=*/ 0);
-        si.copyNonNullFieldsFrom(new ShortcutInfo.Builder(getTestContext()).setId("id")
-                .setIntent(makeIntent("action3", ShortcutActivity.class, "key", "x")).build());
-        assertEquals(11, si.getTextResId());
-        assertEquals("action3", si.getIntent().getAction());
-        assertEquals("x", si.getIntent().getStringExtra("key"));
-
-        si = sorig.clone(/* flags=*/ 0);
-        si.copyNonNullFieldsFrom(new ShortcutInfo.Builder(getTestContext()).setId("id")
-                .setRank(999).build());
-        assertEquals(11, si.getTextResId());
-        assertEquals(999, si.getRank());
-
-
-        PersistableBundle pb2 = new PersistableBundle();
-        pb2.putInt("x", 99);
-
-        si = sorig.clone(/* flags=*/ 0);
-        si.copyNonNullFieldsFrom(new ShortcutInfo.Builder(getTestContext()).setId("id")
-                .setExtras(pb2).build());
-        assertEquals(11, si.getTextResId());
-        assertEquals(99, si.getExtras().getInt("x"));
-    }
-
-    public void testShortcutInfoSaveAndLoad() throws InterruptedException {
-        mRunningUsers.put(USER_10, true);
-
-        setCaller(CALLING_PACKAGE_1, USER_10);
-
-        final Icon bmp32x32 = Icon.createWithBitmap(BitmapFactory.decodeResource(
-                getTestContext().getResources(), R.drawable.black_32x32));
-
-        PersistableBundle pb = new PersistableBundle();
-        pb.putInt("k", 1);
-        ShortcutInfo sorig = new ShortcutInfo.Builder(mClientContext)
-                .setId("id")
-                .setActivity(new ComponentName(mClientContext, ShortcutActivity2.class))
-                .setIcon(bmp32x32)
-                .setTitle("title")
-                .setText("text")
-                .setDisabledMessage("dismes")
-                .setCategories(set(ShortcutInfo.SHORTCUT_CATEGORY_CONVERSATION, "xyz"))
-                .setIntent(makeIntent("action", ShortcutActivity.class, "key", "val"))
-                .setRank(123)
-                .setExtras(pb)
-                .build();
-        sorig.setTimestamp(mInjectedCurrentTimeMillis);
-
-        ShortcutInfo sorig2 = new ShortcutInfo.Builder(mClientContext)
-                .setId("id2")
-                .setTitle("x")
-                .setActivity(new ComponentName(mClientContext, ShortcutActivity2.class))
-                .setIntent(makeIntent("action", ShortcutActivity.class, "key", "val"))
-                .setRank(456)
-                .build();
-        sorig2.setTimestamp(mInjectedCurrentTimeMillis);
-
-        mManager.addDynamicShortcuts(list(sorig, sorig2));
-
-        mInjectedCurrentTimeMillis += 1;
-        final long now = mInjectedCurrentTimeMillis;
-        mInjectedCurrentTimeMillis += 1;
-
-        dumpsysOnLogcat("before save");
-
-        // Save and load.
-        mService.saveDirtyInfo();
-        initService();
-        mService.handleUnlockUser(USER_10);
-
-        dumpUserFile(USER_10);
-        dumpsysOnLogcat("after load");
-
-        ShortcutInfo si;
-        si = mService.getPackageShortcutForTest(CALLING_PACKAGE_1, "id", USER_10);
-
-        assertEquals(USER_10, si.getUserId());
-        assertEquals(HANDLE_USER_10, si.getUserHandle());
-        assertEquals(CALLING_PACKAGE_1, si.getPackage());
-        assertEquals("id", si.getId());
-        assertEquals(ShortcutActivity2.class.getName(), si.getActivity().getClassName());
-        assertEquals(null, si.getIcon());
-        assertEquals("title", si.getTitle());
-        assertEquals("text", si.getText());
-        assertEquals("dismes", si.getDisabledMessage());
-        assertEquals(set(ShortcutInfo.SHORTCUT_CATEGORY_CONVERSATION, "xyz"), si.getCategories());
-        assertEquals("action", si.getIntent().getAction());
-        assertEquals("val", si.getIntent().getStringExtra("key"));
-        assertEquals(0, si.getRank());
-        assertEquals(1, si.getExtras().getInt("k"));
-
-        assertEquals(ShortcutInfo.FLAG_DYNAMIC | ShortcutInfo.FLAG_HAS_ICON_FILE
-                | ShortcutInfo.FLAG_STRINGS_RESOLVED, si.getFlags());
-        assertNotNull(si.getBitmapPath()); // Something should be set.
-        assertEquals(0, si.getIconResourceId());
-        assertTrue(si.getLastChangedTimestamp() < now);
-
-        // Make sure ranks are saved too.  Because of the auto-adjusting, we need two shortcuts
-        // to test it.
-        si = mService.getPackageShortcutForTest(CALLING_PACKAGE_1, "id2", USER_10);
-        assertEquals(1, si.getRank());
-
-        dumpUserFile(USER_10);
-    }
-
-    public void testShortcutInfoSaveAndLoad_resId() throws InterruptedException {
-        mRunningUsers.put(USER_10, true);
-
-        setCaller(CALLING_PACKAGE_1, USER_10);
-
-        final Icon res32x32 = Icon.createWithResource(mClientContext, R.drawable.black_32x32);
-
-        PersistableBundle pb = new PersistableBundle();
-        pb.putInt("k", 1);
-        ShortcutInfo sorig = new ShortcutInfo.Builder(mClientContext)
-                .setId("id")
-                .setActivity(new ComponentName(mClientContext, ShortcutActivity2.class))
-                .setIcon(res32x32)
-                .setTitleResId(10)
-                .setTextResId(11)
-                .setDisabledMessageResId(12)
-                .setCategories(set(ShortcutInfo.SHORTCUT_CATEGORY_CONVERSATION, "xyz"))
-                .setIntent(makeIntent("action", ShortcutActivity.class, "key", "val"))
-                .setRank(123)
-                .setExtras(pb)
-                .build();
-        sorig.setTimestamp(mInjectedCurrentTimeMillis);
-
-        ShortcutInfo sorig2 = new ShortcutInfo.Builder(mClientContext)
-                .setId("id2")
-                .setTitle("x")
-                .setActivity(new ComponentName(mClientContext, ShortcutActivity2.class))
-                .setIntent(makeIntent("action", ShortcutActivity.class, "key", "val"))
-                .setRank(456)
-                .build();
-        sorig2.setTimestamp(mInjectedCurrentTimeMillis);
-
-        mManager.addDynamicShortcuts(list(sorig, sorig2));
-
-        mInjectedCurrentTimeMillis += 1;
-        final long now = mInjectedCurrentTimeMillis;
-        mInjectedCurrentTimeMillis += 1;
-
-        // Save and load.
-        mService.saveDirtyInfo();
-        initService();
-        mService.handleUnlockUser(USER_10);
-
-        ShortcutInfo si;
-        si = mService.getPackageShortcutForTest(CALLING_PACKAGE_1, "id", USER_10);
-
-        assertEquals(USER_10, si.getUserId());
-        assertEquals(HANDLE_USER_10, si.getUserHandle());
-        assertEquals(CALLING_PACKAGE_1, si.getPackage());
-        assertEquals("id", si.getId());
-        assertEquals(ShortcutActivity2.class.getName(), si.getActivity().getClassName());
-        assertEquals(null, si.getIcon());
-        assertEquals(10, si.getTitleResId());
-        assertEquals("r10", si.getTitleResName());
-        assertEquals(11, si.getTextResId());
-        assertEquals("r11", si.getTextResName());
-        assertEquals(12, si.getDisabledMessageResourceId());
-        assertEquals("r12", si.getDisabledMessageResName());
-        assertEquals(set(ShortcutInfo.SHORTCUT_CATEGORY_CONVERSATION, "xyz"), si.getCategories());
-        assertEquals("action", si.getIntent().getAction());
-        assertEquals("val", si.getIntent().getStringExtra("key"));
-        assertEquals(0, si.getRank());
-        assertEquals(1, si.getExtras().getInt("k"));
-
-        assertEquals(ShortcutInfo.FLAG_DYNAMIC | ShortcutInfo.FLAG_HAS_ICON_RES
-                | ShortcutInfo.FLAG_STRINGS_RESOLVED, si.getFlags());
-        assertNull(si.getBitmapPath());
-        assertEquals(R.drawable.black_32x32, si.getIconResourceId());
-        assertTrue(si.getLastChangedTimestamp() < now);
-
-        // Make sure ranks are saved too.  Because of the auto-adjusting, we need two shortcuts
-        // to test it.
-        si = mService.getPackageShortcutForTest(CALLING_PACKAGE_1, "id2", USER_10);
-        assertEquals(1, si.getRank());
-    }
-
-    public void testShortcutInfoSaveAndLoad_forBackup() {
-        setCaller(CALLING_PACKAGE_1, USER_0);
-
-        final Icon bmp32x32 = Icon.createWithBitmap(BitmapFactory.decodeResource(
-                getTestContext().getResources(), R.drawable.black_32x32));
-
-        PersistableBundle pb = new PersistableBundle();
-        pb.putInt("k", 1);
-        ShortcutInfo sorig = new ShortcutInfo.Builder(mClientContext)
-                .setId("id")
-                .setActivity(new ComponentName(mClientContext, ShortcutActivity2.class))
-                .setIcon(bmp32x32)
-                .setTitle("title")
-                .setText("text")
-                .setDisabledMessage("dismes")
-                .setCategories(set(ShortcutInfo.SHORTCUT_CATEGORY_CONVERSATION, "xyz"))
-                .setIntent(makeIntent("action", ShortcutActivity.class, "key", "val"))
-                .setRank(123)
-                .setExtras(pb)
-                .build();
-
-        ShortcutInfo sorig2 = new ShortcutInfo.Builder(mClientContext)
-                .setId("id2")
-                .setTitle("x")
-                .setActivity(new ComponentName(mClientContext, ShortcutActivity2.class))
-                .setIntent(makeIntent("action", ShortcutActivity.class, "key", "val"))
-                .setRank(456)
-                .build();
-
-        mManager.addDynamicShortcuts(list(sorig, sorig2));
-
-        // Dynamic shortcuts won't be backed up, so we need to pin it.
-        setCaller(LAUNCHER_1, USER_0);
-        mLauncherApps.pinShortcuts(CALLING_PACKAGE_1, list("id", "id2"), HANDLE_USER_0);
-
-        // Do backup & restore.
-        backupAndRestore();
-
-        mService.handleUnlockUser(USER_0); // Load user-0.
-
-        ShortcutInfo si;
-        si = mService.getPackageShortcutForTest(CALLING_PACKAGE_1, "id", USER_0);
-
-        assertEquals(CALLING_PACKAGE_1, si.getPackage());
-        assertEquals("id", si.getId());
-        assertEquals(ShortcutActivity2.class.getName(), si.getActivity().getClassName());
-        assertEquals(null, si.getIcon());
-        assertEquals("title", si.getTitle());
-        assertEquals("text", si.getText());
-        assertEquals("dismes", si.getDisabledMessage());
-        assertEquals(set(ShortcutInfo.SHORTCUT_CATEGORY_CONVERSATION, "xyz"), si.getCategories());
-        assertEquals("action", si.getIntent().getAction());
-        assertEquals("val", si.getIntent().getStringExtra("key"));
-        assertEquals(0, si.getRank());
-        assertEquals(1, si.getExtras().getInt("k"));
-
-        assertEquals(ShortcutInfo.FLAG_PINNED | ShortcutInfo.FLAG_STRINGS_RESOLVED, si.getFlags());
-        assertNull(si.getBitmapPath()); // No icon.
-        assertEquals(0, si.getIconResourceId());
-
-        // Note when restored from backup, it's no longer dynamic, so shouldn't have a rank.
-        si = mService.getPackageShortcutForTest(CALLING_PACKAGE_1, "id2", USER_0);
-        assertEquals(0, si.getRank());
-    }
-
-    public void testShortcutInfoSaveAndLoad_forBackup_resId() {
-        setCaller(CALLING_PACKAGE_1, USER_0);
-
-        final Icon res32x32 = Icon.createWithResource(mClientContext, R.drawable.black_32x32);
-
-        PersistableBundle pb = new PersistableBundle();
-        pb.putInt("k", 1);
-        ShortcutInfo sorig = new ShortcutInfo.Builder(mClientContext)
-                .setId("id")
-                .setActivity(new ComponentName(mClientContext, ShortcutActivity2.class))
-                .setIcon(res32x32)
-                .setTitleResId(10)
-                .setTextResId(11)
-                .setDisabledMessageResId(12)
-                .setCategories(set(ShortcutInfo.SHORTCUT_CATEGORY_CONVERSATION, "xyz"))
-                .setIntent(makeIntent("action", ShortcutActivity.class, "key", "val"))
-                .setRank(123)
-                .setExtras(pb)
-                .build();
-
-        ShortcutInfo sorig2 = new ShortcutInfo.Builder(mClientContext)
-                .setId("id2")
-                .setTitle("x")
-                .setActivity(new ComponentName(mClientContext, ShortcutActivity2.class))
-                .setIntent(makeIntent("action", ShortcutActivity.class, "key", "val"))
-                .setRank(456)
-                .build();
-
-        mManager.addDynamicShortcuts(list(sorig, sorig2));
-
-        // Dynamic shortcuts won't be backed up, so we need to pin it.
-        setCaller(LAUNCHER_1, USER_0);
-        mLauncherApps.pinShortcuts(CALLING_PACKAGE_1, list("id", "id2"), HANDLE_USER_0);
-
-        // Do backup & restore.
-        backupAndRestore();
-
-        mService.handleUnlockUser(USER_0); // Load user-0.
-
-        ShortcutInfo si;
-        si = mService.getPackageShortcutForTest(CALLING_PACKAGE_1, "id", USER_0);
-
-        assertEquals(CALLING_PACKAGE_1, si.getPackage());
-        assertEquals("id", si.getId());
-        assertEquals(ShortcutActivity2.class.getName(), si.getActivity().getClassName());
-        assertEquals(null, si.getIcon());
-        assertEquals(10, si.getTitleResId());
-        assertEquals("r10", si.getTitleResName());
-        assertEquals(11, si.getTextResId());
-        assertEquals("r11", si.getTextResName());
-        assertEquals(12, si.getDisabledMessageResourceId());
-        assertEquals("r12", si.getDisabledMessageResName());
-        assertEquals(set(ShortcutInfo.SHORTCUT_CATEGORY_CONVERSATION, "xyz"), si.getCategories());
-        assertEquals("action", si.getIntent().getAction());
-        assertEquals("val", si.getIntent().getStringExtra("key"));
-        assertEquals(0, si.getRank());
-        assertEquals(1, si.getExtras().getInt("k"));
-
-        assertEquals(ShortcutInfo.FLAG_PINNED | ShortcutInfo.FLAG_STRINGS_RESOLVED, si.getFlags());
-        assertNull(si.getBitmapPath()); // No icon.
-        assertEquals(0, si.getIconResourceId());
-        assertEquals(null, si.getIconResName());
-
-        // Note when restored from backup, it's no longer dynamic, so shouldn't have a rank.
-        si = mService.getPackageShortcutForTest(CALLING_PACKAGE_1, "id2", USER_0);
-        assertEquals(0, si.getRank());
-    }
-
-    private void checkShortcutInfoSaveAndLoad_intents(Intent intent) {
-        assertTrue(mManager.setDynamicShortcuts(list(
-                makeShortcutWithIntent("s1", intent))));
-        initService();
-        mService.handleUnlockUser(USER_0);
-
-        assertWith(getCallerShortcuts())
-                .haveIds("s1")
-                .forShortcutWithId("s1", si -> {
-                    assertEquals(intent.getAction(), si.getIntent().getAction());
-                    assertEquals(intent.getData(), si.getIntent().getData());
-                    assertEquals(intent.getComponent(), si.getIntent().getComponent());
-                    assertBundlesEqual(intent.getExtras(), si.getIntent().getExtras());
-                });
-    }
-
-    private void checkShortcutInfoSaveAndLoad_intents(Intent... intents) {
-        assertTrue(mManager.setDynamicShortcuts(list(
-                makeShortcutWithIntents("s1", intents))));
-        initService();
-        mService.handleUnlockUser(USER_0);
-
-        assertWith(getCallerShortcuts())
-                .haveIds("s1")
-                .forShortcutWithId("s1", si -> {
-
-                    final Intent[] actual = si.getIntents();
-                    assertEquals(intents.length, actual.length);
-
-                    for (int i = 0; i < intents.length; i++) {
-                        assertEquals(intents[i].getAction(), actual[i].getAction());
-                        assertEquals(intents[i].getData(), actual[i].getData());
-                        assertEquals(intents[i].getComponent(), actual[i].getComponent());
-                        assertEquals(intents[i].getFlags(), actual[i].getFlags());
-                        assertBundlesEqual(intents[i].getExtras(), actual[i].getExtras());
-                    }
-                });
-    }
-
-    public void testShortcutInfoSaveAndLoad_intents() {
-        checkShortcutInfoSaveAndLoad_intents(new Intent(Intent.ACTION_VIEW));
-
-        mInjectedCurrentTimeMillis += INTERVAL; // reset throttling.
-
-        checkShortcutInfoSaveAndLoad_intents(new Intent(Intent.ACTION_MAIN));
-
-        mInjectedCurrentTimeMillis += INTERVAL; // reset throttling.
-
-        checkShortcutInfoSaveAndLoad_intents(new Intent(Intent.ACTION_VIEW,
-                Uri.parse("http://www.example.com/")));
-
-        mInjectedCurrentTimeMillis += INTERVAL; // reset throttling.
-
-        checkShortcutInfoSaveAndLoad_intents(new Intent(Intent.ACTION_MAIN,
-                Uri.parse("http://www.example.com/")));
-
-        mInjectedCurrentTimeMillis += INTERVAL; // reset throttling.
-
-        checkShortcutInfoSaveAndLoad_intents(new Intent(Intent.ACTION_VIEW)
-                .setComponent(new ComponentName("a", "b")));
-
-        mInjectedCurrentTimeMillis += INTERVAL; // reset throttling.
-
-        checkShortcutInfoSaveAndLoad_intents(new Intent(Intent.ACTION_MAIN)
-                .setComponent(new ComponentName("a", "b")));
-
-        mInjectedCurrentTimeMillis += INTERVAL; // reset throttling.
-
-        checkShortcutInfoSaveAndLoad_intents(new Intent(Intent.ACTION_VIEW)
-                .putExtras(makeBundle("a", "b")));
-
-        mInjectedCurrentTimeMillis += INTERVAL; // reset throttling.
-
-
-        checkShortcutInfoSaveAndLoad_intents(new Intent(Intent.ACTION_MAIN)
-                .putExtras(makeBundle("a", "b")));
-
-        mInjectedCurrentTimeMillis += INTERVAL; // reset throttling.
-
-        // Multi-intents
-        checkShortcutInfoSaveAndLoad_intents(
-                new Intent(Intent.ACTION_MAIN).setFlags(Intent.FLAG_ACTIVITY_CLEAR_TASK),
-                new Intent(Intent.ACTION_VIEW).setFlags(Intent.FLAG_ACTIVITY_FORWARD_RESULT)
-        );
-
-        checkShortcutInfoSaveAndLoad_intents(
-                new Intent(Intent.ACTION_MAIN).setFlags(Intent.FLAG_ACTIVITY_CLEAR_TASK)
-                        .setComponent(new ComponentName("a", "b")),
-                new Intent(Intent.ACTION_VIEW)
-                        .setComponent(new ComponentName("a", "b"))
-                );
-
-        checkShortcutInfoSaveAndLoad_intents(
-                new Intent(Intent.ACTION_MAIN)
-                        .setComponent(new ComponentName("a", "b")),
-                new Intent(Intent.ACTION_VIEW).setFlags(Intent.FLAG_ACTIVITY_CLEAR_TASK)
-                        .setComponent(new ComponentName("a", "b")),
-                new Intent("xyz").setFlags(Intent.FLAG_ACTIVITY_CLEAR_TASK
-                        | Intent.FILL_IN_COMPONENT)
-                        .setComponent(new ComponentName("a", "b")).putExtras(
-                        makeBundle("xx", "yy"))
-                );
-    }
-
-    public void testThrottling() {
-        final ShortcutInfo si1 = makeShortcut("shortcut1");
-
-        assertTrue(mManager.setDynamicShortcuts(list(si1)));
-        assertEquals(2, mManager.getRemainingCallCount());
-        assertEquals(START_TIME + INTERVAL, mManager.getRateLimitResetTime());
-
-        mInjectedCurrentTimeMillis++;
-        assertTrue(mManager.setDynamicShortcuts(list(si1)));
-        assertEquals(1, mManager.getRemainingCallCount());
-        assertEquals(START_TIME + INTERVAL, mManager.getRateLimitResetTime());
-
-        mInjectedCurrentTimeMillis++;
-        assertTrue(mManager.setDynamicShortcuts(list(si1)));
-        assertEquals(0, mManager.getRemainingCallCount());
-        assertEquals(START_TIME + INTERVAL, mManager.getRateLimitResetTime());
-
-        // Reached the max
-
-        mInjectedCurrentTimeMillis++;
-        assertFalse(mManager.setDynamicShortcuts(list(si1)));
-        assertEquals(0, mManager.getRemainingCallCount());
-        assertEquals(START_TIME + INTERVAL, mManager.getRateLimitResetTime());
-
-        // Still throttled
-        mInjectedCurrentTimeMillis = START_TIME + INTERVAL - 1;
-        assertFalse(mManager.setDynamicShortcuts(list(si1)));
-        assertEquals(0, mManager.getRemainingCallCount());
-        assertEquals(START_TIME + INTERVAL, mManager.getRateLimitResetTime());
-
-        // Now it should work.
-        mInjectedCurrentTimeMillis++;
-        assertTrue(mManager.setDynamicShortcuts(list(si1))); // fail
-        assertEquals(2, mManager.getRemainingCallCount());
-        assertEquals(START_TIME + INTERVAL * 2, mManager.getRateLimitResetTime());
-
-        mInjectedCurrentTimeMillis++;
-        assertTrue(mManager.setDynamicShortcuts(list(si1)));
-        assertEquals(1, mManager.getRemainingCallCount());
-        assertEquals(START_TIME + INTERVAL * 2, mManager.getRateLimitResetTime());
-
-        mInjectedCurrentTimeMillis++;
-        assertTrue(mManager.setDynamicShortcuts(list(si1)));
-        assertEquals(0, mManager.getRemainingCallCount());
-        assertEquals(START_TIME + INTERVAL * 2, mManager.getRateLimitResetTime());
-
-        mInjectedCurrentTimeMillis++;
-        assertFalse(mManager.setDynamicShortcuts(list(si1)));
-        assertEquals(0, mManager.getRemainingCallCount());
-        assertEquals(START_TIME + INTERVAL * 2, mManager.getRateLimitResetTime());
-
-        // 4 hours later...
-        mInjectedCurrentTimeMillis = START_TIME + 4 * INTERVAL;
-        assertTrue(mManager.setDynamicShortcuts(list(si1)));
-        assertEquals(2, mManager.getRemainingCallCount());
-        assertEquals(START_TIME + INTERVAL * 5, mManager.getRateLimitResetTime());
-
-        mInjectedCurrentTimeMillis++;
-        assertTrue(mManager.setDynamicShortcuts(list(si1)));
-        assertEquals(1, mManager.getRemainingCallCount());
-        assertEquals(START_TIME + INTERVAL * 5, mManager.getRateLimitResetTime());
-
-        // Make sure getRemainingCallCount() itself gets reset without calling setDynamicShortcuts().
-        mInjectedCurrentTimeMillis = START_TIME + 8 * INTERVAL;
-        assertEquals(3, mManager.getRemainingCallCount());
-        assertEquals(START_TIME + INTERVAL * 9, mManager.getRateLimitResetTime());
-
-        mInjectedCurrentTimeMillis++;
-        assertTrue(mManager.setDynamicShortcuts(list(si1)));
-        assertEquals(2, mManager.getRemainingCallCount());
-        assertEquals(START_TIME + INTERVAL * 9, mManager.getRateLimitResetTime());
-    }
-
-    public void testThrottling_rewind() {
-        final ShortcutInfo si1 = makeShortcut("shortcut1");
-
-        assertTrue(mManager.setDynamicShortcuts(list(si1)));
-        assertEquals(2, mManager.getRemainingCallCount());
-        assertEquals(START_TIME + INTERVAL, mManager.getRateLimitResetTime());
-
-        mInjectedCurrentTimeMillis = 12345; // Clock reset!
-
-        // Since the clock looks invalid, the counter shouldn't have reset.
-        assertEquals(2, mManager.getRemainingCallCount());
-        assertEquals(START_TIME + INTERVAL, mManager.getRateLimitResetTime());
-
-        // Forward again.  Still haven't reset yet.
-        mInjectedCurrentTimeMillis = START_TIME + INTERVAL - 1;
-        assertEquals(2, mManager.getRemainingCallCount());
-        assertEquals(START_TIME + INTERVAL, mManager.getRateLimitResetTime());
-
-        // Now rewind -- this will reset the counters.
-        mInjectedCurrentTimeMillis = START_TIME - 100000;
-        assertEquals(3, mManager.getRemainingCallCount());
-
-        assertTrue(mManager.setDynamicShortcuts(list(si1)));
-        assertEquals(2, mManager.getRemainingCallCount());
-
-        // Forward again, should be reset now.
-        mInjectedCurrentTimeMillis += INTERVAL;
-        assertEquals(3, mManager.getRemainingCallCount());
-    }
-
-    public void testThrottling_perPackage() {
-        final ShortcutInfo si1 = makeShortcut("shortcut1");
-
-        assertTrue(mManager.setDynamicShortcuts(list(si1)));
-        assertEquals(2, mManager.getRemainingCallCount());
-
-        mInjectedCurrentTimeMillis++;
-        assertTrue(mManager.setDynamicShortcuts(list(si1)));
-        assertEquals(1, mManager.getRemainingCallCount());
-
-        mInjectedCurrentTimeMillis++;
-        assertTrue(mManager.setDynamicShortcuts(list(si1)));
-        assertEquals(0, mManager.getRemainingCallCount());
-
-        // Reached the max
-
-        mInjectedCurrentTimeMillis++;
-        assertFalse(mManager.setDynamicShortcuts(list(si1)));
-
-        // Try from a different caller.
-        mInjectedClientPackage = CALLING_PACKAGE_2;
-        mInjectedCallingUid = CALLING_UID_2;
-
-        // Need to create a new one wit the updated package name.
-        final ShortcutInfo si2 = makeShortcut("shortcut1");
-
-        assertEquals(3, mManager.getRemainingCallCount());
-
-        assertTrue(mManager.setDynamicShortcuts(list(si2)));
-        assertEquals(2, mManager.getRemainingCallCount());
-
-        mInjectedCurrentTimeMillis++;
-        assertTrue(mManager.setDynamicShortcuts(list(si2)));
-        assertEquals(1, mManager.getRemainingCallCount());
-
-        // Back to the original caller, still throttled.
-        mInjectedClientPackage = CALLING_PACKAGE_1;
-        mInjectedCallingUid = CALLING_UID_1;
-
-        mInjectedCurrentTimeMillis = START_TIME + INTERVAL - 1;
-        assertEquals(0, mManager.getRemainingCallCount());
-        assertFalse(mManager.setDynamicShortcuts(list(si1)));
-        assertEquals(0, mManager.getRemainingCallCount());
-
-        // Now it should work.
-        mInjectedCurrentTimeMillis++;
-        assertTrue(mManager.setDynamicShortcuts(list(si1)));
-
-        mInjectedCurrentTimeMillis++;
-        assertTrue(mManager.setDynamicShortcuts(list(si1)));
-
-        mInjectedCurrentTimeMillis++;
-        assertTrue(mManager.setDynamicShortcuts(list(si1)));
-
-        mInjectedCurrentTimeMillis++;
-        assertFalse(mManager.setDynamicShortcuts(list(si1)));
-
-        mInjectedCurrentTimeMillis = START_TIME + 4 * INTERVAL;
-        assertTrue(mManager.setDynamicShortcuts(list(si1)));
-        assertTrue(mManager.setDynamicShortcuts(list(si1)));
-        assertTrue(mManager.setDynamicShortcuts(list(si1)));
-        assertFalse(mManager.setDynamicShortcuts(list(si1)));
-
-        mInjectedClientPackage = CALLING_PACKAGE_2;
-        mInjectedCallingUid = CALLING_UID_2;
-
-        assertEquals(3, mManager.getRemainingCallCount());
-
-        assertTrue(mManager.setDynamicShortcuts(list(si2)));
-        assertTrue(mManager.setDynamicShortcuts(list(si2)));
-        assertTrue(mManager.setDynamicShortcuts(list(si2)));
-        assertFalse(mManager.setDynamicShortcuts(list(si2)));
-    }
-
-    public void testThrottling_localeChanges() {
-        prepareCrossProfileDataSet();
-
-        dumpsysOnLogcat("Before save & load");
-
-        mService.saveDirtyInfo();
-        initService();
-
-        mInjectedLocale = Locale.CHINA;
-        mService.mReceiver.onReceive(mServiceContext, new Intent(Intent.ACTION_LOCALE_CHANGED));
-
-        // Note at this point only user-0 is loaded, and the counters are reset for this user,
-        // but it will work for other users too because we check the locale change at any
-        // API entry point.
-
-        runWithCaller(CALLING_PACKAGE_1, USER_0, () -> {
-            assertEquals(3, mManager.getRemainingCallCount());
-        });
-        runWithCaller(CALLING_PACKAGE_2, USER_0, () -> {
-            assertEquals(3, mManager.getRemainingCallCount());
-        });
-        runWithCaller(CALLING_PACKAGE_3, USER_0, () -> {
-            assertEquals(3, mManager.getRemainingCallCount());
-        });
-        runWithCaller(CALLING_PACKAGE_4, USER_0, () -> {
-            assertEquals(3, mManager.getRemainingCallCount());
-        });
-        runWithCaller(CALLING_PACKAGE_1, USER_P0, () -> {
-            assertEquals(3, mManager.getRemainingCallCount());
-        });
-        runWithCaller(CALLING_PACKAGE_1, USER_10, () -> {
-            assertEquals(3, mManager.getRemainingCallCount());
-        });
-
-        // Make sure even if we receive ACTION_LOCALE_CHANGED, if the locale hasn't actually
-        // changed, we don't reset throttling.
-        runWithCaller(CALLING_PACKAGE_1, USER_0, () -> {
-            mManager.updateShortcuts(list());
-            assertEquals(2, mManager.getRemainingCallCount());
-        });
-
-        mService.mReceiver.onReceive(mServiceContext, new Intent(Intent.ACTION_LOCALE_CHANGED));
-
-        runWithCaller(CALLING_PACKAGE_1, USER_0, () -> {
-            assertEquals(2, mManager.getRemainingCallCount()); // Still 2.
-        });
-
-        mService.saveDirtyInfo();
-        initService();
-
-        // The locale should be persisted, so it still shouldn't reset throttling.
-        mService.mReceiver.onReceive(mServiceContext, new Intent(Intent.ACTION_LOCALE_CHANGED));
-
-        runWithCaller(CALLING_PACKAGE_1, USER_0, () -> {
-            assertEquals(2, mManager.getRemainingCallCount()); // Still 2.
-        });
-    }
-
-    public void testThrottling_foreground() throws Exception {
-        prepareCrossProfileDataSet();
-
-        dumpsysOnLogcat("Before save & load");
-
-        mService.saveDirtyInfo();
-        initService();
-
-        // We need to update the current time from time to time, since some of the internal checks
-        // rely on the time being correctly incremented.
-        mInjectedCurrentTimeMillis++;
-
-        // First, all packages have less than 3 (== initial value) remaining calls.
-
-        runWithCaller(CALLING_PACKAGE_1, USER_0, () -> {
-            MoreAsserts.assertNotEqual(3, mManager.getRemainingCallCount());
-        });
-        runWithCaller(CALLING_PACKAGE_2, USER_0, () -> {
-            MoreAsserts.assertNotEqual(3, mManager.getRemainingCallCount());
-        });
-        runWithCaller(CALLING_PACKAGE_3, USER_0, () -> {
-            MoreAsserts.assertNotEqual(3, mManager.getRemainingCallCount());
-        });
-        runWithCaller(CALLING_PACKAGE_4, USER_0, () -> {
-            MoreAsserts.assertNotEqual(3, mManager.getRemainingCallCount());
-        });
-        runWithCaller(CALLING_PACKAGE_1, USER_P0, () -> {
-            MoreAsserts.assertNotEqual(3, mManager.getRemainingCallCount());
-        });
-        runWithCaller(CALLING_PACKAGE_1, USER_10, () -> {
-            MoreAsserts.assertNotEqual(3, mManager.getRemainingCallCount());
-        });
-
-        mInjectedCurrentTimeMillis++;
-
-        // State changed, but not foreground, so no resetting.
-        mService.mUidObserver.onUidStateChanged(
-                CALLING_UID_1, ActivityManager.PROCESS_STATE_TOP_SLEEPING);
-        runWithCaller(CALLING_PACKAGE_1, USER_0, () -> {
-            MoreAsserts.assertNotEqual(3, mManager.getRemainingCallCount());
-        });
-        runWithCaller(CALLING_PACKAGE_2, USER_0, () -> {
-            MoreAsserts.assertNotEqual(3, mManager.getRemainingCallCount());
-        });
-        runWithCaller(CALLING_PACKAGE_3, USER_0, () -> {
-            MoreAsserts.assertNotEqual(3, mManager.getRemainingCallCount());
-        });
-        runWithCaller(CALLING_PACKAGE_4, USER_0, () -> {
-            MoreAsserts.assertNotEqual(3, mManager.getRemainingCallCount());
-        });
-        runWithCaller(CALLING_PACKAGE_1, USER_P0, () -> {
-            MoreAsserts.assertNotEqual(3, mManager.getRemainingCallCount());
-        });
-        runWithCaller(CALLING_PACKAGE_1, USER_10, () -> {
-            MoreAsserts.assertNotEqual(3, mManager.getRemainingCallCount());
-        });
-
-        mInjectedCurrentTimeMillis++;
-
-        // State changed, package1 foreground, reset.
-        mService.mUidObserver.onUidStateChanged(
-                CALLING_UID_1, ActivityManager.PROCESS_STATE_FOREGROUND_SERVICE);
-        runWithCaller(CALLING_PACKAGE_1, USER_0, () -> {
-            assertEquals(3, mManager.getRemainingCallCount());
-        });
-        runWithCaller(CALLING_PACKAGE_2, USER_0, () -> {
-            MoreAsserts.assertNotEqual(3, mManager.getRemainingCallCount());
-        });
-        runWithCaller(CALLING_PACKAGE_3, USER_0, () -> {
-            MoreAsserts.assertNotEqual(3, mManager.getRemainingCallCount());
-        });
-        runWithCaller(CALLING_PACKAGE_4, USER_0, () -> {
-            MoreAsserts.assertNotEqual(3, mManager.getRemainingCallCount());
-        });
-        runWithCaller(CALLING_PACKAGE_1, USER_P0, () -> {
-            MoreAsserts.assertNotEqual(3, mManager.getRemainingCallCount());
-        });
-        runWithCaller(CALLING_PACKAGE_1, USER_10, () -> {
-            MoreAsserts.assertNotEqual(3, mManager.getRemainingCallCount());
-        });
-        mService.mUidObserver.onUidStateChanged(
-                CALLING_UID_1, ActivityManager.PROCESS_STATE_TOP_SLEEPING);
-
-        mInjectedCurrentTimeMillis++;
-
-        // Different app comes to foreground briefly, and goes back to background.
-        // Now, make sure package 2's counter is reset, even in this case.
-        mService.mUidObserver.onUidStateChanged(
-                CALLING_UID_2, ActivityManager.PROCESS_STATE_FOREGROUND_SERVICE);
-        mService.mUidObserver.onUidStateChanged(
-                CALLING_UID_2, ActivityManager.PROCESS_STATE_TOP_SLEEPING);
-
-        runWithCaller(CALLING_PACKAGE_1, USER_0, () -> {
-            assertEquals(3, mManager.getRemainingCallCount());
-        });
-        runWithCaller(CALLING_PACKAGE_2, USER_0, () -> {
-            assertEquals(3, mManager.getRemainingCallCount());
-        });
-        runWithCaller(CALLING_PACKAGE_3, USER_0, () -> {
-            MoreAsserts.assertNotEqual(3, mManager.getRemainingCallCount());
-        });
-        runWithCaller(CALLING_PACKAGE_4, USER_0, () -> {
-            MoreAsserts.assertNotEqual(3, mManager.getRemainingCallCount());
-        });
-        runWithCaller(CALLING_PACKAGE_1, USER_P0, () -> {
-            MoreAsserts.assertNotEqual(3, mManager.getRemainingCallCount());
-        });
-        runWithCaller(CALLING_PACKAGE_1, USER_10, () -> {
-            MoreAsserts.assertNotEqual(3, mManager.getRemainingCallCount());
-        });
-
-        mInjectedCurrentTimeMillis++;
-
-        // Do the same thing one more time.  This would catch the bug with mixuing up
-        // the current time and the elapsed time.
-        runWithCaller(CALLING_PACKAGE_2, USER_0, () -> {
-            mManager.updateShortcuts(list(makeShortcut("s")));
-            MoreAsserts.assertNotEqual(3, mManager.getRemainingCallCount());
-        });
-
-        mService.mUidObserver.onUidStateChanged(
-                CALLING_UID_2, ActivityManager.PROCESS_STATE_FOREGROUND_SERVICE);
-        mService.mUidObserver.onUidStateChanged(
-                CALLING_UID_2, ActivityManager.PROCESS_STATE_TOP_SLEEPING);
-
-        runWithCaller(CALLING_PACKAGE_1, USER_0, () -> {
-            assertEquals(3, mManager.getRemainingCallCount());
-        });
-        runWithCaller(CALLING_PACKAGE_2, USER_0, () -> {
-            assertEquals(3, mManager.getRemainingCallCount());
-        });
-        runWithCaller(CALLING_PACKAGE_3, USER_0, () -> {
-            MoreAsserts.assertNotEqual(3, mManager.getRemainingCallCount());
-        });
-        runWithCaller(CALLING_PACKAGE_4, USER_0, () -> {
-            MoreAsserts.assertNotEqual(3, mManager.getRemainingCallCount());
-        });
-        runWithCaller(CALLING_PACKAGE_1, USER_P0, () -> {
-            MoreAsserts.assertNotEqual(3, mManager.getRemainingCallCount());
-        });
-        runWithCaller(CALLING_PACKAGE_1, USER_10, () -> {
-            MoreAsserts.assertNotEqual(3, mManager.getRemainingCallCount());
-        });
-
-        mInjectedCurrentTimeMillis++;
-
-        // Package 1 on user-10 comes to foreground.
-        // Now, also try calling some APIs and make sure foreground apps don't get throttled.
-        mService.mUidObserver.onUidStateChanged(
-                UserHandle.getUid(USER_10, CALLING_UID_1),
-                ActivityManager.PROCESS_STATE_FOREGROUND_SERVICE);
-        runWithCaller(CALLING_PACKAGE_1, USER_0, () -> {
-            assertEquals(3, mManager.getRemainingCallCount());
-            assertFalse(mManager.isRateLimitingActive());
-
-            mManager.setDynamicShortcuts(list(makeShortcut("s")));
-
-            assertEquals(2, mManager.getRemainingCallCount());
-            assertFalse(mManager.isRateLimitingActive());
-
-            mManager.setDynamicShortcuts(list(makeShortcut("s")));
-
-            assertEquals(1, mManager.getRemainingCallCount());
-            assertFalse(mManager.isRateLimitingActive());
-
-            mManager.setDynamicShortcuts(list(makeShortcut("s")));
-
-            assertEquals(0, mManager.getRemainingCallCount());
-            assertTrue(mManager.isRateLimitingActive());
-        });
-        runWithCaller(CALLING_PACKAGE_2, USER_0, () -> {
-            assertEquals(3, mManager.getRemainingCallCount());
-
-            mManager.setDynamicShortcuts(list(makeShortcut("s")));
-            mManager.setDynamicShortcuts(list(makeShortcut("s")));
-            mManager.setDynamicShortcuts(list(makeShortcut("s")));
-
-            assertEquals(0, mManager.getRemainingCallCount());
-            assertTrue(mManager.isRateLimitingActive());
-        });
-        runWithCaller(CALLING_PACKAGE_3, USER_0, () -> {
-            MoreAsserts.assertNotEqual(3, mManager.getRemainingCallCount());
-
-            mManager.setDynamicShortcuts(list(makeShortcut("s")));
-            mManager.setDynamicShortcuts(list(makeShortcut("s")));
-            mManager.setDynamicShortcuts(list(makeShortcut("s")));
-
-            assertEquals(0, mManager.getRemainingCallCount());
-            assertTrue(mManager.isRateLimitingActive());
-        });
-        runWithCaller(CALLING_PACKAGE_4, USER_0, () -> {
-            MoreAsserts.assertNotEqual(3, mManager.getRemainingCallCount());
-
-            mManager.setDynamicShortcuts(list(makeShortcut("s")));
-            mManager.setDynamicShortcuts(list(makeShortcut("s")));
-            mManager.setDynamicShortcuts(list(makeShortcut("s")));
-
-            assertEquals(0, mManager.getRemainingCallCount());
-            assertTrue(mManager.isRateLimitingActive());
-        });
-        runWithCaller(CALLING_PACKAGE_1, USER_P0, () -> {
-            MoreAsserts.assertNotEqual(3, mManager.getRemainingCallCount());
-
-            mManager.setDynamicShortcuts(list(makeShortcut("s")));
-            mManager.setDynamicShortcuts(list(makeShortcut("s")));
-            mManager.setDynamicShortcuts(list(makeShortcut("s")));
-
-            assertEquals(0, mManager.getRemainingCallCount());
-            assertTrue(mManager.isRateLimitingActive());
-        });
-        runWithCaller(CALLING_PACKAGE_1, USER_10, () -> {
-            assertEquals(3, mManager.getRemainingCallCount());
-
-            mManager.setDynamicShortcuts(list(makeShortcut("s")));
-            mManager.setDynamicShortcuts(list(makeShortcut("s")));
-            mManager.setDynamicShortcuts(list(makeShortcut("s")));
-
-            assertEquals(3, mManager.getRemainingCallCount()); // Still 3!
-            assertFalse(mManager.isRateLimitingActive());
-        });
-    }
-
-
-    public void testThrottling_resetByInternalCall() throws Exception {
-        prepareCrossProfileDataSet();
-
-        dumpsysOnLogcat("Before save & load");
-
-        mService.saveDirtyInfo();
-        initService();
-
-        // First, all packages have less than 3 (== initial value) remaining calls.
-
-        runWithCaller(CALLING_PACKAGE_1, USER_0, () -> {
-            MoreAsserts.assertNotEqual(3, mManager.getRemainingCallCount());
-        });
-        runWithCaller(CALLING_PACKAGE_2, USER_0, () -> {
-            MoreAsserts.assertNotEqual(3, mManager.getRemainingCallCount());
-        });
-        runWithCaller(CALLING_PACKAGE_3, USER_0, () -> {
-            MoreAsserts.assertNotEqual(3, mManager.getRemainingCallCount());
-        });
-        runWithCaller(CALLING_PACKAGE_4, USER_0, () -> {
-            MoreAsserts.assertNotEqual(3, mManager.getRemainingCallCount());
-        });
-        runWithCaller(CALLING_PACKAGE_1, USER_P0, () -> {
-            MoreAsserts.assertNotEqual(3, mManager.getRemainingCallCount());
-        });
-        runWithCaller(CALLING_PACKAGE_1, USER_10, () -> {
-            MoreAsserts.assertNotEqual(3, mManager.getRemainingCallCount());
-        });
-
-        // Simulate a call from sys UI.
-        mCallerPermissions.add(permission.RESET_SHORTCUT_MANAGER_THROTTLING);
-        mManager.onApplicationActive(CALLING_PACKAGE_1, USER_0);
-
-        runWithCaller(CALLING_PACKAGE_1, USER_0, () -> {
-            assertEquals(3, mManager.getRemainingCallCount());
-        });
-        runWithCaller(CALLING_PACKAGE_2, USER_0, () -> {
-            MoreAsserts.assertNotEqual(3, mManager.getRemainingCallCount());
-        });
-        runWithCaller(CALLING_PACKAGE_3, USER_0, () -> {
-            MoreAsserts.assertNotEqual(3, mManager.getRemainingCallCount());
-        });
-        runWithCaller(CALLING_PACKAGE_4, USER_0, () -> {
-            MoreAsserts.assertNotEqual(3, mManager.getRemainingCallCount());
-        });
-        runWithCaller(CALLING_PACKAGE_1, USER_P0, () -> {
-            MoreAsserts.assertNotEqual(3, mManager.getRemainingCallCount());
-        });
-        runWithCaller(CALLING_PACKAGE_1, USER_10, () -> {
-            MoreAsserts.assertNotEqual(3, mManager.getRemainingCallCount());
-        });
-
-        mManager.onApplicationActive(CALLING_PACKAGE_3, USER_0);
-
-        runWithCaller(CALLING_PACKAGE_1, USER_0, () -> {
-            assertEquals(3, mManager.getRemainingCallCount());
-        });
-        runWithCaller(CALLING_PACKAGE_2, USER_0, () -> {
-            MoreAsserts.assertNotEqual(3, mManager.getRemainingCallCount());
-        });
-        runWithCaller(CALLING_PACKAGE_3, USER_0, () -> {
-            assertEquals(3, mManager.getRemainingCallCount());
-        });
-        runWithCaller(CALLING_PACKAGE_4, USER_0, () -> {
-            MoreAsserts.assertNotEqual(3, mManager.getRemainingCallCount());
-        });
-        runWithCaller(CALLING_PACKAGE_1, USER_P0, () -> {
-            MoreAsserts.assertNotEqual(3, mManager.getRemainingCallCount());
-        });
-        runWithCaller(CALLING_PACKAGE_1, USER_10, () -> {
-            MoreAsserts.assertNotEqual(3, mManager.getRemainingCallCount());
-        });
-
-        mManager.onApplicationActive(CALLING_PACKAGE_1, USER_10);
-
-        runWithCaller(CALLING_PACKAGE_1, USER_0, () -> {
-            assertEquals(3, mManager.getRemainingCallCount());
-        });
-        runWithCaller(CALLING_PACKAGE_2, USER_0, () -> {
-            MoreAsserts.assertNotEqual(3, mManager.getRemainingCallCount());
-        });
-        runWithCaller(CALLING_PACKAGE_3, USER_0, () -> {
-            assertEquals(3, mManager.getRemainingCallCount());
-        });
-        runWithCaller(CALLING_PACKAGE_4, USER_0, () -> {
-            MoreAsserts.assertNotEqual(3, mManager.getRemainingCallCount());
-        });
-        runWithCaller(CALLING_PACKAGE_1, USER_P0, () -> {
-            MoreAsserts.assertNotEqual(3, mManager.getRemainingCallCount());
-        });
-        runWithCaller(CALLING_PACKAGE_1, USER_10, () -> {
-            assertEquals(3, mManager.getRemainingCallCount());
-        });
-    }
-
-    public void testReportShortcutUsed() {
-        mRunningUsers.put(USER_10, true);
-
-        runWithCaller(CALLING_PACKAGE_1, USER_10, () -> {
-            reset(mMockUsageStatsManagerInternal);
-
-            // Report with an nonexistent shortcut.
-            mManager.reportShortcutUsed("s1");
-            verify(mMockUsageStatsManagerInternal, times(0)).reportShortcutUsage(
-                    anyString(), anyString(), anyInt());
-
-            // Publish s2, but s1 still doesn't exist.
-            mManager.setDynamicShortcuts(list(makeShortcut("s2")));
-            mManager.reportShortcutUsed("s1");
-            verify(mMockUsageStatsManagerInternal, times(0)).reportShortcutUsage(
-                    anyString(), anyString(), anyInt());
-
-            mManager.reportShortcutUsed("s2");
-            verify(mMockUsageStatsManagerInternal, times(1)).reportShortcutUsage(
-                    eq(CALLING_PACKAGE_1), eq("s2"), eq(USER_10));
-
-        });
-        runWithCaller(CALLING_PACKAGE_2, USER_10, () -> {
-            // Try with a different package.
-            reset(mMockUsageStatsManagerInternal);
-
-            // Report with an nonexistent shortcut.
-            mManager.reportShortcutUsed("s2");
-            verify(mMockUsageStatsManagerInternal, times(0)).reportShortcutUsage(
-                    anyString(), anyString(), anyInt());
-
-            // Publish s2, but s1 still doesn't exist.
-            mManager.setDynamicShortcuts(list(makeShortcut("s3")));
-            mManager.reportShortcutUsed("s2");
-            verify(mMockUsageStatsManagerInternal, times(0)).reportShortcutUsage(
-                    anyString(), anyString(), anyInt());
-
-            mManager.reportShortcutUsed("s3");
-            verify(mMockUsageStatsManagerInternal, times(1)).reportShortcutUsage(
-                    eq(CALLING_PACKAGE_2), eq("s3"), eq(USER_10));
-
-        });
-    }
-
-    // Test for a ShortcutInfo method.
-    public void testGetResourcePackageName() {
-        assertEquals(null, ShortcutInfo.getResourcePackageName(""));
-        assertEquals(null, ShortcutInfo.getResourcePackageName("abc"));
-        assertEquals("p", ShortcutInfo.getResourcePackageName("p:"));
-        assertEquals("p", ShortcutInfo.getResourcePackageName("p:xx"));
-        assertEquals("pac", ShortcutInfo.getResourcePackageName("pac:"));
-    }
-
-    // Test for a ShortcutInfo method.
-    public void testGetResourceTypeName() {
-        assertEquals(null, ShortcutInfo.getResourceTypeName(""));
-        assertEquals(null, ShortcutInfo.getResourceTypeName(":"));
-        assertEquals(null, ShortcutInfo.getResourceTypeName("/"));
-        assertEquals(null, ShortcutInfo.getResourceTypeName("/:"));
-        assertEquals("a", ShortcutInfo.getResourceTypeName(":a/"));
-        assertEquals("type", ShortcutInfo.getResourceTypeName("xxx:type/yyy"));
-    }
-
-    // Test for a ShortcutInfo method.
-    public void testGetResourceTypeAndEntryName() {
-        assertEquals(null, ShortcutInfo.getResourceTypeAndEntryName(""));
-        assertEquals(null, ShortcutInfo.getResourceTypeAndEntryName("abc"));
-        assertEquals("", ShortcutInfo.getResourceTypeAndEntryName("p:"));
-        assertEquals("x", ShortcutInfo.getResourceTypeAndEntryName(":x"));
-        assertEquals("x", ShortcutInfo.getResourceTypeAndEntryName("p:x"));
-        assertEquals("xyz", ShortcutInfo.getResourceTypeAndEntryName("pac:xyz"));
-    }
-
-    // Test for a ShortcutInfo method.
-    public void testGetResourceEntryName() {
-        assertEquals(null, ShortcutInfo.getResourceEntryName(""));
-        assertEquals(null, ShortcutInfo.getResourceEntryName("ab:"));
-        assertEquals("", ShortcutInfo.getResourceEntryName("/"));
-        assertEquals("abc", ShortcutInfo.getResourceEntryName("/abc"));
-        assertEquals("abc", ShortcutInfo.getResourceEntryName("xyz/abc"));
-    }
-
-    // Test for a ShortcutInfo method.
-    public void testLookUpResourceName_systemResources() {
-        // For android system resources, lookUpResourceName will simply return the value as a
-        // string, regardless of "withType".
-        final Resources res = getTestContext().getResources();
-
-        assertEquals("" + android.R.string.cancel, ShortcutInfo.lookUpResourceName(res,
-                android.R.string.cancel, true, getTestContext().getPackageName()));
-        assertEquals("" + android.R.drawable.alert_dark_frame, ShortcutInfo.lookUpResourceName(res,
-                android.R.drawable.alert_dark_frame, true, getTestContext().getPackageName()));
-        assertEquals("" + android.R.string.cancel, ShortcutInfo.lookUpResourceName(res,
-                android.R.string.cancel, false, getTestContext().getPackageName()));
-    }
-
-    public void testLookUpResourceName_appResources() {
-        final Resources res = getTestContext().getResources();
-
-        assertEquals("shortcut_text1", ShortcutInfo.lookUpResourceName(res,
-                R.string.shortcut_text1, false, getTestContext().getPackageName()));
-        assertEquals("string/shortcut_text1", ShortcutInfo.lookUpResourceName(res,
-                R.string.shortcut_text1, true, getTestContext().getPackageName()));
-
-        assertEquals("black_16x64", ShortcutInfo.lookUpResourceName(res,
-                R.drawable.black_16x64, false, getTestContext().getPackageName()));
-        assertEquals("drawable/black_16x64", ShortcutInfo.lookUpResourceName(res,
-                R.drawable.black_16x64, true, getTestContext().getPackageName()));
-    }
-
-    // Test for a ShortcutInfo method.
-    public void testLookUpResourceId_systemResources() {
-        final Resources res = getTestContext().getResources();
-
-        assertEquals(android.R.string.cancel, ShortcutInfo.lookUpResourceId(res,
-                "" + android.R.string.cancel, null,
-                getTestContext().getPackageName()));
-        assertEquals(android.R.drawable.alert_dark_frame, ShortcutInfo.lookUpResourceId(res,
-                "" + android.R.drawable.alert_dark_frame, null,
-                getTestContext().getPackageName()));
-    }
-
-    // Test for a ShortcutInfo method.
-    public void testLookUpResourceId_appResources() {
-        final Resources res = getTestContext().getResources();
-
-        assertEquals(R.string.shortcut_text1,
-                ShortcutInfo.lookUpResourceId(res, "shortcut_text1", "string",
-                        getTestContext().getPackageName()));
-
-        assertEquals(R.string.shortcut_text1,
-                ShortcutInfo.lookUpResourceId(res, "string/shortcut_text1", null,
-                        getTestContext().getPackageName()));
-
-        assertEquals(R.drawable.black_16x64,
-                ShortcutInfo.lookUpResourceId(res, "black_16x64", "drawable",
-                        getTestContext().getPackageName()));
-
-        assertEquals(R.drawable.black_16x64,
-                ShortcutInfo.lookUpResourceId(res, "drawable/black_16x64", null,
-                        getTestContext().getPackageName()));
-    }
-
-    public void testDumpCheckin() throws IOException {
-        prepareCrossProfileDataSet();
-
-        // prepareCrossProfileDataSet() doesn't set any icons, so do set here.
-        final Icon res32x32 = Icon.createWithResource(getTestContext(), R.drawable.black_32x32);
-        final Icon res64x64 = Icon.createWithResource(getTestContext(), R.drawable.black_64x64);
-        final Icon bmp32x32 = Icon.createWithBitmap(BitmapFactory.decodeResource(
-                getTestContext().getResources(), R.drawable.black_32x32));
-        final Icon bmp64x64 = Icon.createWithBitmap(BitmapFactory.decodeResource(
-                getTestContext().getResources(), R.drawable.black_64x64));
-
-        runWithCaller(CALLING_PACKAGE_2, USER_0, () -> {
-            assertTrue(mManager.setDynamicShortcuts(list(
-                    makeShortcutWithIcon("res32x32", res32x32),
-                    makeShortcutWithIcon("res64x64", res64x64),
-                    makeShortcutWithIcon("bmp32x32", bmp32x32),
-                    makeShortcutWithIcon("bmp64x64", bmp64x64))));
-        });
-        // We can't predict the compressed bitmap sizes, so get the real sizes here.
-        final long bitmapTotal =
-                new File(getPackageShortcut(CALLING_PACKAGE_2, "bmp32x32", USER_0)
-                        .getBitmapPath()).length() +
-                new File(getPackageShortcut(CALLING_PACKAGE_2, "bmp64x64", USER_0)
-                        .getBitmapPath()).length();
-
-        // Read the expected output and inject the bitmap size.
-        final String expected = readTestAsset("shortcut/dumpsys_expected.txt")
-                .replace("***BITMAP_SIZE***", String.valueOf(bitmapTotal));
-
-        assertEquals(expected, dumpCheckin());
-    }
-
-    public void testDumpsysNoPermission() {
-        assertExpectException(SecurityException.class, "android.permission.DUMP",
-                () -> mService.dump(null, new PrintWriter(new StringWriter()), null));
-
-        // System can call it without the permission.
-        runWithSystemUid(() -> {
-            mService.dump(null, new PrintWriter(new StringWriter()), null);
-        });
-    }
-
-    /**
-     * Make sure the legacy file format that only supported a single intent per shortcut
-     * can still be read.
-     */
-    public void testLoadLegacySavedFile() throws Exception {
-        final File path = mService.getUserFile(USER_0);
-        path.getParentFile().mkdirs();
-        try (Writer w = new FileWriter(path)) {
-            w.write(readTestAsset("shortcut/shortcut_legacy_file.xml"));
-        };
-        initService();
-        mService.handleUnlockUser(USER_0);
-
-        runWithCaller(CALLING_PACKAGE_1, USER_0, () -> {
-            assertWith(getCallerShortcuts())
-                    .haveIds("manifest-shortcut-storage")
-                    .forShortcutWithId("manifest-shortcut-storage", si -> {
-                        assertEquals("android.settings.INTERNAL_STORAGE_SETTINGS",
-                                si.getIntent().getAction());
-                        assertEquals(12345, si.getIntent().getIntExtra("key", 0));
-                    });
-        });
-    }
-
-    public void testIsUserUnlocked() {
-        mRunningUsers.clear();
-        mUnlockedUsers.clear();
-
-        assertFalse(mService.isUserUnlockedL(USER_0));
-        assertFalse(mService.isUserUnlockedL(USER_10));
-
-        // Start user 0, still locked.
-        mRunningUsers.put(USER_0, true);
-        assertFalse(mService.isUserUnlockedL(USER_0));
-        assertFalse(mService.isUserUnlockedL(USER_10));
-
-        // Unlock user.
-        mUnlockedUsers.put(USER_0, true);
-        assertTrue(mService.isUserUnlockedL(USER_0));
-        assertFalse(mService.isUserUnlockedL(USER_10));
-
-        // Clear again.
-        mRunningUsers.clear();
-        mUnlockedUsers.clear();
-
-        // Directly call the lifecycle event.  Now also locked.
-        mService.handleUnlockUser(USER_0);
-        assertTrue(mService.isUserUnlockedL(USER_0));
-        assertFalse(mService.isUserUnlockedL(USER_10));
-
-        // Directly call the stop lifecycle event.  Goes back to the initial state.
-        mService.handleCleanupUser(USER_0);
-        assertFalse(mService.isUserUnlockedL(USER_0));
-        assertFalse(mService.isUserUnlockedL(USER_10));
-    }
-}
diff --git a/services/tests/servicestests/src/com/android/server/pm/ShortcutManagerTest3.java b/services/tests/servicestests/src/com/android/server/pm/ShortcutManagerTest3.java
deleted file mode 100644
index eb4db7a0f4a..00000000000
--- a/services/tests/servicestests/src/com/android/server/pm/ShortcutManagerTest3.java
+++ /dev/null
@@ -1,505 +0,0 @@
-/*
- * Copyright (C) 2016 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.android.server.pm;
-
-import static com.android.server.pm.shortcutmanagertest.ShortcutManagerTestUtils.assertWith;
-import static com.android.server.pm.shortcutmanagertest.ShortcutManagerTestUtils.list;
-
-import android.content.ComponentName;
-import android.content.pm.ShortcutInfo;
-import android.test.suitebuilder.annotation.SmallTest;
-
-import com.android.frameworks.servicestests.R;
-import com.android.server.pm.ShortcutService.ConfigConstants;
-
-/**
- * Tests related to shortcut rank auto-adjustment.
- */
-@SmallTest
-public class ShortcutManagerTest3 extends BaseShortcutManagerTest {
-
-    private static final String CALLING_PACKAGE = CALLING_PACKAGE_1;
-
-    private static final ComponentName A1 = new ComponentName(CALLING_PACKAGE,
-            ShortcutActivity.class.getName());
-
-    private static final ComponentName A2 = new ComponentName(CALLING_PACKAGE,
-            ShortcutActivity2.class.getName());
-
-    private static final ComponentName A3 = new ComponentName(CALLING_PACKAGE,
-            ShortcutActivity3.class.getName());
-
-    private ShortcutInfo shortcut(String id, ComponentName activity, int rank) {
-        return makeShortcutWithActivityAndRank(id, activity, rank);
-    }
-
-    private ShortcutInfo shortcut(String id, ComponentName activity) {
-        return makeShortcutWithActivityAndRank(id, activity, ShortcutInfo.RANK_NOT_SET);
-    }
-
-    @Override
-    protected void setUp() throws Exception {
-        super.setUp();
-
-        // We don't need throttling during this test class, and also relax the max cap.
-        mService.updateConfigurationLocked(
-                ConfigConstants.KEY_MAX_UPDATES_PER_INTERVAL + "=99999999,"
-                + ConfigConstants.KEY_MAX_SHORTCUTS + "=99999999"
-        );
-
-        setCaller(CALLING_PACKAGE, USER_0);
-    }
-
-    private void publishManifestShortcuts(ComponentName activity, int resId) {
-        addManifestShortcutResource(activity, resId);
-        updatePackageVersion(CALLING_PACKAGE, 1);
-        mService.mPackageMonitor.onReceive(getTestContext(),
-                genPackageAddIntent(CALLING_PACKAGE, USER_0));
-    }
-
-    public void testSetDynamicShortcuts_noManifestShortcuts() {
-        mManager.setDynamicShortcuts(list(
-                shortcut("s1", A1)
-        ));
-
-        assertWith(getCallerShortcuts()).selectDynamic().selectByActivity(A1)
-                .haveRanksInOrder("s1");
-
-        assertTrue(mManager.setDynamicShortcuts(list(
-                shortcut("s5", A1),
-                shortcut("s4", A1),
-                shortcut("s3", A1)
-        )));
-        assertWith(getCallerShortcuts()).selectDynamic().selectByActivity(A1)
-                .haveRanksInOrder("s5", "s4", "s3");
-
-        // RANK_NOT_SET is always the last.
-        assertTrue(mManager.setDynamicShortcuts(list(
-                shortcut("s5", A1),
-                shortcut("s4", A1, 5),
-                shortcut("s3", A1, 3),
-                shortcut("s2", A1)
-        )));
-        assertWith(getCallerShortcuts()).selectDynamic().selectByActivity(A1)
-                .haveRanksInOrder("s3", "s4", "s5", "s2");
-
-        // Same rank, preserve the argument order.
-        assertTrue(mManager.setDynamicShortcuts(list(
-                shortcut("s5", A1, 5),
-                shortcut("s4", A1, 0),
-                shortcut("s3", A1, 5)
-        )));
-        assertWith(getCallerShortcuts()).selectDynamic().selectByActivity(A1)
-                .haveRanksInOrder("s4", "s5", "s3");
-
-        // Multiple activities.
-        assertTrue(mManager.setDynamicShortcuts(list(
-                shortcut("s5", A1),
-                shortcut("s4", A2),
-                shortcut("s3", A3)
-        )));
-        assertWith(getCallerShortcuts()).selectDynamic().selectByActivity(A1)
-                .haveRanksInOrder("s5");
-        assertWith(getCallerShortcuts()).selectDynamic().selectByActivity(A2)
-                .haveRanksInOrder("s4");
-        assertWith(getCallerShortcuts()).selectDynamic().selectByActivity(A3)
-                .haveRanksInOrder("s3");
-
-        assertTrue(mManager.setDynamicShortcuts(list(
-                shortcut("s5", A1, 5),
-                shortcut("s4", A1),
-                shortcut("s3", A1, 5),
-                shortcut("x5", A2, 5),
-                shortcut("x4", A2),
-                shortcut("x3", A2, 1)
-        )));
-        assertWith(getCallerShortcuts()).selectDynamic().selectByActivity(A1)
-                .haveRanksInOrder("s5", "s3", "s4");
-        assertWith(getCallerShortcuts()).selectDynamic().selectByActivity(A2)
-                .haveRanksInOrder("x3", "x5", "x4");
-
-        // Clear.  Make sure it wouldn't lead to invalid internals state.
-        // (ShortcutService.verifyStates() will do so internally.)
-        assertTrue(mManager.setDynamicShortcuts(list()));
-        assertWith(getCallerShortcuts()).selectDynamic().selectByActivity(A1).isEmpty();
-        assertWith(getCallerShortcuts()).selectDynamic().selectByActivity(A2).isEmpty();
-    }
-
-    private void runTestWithManifestShortcuts(Runnable r) {
-        publishManifestShortcuts(A1, R.xml.shortcut_5_alt);
-        publishManifestShortcuts(A2, R.xml.shortcut_1);
-
-        assertWith(getCallerShortcuts()).selectManifest().selectByActivity(A1)
-                .haveRanksInOrder("ms1_alt", "ms2_alt", "ms3_alt", "ms4_alt", "ms5_alt");
-
-        assertWith(getCallerShortcuts()).selectManifest().selectByActivity(A2)
-                .haveRanksInOrder("ms1");
-
-        // Existence of manifest shortcuts shouldn't affect dynamic shortcut ranks,
-        // so running another test here should pass.
-        r.run();
-
-        // And dynamic shortcut tests shouldn't affect manifest shortcuts, so repeat the
-        // same check.
-        assertWith(getCallerShortcuts()).selectManifest().selectByActivity(A1)
-                .haveRanksInOrder("ms1_alt", "ms2_alt", "ms3_alt", "ms4_alt", "ms5_alt");
-
-        assertWith(getCallerShortcuts()).selectManifest().selectByActivity(A2)
-                .haveRanksInOrder("ms1");
-    }
-
-    public void testSetDynamicShortcuts_withManifestShortcuts() {
-        runTestWithManifestShortcuts(() -> testSetDynamicShortcuts_noManifestShortcuts());
-    }
-
-    public void testAddDynamicShortcuts_noManifestShortcuts() {
-        mManager.addDynamicShortcuts(list(
-                shortcut("s1", A1)
-        ));
-        assertWith(getCallerShortcuts()).selectDynamic().selectByActivity(A1)
-                .haveRanksInOrder("s1");
-
-        //------------------------------------------------------
-        long lastApiTime = ++mInjectedCurrentTimeMillis;
-
-        mManager.addDynamicShortcuts(list(
-                shortcut("s5", A1, 0),
-                shortcut("s4", A1),
-                shortcut("s2", A1, 3),
-                shortcut("x1", A2),
-                shortcut("x3", A2, 2),
-                shortcut("x2", A2, 2),
-                shortcut("s3", A1, 0)
-        ));
-        assertWith(getCallerShortcuts()).selectDynamic().selectByActivity(A1)
-                .haveRanksInOrder("s5", "s3", "s1", "s2", "s4");
-
-        assertWith(getCallerShortcuts()).selectDynamic().selectByActivity(A2)
-                .haveRanksInOrder("x3", "x2", "x1");
-
-        assertWith(getCallerShortcuts()).selectDynamic().selectByChangedSince(lastApiTime)
-                .haveIds("s5", "s3", "s1", "s2", "s4", "x3", "x2", "x1");
-
-        //------------------------------------------------------
-        lastApiTime = ++mInjectedCurrentTimeMillis;
-
-        mManager.addDynamicShortcuts(list(
-                shortcut("s1", A1, 1)
-        ));
-        assertWith(getCallerShortcuts()).selectDynamic().selectByActivity(A1)
-                .haveRanksInOrder("s5", "s1", "s3", "s2", "s4");
-
-        assertWith(getCallerShortcuts()).selectDynamic().selectByActivity(A2)
-                .haveRanksInOrder("x3", "x2", "x1");
-
-        assertWith(getCallerShortcuts()).selectDynamic().selectByChangedSince(lastApiTime)
-                .haveIds("s1", "s3");
-
-        //------------------------------------------------------
-        lastApiTime = ++mInjectedCurrentTimeMillis;
-
-        mManager.addDynamicShortcuts(list(
-                shortcut("s1", A1, 1),
-
-                // This is add, not update, so the following means s5 will have NO_RANK,
-                // which puts it at the end.
-                shortcut("s5", A1),
-                shortcut("s3", A1, 0),
-
-                // s10 also has NO_RANK, so it'll be put at the end, even after "s5" as we preserve
-                // the argument order.
-                shortcut("s10", A1),
-
-                // Note we're changing the activity for x2.
-                shortcut("x2", A1, 0),
-                shortcut("x10", A2)
-        ));
-        assertWith(getCallerShortcuts()).selectDynamic().selectByActivity(A1)
-                .haveRanksInOrder("s3", "x2", "s1", "s2", "s4", "s5", "s10");
-
-        assertWith(getCallerShortcuts()).selectDynamic().selectByActivity(A2)
-                .haveRanksInOrder("x3", "x1", "x10");
-
-        assertWith(getCallerShortcuts()).selectDynamic().selectByChangedSince(lastApiTime)
-                .haveIds("s3", "x2", "s1", "s5", "s10", "x1", "x10");
-
-        //------------------------------------------------------
-        lastApiTime = ++mInjectedCurrentTimeMillis;
-
-        // Change the activities again.
-        mManager.addDynamicShortcuts(list(
-                shortcut("s1", A2),
-                shortcut("s2", A2, 999)
-        ));
-        assertWith(getCallerShortcuts()).selectDynamic().selectByActivity(A1)
-                .haveRanksInOrder("s3", "x2", "s4", "s5", "s10");
-
-        assertWith(getCallerShortcuts()).selectDynamic().selectByActivity(A2)
-                .haveRanksInOrder("x3", "x1", "x10", "s2", "s1");
-
-        assertWith(getCallerShortcuts()).selectDynamic().selectByChangedSince(lastApiTime)
-                .haveIds("s1", "s2", "s4", "s5", "s10");
-    }
-
-    public void testAddDynamicShortcuts_withManifestShortcuts() {
-        runTestWithManifestShortcuts(() -> testAddDynamicShortcuts_noManifestShortcuts());
-    }
-
-    public void testUpdateShortcuts_noManifestShortcuts() {
-        mManager.addDynamicShortcuts(list(
-                shortcut("s5", A1, 0),
-                shortcut("s4", A1),
-                shortcut("s2", A1, 3),
-                shortcut("x1", A2),
-                shortcut("x3", A2, 2),
-                shortcut("x2", A2, 2),
-                shortcut("s3", A1, 0)
-        ));
-        assertWith(getCallerShortcuts()).selectDynamic().selectByActivity(A1)
-                .haveRanksInOrder("s5", "s3", "s2", "s4");
-
-        assertWith(getCallerShortcuts()).selectDynamic().selectByActivity(A2)
-                .haveRanksInOrder("x3", "x2", "x1");
-
-        //------------------------------------------------------
-        long lastApiTime = ++mInjectedCurrentTimeMillis;
-
-        mManager.updateShortcuts(list());
-        // Same order.
-        assertWith(getCallerShortcuts()).selectDynamic().selectByActivity(A1)
-                .haveRanksInOrder("s5", "s3", "s2", "s4");
-
-        assertWith(getCallerShortcuts()).selectDynamic().selectByActivity(A2)
-                .haveRanksInOrder("x3", "x2", "x1");
-
-        assertWith(getCallerShortcuts()).selectDynamic().selectByChangedSince(lastApiTime)
-                .isEmpty();
-
-
-        runWithCaller(LAUNCHER_1, USER_0, () -> {
-            mLauncherApps.pinShortcuts(CALLING_PACKAGE, list("s2", "s4", "x2"), HANDLE_USER_0);
-        });
-        // Still same order.
-        assertWith(getCallerShortcuts()).selectDynamic().selectByActivity(A1)
-                .haveRanksInOrder("s5", "s3", "s2", "s4");
-
-        assertWith(getCallerShortcuts()).selectDynamic().selectByActivity(A2)
-                .haveRanksInOrder("x3", "x2", "x1");
-
-        //------------------------------------------------------
-        lastApiTime = ++mInjectedCurrentTimeMillis;
-
-        mManager.updateShortcuts(list(
-                shortcut("s4", A1, 1),
-
-                // Rank not changing, should keep the same positions.
-                // c.f. in case of addDynamicShortcuts, this means "put them at the end".
-                shortcut("s3", A1),
-                shortcut("x2", A2)
-        ));
-        assertWith(getCallerShortcuts()).selectDynamic().selectByActivity(A1)
-                .haveRanksInOrder("s5", "s4", "s3", "s2");
-
-        assertWith(getCallerShortcuts()).selectDynamic().selectByActivity(A2)
-                .haveRanksInOrder("x3", "x2", "x1");
-
-        assertWith(getCallerShortcuts()).selectDynamic().selectByChangedSince(lastApiTime)
-                .haveIds("s4", "s3", "s2", "x2");
-
-        //------------------------------------------------------
-        lastApiTime = ++mInjectedCurrentTimeMillis;
-
-        mManager.updateShortcuts(list(
-                shortcut("s4", A1, 0),
-
-                // Change the activity without specifying a rank -> keep the same rank.
-                shortcut("s5", A2),
-
-                // Change the activity without specifying a rank -> assign a new rank.
-                shortcut("x2", A1, 2),
-
-                // "xx" doesn't exist, so it'll be ignored.
-                shortcut("xx", A1, 0)
-        ));
-        assertWith(getCallerShortcuts()).selectDynamic().selectByActivity(A1)
-                .haveRanksInOrder("s4", "x2", "s3", "s2");
-
-        // Interesting case: both x3 and s5 originally had rank=0, and in this case s5 has moved
-        // to A2 without changing the rank.  So they're tie for the new rank, as well as
-        // the "rank changed" bit.  Also in this case, "s5" won't have an implicit order, since
-        // its rank isn't changing.  So we sort them by ID, thus s5 comes before x3.
-        assertWith(getCallerShortcuts()).selectDynamic().selectByActivity(A2)
-                .haveRanksInOrder("s5", "x3", "x1");
-
-        assertWith(getCallerShortcuts()).selectDynamic().selectByChangedSince(lastApiTime)
-                .haveIds("s4", "x2", "s5", "x3");
-
-        //------------------------------------------------------
-        lastApiTime = ++mInjectedCurrentTimeMillis;
-
-        mManager.updateShortcuts(list(
-                shortcut("s3", A3)));
-
-        assertWith(getCallerShortcuts()).selectDynamic().selectByActivity(A1)
-                .haveRanksInOrder("s4", "x2", "s2");
-        assertWith(getCallerShortcuts()).selectDynamic().selectByActivity(A2)
-                .haveRanksInOrder("s5", "x3", "x1");
-        assertWith(getCallerShortcuts()).selectDynamic().selectByActivity(A3)
-                .haveRanksInOrder("s3");
-
-        assertWith(getCallerShortcuts()).selectDynamic().selectByChangedSince(lastApiTime)
-                .haveIds("s3", "s2");
-    }
-
-    public void testUpdateShortcuts_withManifestShortcuts() {
-        runTestWithManifestShortcuts(() -> testUpdateShortcuts_noManifestShortcuts());
-    }
-
-    public void testDeleteDynamicShortcuts_noManifestShortcuts() {
-        mManager.addDynamicShortcuts(list(
-                shortcut("s5", A1, 0),
-                shortcut("s4", A1),
-                shortcut("s2", A1, 3),
-                shortcut("x1", A2),
-                shortcut("x3", A2, 2),
-                shortcut("x2", A2, 2),
-                shortcut("s3", A1, 0)
-        ));
-        assertWith(getCallerShortcuts()).selectDynamic().selectByActivity(A1)
-                .haveRanksInOrder("s5", "s3", "s2", "s4");
-
-        assertWith(getCallerShortcuts()).selectDynamic().selectByActivity(A2)
-                .haveRanksInOrder("x3", "x2", "x1");
-
-        //------------------------------------------------------
-        long lastApiTime = ++mInjectedCurrentTimeMillis;
-
-        mManager.removeDynamicShortcuts(list());
-
-        assertWith(getCallerShortcuts()).selectDynamic().selectByActivity(A1)
-                .haveRanksInOrder("s5", "s3", "s2", "s4");
-
-        assertWith(getCallerShortcuts()).selectDynamic().selectByActivity(A2)
-                .haveRanksInOrder("x3", "x2", "x1");
-
-        assertWith(getCallerShortcuts()).selectDynamic().selectByChangedSince(lastApiTime)
-                .isEmpty();
-
-        runWithCaller(LAUNCHER_1, USER_0, () -> {
-            mLauncherApps.pinShortcuts(
-                    CALLING_PACKAGE, list("s2", "s4", "x1", "x2"), HANDLE_USER_0);
-        });
-        // Still same order.
-
-        assertWith(getCallerShortcuts()).selectDynamic().selectByActivity(A1)
-                .haveRanksInOrder("s5", "s3", "s2", "s4");
-
-        assertWith(getCallerShortcuts()).selectDynamic().selectByActivity(A2)
-                .haveRanksInOrder("x3", "x2", "x1");
-
-        //------------------------------------------------------
-        lastApiTime = ++mInjectedCurrentTimeMillis;
-
-        mManager.removeDynamicShortcuts(list("s3", "x1", "xxxx"));
-
-        assertWith(getCallerShortcuts()).selectDynamic().selectByActivity(A1)
-                .haveRanksInOrder("s5", "s2", "s4");
-
-        assertWith(getCallerShortcuts()).selectDynamic().selectByActivity(A2)
-                .haveRanksInOrder("x3", "x2");
-
-        assertWith(getCallerShortcuts()).selectDynamic().selectByChangedSince(lastApiTime)
-                .haveIds("s2", "s4");
-    }
-
-    public void testDeleteDynamicShortcuts_withManifestShortcuts() {
-        runTestWithManifestShortcuts(() -> testDeleteDynamicShortcuts_noManifestShortcuts());
-    }
-
-    public void testDisableShortcuts_noManifestShortcuts() {
-        mManager.addDynamicShortcuts(list(
-                shortcut("s5", A1, 0),
-                shortcut("s4", A1),
-                shortcut("s2", A1, 3),
-                shortcut("x1", A2),
-                shortcut("x3", A2, 2),
-                shortcut("x2", A2, 2),
-                shortcut("s3", A1, 0)
-        ));
-        assertWith(getCallerShortcuts()).selectDynamic().selectByActivity(A1)
-                .haveRanksInOrder("s5", "s3", "s2", "s4");
-
-        assertWith(getCallerShortcuts()).selectDynamic().selectByActivity(A2)
-                .haveRanksInOrder("x3", "x2", "x1");
-
-        //------------------------------------------------------
-        long lastApiTime = ++mInjectedCurrentTimeMillis;
-
-        mManager.disableShortcuts(list());
-
-        assertWith(getCallerShortcuts()).selectDynamic().selectByActivity(A1)
-                .haveRanksInOrder("s5", "s3", "s2", "s4");
-
-        assertWith(getCallerShortcuts()).selectDynamic().selectByActivity(A2)
-                .haveRanksInOrder("x3", "x2", "x1");
-
-        assertWith(getCallerShortcuts()).selectDynamic().selectByChangedSince(lastApiTime)
-                .isEmpty();
-
-        //------------------------------------------------------
-        lastApiTime = ++mInjectedCurrentTimeMillis;
-
-        mManager.disableShortcuts(list("s3", "x1", "xxxx"));
-
-        assertWith(getCallerShortcuts()).selectDynamic().selectByActivity(A1)
-                .haveRanksInOrder("s5", "s2", "s4");
-
-        assertWith(getCallerShortcuts()).selectDynamic().selectByActivity(A2)
-                .haveRanksInOrder("x3", "x2");
-
-        assertWith(getCallerShortcuts()).selectDynamic().selectByChangedSince(lastApiTime)
-                .haveIds("s2", "s4");
-
-        runWithCaller(LAUNCHER_1, USER_0, () -> {
-            mLauncherApps.pinShortcuts(CALLING_PACKAGE, list("s2", "s4", "x2"), HANDLE_USER_0);
-        });
-        // Still same order.
-        assertWith(getCallerShortcuts()).selectDynamic().selectByActivity(A1)
-                .haveRanksInOrder("s5", "s2", "s4");
-
-        assertWith(getCallerShortcuts()).selectDynamic().selectByActivity(A2)
-                .haveRanksInOrder("x3", "x2");
-
-        //------------------------------------------------------
-        lastApiTime = ++mInjectedCurrentTimeMillis;
-
-        mManager.disableShortcuts(list("s2", "x3"));
-
-        assertWith(getCallerShortcuts()).selectDynamic().selectByActivity(A1)
-                .haveRanksInOrder("s5", "s4");
-
-        assertWith(getCallerShortcuts()).selectDynamic().selectByActivity(A2)
-                .haveRanksInOrder("x2");
-
-        assertWith(getCallerShortcuts()).selectDynamic().selectByChangedSince(lastApiTime)
-                .haveIds("s4", "x2");
-    }
-
-    public void testDisableShortcuts_withManifestShortcuts() {
-        runTestWithManifestShortcuts(() -> testDisableShortcuts_noManifestShortcuts());
-    }
-
-}
diff --git a/services/tests/servicestests/src/com/android/server/pm/ShortcutManagerTest4.java b/services/tests/servicestests/src/com/android/server/pm/ShortcutManagerTest4.java
deleted file mode 100644
index 583c3d41c40..00000000000
--- a/services/tests/servicestests/src/com/android/server/pm/ShortcutManagerTest4.java
+++ /dev/null
@@ -1,126 +0,0 @@
-/*
- * Copyright (C) 2016 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.android.server.pm;
-
-import static com.android.server.pm.shortcutmanagertest.ShortcutManagerTestUtils.assertBundlesEqual;
-import static com.android.server.pm.shortcutmanagertest.ShortcutManagerTestUtils.assertWith;
-import static com.android.server.pm.shortcutmanagertest.ShortcutManagerTestUtils.list;
-import static com.android.server.pm.shortcutmanagertest.ShortcutManagerTestUtils.makeBundle;
-import static com.android.server.pm.shortcutmanagertest.ShortcutManagerTestUtils.makePersistableBundle;
-
-import android.content.Intent;
-import android.os.Bundle;
-import android.os.PersistableBundle;
-import android.test.suitebuilder.annotation.SmallTest;
-
-@SmallTest
-public class ShortcutManagerTest4 extends BaseShortcutManagerTest {
-
-    private static Bundle sIntentExtras = makeBundle(
-            "key{\u0000}", "value{\u0000}",
-            "key{\u0001}", "value{\u0001}",
-            "key{\u001f}", "value{\u001f}",
-            "key{\u007f}", "value{\u007f}",
-
-            "key{\ud800\udc00}", "value{\ud800\udc00}",
-            "key{\ud801\udc01}", "value{\ud801\udc01}",
-            "key{\udbff\udfff}", "value{\udbff\udfff}",
-
-            "key{\ud801}x", 1, // broken surrogate pair
-            "key{\uDC01}\"x", 2, // broken surrogate pair
-
-            "x1", "value{\ud801}x", // broken surrogate pair
-            "x2", "value{\uDC01}\"x" // broken surrogate pair
-    );
-
-    // Same as above, except broken surrogate pairs are replaced with '?'s.
-    private static Bundle sIntentExtrasDecoded = makeBundle(
-            "key{\u0000}", "value{\u0000}",
-            "key{\u0001}", "value{\u0001}",
-            "key{\u001f}", "value{\u001f}",
-            "key{\u007f}", "value{\u007f}",
-
-            "key{\ud800\udc00}", "value{\ud800\udc00}",
-            "key{\ud801\udc01}", "value{\ud801\udc01}",
-            "key{\udbff\udfff}", "value{\udbff\udfff}",
-
-            "key{?}x", 1,
-            "key{?}\"x", 2,
-
-            "x1", "value{?}x",
-            "x2", "value{?}\"x"
-    );
-
-    private static PersistableBundle sShortcutExtras = makePersistableBundle(
-            "key{\u0000}", "value{\u0000}",
-            "key{\u0001}", "value{\u0001}",
-            "key{\u001f}", "value{\u001f}",
-            "key{\u007f}", "value{\u007f}",
-
-            "key{\ud800\udc00}", "value{\ud800\udc00}",
-            "key{\ud801\udc01}", "value{\ud801\udc01}",
-            "key{\udbff\udfff}", "value{\udbff\udfff}",
-
-            "key{\ud801}", 1, // broken surrogate pair
-            "key{\uDC01}", 2, // broken surrogate pair
-
-            "x1", "value{\ud801}", // broken surrogate pair
-            "x2", "value{\uDC01}" // broken surrogate pair
-    );
-
-    // Same as above, except broken surrogate pairs are replaced with '?'s.
-    private static PersistableBundle sShortcutExtrasDecoded = makePersistableBundle(
-            "key{\u0000}", "value{\u0000}",
-            "key{\u0001}", "value{\u0001}",
-            "key{\u001f}", "value{\u001f}",
-            "key{\u007f}", "value{\u007f}",
-
-            "key{\ud800\udc00}", "value{\ud800\udc00}",
-            "key{\ud801\udc01}", "value{\ud801\udc01}",
-            "key{\udbff\udfff}", "value{\udbff\udfff}",
-
-            "key{?}", 1,
-            "key{?}", 2,
-
-            "x1", "value{?}",
-            "x2", "value{?}"
-    );
-
-    public void testPersistingWeirdCharacters() {
-        final Intent intent = new Intent(Intent.ACTION_MAIN)
-                .putExtras(sIntentExtras);
-
-        runWithCaller(CALLING_PACKAGE_1, USER_0, () -> {
-            assertTrue(mManager.setDynamicShortcuts(list(
-                    makeShortcutWithExtras("s1", intent, sShortcutExtras),
-                    makeShortcut("s{\u0000}{\u0001}{\uD800\uDC00}x[\uD801][\uDC01]")
-            )));
-        });
-
-        // Make sure save & load works fine. (i.e. shouldn't crash even with invalid characters.)
-        initService();
-        mService.handleUnlockUser(USER_0);
-
-        runWithCaller(CALLING_PACKAGE_1, USER_0, () -> {
-            assertWith(getCallerShortcuts())
-                    .haveIds("s1", "s{\u0000}{\u0001}{\uD800\uDC00}x[?][?]")
-                    .forShortcutWithId("s1", si -> {
-                        assertBundlesEqual(si.getIntent().getExtras(), sIntentExtrasDecoded);
-                        assertBundlesEqual(si.getExtras(), sShortcutExtrasDecoded);
-                    });
-        });
-    }
-}
\ No newline at end of file
diff --git a/services/tests/servicestests/src/com/android/server/pm/ShortcutManagerTest5.java b/services/tests/servicestests/src/com/android/server/pm/ShortcutManagerTest5.java
deleted file mode 100644
index 29c98dcf522..00000000000
--- a/services/tests/servicestests/src/com/android/server/pm/ShortcutManagerTest5.java
+++ /dev/null
@@ -1,202 +0,0 @@
-/*
- * Copyright (C) 2016 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.android.server.pm;
-
-import static com.android.server.pm.shortcutmanagertest.ShortcutManagerTestUtils.set;
-
-import android.app.Activity;
-import android.content.ComponentName;
-import android.content.pm.ActivityInfo;
-import android.content.pm.ApplicationInfo;
-import android.content.pm.PackageInfo;
-import android.content.pm.ShortcutServiceInternal;
-import android.content.res.XmlResourceParser;
-import android.os.Looper;
-import android.test.suitebuilder.annotation.SmallTest;
-
-import com.android.server.LocalServices;
-
-import java.util.List;
-import java.util.Set;
-
-/**
- * Unit tests for all the IPackageManager related methods in {@link ShortcutService}.
- *
- * All the tests here actually talks to the real IPackageManager, so we can't test complicated
- * cases.  Instead we just make sure they all work reasonably without at least crashing.
- */
-@SmallTest
-public class ShortcutManagerTest5 extends BaseShortcutManagerTest {
-    private ShortcutService mShortcutService;
-
-    private String mMyPackage;
-    private int mMyUserId;
-
-    public static class ShortcutEnabled extends Activity {
-    }
-
-    public static class ShortcutDisabled extends Activity {
-    }
-
-    @Override
-    protected void setUp() throws Exception {
-        super.setUp();
-
-        LocalServices.removeServiceForTest(ShortcutServiceInternal.class);
-        mShortcutService = new ShortcutService(getTestContext(), Looper.getMainLooper(),
-                /* onyForPackageManagerApis */ true);
-
-        mMyPackage = getTestContext().getPackageName();
-        mMyUserId = android.os.Process.myUserHandle().getIdentifier();
-    }
-
-    public void testGetPackageUid() {
-        assertTrue(mShortcutService.injectGetPackageUid(
-                mMyPackage, mMyUserId) != 0);
-
-        assertEquals(-1, mShortcutService.injectGetPackageUid(
-                "no.such.package", mMyUserId));
-    }
-
-    public void testGetPackageInfo() {
-        PackageInfo pi = mShortcutService.getPackageInfo(
-                mMyPackage, mMyUserId, /*signature*/ false);
-        assertEquals(mMyPackage, pi.packageName);
-        assertNull(pi.signatures);
-
-        pi = mShortcutService.getPackageInfo(
-                mMyPackage, mMyUserId, /*signature*/ true);
-        assertEquals(mMyPackage, pi.packageName);
-        assertNotNull(pi.signatures);
-
-        pi = mShortcutService.getPackageInfo(
-                "no.such.package", mMyUserId, /*signature*/ true);
-        assertNull(pi);
-    }
-
-    public void testGetApplicationInfo() {
-        ApplicationInfo ai = mShortcutService.getApplicationInfo(
-                mMyPackage, mMyUserId);
-        assertEquals(mMyPackage, ai.packageName);
-
-        ai = mShortcutService.getApplicationInfo(
-                "no.such.package", mMyUserId);
-        assertNull(ai);
-    }
-
-    public void testGetActivityInfoWithMetadata() {
-        // Disabled activity
-        ActivityInfo ai = mShortcutService.getActivityInfoWithMetadata(
-                new ComponentName(mMyPackage, "ShortcutDisabled"), mMyUserId);
-        assertNull(ai);
-
-        // Nonexistent
-        ai = mShortcutService.getActivityInfoWithMetadata(
-                new ComponentName("no.such.package", "ShortcutDisabled"), mMyUserId);
-        assertNull(ai);
-
-        // Existent, with no metadata.
-        ai = mShortcutService.getActivityInfoWithMetadata(
-                new ComponentName(mMyPackage, "a.ShortcutEnabled"), mMyUserId);
-        assertEquals(mMyPackage, ai.packageName);
-        assertEquals("a.ShortcutEnabled", ai.name);
-        assertNull(ai.loadXmlMetaData(getTestContext().getPackageManager(),
-                "android.app.shortcuts"));
-
-        // Existent, with a shortcut metadata.
-        ai = mShortcutService.getActivityInfoWithMetadata(
-                new ComponentName(mMyPackage, "a.Shortcut1"), mMyUserId);
-        assertEquals(mMyPackage, ai.packageName);
-        assertEquals("a.Shortcut1", ai.name);
-        XmlResourceParser meta = ai.loadXmlMetaData(getTestContext().getPackageManager(),
-                "android.app.shortcuts");
-        assertNotNull(meta);
-        meta.close();
-    }
-
-    public void testGetInstalledPackages() {
-        List<PackageInfo> apks = mShortcutService.getInstalledPackages(mMyUserId);
-
-        Set<String> expectedPackages = set("com.android.settings", mMyPackage);
-        for (PackageInfo pi : apks) {
-            expectedPackages.remove(pi.packageName);
-        }
-        assertEquals(set(), expectedPackages);
-    }
-
-    public void testGetDefaultMainActivity() {
-        ComponentName cn = mShortcutService.injectGetDefaultMainActivity(
-                "com.android.settings", mMyUserId);
-
-        assertEquals(
-                ComponentName.unflattenFromString("com.android.settings/.Settings"),
-                cn);
-
-        // This package has no main activity.
-        assertNull(mShortcutService.injectGetDefaultMainActivity(
-                mMyPackage, mMyUserId));
-
-        // Nonexistent.
-        assertNull(mShortcutService.injectGetDefaultMainActivity(
-                "no.such.package", mMyUserId));
-    }
-
-    public void testIsMainActivity() {
-        assertTrue(mShortcutService.injectIsMainActivity(
-                ComponentName.unflattenFromString("com.android.settings/.Settings"), mMyUserId));
-        assertFalse(mShortcutService.injectIsMainActivity(
-                ComponentName.unflattenFromString("com.android.settings/.xxx"), mMyUserId));
-        assertFalse(mShortcutService.injectIsMainActivity(
-                ComponentName.unflattenFromString("no.such.package/.xxx"), mMyUserId));
-
-        assertFalse(mShortcutService.injectIsMainActivity(
-                new ComponentName(mMyPackage, "a.DisabledMain"), mMyUserId));
-        assertFalse(mShortcutService.injectIsMainActivity(
-                new ComponentName(mMyPackage, "a.UnexportedMain"), mMyUserId));
-
-    }
-
-    public void testGetMainActivities() {
-        assertEquals(1, mShortcutService.injectGetMainActivities(
-                "com.android.settings", mMyUserId).size());
-
-        // This APK has no main activities.
-        assertEquals(0, mShortcutService.injectGetMainActivities(
-                mMyPackage, mMyUserId).size());
-    }
-
-    public void testIsActivityEnabledAndExported() {
-        assertTrue(mShortcutService.injectIsActivityEnabledAndExported(
-                ComponentName.unflattenFromString("com.android.settings/.Settings"), mMyUserId));
-        assertFalse(mShortcutService.injectIsActivityEnabledAndExported(
-                ComponentName.unflattenFromString("com.android.settings/.xxx"), mMyUserId));
-        assertFalse(mShortcutService.injectIsActivityEnabledAndExported(
-                ComponentName.unflattenFromString("no.such.package/.xxx"), mMyUserId));
-
-        assertTrue(mShortcutService.injectIsActivityEnabledAndExported(
-                new ComponentName(mMyPackage, "com.android.server.pm.ShortcutTestActivity"),
-                mMyUserId));
-
-        assertTrue(mShortcutService.injectIsActivityEnabledAndExported(
-                new ComponentName(mMyPackage, "a.ShortcutEnabled"), mMyUserId));
-
-        assertFalse(mShortcutService.injectIsActivityEnabledAndExported(
-                new ComponentName(mMyPackage, "a.ShortcutDisabled"), mMyUserId));
-        assertFalse(mShortcutService.injectIsActivityEnabledAndExported(
-                new ComponentName(mMyPackage, "a.ShortcutUnexported"), mMyUserId));
-
-    }
-}
diff --git a/services/tests/servicestests/src/com/android/server/pm/ShortcutManagerTest6.java b/services/tests/servicestests/src/com/android/server/pm/ShortcutManagerTest6.java
deleted file mode 100644
index ba4dbc1d258..00000000000
--- a/services/tests/servicestests/src/com/android/server/pm/ShortcutManagerTest6.java
+++ /dev/null
@@ -1,281 +0,0 @@
-/*
- * Copyright (C) 2016 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.android.server.pm;
-
-import static com.android.server.pm.shortcutmanagertest.ShortcutManagerTestUtils.list;
-
-import static org.mockito.Matchers.any;
-import static org.mockito.Matchers.eq;
-import static org.mockito.Mockito.doAnswer;
-
-import android.content.ComponentName;
-import android.content.Intent;
-import android.content.pm.ActivityInfo;
-import android.content.pm.ApplicationInfo;
-import android.content.pm.ResolveInfo;
-import android.test.suitebuilder.annotation.SmallTest;
-
-import java.util.List;
-
-/**
- * Tests for {@link ShortcutService#hasShortcutHostPermissionInner}.
- */
-@SmallTest
-public class ShortcutManagerTest6 extends BaseShortcutManagerTest {
-    public void testHasShortcutHostPermissionInner_systemLauncherOnly() {
-        // Preferred isn't set, use the system launcher.
-        prepareGetHomeActivitiesAsUser(
-                /* preferred */ null,
-                list(getSystemLauncher(), getFallbackLauncher()),
-                USER_0);
-        assertTrue(mService.hasShortcutHostPermissionInner(PACKAGE_SYSTEM_LAUNCHER, USER_0));
-        assertFalse(mService.hasShortcutHostPermissionInner(PACKAGE_FALLBACK_LAUNCHER, USER_0));
-        assertFalse(mService.hasShortcutHostPermissionInner(CALLING_PACKAGE_1, USER_0));
-        assertFalse(mService.hasShortcutHostPermissionInner(CALLING_PACKAGE_2, USER_0));
-
-        // Should be cached.
-        assertEquals(cn(PACKAGE_SYSTEM_LAUNCHER, PACKAGE_SYSTEM_LAUNCHER_NAME),
-                mService.getUserShortcutsLocked(USER_0).getLastKnownLauncher());
-        assertEquals(cn(PACKAGE_SYSTEM_LAUNCHER, PACKAGE_SYSTEM_LAUNCHER_NAME),
-                mService.getUserShortcutsLocked(USER_0).getCachedLauncher());
-
-        // Also make sure the last known is saved, but the cached is not.
-
-        initService();
-
-        assertEquals(cn(PACKAGE_SYSTEM_LAUNCHER, PACKAGE_SYSTEM_LAUNCHER_NAME),
-                mService.getUserShortcutsLocked(USER_0).getLastKnownLauncher());
-        assertEquals(null,
-                mService.getUserShortcutsLocked(USER_0).getCachedLauncher());
-    }
-
-    public void testHasShortcutHostPermissionInner_with3pLauncher() {
-        // Preferred isn't set, still use the system launcher.
-        prepareGetHomeActivitiesAsUser(
-                /* preferred */ null,
-                list(getSystemLauncher(), getFallbackLauncher(),
-                        ri(CALLING_PACKAGE_1, "name", false, 0),
-                        ri(CALLING_PACKAGE_2, "name", false, 0)
-                ),
-                USER_0);
-        assertTrue(mService.hasShortcutHostPermissionInner(PACKAGE_SYSTEM_LAUNCHER, USER_0));
-        assertFalse(mService.hasShortcutHostPermissionInner(PACKAGE_FALLBACK_LAUNCHER, USER_0));
-        assertFalse(mService.hasShortcutHostPermissionInner(CALLING_PACKAGE_1, USER_0));
-        assertFalse(mService.hasShortcutHostPermissionInner(CALLING_PACKAGE_2, USER_0));
-
-        // Should be cached.
-        assertEquals(cn(PACKAGE_SYSTEM_LAUNCHER, PACKAGE_SYSTEM_LAUNCHER_NAME),
-                mService.getUserShortcutsLocked(USER_0).getLastKnownLauncher());
-        assertEquals(cn(PACKAGE_SYSTEM_LAUNCHER, PACKAGE_SYSTEM_LAUNCHER_NAME),
-                mService.getUserShortcutsLocked(USER_0).getCachedLauncher());
-    }
-
-    public void testHasShortcutHostPermissionInner_with3pLauncher_complicated() {
-        // Preferred is set.  That's the default launcher.
-        prepareGetHomeActivitiesAsUser(
-                /* preferred */ cn(CALLING_PACKAGE_2, "name"),
-                list(getSystemLauncher(), getFallbackLauncher(),
-                        ri(CALLING_PACKAGE_1, "name", false, 0),
-                        ri(CALLING_PACKAGE_2, "name", false, 0)
-                ),
-                USER_0);
-        assertFalse(mService.hasShortcutHostPermissionInner(PACKAGE_SYSTEM_LAUNCHER, USER_0));
-        assertFalse(mService.hasShortcutHostPermissionInner(PACKAGE_FALLBACK_LAUNCHER, USER_0));
-        assertFalse(mService.hasShortcutHostPermissionInner(CALLING_PACKAGE_1, USER_0));
-        assertTrue(mService.hasShortcutHostPermissionInner(CALLING_PACKAGE_2, USER_0));
-
-        // Should be cached.
-        assertEquals(cn(CALLING_PACKAGE_2, "name"),
-                mService.getUserShortcutsLocked(USER_0).getLastKnownLauncher());
-        assertEquals(cn(CALLING_PACKAGE_2, "name"),
-                mService.getUserShortcutsLocked(USER_0).getCachedLauncher());
-
-
-        // Once set, even after the preferred launcher is cleared, SM still allows it to access
-        // shortcuts.
-        prepareGetHomeActivitiesAsUser(
-                /* preferred */ null,
-                list(getSystemLauncher(), getFallbackLauncher(),
-                        ri(CALLING_PACKAGE_1, "name", false, 0),
-                        ri(CALLING_PACKAGE_2, "name", false, 0)
-                ),
-                USER_0);
-
-        assertFalse(mService.hasShortcutHostPermissionInner(PACKAGE_SYSTEM_LAUNCHER, USER_0));
-        assertFalse(mService.hasShortcutHostPermissionInner(PACKAGE_FALLBACK_LAUNCHER, USER_0));
-        assertFalse(mService.hasShortcutHostPermissionInner(CALLING_PACKAGE_1, USER_0));
-        assertTrue(mService.hasShortcutHostPermissionInner(CALLING_PACKAGE_2, USER_0));
-
-        // Should be cached.
-        assertEquals(cn(CALLING_PACKAGE_2, "name"),
-                mService.getUserShortcutsLocked(USER_0).getLastKnownLauncher());
-        assertEquals(cn(CALLING_PACKAGE_2, "name"),
-                mService.getUserShortcutsLocked(USER_0).getCachedLauncher());
-
-        // However, if the component has been disabled, then we'll recalculate it.
-        mEnabledActivityChecker = (comp, user) -> false;
-
-        assertTrue(mService.hasShortcutHostPermissionInner(PACKAGE_SYSTEM_LAUNCHER, USER_0));
-        assertFalse(mService.hasShortcutHostPermissionInner(PACKAGE_FALLBACK_LAUNCHER, USER_0));
-        assertFalse(mService.hasShortcutHostPermissionInner(CALLING_PACKAGE_1, USER_0));
-        assertFalse(mService.hasShortcutHostPermissionInner(CALLING_PACKAGE_2, USER_0));
-
-        mEnabledActivityChecker = (comp, user) -> true;
-
-        // Now the preferred changed.
-        prepareGetHomeActivitiesAsUser(
-                /* preferred */ cn(CALLING_PACKAGE_1, "xyz"),
-                list(getSystemLauncher(), getFallbackLauncher(),
-                        ri(CALLING_PACKAGE_1, "name", false, 0),
-                        ri(CALLING_PACKAGE_2, "name", false, 0)
-                ),
-                USER_0);
-
-        assertTrue(mService.hasShortcutHostPermissionInner(CALLING_PACKAGE_1, USER_0));
-
-        // Should be cached.
-        assertEquals(cn(CALLING_PACKAGE_1, "xyz"),
-                mService.getUserShortcutsLocked(USER_0).getLastKnownLauncher());
-        assertEquals(cn(CALLING_PACKAGE_1, "xyz"),
-                mService.getUserShortcutsLocked(USER_0).getCachedLauncher());
-
-
-        // As long as there's the cached launcher set, even if getHomeActivitiesAsUser()
-        // returns different values, the cached one is still the default.
-        prepareGetHomeActivitiesAsUser(
-                /* preferred */ getSystemLauncher().activityInfo.getComponentName(),
-                list(getSystemLauncher(), getFallbackLauncher()),
-                USER_0);
-
-        assertTrue(mService.hasShortcutHostPermissionInner(CALLING_PACKAGE_1, USER_0));
-
-        // Cached ones haven't changed.
-        assertEquals(cn(CALLING_PACKAGE_1, "xyz"),
-                mService.getUserShortcutsLocked(USER_0).getLastKnownLauncher());
-        assertEquals(cn(CALLING_PACKAGE_1, "xyz"),
-                mService.getUserShortcutsLocked(USER_0).getCachedLauncher());
-
-        // However, now the "real" default launcher is the system one.  So if the system
-        // launcher asks for shortcuts, we'll allow it.
-        assertTrue(mService.hasShortcutHostPermissionInner(PACKAGE_SYSTEM_LAUNCHER, USER_0));
-
-        // Since the cache is updated, CALLING_PACKAGE_1 no longer has the permission.
-        assertFalse(mService.hasShortcutHostPermissionInner(CALLING_PACKAGE_1, USER_0));
-
-        // Cached ones haven't changed.
-        assertEquals(cn(PACKAGE_SYSTEM_LAUNCHER, PACKAGE_SYSTEM_LAUNCHER_NAME),
-                mService.getUserShortcutsLocked(USER_0).getLastKnownLauncher());
-        assertEquals(cn(PACKAGE_SYSTEM_LAUNCHER, PACKAGE_SYSTEM_LAUNCHER_NAME),
-                mService.getUserShortcutsLocked(USER_0).getCachedLauncher());
-    }
-
-    public void testHasShortcutHostPermissionInner_multiUser() {
-        mRunningUsers.put(USER_10, true);
-
-        prepareGetHomeActivitiesAsUser(
-                /* preferred */ null,
-                list(getSystemLauncher(), getFallbackLauncher()),
-                USER_0);
-
-        prepareGetHomeActivitiesAsUser(
-                /* preferred */ cn(CALLING_PACKAGE_2, "name"),
-                list(getSystemLauncher(), getFallbackLauncher(),
-                        ri(CALLING_PACKAGE_1, "name", false, 0),
-                        ri(CALLING_PACKAGE_2, "name", false, 0)
-                ),
-                USER_10);
-
-        assertTrue(mService.hasShortcutHostPermissionInner(PACKAGE_SYSTEM_LAUNCHER, USER_0));
-        assertFalse(mService.hasShortcutHostPermissionInner(PACKAGE_FALLBACK_LAUNCHER, USER_0));
-        assertFalse(mService.hasShortcutHostPermissionInner(CALLING_PACKAGE_1, USER_0));
-        assertFalse(mService.hasShortcutHostPermissionInner(CALLING_PACKAGE_2, USER_0));
-
-        // Check the cache.
-        assertEquals(cn(PACKAGE_SYSTEM_LAUNCHER, PACKAGE_SYSTEM_LAUNCHER_NAME),
-                mService.getUserShortcutsLocked(USER_0).getLastKnownLauncher());
-        assertEquals(cn(PACKAGE_SYSTEM_LAUNCHER, PACKAGE_SYSTEM_LAUNCHER_NAME),
-                mService.getUserShortcutsLocked(USER_0).getCachedLauncher());
-
-        assertFalse(mService.hasShortcutHostPermissionInner(PACKAGE_SYSTEM_LAUNCHER, USER_10));
-        assertFalse(mService.hasShortcutHostPermissionInner(PACKAGE_FALLBACK_LAUNCHER, USER_10));
-        assertFalse(mService.hasShortcutHostPermissionInner(CALLING_PACKAGE_1, USER_10));
-        assertTrue(mService.hasShortcutHostPermissionInner(CALLING_PACKAGE_2, USER_10));
-
-        // Check the cache.
-        assertEquals(cn(CALLING_PACKAGE_2, "name"),
-                mService.getUserShortcutsLocked(USER_10).getLastKnownLauncher());
-        assertEquals(cn(CALLING_PACKAGE_2, "name"),
-                mService.getUserShortcutsLocked(USER_10).getCachedLauncher());
-    }
-
-    public void testHasShortcutHostPermissionInner_clearCache() {
-        mRunningUsers.put(USER_10, true);
-
-        prepareGetHomeActivitiesAsUser(
-                /* preferred */ null,
-                list(getSystemLauncher(), getFallbackLauncher()),
-                USER_0);
-
-        prepareGetHomeActivitiesAsUser(
-                /* preferred */ cn(CALLING_PACKAGE_2, "name"),
-                list(getSystemLauncher(), getFallbackLauncher(),
-                        ri(CALLING_PACKAGE_1, "name", false, 0),
-                        ri(CALLING_PACKAGE_2, "name", false, 0)
-                ),
-                USER_10);
-
-        assertTrue(mService.hasShortcutHostPermissionInner(PACKAGE_SYSTEM_LAUNCHER, USER_0));
-        assertTrue(mService.hasShortcutHostPermissionInner(CALLING_PACKAGE_2, USER_10));
-
-        assertEquals(cn(PACKAGE_SYSTEM_LAUNCHER, PACKAGE_SYSTEM_LAUNCHER_NAME),
-                mService.getUserShortcutsLocked(USER_0).getCachedLauncher());
-
-        assertEquals(cn(CALLING_PACKAGE_2, "name"),
-                mService.getUserShortcutsLocked(USER_10).getCachedLauncher());
-
-        // Test it on a non-running user.
-        // Send ACTION_PREFERRED_ACTIVITY_CHANGED on user 10.
-        // But the user is not running, so will be ignored.
-        mRunningUsers.put(USER_10, false);
-
-        mService.mPackageMonitor.onReceive(mServiceContext,
-                new Intent(Intent.ACTION_PREFERRED_ACTIVITY_CHANGED).putExtra(
-                        Intent.EXTRA_USER_HANDLE, USER_10));
-
-        // Need to run the user again to access the internal status.
-        mRunningUsers.put(USER_10, true);
-
-        assertEquals(cn(PACKAGE_SYSTEM_LAUNCHER, PACKAGE_SYSTEM_LAUNCHER_NAME),
-                mService.getUserShortcutsLocked(USER_0).getCachedLauncher());
-
-        assertEquals(cn(CALLING_PACKAGE_2, "name"),
-                mService.getUserShortcutsLocked(USER_10).getCachedLauncher());
-
-         // Send it again after starting the user.
-        mRunningUsers.put(USER_10, true);
-        mService.mPackageMonitor.onReceive(mServiceContext,
-                new Intent(Intent.ACTION_PREFERRED_ACTIVITY_CHANGED).putExtra(
-                        Intent.EXTRA_USER_HANDLE, USER_10));
-
-        assertEquals(cn(PACKAGE_SYSTEM_LAUNCHER, PACKAGE_SYSTEM_LAUNCHER_NAME),
-                mService.getUserShortcutsLocked(USER_0).getCachedLauncher());
-
-        // Only user-10's cache is cleared.
-        assertEquals(null,
-                mService.getUserShortcutsLocked(USER_10).getCachedLauncher());
-
-    }
-}
diff --git a/services/tests/servicestests/src/com/android/server/pm/ShortcutManagerTest7.java b/services/tests/servicestests/src/com/android/server/pm/ShortcutManagerTest7.java
deleted file mode 100644
index 3c99174142c..00000000000
--- a/services/tests/servicestests/src/com/android/server/pm/ShortcutManagerTest7.java
+++ /dev/null
@@ -1,339 +0,0 @@
-/*
- * Copyright (C) 2016 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.android.server.pm;
-
-import static com.android.server.pm.shortcutmanagertest.ShortcutManagerTestUtils.assertContains;
-import static com.android.server.pm.shortcutmanagertest.ShortcutManagerTestUtils.assertExpectException;
-import static com.android.server.pm.shortcutmanagertest.ShortcutManagerTestUtils.assertSuccess;
-import static com.android.server.pm.shortcutmanagertest.ShortcutManagerTestUtils.assertWith;
-import static com.android.server.pm.shortcutmanagertest.ShortcutManagerTestUtils.list;
-import static com.android.server.pm.shortcutmanagertest.ShortcutManagerTestUtils.readAll;
-import static com.android.server.pm.shortcutmanagertest.ShortcutManagerTestUtils.resultContains;
-
-import android.content.ComponentName;
-import android.os.Bundle;
-import android.os.ParcelFileDescriptor;
-import android.os.Process;
-import android.os.RemoteException;
-import android.os.ResultReceiver;
-import android.test.suitebuilder.annotation.SmallTest;
-
-import com.android.frameworks.servicestests.R;
-import com.android.server.pm.ShortcutService.ConfigConstants;
-
-import java.io.File;
-import java.io.IOException;
-import java.util.List;
-import java.util.concurrent.atomic.AtomicInteger;
-
-/**
- * Unit test for "cmd shortcut"
- *
- * Launcher related commands are tested in
- */
-@SmallTest
-public class ShortcutManagerTest7 extends BaseShortcutManagerTest {
-    private List<String> callShellCommand(String... args) throws IOException, RemoteException {
-
-        // For reset to work, the current time needs to be incrementing.
-        mInjectedCurrentTimeMillis++;
-
-        final AtomicInteger resultCode = new AtomicInteger(Integer.MIN_VALUE);
-
-        final ResultReceiver rr = new ResultReceiver(mHandler) {
-            @Override
-            public void send(int resultCode_, Bundle resultData) {
-                resultCode.set(resultCode_);
-            }
-        };
-        final File out = File.createTempFile("shellout-", ".tmp",
-                getTestContext().getCacheDir());
-        try {
-            try (final ParcelFileDescriptor fd = ParcelFileDescriptor.open(out,
-                    ParcelFileDescriptor.MODE_READ_WRITE)) {
-                mService.onShellCommand(
-                    /* fdin*/ null,
-                    /* fdout*/ fd.getFileDescriptor(),
-                    /* fderr*/ fd.getFileDescriptor(),
-                        args, rr);
-            }
-            return readAll(out);
-        } finally {
-            out.delete();
-        }
-    }
-
-    public void testNonShell() throws Exception {
-        mService.mMaxUpdatesPerInterval = 99;
-
-        mInjectedCallingUid = 12345;
-        assertExpectException(SecurityException.class, "must be shell",
-                () -> callShellCommand("reset-config"));
-
-        mInjectedCallingUid = Process.SYSTEM_UID;
-        assertExpectException(SecurityException.class, "must be shell",
-                () -> callShellCommand("reset-config"));
-
-        assertEquals(99, mService.mMaxUpdatesPerInterval);
-    }
-
-    public void testRoot() throws Exception {
-        mService.mMaxUpdatesPerInterval = 99;
-
-        mInjectedCallingUid = Process.ROOT_UID;
-        assertSuccess(callShellCommand("reset-config"));
-
-        assertEquals(3, mService.mMaxUpdatesPerInterval);
-    }
-
-    public void testRestConfig() throws Exception {
-        mService.mMaxUpdatesPerInterval = 99;
-
-        mInjectedCallingUid = Process.SHELL_UID;
-        assertSuccess(callShellCommand("reset-config"));
-
-        assertEquals(3, mService.mMaxUpdatesPerInterval);
-    }
-
-    public void testOverrideConfig() throws Exception {
-        mService.mMaxUpdatesPerInterval = 99;
-
-        mInjectedCallingUid = Process.SHELL_UID;
-        assertSuccess(callShellCommand("override-config",
-                ConfigConstants.KEY_MAX_UPDATES_PER_INTERVAL + "=1"));
-
-        assertEquals(1, mService.mMaxUpdatesPerInterval);
-    }
-
-    public void testResetThrottling() throws Exception {
-        prepareCrossProfileDataSet();
-
-        runWithCaller(CALLING_PACKAGE_1, USER_0, () -> {
-            assertTrue(mManager.getRemainingCallCount() < 3);
-        });
-        runWithCaller(CALLING_PACKAGE_1, USER_10, () -> {
-            assertTrue(mManager.getRemainingCallCount() < 3);
-        });
-
-        mInjectedCallingUid = Process.SHELL_UID;
-        assertSuccess(callShellCommand("reset-throttling"));
-
-        runWithCaller(CALLING_PACKAGE_1, USER_0, () -> {
-            assertEquals(3, mManager.getRemainingCallCount());
-        });
-        runWithCaller(CALLING_PACKAGE_1, USER_10, () -> {
-            assertTrue(mManager.getRemainingCallCount() < 3);
-        });
-    }
-
-    public void testResetThrottling_user_not_running() throws Exception {
-        prepareCrossProfileDataSet();
-
-        runWithCaller(CALLING_PACKAGE_1, USER_0, () -> {
-            assertTrue(mManager.getRemainingCallCount() < 3);
-        });
-        runWithCaller(CALLING_PACKAGE_1, USER_10, () -> {
-            assertTrue(mManager.getRemainingCallCount() < 3);
-        });
-
-        mInjectedCallingUid = Process.SHELL_UID;
-
-        mRunningUsers.put(USER_10, false);
-
-        assertTrue(resultContains(
-                callShellCommand("reset-throttling", "--user", "10"),
-                "User 10 is not running or locked"));
-
-        mRunningUsers.put(USER_10, true);
-
-        runWithCaller(CALLING_PACKAGE_1, USER_0, () -> {
-            assertTrue(mManager.getRemainingCallCount() < 3);
-        });
-        runWithCaller(CALLING_PACKAGE_1, USER_10, () -> {
-            assertTrue(mManager.getRemainingCallCount() < 3);
-        });
-    }
-
-    public void testResetThrottling_user_running() throws Exception {
-        prepareCrossProfileDataSet();
-
-        runWithCaller(CALLING_PACKAGE_1, USER_0, () -> {
-            assertTrue(mManager.getRemainingCallCount() < 3);
-        });
-        runWithCaller(CALLING_PACKAGE_1, USER_10, () -> {
-            assertTrue(mManager.getRemainingCallCount() < 3);
-        });
-
-        mRunningUsers.put(USER_10, true);
-        mUnlockedUsers.put(USER_10, true);
-
-        mInjectedCallingUid = Process.SHELL_UID;
-        assertSuccess(callShellCommand("reset-throttling", "--user", "10"));
-
-        runWithCaller(CALLING_PACKAGE_1, USER_0, () -> {
-            assertTrue(mManager.getRemainingCallCount() < 3);
-        });
-        runWithCaller(CALLING_PACKAGE_1, USER_10, () -> {
-            assertEquals(3, mManager.getRemainingCallCount());
-        });
-    }
-
-    public void testResetAllThrottling() throws Exception {
-        prepareCrossProfileDataSet();
-
-        runWithCaller(CALLING_PACKAGE_1, USER_0, () -> {
-            assertTrue(mManager.getRemainingCallCount() < 3);
-        });
-        runWithCaller(CALLING_PACKAGE_1, USER_10, () -> {
-            assertTrue(mManager.getRemainingCallCount() < 3);
-        });
-
-        mInjectedCallingUid = Process.SHELL_UID;
-        assertSuccess(callShellCommand("reset-all-throttling"));
-
-        runWithCaller(CALLING_PACKAGE_1, USER_0, () -> {
-            assertEquals(3, mManager.getRemainingCallCount());
-        });
-        runWithCaller(CALLING_PACKAGE_1, USER_10, () -> {
-            assertEquals(3, mManager.getRemainingCallCount());
-        });
-    }
-
-    public void testLauncherCommands() throws Exception {
-        prepareGetHomeActivitiesAsUser(
-                /* preferred */ null,
-                list(getSystemLauncher(), getFallbackLauncher()),
-                USER_0);
-
-        prepareGetHomeActivitiesAsUser(
-                /* preferred */ cn(CALLING_PACKAGE_2, "name"),
-                list(getSystemLauncher(), getFallbackLauncher(),
-                        ri(CALLING_PACKAGE_1, "name", false, 0),
-                        ri(CALLING_PACKAGE_2, "name", false, 0)
-                ),
-                USER_10);
-
-        assertTrue(mService.hasShortcutHostPermissionInner(PACKAGE_SYSTEM_LAUNCHER, USER_0));
-
-        // First, test "get".
-
-        mRunningUsers.put(USER_10, true);
-        mUnlockedUsers.put(USER_10, true);
-        mInjectedCallingUid = Process.SHELL_UID;
-        assertContains(
-                assertSuccess(callShellCommand("get-default-launcher")),
-                "Launcher: ComponentInfo{com.android.systemlauncher/systemlauncher_name}");
-
-        assertContains(
-                assertSuccess(callShellCommand("get-default-launcher", "--user", "10")),
-                "Launcher: ComponentInfo{com.android.test.2/name}");
-
-        // Next, test "clear".
-        assertSuccess(callShellCommand("clear-default-launcher", "--user", "10"));
-
-        // User-10's launcher should be cleared.
-        assertEquals(null, mService.getUserShortcutsLocked(USER_10).getLastKnownLauncher());
-        assertEquals(null, mService.getUserShortcutsLocked(USER_10).getCachedLauncher());
-
-        // but user'0's shouldn't.
-        assertEquals(cn(PACKAGE_SYSTEM_LAUNCHER, PACKAGE_SYSTEM_LAUNCHER_NAME),
-                mService.getUserShortcutsLocked(USER_0).getCachedLauncher());
-
-        // Change user-0's launcher.
-        prepareGetHomeActivitiesAsUser(
-                /* preferred */ cn(CALLING_PACKAGE_1, "name"),
-                list(
-                        ri(CALLING_PACKAGE_1, "name", false, 0)
-                ),
-                USER_0);
-        assertContains(
-                assertSuccess(callShellCommand("get-default-launcher")),
-                "Launcher: ComponentInfo{com.android.test.1/name}");
-    }
-
-    public void testUnloadUser() throws Exception {
-        prepareCrossProfileDataSet();
-
-        assertNotNull(mService.getShortcutsForTest().get(USER_10));
-
-        mRunningUsers.put(USER_10, true);
-        mUnlockedUsers.put(USER_10, true);
-
-        mInjectedCallingUid = Process.SHELL_UID;
-        assertSuccess(callShellCommand("unload-user", "--user", "10"));
-
-        assertNull(mService.getShortcutsForTest().get(USER_10));
-    }
-
-    public void testClearShortcuts() throws Exception {
-
-        mRunningUsers.put(USER_10, true);
-
-        // Add two manifests and two dynamics.
-        addManifestShortcutResource(
-                new ComponentName(CALLING_PACKAGE_1, ShortcutActivity.class.getName()),
-                R.xml.shortcut_2);
-        updatePackageVersion(CALLING_PACKAGE_1, 1);
-        mService.mPackageMonitor.onReceive(getTestContext(),
-                genPackageAddIntent(CALLING_PACKAGE_1, USER_10));
-
-        runWithCaller(CALLING_PACKAGE_1, USER_10, () -> {
-            assertTrue(mManager.addDynamicShortcuts(list(
-                    makeShortcut("s1"), makeShortcut("s2"))));
-        });
-        runWithCaller(LAUNCHER_1, USER_10, () -> {
-            mLauncherApps.pinShortcuts(CALLING_PACKAGE_1, list("ms2", "s2"), HANDLE_USER_10);
-        });
-
-        runWithCaller(CALLING_PACKAGE_1, USER_10, () -> {
-            assertWith(getCallerShortcuts())
-                    .haveIds("ms1", "ms2", "s1", "s2")
-                    .areAllEnabled()
-
-                    .selectPinned()
-                    .haveIds("ms2", "s2");
-        });
-
-        // First, call for a different package.
-
-        mRunningUsers.put(USER_10, true);
-        mUnlockedUsers.put(USER_10, true);
-
-        mInjectedCallingUid = Process.SHELL_UID;
-        assertSuccess(callShellCommand("clear-shortcuts", "--user", "10", CALLING_PACKAGE_2));
-
-        // Shouldn't be cleared yet.
-        runWithCaller(CALLING_PACKAGE_1, USER_10, () -> {
-            assertWith(getCallerShortcuts())
-                    .haveIds("ms1", "ms2", "s1", "s2")
-                    .areAllEnabled()
-
-                    .selectPinned()
-                    .haveIds("ms2", "s2");
-        });
-
-        mInjectedCallingUid = Process.SHELL_UID;
-        assertSuccess(callShellCommand("clear-shortcuts", "--user", "10", CALLING_PACKAGE_1));
-
-        // Only manifest shortcuts will remain, and are no longer pinned.
-        runWithCaller(CALLING_PACKAGE_1, USER_10, () -> {
-            assertWith(getCallerShortcuts())
-                    .haveIds("ms1", "ms2")
-                    .areAllEnabled()
-                    .areAllNotPinned();
-        });
-    }
-}
diff --git a/services/tests/servicestests/src/com/android/server/pm/ShortcutTestActivity.java b/services/tests/servicestests/src/com/android/server/pm/ShortcutTestActivity.java
deleted file mode 100644
index d82b0d55f2a..00000000000
--- a/services/tests/servicestests/src/com/android/server/pm/ShortcutTestActivity.java
+++ /dev/null
@@ -1,21 +0,0 @@
-/*
- * Copyright (C) 2016 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.android.server.pm;
-
-import android.app.Activity;
-
-public class ShortcutTestActivity extends Activity {
-}
diff --git a/services/tests/servicestests/src/com/android/server/pm/UserManagerServiceTest.java b/services/tests/servicestests/src/com/android/server/pm/UserManagerServiceTest.java
deleted file mode 100644
index 9f77297b49d..00000000000
--- a/services/tests/servicestests/src/com/android/server/pm/UserManagerServiceTest.java
+++ /dev/null
@@ -1,121 +0,0 @@
-/*
- * Copyright (C) 2015 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License
- */
-
-package com.android.server.pm;
-
-import android.content.pm.UserInfo;
-import android.os.Bundle;
-import android.os.FileUtils;
-import android.os.Parcelable;
-import android.os.UserHandle;
-import android.os.UserManager;
-import android.test.AndroidTestCase;
-import android.test.suitebuilder.annotation.SmallTest;
-import android.util.AtomicFile;
-
-import java.io.File;
-import java.io.IOException;
-import java.util.Arrays;
-
-@SmallTest
-public class UserManagerServiceTest extends AndroidTestCase {
-    private static String[] STRING_ARRAY = new String[] {"<tag", "<![CDATA["};
-    private File restrictionsFile;
-    private int tempUserId = UserHandle.USER_NULL;
-
-    @Override
-    protected void setUp() throws Exception {
-        super.setUp();
-        restrictionsFile = new File(mContext.getCacheDir(), "restrictions.xml");
-        restrictionsFile.delete();
-    }
-
-    @Override
-    protected void tearDown() throws Exception {
-        restrictionsFile.delete();
-        if (tempUserId != UserHandle.USER_NULL) {
-            UserManager.get(mContext).removeUser(tempUserId);
-        }
-        super.tearDown();
-    }
-
-    public void testWriteReadApplicationRestrictions() throws IOException {
-        AtomicFile atomicFile = new AtomicFile(restrictionsFile);
-        Bundle bundle = createBundle();
-        UserManagerService.writeApplicationRestrictionsLP(bundle, atomicFile);
-        assertTrue(atomicFile.getBaseFile().exists());
-        String s = FileUtils.readTextFile(restrictionsFile, 10000, "");
-        System.out.println("restrictionsFile: " + s);
-        bundle = UserManagerService.readApplicationRestrictionsLP(atomicFile);
-        System.out.println("readApplicationRestrictionsLocked bundle: " + bundle);
-        assertBundle(bundle);
-    }
-
-    public void testAddUserWithAccount() {
-        UserManager um = UserManager.get(mContext);
-        UserInfo user = um.createUser("Test User", 0);
-        assertNotNull(user);
-        tempUserId = user.id;
-        String accountName = "Test Account";
-        um.setUserAccount(tempUserId, accountName);
-        assertEquals(accountName, um.getUserAccount(tempUserId));
-    }
-
-    private Bundle createBundle() {
-        Bundle result = new Bundle();
-        // Tests for 6 allowed types: Integer, Boolean, String, String[], Bundle and Parcelable[]
-        result.putBoolean("boolean_0", false);
-        result.putBoolean("boolean_1", true);
-        result.putInt("integer", 100);
-        result.putString("empty", "");
-        result.putString("string", "text");
-        result.putStringArray("string[]", STRING_ARRAY);
-
-        Bundle bundle = new Bundle();
-        bundle.putString("bundle_string", "bundle_string");
-        bundle.putInt("bundle_int", 1);
-        result.putBundle("bundle", bundle);
-
-        Bundle[] bundleArray = new Bundle[2];
-        bundleArray[0] = new Bundle();
-        bundleArray[0].putString("bundle_array_string", "bundle_array_string");
-        bundleArray[0].putBundle("bundle_array_bundle", bundle);
-        bundleArray[1] = new Bundle();
-        bundleArray[1].putString("bundle_array_string2", "bundle_array_string2");
-        result.putParcelableArray("bundle_array", bundleArray);
-        return result;
-    }
-
-    private void assertBundle(Bundle bundle) {
-        assertFalse(bundle.getBoolean("boolean_0"));
-        assertTrue(bundle.getBoolean("boolean_1"));
-        assertEquals(100, bundle.getInt("integer"));
-        assertEquals("", bundle.getString("empty"));
-        assertEquals("text", bundle.getString("string"));
-        assertEquals(Arrays.asList(STRING_ARRAY), Arrays.asList(bundle.getStringArray("string[]")));
-        Parcelable[] bundle_array = bundle.getParcelableArray("bundle_array");
-        assertEquals(2, bundle_array.length);
-        Bundle bundle1 = (Bundle) bundle_array[0];
-        assertEquals("bundle_array_string", bundle1.getString("bundle_array_string"));
-        assertNotNull(bundle1.getBundle("bundle_array_bundle"));
-        Bundle bundle2 = (Bundle) bundle_array[1];
-        assertEquals("bundle_array_string2", bundle2.getString("bundle_array_string2"));
-        Bundle childBundle = bundle.getBundle("bundle");
-        assertEquals("bundle_string", childBundle.getString("bundle_string"));
-        assertEquals(1, childBundle.getInt("bundle_int"));
-    }
-
-}
diff --git a/services/tests/servicestests/src/com/android/server/pm/UserManagerTest.java b/services/tests/servicestests/src/com/android/server/pm/UserManagerTest.java
deleted file mode 100644
index ced4980df52..00000000000
--- a/services/tests/servicestests/src/com/android/server/pm/UserManagerTest.java
+++ /dev/null
@@ -1,278 +0,0 @@
-/*
- * Copyright (C) 2011 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.android.server.pm;
-
-import android.content.BroadcastReceiver;
-import android.content.Context;
-import android.content.Intent;
-import android.content.IntentFilter;
-import android.content.pm.UserInfo;
-import android.os.Bundle;
-import android.os.UserHandle;
-import android.os.UserManager;
-import android.test.AndroidTestCase;
-import android.test.suitebuilder.annotation.MediumTest;
-
-import com.android.internal.util.ArrayUtils;
-
-import java.util.ArrayList;
-import java.util.Arrays;
-import java.util.List;
-
-/** Test {@link UserManager} functionality. */
-@MediumTest
-public class UserManagerTest extends AndroidTestCase {
-    private static final int REMOVE_CHECK_INTERVAL = 500;
-    private static final int REMOVE_TIMEOUT = 60 * 1000;
-    private UserManager mUserManager = null;
-    private final Object mUserLock = new Object();
-    private List<Integer> usersToRemove;
-
-    @Override
-    public void setUp() throws Exception {
-        super.setUp();
-        mUserManager = UserManager.get(getContext());
-        IntentFilter filter = new IntentFilter(Intent.ACTION_USER_REMOVED);
-        getContext().registerReceiver(new BroadcastReceiver() {
-            @Override
-            public void onReceive(Context context, Intent intent) {
-                synchronized (mUserLock) {
-                    mUserLock.notifyAll();
-                }
-            }
-        }, filter);
-
-        removeExistingUsers();
-        usersToRemove = new ArrayList<>();
-    }
-
-    @Override
-    protected void tearDown() throws Exception {
-        for (Integer userId : usersToRemove) {
-            removeUser(userId);
-        }
-        super.tearDown();
-    }
-
-    private void removeExistingUsers() {
-        List<UserInfo> list = mUserManager.getUsers();
-        for (UserInfo user : list) {
-            // Keep system and primary user.
-            // We do not have to keep primary user, but in split system user mode, we need it
-            // until http://b/22976637 is fixed.  Right now in split system user mode, you need to
-            // switch to primary user and run tests under primary user.
-            if (user.id != UserHandle.USER_SYSTEM && !user.isPrimary()) {
-                removeUser(user.id);
-            }
-        }
-    }
-
-    public void testHasSystemUser() throws Exception {
-        assertTrue(findUser(UserHandle.USER_SYSTEM));
-    }
-
-    public void testAddUser() throws Exception {
-        UserInfo userInfo = createUser("Guest 1", UserInfo.FLAG_GUEST);
-        assertTrue(userInfo != null);
-
-        List<UserInfo> list = mUserManager.getUsers();
-        boolean found = false;
-        for (UserInfo user : list) {
-            if (user.id == userInfo.id && user.name.equals("Guest 1")
-                    && user.isGuest()
-                    && !user.isAdmin()
-                    && !user.isPrimary()) {
-                found = true;
-                Bundle restrictions = mUserManager.getUserRestrictions(user.getUserHandle());
-                assertTrue("Guest user should have DISALLOW_CONFIG_WIFI=true by default",
-                        restrictions.getBoolean(UserManager.DISALLOW_CONFIG_WIFI));
-            }
-        }
-        assertTrue(found);
-    }
-
-    public void testAdd2Users() throws Exception {
-        UserInfo user1 = createUser("Guest 1", UserInfo.FLAG_GUEST);
-        UserInfo user2 = createUser("User 2", UserInfo.FLAG_ADMIN);
-
-        assertTrue(user1 != null);
-        assertTrue(user2 != null);
-
-        assertTrue(findUser(0));
-        assertTrue(findUser(user1.id));
-        assertTrue(findUser(user2.id));
-    }
-
-    public void testRemoveUser() throws Exception {
-        UserInfo userInfo = createUser("Guest 1", UserInfo.FLAG_GUEST);
-        removeUser(userInfo.id);
-
-        assertFalse(findUser(userInfo.id));
-    }
-
-    public void testAddGuest() throws Exception {
-        UserInfo userInfo1 = createUser("Guest 1", UserInfo.FLAG_GUEST);
-        UserInfo userInfo2 = createUser("Guest 2", UserInfo.FLAG_GUEST);
-        assertNotNull(userInfo1);
-        assertNull(userInfo2);
-    }
-
-    // Make sure only one managed profile can be created
-    public void testAddManagedProfile() throws Exception {
-        final int primaryUserId = mUserManager.getPrimaryUser().id;
-        UserInfo userInfo1 = createProfileForUser("Managed 1",
-                UserInfo.FLAG_MANAGED_PROFILE, primaryUserId);
-        UserInfo userInfo2 = createProfileForUser("Managed 2",
-                UserInfo.FLAG_MANAGED_PROFILE, primaryUserId);
-        assertNotNull(userInfo1);
-        assertNull(userInfo2);
-        // Verify that current user is not a managed profile
-        assertFalse(mUserManager.isManagedProfile());
-    }
-
-    public void testGetUserCreationTime() throws Exception {
-        final int primaryUserId = mUserManager.getPrimaryUser().id;
-        UserInfo profile = createProfileForUser("Managed 1",
-                UserInfo.FLAG_MANAGED_PROFILE, primaryUserId);
-        assertNotNull(profile);
-        assertTrue("creationTime must be set when the profile is created",
-                profile.creationTime > 0);
-        assertEquals(profile.creationTime, mUserManager.getUserCreationTime(
-                new UserHandle(profile.id)));
-
-        long ownerCreationTime = mUserManager.getUserInfo(primaryUserId).creationTime;
-        assertEquals(ownerCreationTime, mUserManager.getUserCreationTime(
-                new UserHandle(primaryUserId)));
-
-        try {
-            int noSuchUserId = 100500;
-            mUserManager.getUserCreationTime(new UserHandle(noSuchUserId));
-            fail("SecurityException should be thrown for nonexistent user");
-        } catch (Exception e) {
-            assertTrue("SecurityException should be thrown for nonexistent user, but was: " + e,
-                    e instanceof SecurityException);
-        }
-
-        UserInfo user = createUser("User 1", 0);
-        try {
-            mUserManager.getUserCreationTime(new UserHandle(user.id));
-            fail("SecurityException should be thrown for other user");
-        } catch (Exception e) {
-            assertTrue("SecurityException should be thrown for other user, but was: " + e,
-                    e instanceof SecurityException);
-        }
-    }
-
-
-    private boolean findUser(int id) {
-        List<UserInfo> list = mUserManager.getUsers();
-
-        for (UserInfo user : list) {
-            if (user.id == id) {
-                return true;
-            }
-        }
-        return false;
-    }
-
-    public void testSerialNumber() {
-        UserInfo user1 = createUser("User 1", 0);
-        int serialNumber1 = user1.serialNumber;
-        assertEquals(serialNumber1, mUserManager.getUserSerialNumber(user1.id));
-        assertEquals(user1.id, mUserManager.getUserHandle(serialNumber1));
-        UserInfo user2 = createUser("User 2", 0);
-        int serialNumber2 = user2.serialNumber;
-        assertFalse(serialNumber1 == serialNumber2);
-        assertEquals(serialNumber2, mUserManager.getUserSerialNumber(user2.id));
-        assertEquals(user2.id, mUserManager.getUserHandle(serialNumber2));
-    }
-
-    public void testGetSerialNumbersOfUsers() {
-        UserInfo user1 = createUser("User 1", 0);
-        UserInfo user2 = createUser("User 2", 0);
-        long[] serialNumbersOfUsers = mUserManager.getSerialNumbersOfUsers(false);
-        String errMsg = "Array " + Arrays.toString(serialNumbersOfUsers) + " should contain ";
-        assertTrue(errMsg + user1.serialNumber,
-                ArrayUtils.contains(serialNumbersOfUsers, user1.serialNumber));
-        assertTrue(errMsg + user2.serialNumber,
-                ArrayUtils.contains(serialNumbersOfUsers, user2.serialNumber));
-    }
-
-    public void testMaxUsers() {
-        int N = UserManager.getMaxSupportedUsers();
-        int count = mUserManager.getUsers().size();
-        // Create as many users as permitted and make sure creation passes
-        while (count < N) {
-            UserInfo ui = createUser("User " + count, 0);
-            assertNotNull(ui);
-            count++;
-        }
-        // Try to create one more user and make sure it fails
-        UserInfo extra = createUser("One more", 0);
-        assertNull(extra);
-    }
-
-    public void testRestrictions() {
-        UserInfo testUser = createUser("User 1", 0);
-
-        mUserManager.setUserRestriction(
-                UserManager.DISALLOW_INSTALL_APPS, true, new UserHandle(testUser.id));
-        mUserManager.setUserRestriction(
-                UserManager.DISALLOW_CONFIG_WIFI, false, new UserHandle(testUser.id));
-
-        Bundle stored = mUserManager.getUserRestrictions(new UserHandle(testUser.id));
-        // Note this will fail if DO already sets those restrictions.
-        assertEquals(stored.getBoolean(UserManager.DISALLOW_CONFIG_WIFI), false);
-        assertEquals(stored.getBoolean(UserManager.DISALLOW_UNINSTALL_APPS), false);
-        assertEquals(stored.getBoolean(UserManager.DISALLOW_INSTALL_APPS), true);
-    }
-
-    private void removeUser(int userId) {
-        synchronized (mUserLock) {
-            mUserManager.removeUser(userId);
-            long time = System.currentTimeMillis();
-            while (mUserManager.getUserInfo(userId) != null) {
-                try {
-                    mUserLock.wait(REMOVE_CHECK_INTERVAL);
-                } catch (InterruptedException ie) {
-                    Thread.currentThread().interrupt();
-                    return;
-                }
-                if (System.currentTimeMillis() - time > REMOVE_TIMEOUT) {
-                    fail("Timeout waiting for removeUser. userId = " + userId);
-                }
-            }
-        }
-    }
-
-    private UserInfo createUser(String name, int flags) {
-        UserInfo user = mUserManager.createUser(name, flags);
-        if (user != null) {
-            usersToRemove.add(user.id);
-        }
-        return user;
-    }
-
-    private UserInfo createProfileForUser(String name, int flags, int userHandle) {
-        UserInfo profile = mUserManager.createProfileForUser(name, flags, userHandle);
-        if (profile != null) {
-            usersToRemove.add(profile.id);
-        }
-        return profile;
-    }
-
-}
diff --git a/services/tests/servicestests/src/com/android/server/pm/UserRestrictionsUtilsTest.java b/services/tests/servicestests/src/com/android/server/pm/UserRestrictionsUtilsTest.java
deleted file mode 100644
index 11f9ebb52f4..00000000000
--- a/services/tests/servicestests/src/com/android/server/pm/UserRestrictionsUtilsTest.java
+++ /dev/null
@@ -1,207 +0,0 @@
-/*
- * Copyright (C) 2015 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.android.server.pm;
-
-import android.os.Bundle;
-import android.os.UserHandle;
-import android.os.UserManager;
-import android.test.AndroidTestCase;
-import android.test.suitebuilder.annotation.SmallTest;
-
-import com.android.server.devicepolicy.DpmTestUtils;
-
-/**
- * Tests for {@link com.android.server.pm.UserRestrictionsUtils}.
- *
- * <p>Run with:<pre>
-   m FrameworksServicesTests &&
-   adb install \
-     -r out/target/product/hammerhead/data/app/FrameworksServicesTests/FrameworksServicesTests.apk &&
-   adb shell am instrument -e class com.android.server.pm.UserRestrictionsUtilsTest \
-     -w com.android.frameworks.servicestests/android.support.test.runner.AndroidJUnitRunner
- * </pre>
- */
-@SmallTest
-public class UserRestrictionsUtilsTest extends AndroidTestCase {
-    public void testNonNull() {
-        Bundle out = UserRestrictionsUtils.nonNull(null);
-        assertNotNull(out);
-        out.putBoolean("a", true); // Should not be Bundle.EMPTY.
-
-        Bundle in = new Bundle();
-        assertSame(in, UserRestrictionsUtils.nonNull(in));
-    }
-
-    public void testIsEmpty() {
-        assertTrue(UserRestrictionsUtils.isEmpty(null));
-        assertTrue(UserRestrictionsUtils.isEmpty(new Bundle()));
-        assertFalse(UserRestrictionsUtils.isEmpty(DpmTestUtils.newRestrictions("a")));
-    }
-
-    public void testClone() {
-        Bundle in = new Bundle();
-        Bundle out = UserRestrictionsUtils.clone(in);
-        assertNotSame(in, out);
-        DpmTestUtils.assertRestrictions(out, new Bundle());
-
-        out = UserRestrictionsUtils.clone(null);
-        assertNotNull(out);
-        out.putBoolean("a", true); // Should not be Bundle.EMPTY.
-    }
-
-    public void testMerge() {
-        Bundle a = DpmTestUtils.newRestrictions("a", "d");
-        Bundle b = DpmTestUtils.newRestrictions("b", "d", "e");
-
-        UserRestrictionsUtils.merge(a, b);
-
-        DpmTestUtils.assertRestrictions(DpmTestUtils.newRestrictions("a", "b", "d", "e"), a);
-
-        UserRestrictionsUtils.merge(a, null);
-
-        DpmTestUtils.assertRestrictions(DpmTestUtils.newRestrictions("a", "b", "d", "e"), a);
-
-        try {
-            UserRestrictionsUtils.merge(a, a);
-            fail();
-        } catch (IllegalArgumentException expected) {
-        }
-    }
-
-    public void testCanDeviceOwnerChange() {
-        assertFalse(UserRestrictionsUtils.canDeviceOwnerChange(UserManager.DISALLOW_RECORD_AUDIO));
-        assertFalse(UserRestrictionsUtils.canDeviceOwnerChange(UserManager.DISALLOW_WALLPAPER));
-        assertTrue(UserRestrictionsUtils.canDeviceOwnerChange(UserManager.DISALLOW_ADD_USER));
-    }
-
-    public void testCanProfileOwnerChange() {
-        int user = UserHandle.USER_SYSTEM;
-        assertFalse(UserRestrictionsUtils.canProfileOwnerChange(
-                UserManager.DISALLOW_RECORD_AUDIO, user));
-        assertFalse(UserRestrictionsUtils.canProfileOwnerChange(
-                UserManager.DISALLOW_WALLPAPER, user));
-        assertTrue(UserRestrictionsUtils.canProfileOwnerChange(
-                UserManager.DISALLOW_ADD_USER, user));
-        assertTrue(UserRestrictionsUtils.canProfileOwnerChange(
-                UserManager.DISALLOW_ADJUST_VOLUME, user));
-
-        user = 10;
-        assertFalse(UserRestrictionsUtils.canProfileOwnerChange(
-                UserManager.DISALLOW_RECORD_AUDIO, user));
-        assertFalse(UserRestrictionsUtils.canProfileOwnerChange(
-                UserManager.DISALLOW_WALLPAPER, user));
-        assertFalse(UserRestrictionsUtils.canProfileOwnerChange(
-                UserManager.DISALLOW_ADD_USER, user));
-        assertTrue(UserRestrictionsUtils.canProfileOwnerChange(
-                UserManager.DISALLOW_ADJUST_VOLUME, user));
-    }
-
-    public void testSortToGlobalAndLocal() {
-        final Bundle local = new Bundle();
-        final Bundle global = new Bundle();
-
-        UserRestrictionsUtils.sortToGlobalAndLocal(null, global, local);
-        assertEquals(0, global.size());
-        assertEquals(0, local.size());
-
-        UserRestrictionsUtils.sortToGlobalAndLocal(Bundle.EMPTY, global, local);
-        assertEquals(0, global.size());
-        assertEquals(0, local.size());
-
-        UserRestrictionsUtils.sortToGlobalAndLocal(DpmTestUtils.newRestrictions(
-                UserManager.DISALLOW_ADJUST_VOLUME,
-                UserManager.DISALLOW_UNMUTE_MICROPHONE,
-                UserManager.DISALLOW_USB_FILE_TRANSFER,
-                UserManager.DISALLOW_CONFIG_TETHERING,
-                UserManager.DISALLOW_OUTGOING_BEAM,
-                UserManager.DISALLOW_APPS_CONTROL
-        ), global, local);
-
-
-        DpmTestUtils.assertRestrictions(DpmTestUtils.newRestrictions(
-                // These can be set by PO too, but when DO sets them, they're global.
-                UserManager.DISALLOW_ADJUST_VOLUME,
-                UserManager.DISALLOW_UNMUTE_MICROPHONE,
-
-                // These can only be set by DO.
-                UserManager.DISALLOW_USB_FILE_TRANSFER,
-                UserManager.DISALLOW_CONFIG_TETHERING
-        ), global);
-
-        DpmTestUtils.assertRestrictions(DpmTestUtils.newRestrictions(
-                // They can be set by both DO/PO.
-                UserManager.DISALLOW_OUTGOING_BEAM,
-                UserManager.DISALLOW_APPS_CONTROL
-        ), local);
-    }
-
-    public void testAreEqual() {
-        assertTrue(UserRestrictionsUtils.areEqual(
-                null,
-                null));
-
-        assertTrue(UserRestrictionsUtils.areEqual(
-                null,
-                Bundle.EMPTY));
-
-        assertTrue(UserRestrictionsUtils.areEqual(
-                Bundle.EMPTY,
-                null));
-
-        assertTrue(UserRestrictionsUtils.areEqual(
-                Bundle.EMPTY,
-                Bundle.EMPTY));
-
-        assertTrue(UserRestrictionsUtils.areEqual(
-                new Bundle(),
-                Bundle.EMPTY));
-
-        assertFalse(UserRestrictionsUtils.areEqual(
-                null,
-                DpmTestUtils.newRestrictions("a")));
-
-        assertFalse(UserRestrictionsUtils.areEqual(
-                DpmTestUtils.newRestrictions("a"),
-                null));
-
-        assertTrue(UserRestrictionsUtils.areEqual(
-                DpmTestUtils.newRestrictions("a"),
-                DpmTestUtils.newRestrictions("a")));
-
-        assertFalse(UserRestrictionsUtils.areEqual(
-                DpmTestUtils.newRestrictions("a"),
-                DpmTestUtils.newRestrictions("a", "b")));
-
-        assertFalse(UserRestrictionsUtils.areEqual(
-                DpmTestUtils.newRestrictions("a", "b"),
-                DpmTestUtils.newRestrictions("a")));
-
-        assertFalse(UserRestrictionsUtils.areEqual(
-                DpmTestUtils.newRestrictions("b", "a"),
-                DpmTestUtils.newRestrictions("a", "a")));
-
-        // Make sure false restrictions are handled correctly.
-        final Bundle a = DpmTestUtils.newRestrictions("a");
-        a.putBoolean("b", true);
-
-        final Bundle b = DpmTestUtils.newRestrictions("a");
-        b.putBoolean("b", false);
-
-        assertFalse(UserRestrictionsUtils.areEqual(a, b));
-        assertFalse(UserRestrictionsUtils.areEqual(b, a));
-    }
-}
diff --git a/services/tests/servicestests/src/com/android/server/pm/backup/BackupUtilsTest.java b/services/tests/servicestests/src/com/android/server/pm/backup/BackupUtilsTest.java
deleted file mode 100644
index c016e610475..00000000000
--- a/services/tests/servicestests/src/com/android/server/pm/backup/BackupUtilsTest.java
+++ /dev/null
@@ -1,118 +0,0 @@
-/*
- * Copyright (C) 2016 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.android.server.pm.backup;
-
-import android.content.pm.ApplicationInfo;
-import android.content.pm.PackageInfo;
-import android.content.pm.PackageParser.Package;
-import android.content.pm.Signature;
-import android.test.AndroidTestCase;
-import android.test.MoreAsserts;
-import android.test.suitebuilder.annotation.SmallTest;
-
-import com.android.server.backup.BackupUtils;
-
-import java.util.ArrayList;
-import java.util.Arrays;
-
-@SmallTest
-public class BackupUtilsTest extends AndroidTestCase {
-
-    private Signature[] genSignatures(String... signatures) {
-        final Signature[] sigs = new Signature[signatures.length];
-        for (int i = 0; i < signatures.length; i++){
-            sigs[i] = new Signature(signatures[i].getBytes());
-        }
-        return sigs;
-    }
-
-    private PackageInfo genPackage(String... signatures) {
-        final PackageInfo pi = new PackageInfo();
-        pi.packageName = "package";
-        pi.applicationInfo = new ApplicationInfo();
-        pi.signatures = genSignatures(signatures);
-
-        return pi;
-    }
-
-    public void testSignaturesMatch() {
-        final ArrayList<byte[]> stored1 = BackupUtils.hashSignatureArray(Arrays.asList(
-                "abc".getBytes()));
-        final ArrayList<byte[]> stored2 = BackupUtils.hashSignatureArray(Arrays.asList(
-                "abc".getBytes(), "def".getBytes()));
-
-        PackageInfo pi;
-
-        // False for null package.
-        assertFalse(BackupUtils.signaturesMatch(stored1, null));
-
-        // If it's a system app, signatures don't matter.
-        pi = genPackage("xyz");
-        pi.applicationInfo.flags |= ApplicationInfo.FLAG_SYSTEM;
-        assertTrue(BackupUtils.signaturesMatch(stored1, pi));
-
-        // Non system apps.
-        assertTrue(BackupUtils.signaturesMatch(stored1, genPackage("abc")));
-
-        // Superset is okay.
-        assertTrue(BackupUtils.signaturesMatch(stored1, genPackage("abc", "xyz")));
-        assertTrue(BackupUtils.signaturesMatch(stored1, genPackage("xyz", "abc")));
-
-        assertFalse(BackupUtils.signaturesMatch(stored1, genPackage("xyz")));
-        assertFalse(BackupUtils.signaturesMatch(stored1, genPackage("xyz", "def")));
-
-        assertTrue(BackupUtils.signaturesMatch(stored2, genPackage("def", "abc")));
-        assertTrue(BackupUtils.signaturesMatch(stored2, genPackage("x", "def", "abc", "y")));
-
-        // Subset is not okay.
-        assertFalse(BackupUtils.signaturesMatch(stored2, genPackage("abc")));
-        assertFalse(BackupUtils.signaturesMatch(stored2, genPackage("def")));
-    }
-
-    public void testHashSignature() {
-        final byte[] sig1 = "abc".getBytes();
-        final byte[] sig2 = "def".getBytes();
-
-        final byte[] hash1a = BackupUtils.hashSignature(sig1);
-        final byte[] hash1b = BackupUtils.hashSignature(new Signature(sig1));
-
-        final byte[] hash2a = BackupUtils.hashSignature(sig2);
-        final byte[] hash2b = BackupUtils.hashSignature(new Signature(sig2));
-
-        assertEquals(32, hash1a.length);
-        MoreAsserts.assertEquals(hash1a, hash1b);
-
-        assertEquals(32, hash2a.length);
-        MoreAsserts.assertEquals(hash2a, hash2b);
-
-        assertFalse(Arrays.equals(hash1a, hash2a));
-
-        final ArrayList<byte[]> listA = BackupUtils.hashSignatureArray(Arrays.asList(
-                "abc".getBytes(), "def".getBytes()));
-
-        final ArrayList<byte[]> listB = BackupUtils.hashSignatureArray(new Signature[]{
-                new Signature("abc".getBytes()), new Signature("def".getBytes())});
-
-        assertEquals(2, listA.size());
-        assertEquals(2, listB.size());
-
-        MoreAsserts.assertEquals(hash1a, listA.get(0));
-        MoreAsserts.assertEquals(hash1a, listB.get(0));
-
-        MoreAsserts.assertEquals(hash2a, listA.get(1));
-        MoreAsserts.assertEquals(hash2a, listB.get(1));
-    }
-}
diff --git a/services/tests/servicestests/src/com/android/server/search/SearchablesTest.java b/services/tests/servicestests/src/com/android/server/search/SearchablesTest.java
deleted file mode 100644
index 0f9bf2f6cd8..00000000000
--- a/services/tests/servicestests/src/com/android/server/search/SearchablesTest.java
+++ /dev/null
@@ -1,449 +0,0 @@
-/*
- * Copyright (C) 2009 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.android.server.search;
-
-import android.app.SearchManager;
-import android.app.SearchableInfo;
-import android.app.SearchableInfo.ActionKeyInfo;
-import android.content.ComponentName;
-import android.content.Context;
-import android.content.Intent;
-import android.content.pm.ActivityInfo;
-import android.content.pm.ApplicationInfo;
-import android.content.pm.PackageManager;
-import android.content.pm.ProviderInfo;
-import android.content.pm.ResolveInfo;
-import android.content.res.Resources;
-import android.content.res.XmlResourceParser;
-import android.os.RemoteException;
-import com.android.server.search.Searchables;
-import android.test.AndroidTestCase;
-import android.test.MoreAsserts;
-import android.test.mock.MockContext;
-import android.test.mock.MockPackageManager;
-import android.test.suitebuilder.annotation.SmallTest;
-import android.view.KeyEvent;
-
-import java.util.ArrayList;
-import java.util.List;
-
-/**
- * To launch this test from the command line:
- * 
- * adb shell am instrument -w \
- *   -e class com.android.unit_tests.SearchablesTest \
- *   com.android.unit_tests/android.test.InstrumentationTestRunner
- */
-@SmallTest
-public class SearchablesTest extends AndroidTestCase {
-    
-    /*
-     * SearchableInfo tests
-     *  Mock the context so I can provide very specific input data
-     *  Confirm OK with "zero" searchables
-     *  Confirm "good" metadata read properly
-     *  Confirm "bad" metadata skipped properly
-     *  Confirm ordering of searchables
-     *  Confirm "good" actionkeys
-     *  confirm "bad" actionkeys are rejected
-     *  confirm XML ordering enforced (will fail today - bug in SearchableInfo)
-     *  findActionKey works
-     *  getIcon works
-     */
-
-    /**
-     * Test that non-searchable activities return no searchable info (this would typically
-     * trigger the use of the default searchable e.g. contacts)
-     */
-    public void testNonSearchable() {
-        // test basic array & hashmap
-        Searchables searchables = new Searchables(mContext, 0);
-        searchables.updateSearchableList();
-
-        // confirm that we return null for non-searchy activities
-        ComponentName nonActivity = new ComponentName(
-                            "com.android.frameworks.coretests",
-                            "com.android.frameworks.coretests.activity.NO_SEARCH_ACTIVITY");
-        SearchableInfo si = searchables.getSearchableInfo(nonActivity);
-        assertNull(si);
-    }
-
-    /**
-     * This is an attempt to run the searchable info list with a mocked context.  Here are some
-     * things I'd like to test.
-     *
-     *  Confirm OK with "zero" searchables
-     *  Confirm "good" metadata read properly
-     *  Confirm "bad" metadata skipped properly
-     *  Confirm ordering of searchables
-     *  Confirm "good" actionkeys
-     *  confirm "bad" actionkeys are rejected
-     *  confirm XML ordering enforced (will fail today - bug in SearchableInfo)
-     *  findActionKey works
-     *  getIcon works
-
-     */
-    public void testSearchablesListReal() {
-        MyMockPackageManager mockPM = new MyMockPackageManager(mContext.getPackageManager());
-        MyMockContext mockContext = new MyMockContext(mContext, mockPM);
-
-        // build item list with real-world source data
-        mockPM.setSearchablesMode(MyMockPackageManager.SEARCHABLES_PASSTHROUGH);
-        Searchables searchables = new Searchables(mockContext, 0);
-        searchables.updateSearchableList();
-        // tests with "real" searchables (deprecate, this should be a unit test)
-        ArrayList<SearchableInfo> searchablesList = searchables.getSearchablesList();
-        int count = searchablesList.size();
-        assertTrue(count >= 1);         // this isn't really a unit test
-        checkSearchables(searchablesList);
-        ArrayList<SearchableInfo> global = searchables.getSearchablesInGlobalSearchList();
-        checkSearchables(global);
-    }
-
-    /**
-     * This round of tests confirms good operations with "zero" searchables found
-     */
-    public void testSearchablesListEmpty() {
-        MyMockPackageManager mockPM = new MyMockPackageManager(mContext.getPackageManager());
-        MyMockContext mockContext = new MyMockContext(mContext, mockPM);
-
-        mockPM.setSearchablesMode(MyMockPackageManager.SEARCHABLES_MOCK_ZERO);
-        Searchables searchables = new Searchables(mockContext, 0);
-        searchables.updateSearchableList();
-        ArrayList<SearchableInfo> searchablesList = searchables.getSearchablesList();
-        assertNotNull(searchablesList);
-        MoreAsserts.assertEmpty(searchablesList);
-        ArrayList<SearchableInfo> global = searchables.getSearchablesInGlobalSearchList();
-        MoreAsserts.assertEmpty(global);
-    }
-    
-    /**
-     * Generic health checker for an array of searchables.
-     * 
-     * This is designed to pass for any semi-legal searchable, without knowing much about
-     * the format of the underlying data.  It's fairly easy for a non-compliant application
-     * to provide meta-data that will pass here (e.g. a non-existent suggestions authority).
-     * 
-     * @param searchables The list of searchables to examine.
-     */
-    private void checkSearchables(ArrayList<SearchableInfo> searchablesList) {
-        assertNotNull(searchablesList);
-        int count = searchablesList.size();
-        for (int ii = 0; ii < count; ii++) {
-            SearchableInfo si = searchablesList.get(ii);
-            checkSearchable(si);
-        }
-    }
-    
-    private void checkSearchable(SearchableInfo si) {
-        assertNotNull(si);
-        assertTrue(si.getLabelId() != 0);        // This must be a useable string
-        assertNotEmpty(si.getSearchActivity().getClassName());
-        assertNotEmpty(si.getSearchActivity().getPackageName());
-        if (si.getSuggestAuthority() != null) {
-            // The suggestion fields are largely optional, so we'll just confirm basic health
-            assertNotEmpty(si.getSuggestAuthority());
-            assertNullOrNotEmpty(si.getSuggestPath());
-            assertNullOrNotEmpty(si.getSuggestSelection());
-            assertNullOrNotEmpty(si.getSuggestIntentAction());
-            assertNullOrNotEmpty(si.getSuggestIntentData());
-        }
-        /* Add a way to get the entire action key list, then explicitly test its elements */
-        /* For now, test the most common action key (CALL) */
-        ActionKeyInfo ai = si.findActionKey(KeyEvent.KEYCODE_CALL);
-        if (ai != null) {
-            assertEquals(ai.getKeyCode(), KeyEvent.KEYCODE_CALL);
-            // one of these three fields must be non-null & non-empty
-            boolean m1 = (ai.getQueryActionMsg() != null) && (ai.getQueryActionMsg().length() > 0);
-            boolean m2 = (ai.getSuggestActionMsg() != null) && (ai.getSuggestActionMsg().length() > 0);
-            boolean m3 = (ai.getSuggestActionMsgColumn() != null) && 
-                            (ai.getSuggestActionMsgColumn().length() > 0);
-            assertTrue(m1 || m2 || m3);
-        }
-        
-        /* 
-         * Find ways to test these:
-         * 
-         * private int mSearchMode
-         * private Drawable mIcon
-         */
-        
-        /*
-         * Explicitly not tested here:
-         * 
-         * Can be null, so not much to see:
-         * public String mSearchHint
-         * private String mZeroQueryBanner
-         * 
-         * To be deprecated/removed, so don't bother:
-         * public boolean mFilterMode
-         * public boolean mQuickStart
-         * private boolean mIconResized
-         * private int mIconResizeWidth
-         * private int mIconResizeHeight
-         * 
-         * All of these are "internal" working variables, not part of any contract
-         * private ActivityInfo mActivityInfo
-         * private Rect mTempRect
-         * private String mSuggestProviderPackage
-         * private String mCacheActivityContext
-         */
-    }
-    
-    /**
-     * Combo assert for "string not null and not empty"
-     */
-    private void assertNotEmpty(final String s) {
-        assertNotNull(s);
-        MoreAsserts.assertNotEqual(s, "");
-    }
-    
-    /**
-     * Combo assert for "string null or (not null and not empty)"
-     */
-    private void assertNullOrNotEmpty(final String s) {
-        if (s != null) {
-            MoreAsserts.assertNotEqual(s, "");
-        }
-    }    
-    
-    /**
-     * This is a mock for context.  Used to perform a true unit test on SearchableInfo.
-     * 
-     */
-    private class MyMockContext extends MockContext {
-        
-        protected Context mRealContext;
-        protected PackageManager mPackageManager;
-        
-        /**
-         * Constructor.
-         * 
-         * @param realContext Please pass in a real context for some pass-throughs to function.
-         */
-        MyMockContext(Context realContext, PackageManager packageManager) {
-            mRealContext = realContext;
-            mPackageManager = packageManager;
-        }
-        
-        /**
-         * Resources.  Pass through for now.
-         */
-        @Override
-        public Resources getResources() {
-            return mRealContext.getResources();
-        }
-
-        /**
-         * Package manager.  Pass through for now.
-         */
-        @Override
-        public PackageManager getPackageManager() {
-            return mPackageManager;
-        }
-
-        /**
-         * Package manager.  Pass through for now.
-         */
-        @Override
-        public Context createPackageContext(String packageName, int flags)
-                throws PackageManager.NameNotFoundException {
-            return mRealContext.createPackageContext(packageName, flags);
-        }
-
-        /**
-         * Message broadcast.  Pass through for now.
-         */
-        @Override
-        public void sendBroadcast(Intent intent) {
-            mRealContext.sendBroadcast(intent);
-        }
-    }
-
-/**
- * This is a mock for package manager.  Used to perform a true unit test on SearchableInfo.
- * 
- */
-    private class MyMockPackageManager extends MockPackageManager {
-        
-        public final static int SEARCHABLES_PASSTHROUGH = 0;
-        public final static int SEARCHABLES_MOCK_ZERO = 1;
-        public final static int SEARCHABLES_MOCK_ONEGOOD = 2;
-        public final static int SEARCHABLES_MOCK_ONEGOOD_ONEBAD = 3;
-        
-        protected PackageManager mRealPackageManager;
-        protected int mSearchablesMode;
-
-        public MyMockPackageManager(PackageManager realPM) {
-            mRealPackageManager = realPM;
-            mSearchablesMode = SEARCHABLES_PASSTHROUGH;
-        }
-
-        /**
-         * Set the mode for various tests.
-         */
-        public void setSearchablesMode(int newMode) {
-            switch (newMode) {
-            case SEARCHABLES_PASSTHROUGH:
-            case SEARCHABLES_MOCK_ZERO:
-                mSearchablesMode = newMode;
-                break;
-                
-            default:
-                throw new UnsupportedOperationException();       
-            }
-        }
-        
-        /**
-         * Find activities that support a given intent.
-         * 
-         * Retrieve all activities that can be performed for the given intent.
-         * 
-         * @param intent The desired intent as per resolveActivity().
-         * @param flags Additional option flags.  The most important is
-         *                    MATCH_DEFAULT_ONLY, to limit the resolution to only
-         *                    those activities that support the CATEGORY_DEFAULT.
-         * 
-         * @return A List<ResolveInfo> containing one entry for each matching
-         *         Activity. These are ordered from best to worst match -- that
-         *         is, the first item in the list is what is returned by
-         *         resolveActivity().  If there are no matching activities, an empty
-         *         list is returned.
-         */
-        @Override 
-        public List<ResolveInfo> queryIntentActivities(Intent intent, int flags) {
-            assertNotNull(intent);
-            assertTrue(intent.getAction().equals(Intent.ACTION_SEARCH)
-                    || intent.getAction().equals(Intent.ACTION_WEB_SEARCH)
-                    || intent.getAction().equals(SearchManager.INTENT_ACTION_GLOBAL_SEARCH));
-            switch (mSearchablesMode) {
-            case SEARCHABLES_PASSTHROUGH:
-                return mRealPackageManager.queryIntentActivities(intent, flags);
-            case SEARCHABLES_MOCK_ZERO:
-                return null;
-            default:
-                throw new UnsupportedOperationException();
-            }
-        }
-        
-        @Override
-        public ResolveInfo resolveActivity(Intent intent, int flags) {
-            assertNotNull(intent);
-            assertTrue(intent.getAction().equals(Intent.ACTION_WEB_SEARCH)
-                    || intent.getAction().equals(SearchManager.INTENT_ACTION_GLOBAL_SEARCH));
-            switch (mSearchablesMode) {
-            case SEARCHABLES_PASSTHROUGH:
-                return mRealPackageManager.resolveActivity(intent, flags);
-            case SEARCHABLES_MOCK_ZERO:
-                return null;
-            default:
-                throw new UnsupportedOperationException();
-            }
-        }
-
-        /**
-         * Retrieve an XML file from a package.  This is a low-level API used to
-         * retrieve XML meta data.
-         * 
-         * @param packageName The name of the package that this xml is coming from.
-         * Can not be null.
-         * @param resid The resource identifier of the desired xml.  Can not be 0.
-         * @param appInfo Overall information about <var>packageName</var>.  This
-         * may be null, in which case the application information will be retrieved
-         * for you if needed; if you already have this information around, it can
-         * be much more efficient to supply it here.
-         * 
-         * @return Returns an XmlPullParser allowing you to parse out the XML
-         * data.  Returns null if the xml resource could not be found for any
-         * reason.
-         */
-        @Override 
-        public XmlResourceParser getXml(String packageName, int resid, ApplicationInfo appInfo) {
-            assertNotNull(packageName);
-            MoreAsserts.assertNotEqual(packageName, "");
-            MoreAsserts.assertNotEqual(resid, 0);
-            switch (mSearchablesMode) {
-            case SEARCHABLES_PASSTHROUGH:
-                return mRealPackageManager.getXml(packageName, resid, appInfo);
-            case SEARCHABLES_MOCK_ZERO:
-            default:
-                throw new UnsupportedOperationException();
-            }
-        }
-        
-        /**
-         * Find a single content provider by its base path name.
-         * 
-         * @param name The name of the provider to find.
-         * @param flags Additional option flags.  Currently should always be 0.
-         * 
-         * @return ContentProviderInfo Information about the provider, if found,
-         *         else null.
-         */
-        @Override 
-        public ProviderInfo resolveContentProvider(String name, int flags) {
-            assertNotNull(name);
-            MoreAsserts.assertNotEqual(name, "");
-            assertEquals(flags, 0);
-            switch (mSearchablesMode) {
-            case SEARCHABLES_PASSTHROUGH:
-                return mRealPackageManager.resolveContentProvider(name, flags);
-            case SEARCHABLES_MOCK_ZERO:
-            default:
-                throw new UnsupportedOperationException();
-            }
-        }
-
-        /**
-         * Get the activity information for a particular activity.
-         *
-         * @param name The name of the activity to find.
-         * @param flags Additional option flags.
-         *
-         * @return ActivityInfo Information about the activity, if found, else null.
-         */
-        @Override
-        public ActivityInfo getActivityInfo(ComponentName name, int flags)
-                throws NameNotFoundException {
-            assertNotNull(name);
-            MoreAsserts.assertNotEqual(name, "");
-            switch (mSearchablesMode) {
-            case SEARCHABLES_PASSTHROUGH:
-                return mRealPackageManager.getActivityInfo(name, flags);
-            case SEARCHABLES_MOCK_ZERO:
-                throw new NameNotFoundException();
-            default:
-                throw new UnsupportedOperationException();
-            }
-        }
-
-        @Override
-        public int checkPermission(String permName, String pkgName) {
-            assertNotNull(permName);
-            assertNotNull(pkgName);
-            switch (mSearchablesMode) {
-                case SEARCHABLES_PASSTHROUGH:
-                    return mRealPackageManager.checkPermission(permName, pkgName);
-                case SEARCHABLES_MOCK_ZERO:
-                    return PackageManager.PERMISSION_DENIED;
-                default:
-                    throw new UnsupportedOperationException();
-                }
-        }
-    }
-}
-
diff --git a/services/tests/servicestests/src/com/android/server/testutis/TestUtils.java b/services/tests/servicestests/src/com/android/server/testutis/TestUtils.java
deleted file mode 100644
index d2a44841ee0..00000000000
--- a/services/tests/servicestests/src/com/android/server/testutis/TestUtils.java
+++ /dev/null
@@ -1,42 +0,0 @@
-/*
- * Copyright (C) 2016 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.android.server.testutis;
-
-import android.test.MoreAsserts;
-
-import junit.framework.Assert;
-
-public class TestUtils {
-    private TestUtils() {
-    }
-
-    public static void assertExpectException(Class<? extends Throwable> expectedExceptionType,
-            String expectedExceptionMessageRegex, Runnable r) {
-        try {
-            r.run();
-            Assert.fail("Expected exception type " + expectedExceptionType.getName()
-                    + " was not thrown");
-        } catch (Throwable e) {
-            Assert.assertTrue(
-                    "Expected exception type was " + expectedExceptionType.getName()
-                    + " but caught " + e.getClass().getName(),
-                    expectedExceptionType.isAssignableFrom(e.getClass()));
-            if (expectedExceptionMessageRegex != null) {
-                MoreAsserts.assertContainsRegex(expectedExceptionMessageRegex, e.getMessage());
-            }
-        }
-    }
-}
diff --git a/services/tests/servicestests/src/com/android/server/updates/CertPinInstallReceiverTest.java b/services/tests/servicestests/src/com/android/server/updates/CertPinInstallReceiverTest.java
deleted file mode 100644
index d79851817f8..00000000000
--- a/services/tests/servicestests/src/com/android/server/updates/CertPinInstallReceiverTest.java
+++ /dev/null
@@ -1,245 +0,0 @@
-/*
- * Copyright (C) 2012 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.android.server.updates;
-
-import com.android.internal.util.HexDump;
-
-import android.content.Context;
-import android.content.Intent;
-import android.test.AndroidTestCase;
-import android.provider.Settings;
-import android.util.Base64;
-import android.util.Log;
-
-import java.io.ByteArrayInputStream;
-import java.io.File;
-import java.io.FileInputStream;
-import java.io.FileOutputStream;
-import java.io.FileWriter;
-import java.io.IOException;
-import java.io.InputStream;
-import java.security.cert.CertificateFactory;
-import java.security.cert.Certificate;
-import java.security.cert.X509Certificate;
-import java.security.MessageDigest;
-import java.security.NoSuchAlgorithmException;
-import java.security.PrivateKey;
-import java.security.Signature;
-import java.security.spec.PKCS8EncodedKeySpec;
-import java.security.KeyFactory;
-import java.util.HashSet;
-import java.io.*;
-import libcore.io.IoUtils;
-
-/**
- * Tests for {@link com.android.server.CertPinInstallReceiver}
- */
-public class CertPinInstallReceiverTest extends AndroidTestCase {
-
-    private static final String TAG = "CertPinInstallReceiverTest";
-
-    private static final String PINLIST_ROOT = System.getenv("ANDROID_DATA") + "/misc/keychain/";
-
-    public static final String PINLIST_CONTENT_PATH = PINLIST_ROOT + "pins";
-    public static final String PINLIST_METADATA_PATH = PINLIST_CONTENT_PATH + "metadata";
-
-    public static final String PINLIST_CONTENT_URL_KEY = "pinlist_content_url";
-    public static final String PINLIST_METADATA_URL_KEY = "pinlist_metadata_url";
-    public static final String PINLIST_CERTIFICATE_KEY = "config_update_certificate";
-    public static final String PINLIST_VERSION_KEY = "pinlist_version";
-
-    private static final String EXTRA_CONTENT_PATH = "CONTENT_PATH";
-    private static final String EXTRA_REQUIRED_HASH = "REQUIRED_HASH";
-    private static final String EXTRA_SIGNATURE = "SIGNATURE";
-    private static final String EXTRA_VERSION_NUMBER = "VERSION";
-
-    public static final String TEST_CERT = "" +
-                    "MIIDsjCCAxugAwIBAgIJAPLf2gS0zYGUMA0GCSqGSIb3DQEBBQUAMIGYMQswCQYDVQQGEwJVUzET" +
-                    "MBEGA1UECBMKQ2FsaWZvcm5pYTEWMBQGA1UEBxMNTW91bnRhaW4gVmlldzEPMA0GA1UEChMGR29v" +
-                    "Z2xlMRAwDgYDVQQLEwd0ZXN0aW5nMRYwFAYDVQQDEw1HZXJlbXkgQ29uZHJhMSEwHwYJKoZIhvcN" +
-                    "AQkBFhJnY29uZHJhQGdvb2dsZS5jb20wHhcNMTIwNzE0MTc1MjIxWhcNMTIwODEzMTc1MjIxWjCB" +
-                    "mDELMAkGA1UEBhMCVVMxEzARBgNVBAgTCkNhbGlmb3JuaWExFjAUBgNVBAcTDU1vdW50YWluIFZp" +
-                    "ZXcxDzANBgNVBAoTBkdvb2dsZTEQMA4GA1UECxMHdGVzdGluZzEWMBQGA1UEAxMNR2VyZW15IENv" +
-                    "bmRyYTEhMB8GCSqGSIb3DQEJARYSZ2NvbmRyYUBnb29nbGUuY29tMIGfMA0GCSqGSIb3DQEBAQUA" +
-                    "A4GNADCBiQKBgQCjGGHATBYlmas+0sEECkno8LZ1KPglb/mfe6VpCT3GhSr+7br7NG/ZwGZnEhLq" +
-                    "E7YIH4fxltHmQC3Tz+jM1YN+kMaQgRRjo/LBCJdOKaMwUbkVynAH6OYsKevjrOPk8lfM5SFQzJMG" +
-                    "sA9+Tfopr5xg0BwZ1vA/+E3mE7Tr3M2UvwIDAQABo4IBADCB/TAdBgNVHQ4EFgQUhzkS9E6G+x8W" +
-                    "L4EsmRjDxu28tHUwgc0GA1UdIwSBxTCBwoAUhzkS9E6G+x8WL4EsmRjDxu28tHWhgZ6kgZswgZgx" +
-                    "CzAJBgNVBAYTAlVTMRMwEQYDVQQIEwpDYWxpZm9ybmlhMRYwFAYDVQQHEw1Nb3VudGFpbiBWaWV3" +
-                    "MQ8wDQYDVQQKEwZHb29nbGUxEDAOBgNVBAsTB3Rlc3RpbmcxFjAUBgNVBAMTDUdlcmVteSBDb25k" +
-                    "cmExITAfBgkqhkiG9w0BCQEWEmdjb25kcmFAZ29vZ2xlLmNvbYIJAPLf2gS0zYGUMAwGA1UdEwQF" +
-                    "MAMBAf8wDQYJKoZIhvcNAQEFBQADgYEAYiugFDmbDOQ2U/+mqNt7o8ftlEo9SJrns6O8uTtK6AvR" +
-                    "orDrR1AXTXkuxwLSbmVfedMGOZy7Awh7iZa8hw5x9XmUudfNxvmrKVEwGQY2DZ9PXbrnta/dwbhK" +
-                    "mWfoepESVbo7CKIhJp8gRW0h1Z55ETXD57aGJRvQS4pxkP8ANhM=";
-
-
-    public static final String TEST_KEY = "" +
-                    "MIICdgIBADANBgkqhkiG9w0BAQEFAASCAmAwggJcAgEAAoGBAKMYYcBMFiWZqz7SwQQKSejwtnUo" +
-                    "+CVv+Z97pWkJPcaFKv7tuvs0b9nAZmcSEuoTtggfh/GW0eZALdPP6MzVg36QxpCBFGOj8sEIl04p" +
-                    "ozBRuRXKcAfo5iwp6+Os4+TyV8zlIVDMkwawD35N+imvnGDQHBnW8D/4TeYTtOvczZS/AgMBAAEC" +
-                    "gYBxwFalNSwZK3WJipq+g6KLCiBn1JxGGDQlLKrweFaSuFyFky9fd3IvkIabirqQchD612sMb+GT" +
-                    "0t1jptW6z4w2w6++IW0A3apDOCwoD+uvDBXrbFqI0VbyAWUNqHVdaFFIRk2IHGEE6463mGRdmILX" +
-                    "IlCd/85RTHReg4rl/GFqWQJBANgLAIR4pWbl5Gm+DtY18wp6Q3pJAAMkmP/lISCBIidu1zcqYIKt" +
-                    "PoDW4Knq9xnhxPbXrXKv4YzZWHBK8GkKhQ0CQQDBQnXufQcMew+PwiS0oJvS+eQ6YJwynuqG2ejg" +
-                    "WE+T7489jKtscRATpUXpZUYmDLGg9bLt7L62hFvFSj2LO2X7AkBcdrD9AWnBFWlh/G77LVHczSEu" +
-                    "KCoyLiqxcs5vy/TjLaQ8vw1ZQG580/qJnr+tOxyCjSJ18GK3VppsTRaBznfNAkB3nuCKNp9HTWCL" +
-                    "dfrsRsFMrFpk++mSt6SoxXaMbn0LL2u1CD4PCEiQMGt+lK3/3TmRTKNs+23sYS7Ahjxj0udDAkEA" +
-                    "p57Nj65WNaWeYiOfTwKXkLj8l29H5NbaGWxPT0XkWr4PvBOFZVH/wj0/qc3CMVGnv11+DyO+QUCN" +
-                    "SqBB5aRe8g==";
-
-    private void overrideSettings(String key, String value) throws Exception {
-        assertTrue(Settings.Secure.putString(mContext.getContentResolver(), key, value));
-        Thread.sleep(1000);
-    }
-
-    private void overrideCert(String value) throws Exception {
-        overrideSettings(PINLIST_CERTIFICATE_KEY, value);
-    }
-
-    private String readPins() throws Exception {
-        return IoUtils.readFileAsString(PINLIST_CONTENT_PATH);
-    }
-
-    private String readCurrentVersion() throws Exception {
-        return IoUtils.readFileAsString("/data/misc/keychain/metadata/version");
-    }
-
-    private String getNextVersion() throws Exception {
-        int currentVersion = Integer.parseInt(readCurrentVersion());
-        return Integer.toString(currentVersion + 1);
-    }
-
-    private static String getCurrentHash(String content) throws Exception {
-        if (content == null) {
-            return "0";
-        }
-        MessageDigest dgst = MessageDigest.getInstance("SHA512");
-        byte[] encoded = content.getBytes();
-        byte[] fingerprint = dgst.digest(encoded);
-        return HexDump.toHexString(fingerprint, false);
-    }
-
-    private static String getHashOfCurrentContent() throws Exception {
-        String content = IoUtils.readFileAsString("/data/misc/keychain/pins");
-        return getCurrentHash(content);
-    }
-
-    private PrivateKey createKey() throws Exception {
-        byte[] derKey = Base64.decode(TEST_KEY.getBytes(), Base64.DEFAULT);
-        PKCS8EncodedKeySpec keySpec = new PKCS8EncodedKeySpec(derKey);
-        KeyFactory keyFactory = KeyFactory.getInstance("RSA");
-        return (PrivateKey) keyFactory.generatePrivate(keySpec);
-    }
-
-    private X509Certificate createCertificate() throws Exception {
-        byte[] derCert = Base64.decode(TEST_CERT.getBytes(), Base64.DEFAULT);
-        InputStream istream = new ByteArrayInputStream(derCert);
-        CertificateFactory cf = CertificateFactory.getInstance("X.509");
-        return (X509Certificate) cf.generateCertificate(istream);
-    }
-
-    private String makeTemporaryContentFile(String content) throws Exception {
-        FileOutputStream fw = mContext.openFileOutput("content.txt", mContext.MODE_WORLD_READABLE);
-        fw.write(content.getBytes(), 0, content.length());
-        fw.close();
-        return mContext.getFilesDir() + "/content.txt";
-    }
-
-    private String createSignature(String content, String version, String requiredHash)
-                                   throws Exception {
-        Signature signer = Signature.getInstance("SHA512withRSA");
-        signer.initSign(createKey());
-        signer.update(content.trim().getBytes());
-        signer.update(version.trim().getBytes());
-        signer.update(requiredHash.getBytes());
-        String sig = new String(Base64.encode(signer.sign(), Base64.DEFAULT));
-        assertEquals(true,
-                     verifySignature(content, version, requiredHash, sig, createCertificate()));
-        return sig;
-    }
-
-    public boolean verifySignature(String content, String version, String requiredPrevious,
-                                   String signature, X509Certificate cert) throws Exception {
-        Signature signer = Signature.getInstance("SHA512withRSA");
-        signer.initVerify(cert);
-        signer.update(content.trim().getBytes());
-        signer.update(version.trim().getBytes());
-        signer.update(requiredPrevious.trim().getBytes());
-        return signer.verify(Base64.decode(signature.getBytes(), Base64.DEFAULT));
-    }
-
-    private void sendIntent(String contentPath, String version, String required, String sig) {
-        Intent i = new Intent();
-        i.setAction("android.intent.action.UPDATE_PINS");
-        i.putExtra(EXTRA_CONTENT_PATH, contentPath);
-        i.putExtra(EXTRA_VERSION_NUMBER, version);
-        i.putExtra(EXTRA_REQUIRED_HASH, required);
-        i.putExtra(EXTRA_SIGNATURE, sig);
-        mContext.sendBroadcast(i);
-    }
-
-    private String runTest(String cert, String content, String version, String required, String sig)
-                           throws Exception {
-        Log.e(TAG, "started test");
-        overrideCert(cert);
-        String contentPath = makeTemporaryContentFile(content);
-        sendIntent(contentPath, version, required, sig);
-        Thread.sleep(1000);
-        return readPins();
-    }
-
-    private String runTestWithoutSig(String cert, String content, String version, String required)
-                                     throws Exception {
-        String sig = createSignature(content, version, required);
-        return runTest(cert, content, version, required, sig);
-    }
-
-    public void testOverwritePinlist() throws Exception {
-        Log.e(TAG, "started testOverwritePinList");
-        assertEquals("abcde", runTestWithoutSig(TEST_CERT, "abcde", getNextVersion(), getHashOfCurrentContent()));
-        Log.e(TAG, "started testOverwritePinList");
-    }
-
-   public void testBadSignatureFails() throws Exception {
-        Log.e(TAG, "started testOverwritePinList");
-        String text = "blahblah";
-        runTestWithoutSig(TEST_CERT, text, getNextVersion(), getHashOfCurrentContent());
-        assertEquals(text, runTest(TEST_CERT, "bcdef", getNextVersion(), getCurrentHash(text), ""));
-        Log.e(TAG, "started testOverwritePinList");
-    }
-
-    public void testBadRequiredHashFails() throws Exception {
-        runTestWithoutSig(TEST_CERT, "blahblahblah", getNextVersion(), getHashOfCurrentContent());
-        assertEquals("blahblahblah", runTestWithoutSig(TEST_CERT, "cdefg", getNextVersion(), "0"));
-        Log.e(TAG, "started testOverwritePinList");
-    }
-
-    public void testBadVersionFails() throws Exception {
-        String text = "blahblahblahblah";
-        String version = getNextVersion();
-        runTestWithoutSig(TEST_CERT, text, version, getHashOfCurrentContent());
-        assertEquals(text, runTestWithoutSig(TEST_CERT, "defgh", version, getCurrentHash(text)));
-        Log.e(TAG, "started testOverwritePinList");
-    }
-
-    public void testOverrideRequiredHash() throws Exception {
-        runTestWithoutSig(TEST_CERT, "blahblahblah", getNextVersion(), getHashOfCurrentContent());
-        assertEquals("blahblahblah", runTestWithoutSig(TEST_CERT, "cdefg", "NONE", "0"));
-        Log.e(TAG, "started testOverwritePinList");
-    }
-
-}
diff --git a/services/tests/servicestests/src/com/android/server/usage/AppIdleHistoryTests.java b/services/tests/servicestests/src/com/android/server/usage/AppIdleHistoryTests.java
deleted file mode 100644
index 0bd014c874b..00000000000
--- a/services/tests/servicestests/src/com/android/server/usage/AppIdleHistoryTests.java
+++ /dev/null
@@ -1,100 +0,0 @@
-/*
- * Copyright (C) 2016 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.android.server.usage;
-
-import android.os.FileUtils;
-import android.test.AndroidTestCase;
-
-import java.io.File;
-
-public class AppIdleHistoryTests extends AndroidTestCase {
-
-    File mStorageDir;
-
-    final static String PACKAGE_1 = "com.android.testpackage1";
-    final static String PACKAGE_2 = "com.android.testpackage2";
-
-    @Override
-    protected void setUp() throws Exception {
-        super.setUp();
-        mStorageDir = new File(getContext().getFilesDir(), "appidle");
-        mStorageDir.mkdirs();
-    }
-
-    @Override
-    protected void tearDown() throws Exception {
-        FileUtils.deleteContents(mStorageDir);
-        super.tearDown();
-    }
-
-    public void testFilesCreation() {
-        final int userId = 0;
-        AppIdleHistory aih = new AppIdleHistory(mStorageDir, 0);
-
-        aih.updateDisplayLocked(true, /* elapsedRealtime= */ 1000);
-        aih.updateDisplayLocked(false, /* elapsedRealtime= */ 2000);
-        // Screen On time file should be written right away
-        assertTrue(aih.getScreenOnTimeFile().exists());
-
-        aih.writeAppIdleTimesLocked(userId);
-        // stats file should be written now
-        assertTrue(new File(new File(mStorageDir, "users/" + userId),
-                AppIdleHistory.APP_IDLE_FILENAME).exists());
-    }
-
-    public void testScreenOnTime() {
-        AppIdleHistory aih = new AppIdleHistory(mStorageDir, 1000);
-        aih.updateDisplayLocked(false, 2000);
-        assertEquals(aih.getScreenOnTimeLocked(2000), 0);
-        aih.updateDisplayLocked(true, 3000);
-        assertEquals(aih.getScreenOnTimeLocked(4000), 1000);
-        assertEquals(aih.getScreenOnTimeLocked(5000), 2000);
-        aih.updateDisplayLocked(false, 6000);
-        // Screen on time should not keep progressing with screen is off
-        assertEquals(aih.getScreenOnTimeLocked(7000), 3000);
-        assertEquals(aih.getScreenOnTimeLocked(8000), 3000);
-        aih.writeAppIdleDurationsLocked();
-
-        // Check if the screen on time is persisted across instantiations
-        AppIdleHistory aih2 = new AppIdleHistory(mStorageDir, 0);
-        assertEquals(aih2.getScreenOnTimeLocked(11000), 3000);
-        aih2.updateDisplayLocked(true, 4000);
-        aih2.updateDisplayLocked(false, 5000);
-        assertEquals(aih2.getScreenOnTimeLocked(13000), 4000);
-    }
-
-    public void testPackageEvents() {
-        AppIdleHistory aih = new AppIdleHistory(mStorageDir, 1000);
-        aih.setThresholds(4000, 1000);
-        aih.updateDisplayLocked(true, 1000);
-        // App is not-idle by default
-        assertFalse(aih.isIdleLocked(PACKAGE_1, 0, 1500));
-        // Still not idle
-        assertFalse(aih.isIdleLocked(PACKAGE_1, 0, 3000));
-        // Idle now
-        assertTrue(aih.isIdleLocked(PACKAGE_1, 0, 8000));
-        // Not idle
-        assertFalse(aih.isIdleLocked(PACKAGE_2, 0, 9000));
-
-        // Screen off
-        aih.updateDisplayLocked(false, 9100);
-        // Still idle after 10 seconds because screen hasn't been on long enough
-        assertFalse(aih.isIdleLocked(PACKAGE_2, 0, 20000));
-        aih.updateDisplayLocked(true, 21000);
-        assertTrue(aih.isIdleLocked(PACKAGE_2, 0, 23000));
-    }
-}
\ No newline at end of file
diff --git a/services/tests/servicestests/src/com/android/server/webkit/TestSystemImpl.java b/services/tests/servicestests/src/com/android/server/webkit/TestSystemImpl.java
deleted file mode 100644
index e33be400a84..00000000000
--- a/services/tests/servicestests/src/com/android/server/webkit/TestSystemImpl.java
+++ /dev/null
@@ -1,116 +0,0 @@
-/*
- * Copyright (C) 2016 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.android.server.webkit;
-
-import android.content.Context;
-import android.content.pm.PackageInfo;
-import android.content.pm.PackageManager.NameNotFoundException;
-import android.webkit.WebViewProviderInfo;
-
-import java.util.HashMap;
-
-public class TestSystemImpl implements SystemInterface {
-    private String mUserProvider = null;
-    private final WebViewProviderInfo[] mPackageConfigs;
-    HashMap<String, PackageInfo> mPackages = new HashMap();
-    private boolean mFallbackLogicEnabled;
-    private final int mNumRelros;
-    private final boolean mIsDebuggable;
-
-    public TestSystemImpl(WebViewProviderInfo[] packageConfigs, boolean fallbackLogicEnabled,
-            int numRelros, boolean isDebuggable) {
-        mPackageConfigs = packageConfigs;
-        mFallbackLogicEnabled = fallbackLogicEnabled;
-        mNumRelros = numRelros;
-        mIsDebuggable = isDebuggable;
-    }
-
-    @Override
-    public WebViewProviderInfo[] getWebViewPackages() {
-        return mPackageConfigs;
-    }
-
-    @Override
-    public int onWebViewProviderChanged(PackageInfo packageInfo) {
-        return mNumRelros;
-    }
-
-    @Override
-    public String getUserChosenWebViewProvider(Context context) { return mUserProvider; }
-
-    @Override
-    public void updateUserSetting(Context context, String newProviderName) {
-        mUserProvider = newProviderName;
-    }
-
-    @Override
-    public void killPackageDependents(String packageName) {}
-
-    @Override
-    public boolean isFallbackLogicEnabled() {
-        return mFallbackLogicEnabled;
-    }
-
-    @Override
-    public void enableFallbackLogic(boolean enable) {
-        mFallbackLogicEnabled = enable;
-    }
-
-    @Override
-    public void uninstallAndDisablePackageForAllUsers(Context context, String packageName) {
-        enablePackageForAllUsers(context, packageName, false);
-    }
-
-    @Override
-    public void enablePackageForAllUsers(Context context, String packageName, boolean enable) {
-        enablePackageForUser(packageName, enable, 0);
-    }
-
-    @Override
-    public void enablePackageForUser(String packageName, boolean enable, int userId) {
-        PackageInfo packageInfo = mPackages.get(packageName);
-        if (packageInfo == null) {
-            throw new IllegalArgumentException("There is no package called " + packageName);
-        }
-        packageInfo.applicationInfo.enabled = enable;
-        setPackageInfo(packageInfo);
-    }
-
-    @Override
-    public boolean systemIsDebuggable() { return mIsDebuggable; }
-
-    @Override
-    public PackageInfo getPackageInfoForProvider(WebViewProviderInfo info) throws
-            NameNotFoundException {
-        PackageInfo ret = mPackages.get(info.packageName);
-        if (ret == null) throw new NameNotFoundException(info.packageName);
-        return ret;
-    }
-
-    public void setPackageInfo(PackageInfo pi) {
-        mPackages.put(pi.packageName, pi);
-    }
-
-    public void removePackageInfo(String packageName) {
-        mPackages.remove(packageName);
-    }
-
-    @Override
-    public int getFactoryPackageVersion(String packageName) {
-        return 0;
-    }
-}
diff --git a/services/tests/servicestests/src/com/android/server/webkit/WebViewUpdateServiceTest.java b/services/tests/servicestests/src/com/android/server/webkit/WebViewUpdateServiceTest.java
deleted file mode 100644
index b7370331ad0..00000000000
--- a/services/tests/servicestests/src/com/android/server/webkit/WebViewUpdateServiceTest.java
+++ /dev/null
@@ -1,1074 +0,0 @@
-/*
- * Copyright (C) 2016 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.android.server.webkit;
-
-import android.content.Context;
-import android.content.pm.ApplicationInfo;
-import android.content.pm.PackageInfo;
-import android.content.pm.Signature;
-import android.os.Bundle;
-import android.util.Base64;
-import android.test.AndroidTestCase;
-
-import android.webkit.WebViewFactory;
-import android.webkit.WebViewProviderInfo;
-import android.webkit.WebViewProviderResponse;
-
-import java.util.concurrent.CountDownLatch;
-
-import org.hamcrest.Description;
-
-import org.mockito.Mockito;
-import org.mockito.Matchers;
-import org.mockito.ArgumentMatcher;
-
-
-/**
- * Tests for WebViewUpdateService
- */
-public class WebViewUpdateServiceTest extends AndroidTestCase {
-    private final static String TAG = WebViewUpdateServiceTest.class.getSimpleName();
-
-    private WebViewUpdateServiceImpl mWebViewUpdateServiceImpl;
-    private TestSystemImpl mTestSystemImpl;
-
-    private static final String WEBVIEW_LIBRARY_FLAG = "com.android.webview.WebViewLibrary";
-
-    @Override
-    protected void setUp() throws Exception {
-        super.setUp();
-    }
-
-    /**
-     * Creates a new instance.
-     */
-    public WebViewUpdateServiceTest() {
-    }
-
-    private void setupWithPackages(WebViewProviderInfo[] packages) {
-        setupWithPackages(packages, true);
-    }
-
-    private void setupWithPackages(WebViewProviderInfo[] packages,
-            boolean fallbackLogicEnabled) {
-        setupWithPackages(packages, fallbackLogicEnabled, 1);
-    }
-
-    private void setupWithPackages(WebViewProviderInfo[] packages,
-            boolean fallbackLogicEnabled, int numRelros) {
-        setupWithPackages(packages, fallbackLogicEnabled, numRelros,
-                true /* isDebuggable == true -> don't check package signatures */);
-    }
-
-    private void setupWithPackages(WebViewProviderInfo[] packages,
-            boolean fallbackLogicEnabled, int numRelros, boolean isDebuggable) {
-        TestSystemImpl testing = new TestSystemImpl(packages, fallbackLogicEnabled, numRelros,
-                isDebuggable);
-        mTestSystemImpl = Mockito.spy(testing);
-        mWebViewUpdateServiceImpl =
-            new WebViewUpdateServiceImpl(null /*Context*/, mTestSystemImpl);
-    }
-
-    private void setEnabledAndValidPackageInfos(WebViewProviderInfo[] providers) {
-        for(WebViewProviderInfo wpi : providers) {
-            mTestSystemImpl.setPackageInfo(createPackageInfo(wpi.packageName, true /* enabled */,
-                        true /* valid */, true /* installed */));
-        }
-    }
-
-    private void checkCertainPackageUsedAfterWebViewBootPreparation(String expectedProviderName,
-            WebViewProviderInfo[] webviewPackages) {
-        checkCertainPackageUsedAfterWebViewBootPreparation(
-                expectedProviderName, webviewPackages, 1);
-    }
-
-    private void checkCertainPackageUsedAfterWebViewBootPreparation(String expectedProviderName,
-            WebViewProviderInfo[] webviewPackages, int numRelros) {
-        setupWithPackages(webviewPackages, true, numRelros);
-        // Add (enabled and valid) package infos for each provider
-        setEnabledAndValidPackageInfos(webviewPackages);
-
-        mWebViewUpdateServiceImpl.prepareWebViewInSystemServer();
-
-        Mockito.verify(mTestSystemImpl).onWebViewProviderChanged(
-                Mockito.argThat(new IsPackageInfoWithName(expectedProviderName)));
-
-        for (int n = 0; n < numRelros; n++) {
-            mWebViewUpdateServiceImpl.notifyRelroCreationCompleted();
-        }
-
-        WebViewProviderResponse response = mWebViewUpdateServiceImpl.waitForAndGetProvider();
-        assertEquals(WebViewFactory.LIBLOAD_SUCCESS, response.status);
-        assertEquals(expectedProviderName, response.packageInfo.packageName);
-    }
-
-    // For matching the package name of a PackageInfo
-    private class IsPackageInfoWithName extends ArgumentMatcher<PackageInfo> {
-        private final String mPackageName;
-
-        IsPackageInfoWithName(String name) {
-            mPackageName = name;
-        }
-
-        @Override
-        public boolean matches(Object p) {
-            return ((PackageInfo) p).packageName.equals(mPackageName);
-        }
-
-        // Provide a more useful description in case of mismatch
-        @Override
-        public void describeTo (Description description) {
-            description.appendText(String.format("PackageInfo with name '%s'", mPackageName));
-        }
-    }
-
-    private static PackageInfo createPackageInfo(
-            String packageName, boolean enabled, boolean valid, boolean installed) {
-        PackageInfo p = new PackageInfo();
-        p.packageName = packageName;
-        p.applicationInfo = new ApplicationInfo();
-        p.applicationInfo.enabled = enabled;
-        p.applicationInfo.metaData = new Bundle();
-        if (installed) {
-            p.applicationInfo.flags |= ApplicationInfo.FLAG_INSTALLED;
-        } else {
-            p.applicationInfo.flags &= ~ApplicationInfo.FLAG_INSTALLED;
-        }
-        if (valid) {
-            // no flag means invalid
-            p.applicationInfo.metaData.putString(WEBVIEW_LIBRARY_FLAG, "blah");
-        }
-        return p;
-    }
-
-    private static PackageInfo createPackageInfo(String packageName, boolean enabled, boolean valid,
-            boolean installed, Signature[] signatures, long updateTime) {
-        PackageInfo p = createPackageInfo(packageName, enabled, valid, installed);
-        p.signatures = signatures;
-        p.lastUpdateTime = updateTime;
-        return p;
-    }
-
-    private static PackageInfo createPackageInfo(String packageName, boolean enabled, boolean valid,
-            boolean installed, Signature[] signatures, long updateTime, boolean hidden) {
-        PackageInfo p =
-            createPackageInfo(packageName, enabled, valid, installed, signatures, updateTime);
-        if (hidden) {
-            p.applicationInfo.privateFlags |= ApplicationInfo.PRIVATE_FLAG_HIDDEN;
-        } else {
-            p.applicationInfo.privateFlags &= ~ApplicationInfo.PRIVATE_FLAG_HIDDEN;
-        }
-        return p;
-    }
-
-    private void checkPreparationPhasesForPackage(String expectedPackage, int numPreparation) {
-        // Verify that onWebViewProviderChanged was called for the numPreparation'th time for the
-        // expected package
-        Mockito.verify(mTestSystemImpl, Mockito.times(numPreparation)).onWebViewProviderChanged(
-                Mockito.argThat(new IsPackageInfoWithName(expectedPackage)));
-
-        mWebViewUpdateServiceImpl.notifyRelroCreationCompleted();
-
-        WebViewProviderResponse response = mWebViewUpdateServiceImpl.waitForAndGetProvider();
-        assertEquals(WebViewFactory.LIBLOAD_SUCCESS, response.status);
-        assertEquals(expectedPackage, response.packageInfo.packageName);
-    }
-
-
-    // ****************
-    // Tests
-    // ****************
-
-
-    public void testWithSinglePackage() {
-        String testPackageName = "test.package.name";
-        checkCertainPackageUsedAfterWebViewBootPreparation(testPackageName,
-                new WebViewProviderInfo[] {
-                    new WebViewProviderInfo(testPackageName, "",
-                            true /*default available*/, false /* fallback */, null)});
-    }
-
-    public void testDefaultPackageUsedOverNonDefault() {
-        String defaultPackage = "defaultPackage";
-        String nonDefaultPackage = "nonDefaultPackage";
-        WebViewProviderInfo[] packages = new WebViewProviderInfo[] {
-            new WebViewProviderInfo(nonDefaultPackage, "", false, false, null),
-            new WebViewProviderInfo(defaultPackage, "", true, false, null)};
-        checkCertainPackageUsedAfterWebViewBootPreparation(defaultPackage, packages);
-    }
-
-    public void testSeveralRelros() {
-        String singlePackage = "singlePackage";
-        checkCertainPackageUsedAfterWebViewBootPreparation(
-                singlePackage,
-                new WebViewProviderInfo[] {
-                    new WebViewProviderInfo(singlePackage, "", true /*def av*/, false, null)},
-                2);
-    }
-
-    // Ensure that package with valid signatures is chosen rather than package with invalid
-    // signatures.
-    public void testWithSignatures() {
-        String validPackage = "valid package";
-        String invalidPackage = "invalid package";
-
-        Signature validSignature = new Signature("11");
-        Signature invalidExpectedSignature = new Signature("22");
-        Signature invalidPackageSignature = new Signature("33");
-
-        WebViewProviderInfo[] packages = new WebViewProviderInfo[] {
-            new WebViewProviderInfo(invalidPackage, "", true, false, new String[]{
-                        Base64.encodeToString(
-                                invalidExpectedSignature.toByteArray(), Base64.DEFAULT)}),
-            new WebViewProviderInfo(validPackage, "", true, false, new String[]{
-                        Base64.encodeToString(
-                                validSignature.toByteArray(), Base64.DEFAULT)})
-        };
-        setupWithPackages(packages, true /* fallback logic enabled */, 1 /* numRelros */,
-                false /* isDebuggable */);
-        mTestSystemImpl.setPackageInfo(createPackageInfo(invalidPackage, true /* enabled */,
-                    true /* valid */, true /* installed */, new Signature[]{invalidPackageSignature}
-                    , 0 /* updateTime */));
-        mTestSystemImpl.setPackageInfo(createPackageInfo(validPackage, true /* enabled */,
-                    true /* valid */, true /* installed */, new Signature[]{validSignature}
-                    , 0 /* updateTime */));
-
-        mWebViewUpdateServiceImpl.prepareWebViewInSystemServer();
-
-
-        checkPreparationPhasesForPackage(validPackage, 1 /* first preparation for this package */);
-
-        WebViewProviderInfo[] validPackages = mWebViewUpdateServiceImpl.getValidWebViewPackages();
-        assertEquals(1, validPackages.length);
-        assertEquals(validPackage, validPackages[0].packageName);
-    }
-
-    public void testFailWaitingForRelro() {
-        WebViewProviderInfo[] packages = new WebViewProviderInfo[] {
-            new WebViewProviderInfo("packagename", "", true, true, null)};
-        setupWithPackages(packages);
-        setEnabledAndValidPackageInfos(packages);
-
-        mWebViewUpdateServiceImpl.prepareWebViewInSystemServer();
-
-        Mockito.verify(mTestSystemImpl).onWebViewProviderChanged(
-                Mockito.argThat(new IsPackageInfoWithName(packages[0].packageName)));
-
-        // Never call notifyRelroCreation()
-
-        WebViewProviderResponse response = mWebViewUpdateServiceImpl.waitForAndGetProvider();
-        assertEquals(WebViewFactory.LIBLOAD_FAILED_WAITING_FOR_RELRO, response.status);
-    }
-
-    public void testFailListingEmptyWebviewPackages() {
-        WebViewProviderInfo[] packages = new WebViewProviderInfo[0];
-        setupWithPackages(packages);
-        setEnabledAndValidPackageInfos(packages);
-
-        mWebViewUpdateServiceImpl.prepareWebViewInSystemServer();
-
-        Mockito.verify(mTestSystemImpl, Mockito.never()).onWebViewProviderChanged(
-                Matchers.anyObject());
-
-        WebViewProviderResponse response = mWebViewUpdateServiceImpl.waitForAndGetProvider();
-        assertEquals(WebViewFactory.LIBLOAD_FAILED_LISTING_WEBVIEW_PACKAGES, response.status);
-    }
-
-    public void testFailListingInvalidWebviewPackage() {
-        WebViewProviderInfo wpi = new WebViewProviderInfo("package", "", true, true, null);
-        WebViewProviderInfo[] packages = new WebViewProviderInfo[] {wpi};
-        setupWithPackages(packages);
-        mTestSystemImpl.setPackageInfo(
-                createPackageInfo(wpi.packageName, true /* enabled */, false /* valid */,
-                    true /* installed */));
-
-        mWebViewUpdateServiceImpl.prepareWebViewInSystemServer();
-
-        Mockito.verify(mTestSystemImpl, Mockito.never()).onWebViewProviderChanged(
-                Matchers.anyObject());
-
-        WebViewProviderResponse response = mWebViewUpdateServiceImpl.waitForAndGetProvider();
-        assertEquals(WebViewFactory.LIBLOAD_FAILED_LISTING_WEBVIEW_PACKAGES, response.status);
-
-        // Verify that we can recover from failing to list webview packages.
-        mTestSystemImpl.setPackageInfo(
-                createPackageInfo(wpi.packageName, true /* enabled */, true /* valid */,
-                    true /* installed */));
-        mWebViewUpdateServiceImpl.packageStateChanged(wpi.packageName,
-                WebViewUpdateService.PACKAGE_ADDED_REPLACED, 0);
-
-        checkPreparationPhasesForPackage(wpi.packageName, 1);
-    }
-
-    // Test that switching provider using changeProviderAndSetting works.
-    public void testSwitchingProvider() {
-        String firstPackage = "first";
-        String secondPackage = "second";
-        WebViewProviderInfo[] packages = new WebViewProviderInfo[] {
-            new WebViewProviderInfo(firstPackage, "", true, false, null),
-            new WebViewProviderInfo(secondPackage, "", true, false, null)};
-        checkSwitchingProvider(packages, firstPackage, secondPackage);
-    }
-
-    public void testSwitchingProviderToNonDefault() {
-        String defaultPackage = "defaultPackage";
-        String nonDefaultPackage = "nonDefaultPackage";
-        WebViewProviderInfo[] packages = new WebViewProviderInfo[] {
-            new WebViewProviderInfo(defaultPackage, "", true, false, null),
-            new WebViewProviderInfo(nonDefaultPackage, "", false, false, null)};
-        checkSwitchingProvider(packages, defaultPackage, nonDefaultPackage);
-    }
-
-    private void checkSwitchingProvider(WebViewProviderInfo[] packages, String initialPackage,
-            String finalPackage) {
-        checkCertainPackageUsedAfterWebViewBootPreparation(initialPackage, packages);
-
-        mWebViewUpdateServiceImpl.changeProviderAndSetting(finalPackage);
-        checkPreparationPhasesForPackage(finalPackage, 1 /* first preparation for this package */);
-
-        Mockito.verify(mTestSystemImpl).killPackageDependents(Mockito.eq(initialPackage));
-    }
-
-    // Change provider during relro creation by using changeProviderAndSetting
-    public void testSwitchingProviderDuringRelroCreation() {
-        checkChangingProviderDuringRelroCreation(true);
-    }
-
-    // Change provider during relro creation by enabling a provider
-    public void testChangingProviderThroughEnablingDuringRelroCreation() {
-        checkChangingProviderDuringRelroCreation(false);
-    }
-
-    private void checkChangingProviderDuringRelroCreation(boolean settingsChange) {
-        String firstPackage = "first";
-        String secondPackage = "second";
-        WebViewProviderInfo[] packages = new WebViewProviderInfo[] {
-            new WebViewProviderInfo(firstPackage, "", true, false, null),
-            new WebViewProviderInfo(secondPackage, "", true, false, null)};
-        setupWithPackages(packages);
-        if (settingsChange) {
-            // Have all packages be enabled, so that we can change provider however we want to
-            setEnabledAndValidPackageInfos(packages);
-        } else {
-            // Have all packages be disabled so that we can change one to enabled later
-            for(WebViewProviderInfo wpi : packages) {
-                mTestSystemImpl.setPackageInfo(createPackageInfo(wpi.packageName,
-                            false /* enabled */, true /* valid */, true /* installed */));
-            }
-        }
-
-        CountDownLatch countdown = new CountDownLatch(1);
-
-        mWebViewUpdateServiceImpl.prepareWebViewInSystemServer();
-
-        Mockito.verify(mTestSystemImpl).onWebViewProviderChanged(
-                Mockito.argThat(new IsPackageInfoWithName(firstPackage)));
-
-        assertEquals(firstPackage, mWebViewUpdateServiceImpl.getCurrentWebViewPackageName());
-
-        new Thread(new Runnable() {
-            @Override
-            public void run() {
-                WebViewProviderResponse threadResponse =
-                    mWebViewUpdateServiceImpl.waitForAndGetProvider();
-                assertEquals(WebViewFactory.LIBLOAD_SUCCESS, threadResponse.status);
-                assertEquals(secondPackage, threadResponse.packageInfo.packageName);
-                // Verify that we killed the first package
-                Mockito.verify(mTestSystemImpl).killPackageDependents(Mockito.eq(firstPackage));
-                countdown.countDown();
-            }
-        }).start();
-        try {
-            Thread.sleep(500); // Let the new thread run / be blocked
-        } catch (InterruptedException e) {
-        }
-
-        if (settingsChange) {
-            mWebViewUpdateServiceImpl.changeProviderAndSetting(secondPackage);
-        } else {
-            // Switch provider by enabling the second one
-            mTestSystemImpl.setPackageInfo(createPackageInfo(secondPackage, true /* enabled */,
-                        true /* valid */, true /* installed */));
-            mWebViewUpdateServiceImpl.packageStateChanged(
-                    secondPackage, WebViewUpdateService.PACKAGE_CHANGED, 0);
-        }
-        mWebViewUpdateServiceImpl.notifyRelroCreationCompleted();
-        // first package done, should start on second
-
-        Mockito.verify(mTestSystemImpl).onWebViewProviderChanged(
-                Mockito.argThat(new IsPackageInfoWithName(secondPackage)));
-
-        mWebViewUpdateServiceImpl.notifyRelroCreationCompleted();
-        // second package done, the other thread should now be unblocked
-        try {
-            countdown.await();
-        } catch (InterruptedException e) {
-        }
-    }
-
-    public void testRunFallbackLogicIfEnabled() {
-        checkFallbackLogicBeingRun(true);
-    }
-
-    public void testDontRunFallbackLogicIfDisabled() {
-        checkFallbackLogicBeingRun(false);
-    }
-
-    private void checkFallbackLogicBeingRun(boolean fallbackLogicEnabled) {
-        String primaryPackage = "primary";
-        String fallbackPackage = "fallback";
-        WebViewProviderInfo[] packages = new WebViewProviderInfo[] {
-            new WebViewProviderInfo(
-                    primaryPackage, "", true /* default available */, false /* fallback */, null),
-            new WebViewProviderInfo(
-                    fallbackPackage, "", true /* default available */, true /* fallback */, null)};
-        setupWithPackages(packages, fallbackLogicEnabled);
-        setEnabledAndValidPackageInfos(packages);
-
-        mWebViewUpdateServiceImpl.prepareWebViewInSystemServer();
-        // Verify that we disable the fallback package if fallback logic enabled, and don't disable
-        // the fallback package if that logic is disabled
-        if (fallbackLogicEnabled) {
-            Mockito.verify(mTestSystemImpl).uninstallAndDisablePackageForAllUsers(
-                    Matchers.anyObject(), Mockito.eq(fallbackPackage));
-        } else {
-            Mockito.verify(mTestSystemImpl, Mockito.never()).uninstallAndDisablePackageForAllUsers(
-                    Matchers.anyObject(), Matchers.anyObject());
-        }
-        Mockito.verify(mTestSystemImpl).onWebViewProviderChanged(
-                Mockito.argThat(new IsPackageInfoWithName(primaryPackage)));
-
-        // Enable fallback package
-        mTestSystemImpl.setPackageInfo(createPackageInfo(fallbackPackage, true /* enabled */,
-                        true /* valid */, true /* installed */));
-        mWebViewUpdateServiceImpl.packageStateChanged(
-                fallbackPackage, WebViewUpdateService.PACKAGE_CHANGED, 0);
-
-        if (fallbackLogicEnabled) {
-            // Check that we have now disabled the fallback package twice
-            Mockito.verify(mTestSystemImpl, Mockito.times(2)).uninstallAndDisablePackageForAllUsers(
-                    Matchers.anyObject(), Mockito.eq(fallbackPackage));
-        } else {
-            // Check that we still haven't disabled any package
-            Mockito.verify(mTestSystemImpl, Mockito.never()).uninstallAndDisablePackageForAllUsers(
-                    Matchers.anyObject(), Matchers.anyObject());
-        }
-    }
-
-    /**
-     * Scenario for installing primary package when fallback enabled.
-     * 1. Start with only fallback installed
-     * 2. Install non-fallback
-     * 3. Fallback should be disabled
-     */
-    public void testInstallingNonFallbackPackage() {
-        String primaryPackage = "primary";
-        String fallbackPackage = "fallback";
-        WebViewProviderInfo[] packages = new WebViewProviderInfo[] {
-            new WebViewProviderInfo(
-                    primaryPackage, "", true /* default available */, false /* fallback */, null),
-            new WebViewProviderInfo(
-                    fallbackPackage, "", true /* default available */, true /* fallback */, null)};
-        setupWithPackages(packages, true /* isFallbackLogicEnabled */);
-        mTestSystemImpl.setPackageInfo(
-                createPackageInfo(fallbackPackage, true /* enabled */ , true /* valid */,
-                    true /* installed */));
-
-        mWebViewUpdateServiceImpl.prepareWebViewInSystemServer();
-        Mockito.verify(mTestSystemImpl, Mockito.never()).uninstallAndDisablePackageForAllUsers(
-                Matchers.anyObject(), Matchers.anyObject());
-
-        checkPreparationPhasesForPackage(fallbackPackage,
-                1 /* first preparation for this package*/);
-
-        // Install primary package
-        mTestSystemImpl.setPackageInfo(
-                createPackageInfo(primaryPackage, true /* enabled */ , true /* valid */,
-                    true /* installed */));
-        mWebViewUpdateServiceImpl.packageStateChanged(primaryPackage,
-                WebViewUpdateService.PACKAGE_ADDED_REPLACED, 0);
-
-        // Verify fallback disabled, primary package used as provider, and fallback package killed
-        Mockito.verify(mTestSystemImpl).uninstallAndDisablePackageForAllUsers(
-                Matchers.anyObject(), Mockito.eq(fallbackPackage));
-        checkPreparationPhasesForPackage(primaryPackage, 1 /* first preparation for this package*/);
-        Mockito.verify(mTestSystemImpl).killPackageDependents(Mockito.eq(fallbackPackage));
-    }
-
-    public void testFallbackChangesEnabledState() {
-        String primaryPackage = "primary";
-        String fallbackPackage = "fallback";
-        WebViewProviderInfo[] packages = new WebViewProviderInfo[] {
-            new WebViewProviderInfo(
-                    primaryPackage, "", true /* default available */, false /* fallback */, null),
-            new WebViewProviderInfo(
-                    fallbackPackage, "", true /* default available */, true /* fallback */, null)};
-        setupWithPackages(packages, true /* fallbackLogicEnabled */);
-        setEnabledAndValidPackageInfos(packages);
-
-        mWebViewUpdateServiceImpl.prepareWebViewInSystemServer();
-
-        // Verify fallback disabled at boot when primary package enabled
-        Mockito.verify(mTestSystemImpl).enablePackageForUser(
-                Mockito.eq(fallbackPackage), Mockito.eq(false) /* enable */,
-                Matchers.anyInt());
-
-        checkPreparationPhasesForPackage(primaryPackage, 1);
-
-        // Disable primary package and ensure fallback becomes enabled and used
-        mTestSystemImpl.setPackageInfo(
-                createPackageInfo(primaryPackage, false /* enabled */, true /* valid */,
-                    true /* installed */));
-        mWebViewUpdateServiceImpl.packageStateChanged(primaryPackage,
-                WebViewUpdateService.PACKAGE_CHANGED, 0);
-
-        Mockito.verify(mTestSystemImpl).enablePackageForUser(
-                Mockito.eq(fallbackPackage), Mockito.eq(true) /* enable */,
-                Matchers.anyInt());
-
-        checkPreparationPhasesForPackage(fallbackPackage, 1);
-
-
-        // Again enable primary package and verify primary is used and fallback becomes disabled
-        mTestSystemImpl.setPackageInfo(
-                createPackageInfo(primaryPackage, true /* enabled */, true /* valid */,
-                    true /* installed */));
-        mWebViewUpdateServiceImpl.packageStateChanged(primaryPackage,
-                WebViewUpdateService.PACKAGE_CHANGED, 0);
-
-        // Verify fallback is disabled a second time when primary package becomes enabled
-        Mockito.verify(mTestSystemImpl, Mockito.times(2)).enablePackageForUser(
-                Mockito.eq(fallbackPackage), Mockito.eq(false) /* enable */,
-                Matchers.anyInt());
-
-        checkPreparationPhasesForPackage(primaryPackage, 2);
-    }
-
-    public void testAddUserWhenFallbackLogicEnabled() {
-        checkAddingNewUser(true);
-    }
-
-    public void testAddUserWhenFallbackLogicDisabled() {
-        checkAddingNewUser(false);
-    }
-
-    public void checkAddingNewUser(boolean fallbackLogicEnabled) {
-        String primaryPackage = "primary";
-        String fallbackPackage = "fallback";
-        WebViewProviderInfo[] packages = new WebViewProviderInfo[] {
-            new WebViewProviderInfo(
-                    primaryPackage, "", true /* default available */, false /* fallback */, null),
-            new WebViewProviderInfo(
-                    fallbackPackage, "", true /* default available */, true /* fallback */, null)};
-        setupWithPackages(packages, fallbackLogicEnabled);
-        setEnabledAndValidPackageInfos(packages);
-        int newUser = 100;
-        mWebViewUpdateServiceImpl.handleNewUser(newUser);
-        if (fallbackLogicEnabled) {
-            // Verify fallback package becomes disabled for new user
-            Mockito.verify(mTestSystemImpl).enablePackageForUser(
-                    Mockito.eq(fallbackPackage), Mockito.eq(false) /* enable */,
-                    Mockito.eq(newUser));
-        } else {
-            // Verify that we don't disable fallback for new user
-            Mockito.verify(mTestSystemImpl, Mockito.never()).enablePackageForUser(
-                    Mockito.anyObject(), Matchers.anyBoolean() /* enable */,
-                    Matchers.anyInt() /* user */);
-        }
-    }
-
-    /**
-     * Timing dependent test where we verify that the list of valid webview packages becoming empty
-     * at a certain point doesn't crash us or break our state.
-     */
-    public void testNotifyRelroDoesntCrashIfNoPackages() {
-        String firstPackage = "first";
-        String secondPackage = "second";
-        WebViewProviderInfo[] packages = new WebViewProviderInfo[] {
-            new WebViewProviderInfo(firstPackage, "", true /* default available */,
-                    false /* fallback */, null),
-            new WebViewProviderInfo(secondPackage, "", true /* default available */,
-                    false /* fallback */, null)};
-        setupWithPackages(packages);
-        // Add (enabled and valid) package infos for each provider
-        setEnabledAndValidPackageInfos(packages);
-
-        mWebViewUpdateServiceImpl.prepareWebViewInSystemServer();
-
-        Mockito.verify(mTestSystemImpl).onWebViewProviderChanged(
-                Mockito.argThat(new IsPackageInfoWithName(firstPackage)));
-
-        // Change provider during relro creation to enter a state where we are
-        // waiting for relro creation to complete just to re-run relro creation.
-        // (so that in next notifyRelroCreationCompleted() call we have to list webview packages)
-        mWebViewUpdateServiceImpl.changeProviderAndSetting(secondPackage);
-
-        // Make packages invalid to cause exception to be thrown
-        mTestSystemImpl.setPackageInfo(createPackageInfo(firstPackage, true /* enabled */,
-                    false /* valid */, true /* installed */, null /* signatures */,
-                    0 /* updateTime */));
-        mTestSystemImpl.setPackageInfo(createPackageInfo(secondPackage, true /* enabled */,
-                    false /* valid */, true /* installed */));
-
-        // This shouldn't throw an exception!
-        mWebViewUpdateServiceImpl.notifyRelroCreationCompleted();
-
-        WebViewProviderResponse response = mWebViewUpdateServiceImpl.waitForAndGetProvider();
-        assertEquals(WebViewFactory.LIBLOAD_FAILED_LISTING_WEBVIEW_PACKAGES, response.status);
-
-        // Now make a package valid again and verify that we can switch back to that
-        mTestSystemImpl.setPackageInfo(createPackageInfo(firstPackage, true /* enabled */,
-                    true /* valid */, true /* installed */, null /* signatures */,
-                    1 /* updateTime */ ));
-
-        mWebViewUpdateServiceImpl.packageStateChanged(firstPackage,
-                WebViewUpdateService.PACKAGE_ADDED_REPLACED, 0);
-
-        // Ensure we use firstPackage
-        checkPreparationPhasesForPackage(firstPackage, 2 /* second preparation for this package */);
-    }
-
-    /**
-     * Verify that even if a user-chosen package is removed temporarily we start using it again when
-     * it is added back.
-     */
-    public void testTempRemovePackageDoesntSwitchProviderPermanently() {
-        String firstPackage = "first";
-        String secondPackage = "second";
-        WebViewProviderInfo[] packages = new WebViewProviderInfo[] {
-            new WebViewProviderInfo(firstPackage, "", true /* default available */,
-                    false /* fallback */, null),
-            new WebViewProviderInfo(secondPackage, "", true /* default available */,
-                    false /* fallback */, null)};
-        checkCertainPackageUsedAfterWebViewBootPreparation(firstPackage, packages);
-
-        // Explicitly use the second package
-        mWebViewUpdateServiceImpl.changeProviderAndSetting(secondPackage);
-        checkPreparationPhasesForPackage(secondPackage, 1 /* first time for this package */);
-
-        // Remove second package (invalidate it) and verify that first package is used
-        mTestSystemImpl.setPackageInfo(createPackageInfo(secondPackage, true /* enabled */,
-                    false /* valid */, true /* installed */));
-        mWebViewUpdateServiceImpl.packageStateChanged(secondPackage,
-                WebViewUpdateService.PACKAGE_ADDED, 0);
-        checkPreparationPhasesForPackage(firstPackage, 2 /* second time for this package */);
-
-        // Now make the second package valid again and verify that it is used again
-        mTestSystemImpl.setPackageInfo(createPackageInfo(secondPackage, true /* enabled */,
-                    true /* valid */, true /* installed */));
-        mWebViewUpdateServiceImpl.packageStateChanged(secondPackage,
-                WebViewUpdateService.PACKAGE_ADDED, 0);
-        checkPreparationPhasesForPackage(secondPackage, 2 /* second time for this package */);
-    }
-
-    /**
-     * Ensure that we update the user-chosen setting across boots if the chosen package is no
-     * longer installed and valid.
-     */
-    public void testProviderSettingChangedDuringBootIfProviderNotAvailable() {
-        String chosenPackage = "chosenPackage";
-        String nonChosenPackage = "non-chosenPackage";
-        WebViewProviderInfo[] packages = new WebViewProviderInfo[] {
-            new WebViewProviderInfo(chosenPackage, "", true /* default available */,
-                    false /* fallback */, null),
-            new WebViewProviderInfo(nonChosenPackage, "", true /* default available */,
-                    false /* fallback */, null)};
-
-        setupWithPackages(packages);
-        // Only 'install' nonChosenPackage
-        mTestSystemImpl.setPackageInfo(
-                createPackageInfo(nonChosenPackage, true /* enabled */, true /* valid */, true /* installed */));
-
-        // Set user-chosen package
-        mTestSystemImpl.updateUserSetting(null, chosenPackage);
-
-        mWebViewUpdateServiceImpl.prepareWebViewInSystemServer();
-
-        // Verify that we switch the setting to point to the current package
-        Mockito.verify(mTestSystemImpl).updateUserSetting(
-                Mockito.anyObject(), Mockito.eq(nonChosenPackage));
-        assertEquals(nonChosenPackage, mTestSystemImpl.getUserChosenWebViewProvider(null));
-
-        checkPreparationPhasesForPackage(nonChosenPackage, 1);
-    }
-
-    public void testRecoverFailedListingWebViewPackagesSettingsChange() {
-        checkRecoverAfterFailListingWebviewPackages(true);
-    }
-
-    public void testRecoverFailedListingWebViewPackagesAddedPackage() {
-        checkRecoverAfterFailListingWebviewPackages(false);
-    }
-
-    /**
-     * Test that we can recover correctly from failing to list WebView packages.
-     * settingsChange: whether to fail during changeProviderAndSetting or packageStateChanged
-     */
-    public void checkRecoverAfterFailListingWebviewPackages(boolean settingsChange) {
-        String firstPackage = "first";
-        String secondPackage = "second";
-        WebViewProviderInfo[] packages = new WebViewProviderInfo[] {
-            new WebViewProviderInfo(firstPackage, "", true /* default available */,
-                    false /* fallback */, null),
-            new WebViewProviderInfo(secondPackage, "", true /* default available */,
-                    false /* fallback */, null)};
-        checkCertainPackageUsedAfterWebViewBootPreparation(firstPackage, packages);
-
-        // Make both packages invalid so that we fail listing WebView packages
-        mTestSystemImpl.setPackageInfo(createPackageInfo(firstPackage, true /* enabled */,
-                    false /* valid */, true /* installed */));
-        mTestSystemImpl.setPackageInfo(createPackageInfo(secondPackage, true /* enabled */,
-                    false /* valid */, true /* installed */));
-
-        // Change package to hit the webview packages listing problem.
-        if (settingsChange) {
-            mWebViewUpdateServiceImpl.changeProviderAndSetting(secondPackage);
-        } else {
-            mWebViewUpdateServiceImpl.packageStateChanged(secondPackage,
-                    WebViewUpdateService.PACKAGE_ADDED_REPLACED, 0);
-        }
-
-        WebViewProviderResponse response = mWebViewUpdateServiceImpl.waitForAndGetProvider();
-        assertEquals(WebViewFactory.LIBLOAD_FAILED_LISTING_WEBVIEW_PACKAGES, response.status);
-
-        // Make second package valid and verify that we can load it again
-        mTestSystemImpl.setPackageInfo(createPackageInfo(secondPackage, true /* enabled */,
-                    true /* valid */, true /* installed */));
-
-        mWebViewUpdateServiceImpl.packageStateChanged(secondPackage,
-                WebViewUpdateService.PACKAGE_ADDED_REPLACED, 0);
-
-
-        checkPreparationPhasesForPackage(secondPackage, 1);
-    }
-
-    public void testDontKillIfPackageReplaced() {
-        checkDontKillIfPackageRemoved(true);
-    }
-
-    public void testDontKillIfPackageRemoved() {
-        checkDontKillIfPackageRemoved(false);
-    }
-
-    public void checkDontKillIfPackageRemoved(boolean replaced) {
-        String firstPackage = "first";
-        String secondPackage = "second";
-        WebViewProviderInfo[] packages = new WebViewProviderInfo[] {
-            new WebViewProviderInfo(firstPackage, "", true /* default available */,
-                    false /* fallback */, null),
-            new WebViewProviderInfo(secondPackage, "", true /* default available */,
-                    false /* fallback */, null)};
-        checkCertainPackageUsedAfterWebViewBootPreparation(firstPackage, packages);
-
-        // Replace or remove the current webview package
-        if (replaced) {
-            mTestSystemImpl.setPackageInfo(
-                    createPackageInfo(firstPackage, true /* enabled */, false /* valid */,
-                        true /* installed */));
-            mWebViewUpdateServiceImpl.packageStateChanged(firstPackage,
-                    WebViewUpdateService.PACKAGE_ADDED_REPLACED, 0);
-        } else {
-            mTestSystemImpl.removePackageInfo(firstPackage);
-            mWebViewUpdateServiceImpl.packageStateChanged(firstPackage,
-                    WebViewUpdateService.PACKAGE_REMOVED, 0);
-        }
-
-        checkPreparationPhasesForPackage(secondPackage, 1);
-
-        Mockito.verify(mTestSystemImpl, Mockito.never()).killPackageDependents(
-                Mockito.anyObject());
-    }
-
-    public void testKillIfSettingChanged() {
-        String firstPackage = "first";
-        String secondPackage = "second";
-        WebViewProviderInfo[] packages = new WebViewProviderInfo[] {
-            new WebViewProviderInfo(firstPackage, "", true /* default available */,
-                    false /* fallback */, null),
-            new WebViewProviderInfo(secondPackage, "", true /* default available */,
-                    false /* fallback */, null)};
-        checkCertainPackageUsedAfterWebViewBootPreparation(firstPackage, packages);
-
-        mWebViewUpdateServiceImpl.changeProviderAndSetting(secondPackage);
-
-        checkPreparationPhasesForPackage(secondPackage, 1);
-
-        Mockito.verify(mTestSystemImpl).killPackageDependents(Mockito.eq(firstPackage));
-    }
-
-    /**
-     * Test that we kill apps using an old provider when we change the provider setting, even if the
-     * new provider is not the one we intended to change to.
-     */
-    public void testKillIfChangeProviderIncorrectly() {
-        String firstPackage = "first";
-        String secondPackage = "second";
-        String thirdPackage = "third";
-        WebViewProviderInfo[] packages = new WebViewProviderInfo[] {
-            new WebViewProviderInfo(firstPackage, "", true /* default available */,
-                    false /* fallback */, null),
-            new WebViewProviderInfo(secondPackage, "", true /* default available */,
-                    false /* fallback */, null),
-            new WebViewProviderInfo(thirdPackage, "", true /* default available */,
-                    false /* fallback */, null)};
-        setupWithPackages(packages);
-        setEnabledAndValidPackageInfos(packages);
-
-        // Start with the setting pointing to the third package
-        mTestSystemImpl.updateUserSetting(null, thirdPackage);
-
-        mWebViewUpdateServiceImpl.prepareWebViewInSystemServer();
-        checkPreparationPhasesForPackage(thirdPackage, 1);
-
-        mTestSystemImpl.setPackageInfo(
-                createPackageInfo(secondPackage, true /* enabled */, false /* valid */, true /* installed */));
-
-        // Try to switch to the invalid second package, this should result in switching to the first
-        // package, since that is more preferred than the third one.
-        assertEquals(firstPackage,
-                mWebViewUpdateServiceImpl.changeProviderAndSetting(secondPackage));
-
-        checkPreparationPhasesForPackage(firstPackage, 1);
-
-        Mockito.verify(mTestSystemImpl).killPackageDependents(Mockito.eq(thirdPackage));
-    }
-
-    // Ensure that the update service uses an uninstalled package if that is the only package
-    // available.
-    public void testWithSingleUninstalledPackage() {
-        String testPackageName = "test.package.name";
-        WebViewProviderInfo[] webviewPackages = new WebViewProviderInfo[] {
-                new WebViewProviderInfo(testPackageName, "",
-                        true /*default available*/, false /* fallback */, null)};
-        setupWithPackages(webviewPackages, true /* fallback logic enabled */, 1 /* numRelros */);
-        mTestSystemImpl.setPackageInfo(createPackageInfo(testPackageName, true /* enabled */,
-                    true /* valid */, false /* installed */));
-
-        mWebViewUpdateServiceImpl.prepareWebViewInSystemServer();
-
-        checkPreparationPhasesForPackage(testPackageName, 1 /* first preparation phase */);
-    }
-
-    public void testNonhiddenPackageUserOverHidden() {
-        checkVisiblePackageUserOverNonVisible(false /* true == uninstalled, false == hidden */);
-    }
-
-    public void testInstalledPackageUsedOverUninstalled() {
-        checkVisiblePackageUserOverNonVisible(true /* true == uninstalled, false == hidden */);
-    }
-
-    private void checkVisiblePackageUserOverNonVisible(boolean uninstalledNotHidden) {
-        boolean testUninstalled = uninstalledNotHidden;
-        boolean testHidden = !uninstalledNotHidden;
-        String installedPackage = "installedPackage";
-        String uninstalledPackage = "uninstalledPackage";
-        WebViewProviderInfo[] webviewPackages = new WebViewProviderInfo[] {
-            new WebViewProviderInfo(uninstalledPackage, "", true /* available by default */,
-                    false /* fallback */, null),
-            new WebViewProviderInfo(installedPackage, "", true /* available by default */,
-                    false /* fallback */, null)};
-
-        setupWithPackages(webviewPackages, true /* fallback logic enabled */, 1 /* numRelros */);
-        mTestSystemImpl.setPackageInfo(createPackageInfo(installedPackage, true /* enabled */,
-                    true /* valid */, true /* installed */));
-        mTestSystemImpl.setPackageInfo(createPackageInfo(uninstalledPackage, true /* enabled */,
-                    true /* valid */, (testUninstalled ? false : true) /* installed */,
-                    null /* signatures */, 0 /* updateTime */, (testHidden ? true : false)));
-
-        mWebViewUpdateServiceImpl.prepareWebViewInSystemServer();
-
-        checkPreparationPhasesForPackage(installedPackage, 1 /* first preparation phase */);
-    }
-
-    public void testCantSwitchToHiddenPackage () {
-        checkCantSwitchToNonVisiblePackage(false /* true == uninstalled, false == hidden */);
-    }
-
-
-    public void testCantSwitchToUninstalledPackage () {
-        checkCantSwitchToNonVisiblePackage(true /* true == uninstalled, false == hidden */);
-    }
-
-    /**
-     * Ensure that we won't prioritize an uninstalled (or hidden) package even if it is user-chosen,
-     * and that an uninstalled (or hidden) package is not considered valid (in the
-     * getValidWebViewPackages() API).
-     */
-    private void checkCantSwitchToNonVisiblePackage(boolean uninstalledNotHidden) {
-        boolean testUninstalled = uninstalledNotHidden;
-        boolean testHidden = !uninstalledNotHidden;
-        String installedPackage = "installedPackage";
-        String uninstalledPackage = "uninstalledPackage";
-        WebViewProviderInfo[] webviewPackages = new WebViewProviderInfo[] {
-            new WebViewProviderInfo(uninstalledPackage, "", true /* available by default */,
-                    false /* fallback */, null),
-            new WebViewProviderInfo(installedPackage, "", true /* available by default */,
-                    false /* fallback */, null)};
-
-        setupWithPackages(webviewPackages, true /* fallback logic enabled */, 1 /* numRelros */);
-        mTestSystemImpl.setPackageInfo(createPackageInfo(installedPackage, true /* enabled */,
-                    true /* valid */, true /* installed */));
-        mTestSystemImpl.setPackageInfo(createPackageInfo(uninstalledPackage, true /* enabled */,
-                    true /* valid */, (testUninstalled ? false : true) /* installed */,
-                    null /* signatures */, 0 /* updateTime */,
-                    (testHidden ? true : false) /* hidden */));
-
-        mWebViewUpdateServiceImpl.prepareWebViewInSystemServer();
-
-        checkPreparationPhasesForPackage(installedPackage, 1 /* first preparation phase */);
-
-        // Ensure that only the installed package is considered valid
-        WebViewProviderInfo[] validPackages = mWebViewUpdateServiceImpl.getValidWebViewPackages();
-        assertEquals(1, validPackages.length);
-        assertEquals(installedPackage, validPackages[0].packageName);
-
-        // ensure that we don't switch to the uninstalled package (it will be used if it becomes
-        // installed later)
-        assertEquals(installedPackage,
-                mWebViewUpdateServiceImpl.changeProviderAndSetting(uninstalledPackage));
-
-        // We should only have called onWebViewProviderChanged once (before calling
-        // changeProviderAndSetting
-        Mockito.verify(mTestSystemImpl, Mockito.times(1)).onWebViewProviderChanged(
-                Mockito.argThat(new IsPackageInfoWithName(installedPackage)));
-    }
-
-    public void testHiddenPackageNotPrioritizedEvenIfChosen() {
-        checkNonvisiblePackageNotPrioritizedEvenIfChosen(
-                false /* true == uninstalled, false == hidden */);
-    }
-
-    public void testUninstalledPackageNotPrioritizedEvenIfChosen() {
-        checkNonvisiblePackageNotPrioritizedEvenIfChosen(
-                true /* true == uninstalled, false == hidden */);
-    }
-
-    public void checkNonvisiblePackageNotPrioritizedEvenIfChosen(boolean uninstalledNotHidden) {
-        boolean testUninstalled = uninstalledNotHidden;
-        boolean testHidden = !uninstalledNotHidden;
-        String installedPackage = "installedPackage";
-        String uninstalledPackage = "uninstalledPackage";
-        WebViewProviderInfo[] webviewPackages = new WebViewProviderInfo[] {
-            new WebViewProviderInfo(uninstalledPackage, "", true /* available by default */,
-                    false /* fallback */, null),
-            new WebViewProviderInfo(installedPackage, "", true /* available by default */,
-                    false /* fallback */, null)};
-
-        setupWithPackages(webviewPackages, true /* fallback logic enabled */, 1 /* numRelros */);
-        mTestSystemImpl.setPackageInfo(createPackageInfo(installedPackage, true /* enabled */,
-                    true /* valid */, true /* installed */));
-        mTestSystemImpl.setPackageInfo(createPackageInfo(uninstalledPackage, true /* enabled */,
-                    true /* valid */, (testUninstalled ? false : true) /* installed */,
-                    null /* signatures */, 0 /* updateTime */,
-                    (testHidden ? true : false) /* hidden */));
-
-        // Start with the setting pointing to the uninstalled package
-        mTestSystemImpl.updateUserSetting(null, uninstalledPackage);
-
-        mWebViewUpdateServiceImpl.prepareWebViewInSystemServer();
-
-        checkPreparationPhasesForPackage(installedPackage, 1 /* first preparation phase */);
-    }
-
-    /**
-     * Ensures that fallback becomes enabled if the primary package is uninstalled for the current
-     * user.
-     */
-    public void testFallbackEnabledIfPrimaryUninstalled() {
-        String primaryPackage = "primary";
-        String fallbackPackage = "fallback";
-        WebViewProviderInfo[] packages = new WebViewProviderInfo[] {
-            new WebViewProviderInfo(
-                    primaryPackage, "", true /* default available */, false /* fallback */, null),
-            new WebViewProviderInfo(
-                    fallbackPackage, "", true /* default available */, true /* fallback */, null)};
-        setupWithPackages(packages, true /* fallback logic enabled */);
-        mTestSystemImpl.setPackageInfo(createPackageInfo(primaryPackage, true /* enabled */,
-                    true /* valid */, false /* installed */));
-        mTestSystemImpl.setPackageInfo(createPackageInfo(fallbackPackage, true /* enabled */,
-                    true /* valid */, true /* installed */));
-
-        mWebViewUpdateServiceImpl.prepareWebViewInSystemServer();
-        // Verify that we enable the fallback package
-        Mockito.verify(mTestSystemImpl).enablePackageForAllUsers(
-                Mockito.anyObject(), Mockito.eq(fallbackPackage), Mockito.eq(true) /* enable */);
-
-        checkPreparationPhasesForPackage(fallbackPackage, 1 /* first preparation phase */);
-    }
-
-    public void testPreparationRunsIffNewPackage() {
-        String primaryPackage = "primary";
-        String fallbackPackage = "fallback";
-        WebViewProviderInfo[] packages = new WebViewProviderInfo[] {
-            new WebViewProviderInfo(
-                    primaryPackage, "", true /* default available */, false /* fallback */, null),
-            new WebViewProviderInfo(
-                    fallbackPackage, "", true /* default available */, true /* fallback */, null)};
-        setupWithPackages(packages, true /* fallback logic enabled */);
-        mTestSystemImpl.setPackageInfo(createPackageInfo(primaryPackage, true /* enabled */,
-                    true /* valid */, true /* installed */, null /* signatures */,
-                    10 /* lastUpdateTime*/ ));
-        mTestSystemImpl.setPackageInfo(createPackageInfo(fallbackPackage, true /* enabled */,
-                    true /* valid */, true /* installed */));
-
-        mWebViewUpdateServiceImpl.prepareWebViewInSystemServer();
-
-        checkPreparationPhasesForPackage(primaryPackage, 1 /* first preparation phase */);
-        Mockito.verify(mTestSystemImpl, Mockito.times(1)).enablePackageForUser(
-                Mockito.eq(fallbackPackage), Mockito.eq(false) /* enable */,
-                Matchers.anyInt() /* user */);
-
-
-        mWebViewUpdateServiceImpl.packageStateChanged(primaryPackage,
-                WebViewUpdateService.PACKAGE_ADDED_REPLACED, 0 /* userId */);
-        mWebViewUpdateServiceImpl.packageStateChanged(primaryPackage,
-                WebViewUpdateService.PACKAGE_ADDED_REPLACED, 1 /* userId */);
-        mWebViewUpdateServiceImpl.packageStateChanged(primaryPackage,
-                WebViewUpdateService.PACKAGE_ADDED_REPLACED, 2 /* userId */);
-        // package still has the same update-time so we shouldn't run preparation here
-        Mockito.verify(mTestSystemImpl, Mockito.times(1)).onWebViewProviderChanged(
-                Mockito.argThat(new IsPackageInfoWithName(primaryPackage)));
-        Mockito.verify(mTestSystemImpl, Mockito.times(1)).enablePackageForUser(
-                Mockito.eq(fallbackPackage), Mockito.eq(false) /* enable */,
-                Matchers.anyInt() /* user */);
-
-        // Ensure we can still load the package
-        WebViewProviderResponse response = mWebViewUpdateServiceImpl.waitForAndGetProvider();
-        assertEquals(WebViewFactory.LIBLOAD_SUCCESS, response.status);
-        assertEquals(primaryPackage, response.packageInfo.packageName);
-
-
-        mTestSystemImpl.setPackageInfo(createPackageInfo(primaryPackage, true /* enabled */,
-                    true /* valid */, true /* installed */, null /* signatures */,
-                    20 /* lastUpdateTime*/ ));
-        mWebViewUpdateServiceImpl.packageStateChanged(primaryPackage,
-                WebViewUpdateService.PACKAGE_ADDED_REPLACED, 0);
-        // The package has now changed - ensure that we have run the preparation phase a second time
-        checkPreparationPhasesForPackage(primaryPackage, 2 /* second preparation phase */);
-
-
-        mTestSystemImpl.setPackageInfo(createPackageInfo(primaryPackage, true /* enabled */,
-                    true /* valid */, true /* installed */, null /* signatures */,
-                    50 /* lastUpdateTime*/ ));
-        // Receive intent for different user
-        mWebViewUpdateServiceImpl.packageStateChanged(primaryPackage,
-                WebViewUpdateService.PACKAGE_ADDED_REPLACED, 2);
-
-        checkPreparationPhasesForPackage(primaryPackage, 3 /* third preparation phase */);
-    }
-
-}
diff --git a/services/tests/shortcutmanagerutils/Android.mk b/services/tests/shortcutmanagerutils/Android.mk
deleted file mode 100644
index 2818457c9ac..00000000000
--- a/services/tests/shortcutmanagerutils/Android.mk
+++ /dev/null
@@ -1,31 +0,0 @@
-# Copyright (C) 2016 The Android Open Source Project
-#
-# Licensed under the Apache License, Version 2.0 (the "License");
-# you may not use this file except in compliance with the License.
-# You may obtain a copy of the License at
-#
-#      http://www.apache.org/licenses/LICENSE-2.0
-#
-# Unless required by applicable law or agreed to in writing, software
-# distributed under the License is distributed on an "AS IS" BASIS,
-# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-# See the License for the specific language governing permissions and
-# limitations under the License.
-
-LOCAL_PATH:= $(call my-dir)
-
-include $(CLEAR_VARS)
-
-LOCAL_SRC_FILES := \
-    $(call all-java-files-under, src)
-
-LOCAL_STATIC_JAVA_LIBRARIES := \
-    mockito-target
-
-LOCAL_MODULE_TAGS := optional
-
-LOCAL_MODULE := ShortcutManagerTestUtils
-
-LOCAL_SDK_VERSION := test_current
-
-include $(BUILD_STATIC_JAVA_LIBRARY)
diff --git a/services/tests/shortcutmanagerutils/src/com/android/server/pm/shortcutmanagertest/ShortcutManagerTestUtils.java b/services/tests/shortcutmanagerutils/src/com/android/server/pm/shortcutmanagertest/ShortcutManagerTestUtils.java
deleted file mode 100644
index 1fe5cb78231..00000000000
--- a/services/tests/shortcutmanagerutils/src/com/android/server/pm/shortcutmanagertest/ShortcutManagerTestUtils.java
+++ /dev/null
@@ -1,1073 +0,0 @@
-/*
- * Copyright (C) 2016 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.android.server.pm.shortcutmanagertest;
-
-import static junit.framework.Assert.assertEquals;
-import static junit.framework.Assert.assertFalse;
-import static junit.framework.Assert.assertNotNull;
-import static junit.framework.Assert.assertNull;
-import static junit.framework.Assert.assertTrue;
-import static junit.framework.Assert.fail;
-
-import static org.mockito.Matchers.any;
-import static org.mockito.Matchers.anyList;
-import static org.mockito.Matchers.anyString;
-import static org.mockito.Matchers.eq;
-import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.reset;
-import static org.mockito.Mockito.times;
-import static org.mockito.Mockito.verify;
-
-import android.app.Instrumentation;
-import android.content.ComponentName;
-import android.content.Context;
-import android.content.pm.LauncherApps;
-import android.content.pm.LauncherApps.Callback;
-import android.content.pm.ShortcutInfo;
-import android.graphics.Bitmap;
-import android.graphics.BitmapFactory;
-import android.os.BaseBundle;
-import android.os.Bundle;
-import android.os.Handler;
-import android.os.Looper;
-import android.os.Parcel;
-import android.os.ParcelFileDescriptor;
-import android.os.PersistableBundle;
-import android.os.UserHandle;
-import android.test.MoreAsserts;
-import android.util.Log;
-
-import junit.framework.Assert;
-
-import org.hamcrest.BaseMatcher;
-import org.hamcrest.Description;
-import org.hamcrest.Matcher;
-import org.json.JSONException;
-import org.json.JSONObject;
-import org.mockito.ArgumentCaptor;
-import org.mockito.Mockito;
-
-import java.io.BufferedReader;
-import java.io.File;
-import java.io.FileNotFoundException;
-import java.io.FileReader;
-import java.io.IOException;
-import java.util.ArrayList;
-import java.util.Arrays;
-import java.util.Collection;
-import java.util.Collections;
-import java.util.Comparator;
-import java.util.LinkedHashSet;
-import java.util.List;
-import java.util.Set;
-import java.util.SortedSet;
-import java.util.TreeSet;
-import java.util.concurrent.CountDownLatch;
-import java.util.function.BooleanSupplier;
-import java.util.function.Consumer;
-import java.util.function.Function;
-import java.util.function.Predicate;
-
-/**
- * Common utility methods for ShortcutManager tests.  This is used by both CTS and the unit tests.
- * Because it's used by CTS too, it can only access the public APIs.
- */
-public class ShortcutManagerTestUtils {
-    private static final String TAG = "ShortcutManagerUtils";
-
-    private static final boolean ENABLE_DUMPSYS = true; // DO NOT SUBMIT WITH true
-
-    private static final int STANDARD_TIMEOUT_SEC = 5;
-
-    private static final String[] EMPTY_STRINGS = new String[0];
-
-    private ShortcutManagerTestUtils() {
-    }
-
-    public static List<String> readAll(File file) throws FileNotFoundException {
-        return readAll(ParcelFileDescriptor.open(
-                file.getAbsoluteFile(), ParcelFileDescriptor.MODE_READ_ONLY));
-    }
-
-    public static List<String> readAll(ParcelFileDescriptor pfd) {
-        try {
-            try {
-                final ArrayList<String> ret = new ArrayList<>();
-                try (BufferedReader r = new BufferedReader(
-                        new FileReader(pfd.getFileDescriptor()))) {
-                    String line;
-                    while ((line = r.readLine()) != null) {
-                        ret.add(line);
-                    }
-                    r.readLine();
-                }
-                return ret;
-            } finally {
-                pfd.close();
-            }
-        } catch (IOException e) {
-            throw new RuntimeException(e);
-        }
-    }
-
-    public static String concatResult(List<String> result) {
-        final StringBuilder sb = new StringBuilder();
-        for (String s : result) {
-            sb.append(s);
-            sb.append("\n");
-        }
-        return sb.toString();
-    }
-
-    public static boolean resultContains(List<String> result, String expected) {
-        for (String line : result) {
-            if (line.contains(expected)) {
-                return true;
-            }
-        }
-        return false;
-    }
-
-    public static List<String> assertSuccess(List<String> result) {
-        if (!resultContains(result, "Success")) {
-            fail("Command failed.  Result was:\n" + concatResult(result));
-        }
-        return result;
-    }
-
-    public static List<String> assertContains(List<String> result, String expected) {
-        if (!resultContains(result, expected)) {
-            fail("Didn't contain expected string=" + expected
-                    + "\nActual:\n" + concatResult(result));
-        }
-        return result;
-    }
-
-    public static List<String> runCommand(Instrumentation instrumentation, String command) {
-        return runCommand(instrumentation, command, null);
-    }
-    public static List<String> runCommand(Instrumentation instrumentation, String command,
-            Predicate<List<String>> resultAsserter) {
-        Log.d(TAG, "Running command: " + command);
-        final List<String> result;
-        try {
-            result = readAll(
-                    instrumentation.getUiAutomation().executeShellCommand(command));
-        } catch (Exception e) {
-            throw new RuntimeException(e);
-        }
-        if (resultAsserter != null && !resultAsserter.test(result)) {
-            fail("Command '" + command + "' failed, output was:\n" + concatResult(result));
-        }
-        return result;
-    }
-
-    public static void runCommandForNoOutput(Instrumentation instrumentation, String command) {
-        runCommand(instrumentation, command, result -> result.size() == 0);
-    }
-
-    public static List<String> runShortcutCommand(Instrumentation instrumentation, String command,
-            Predicate<List<String>> resultAsserter) {
-        return runCommand(instrumentation, "cmd shortcut " + command, resultAsserter);
-    }
-
-    public static List<String> runShortcutCommandForSuccess(Instrumentation instrumentation,
-            String command) {
-        return runShortcutCommand(instrumentation, command, result -> result.contains("Success"));
-    }
-
-    public static String getDefaultLauncher(Instrumentation instrumentation) {
-        final String PREFIX = "Launcher: ComponentInfo{";
-        final String POSTFIX = "}";
-        final List<String> result = runShortcutCommandForSuccess(
-                instrumentation, "get-default-launcher");
-        for (String s : result) {
-            if (s.startsWith(PREFIX) && s.endsWith(POSTFIX)) {
-                return s.substring(PREFIX.length(), s.length() - POSTFIX.length());
-            }
-        }
-        fail("Default launcher not found");
-        return null;
-    }
-
-    public static void setDefaultLauncher(Instrumentation instrumentation, String component) {
-        runCommand(instrumentation, "cmd package set-home-activity --user "
-                + instrumentation.getContext().getUserId() + " " + component,
-                result -> result.contains("Success"));
-    }
-
-    public static void setDefaultLauncher(Instrumentation instrumentation, Context packageContext) {
-        setDefaultLauncher(instrumentation, packageContext.getPackageName()
-                + "/android.content.pm.cts.shortcutmanager.packages.Launcher");
-    }
-
-    public static void overrideConfig(Instrumentation instrumentation, String config) {
-        runShortcutCommandForSuccess(instrumentation, "override-config " + config);
-    }
-
-    public static void resetConfig(Instrumentation instrumentation) {
-        runShortcutCommandForSuccess(instrumentation, "reset-config");
-    }
-
-    public static void resetThrottling(Instrumentation instrumentation) {
-        runShortcutCommandForSuccess(instrumentation, "reset-throttling");
-    }
-
-    public static void resetAllThrottling(Instrumentation instrumentation) {
-        runShortcutCommandForSuccess(instrumentation, "reset-all-throttling");
-    }
-
-    public static void clearShortcuts(Instrumentation instrumentation, int userId,
-            String packageName) {
-        runShortcutCommandForSuccess(instrumentation, "clear-shortcuts "
-                + " --user " + userId + " " + packageName);
-    }
-
-    public static void anyContains(List<String> result, String expected) {
-        for (String l : result) {
-            if (l.contains(expected)) {
-                return;
-            }
-        }
-        fail("Result didn't contain '" + expected + "': was\n" + result);
-    }
-
-    public static void enableComponent(Instrumentation instrumentation, ComponentName cn,
-            boolean enable) {
-
-        final String word = (enable ? "enable" : "disable");
-        runCommand(instrumentation,
-                "pm " + word + " " + cn.flattenToString()
-                , result ->concatResult(result).contains(word));
-    }
-
-    public static void appOps(Instrumentation instrumentation, String packageName,
-            String op, String mode) {
-        runCommand(instrumentation, "appops set " + packageName + " " + op + " " + mode);
-    }
-
-    public static void dumpsysShortcut(Instrumentation instrumentation) {
-        if (!ENABLE_DUMPSYS) {
-            return;
-        }
-        Log.e(TAG, "Dumpsys shortcut");
-        for (String s : runCommand(instrumentation, "dumpsys shortcut")) {
-            Log.e(TAG, s);
-        }
-    }
-
-    public static JSONObject getCheckinDump(Instrumentation instrumentation) throws JSONException {
-        return new JSONObject(concatResult(runCommand(instrumentation, "dumpsys shortcut -c")));
-    }
-
-    public static boolean isLowRamDevice(Instrumentation instrumentation) throws JSONException {
-        return getCheckinDump(instrumentation).getBoolean("lowRam");
-    }
-
-    public static int getIconSize(Instrumentation instrumentation) throws JSONException {
-        return getCheckinDump(instrumentation).getInt("iconSize");
-    }
-
-    public static Bundle makeBundle(Object... keysAndValues) {
-        assertTrue((keysAndValues.length % 2) == 0);
-
-        if (keysAndValues.length == 0) {
-            return null;
-        }
-        final Bundle ret = new Bundle();
-
-        for (int i = keysAndValues.length - 2; i >= 0; i -= 2) {
-            final String key = keysAndValues[i].toString();
-            final Object value = keysAndValues[i + 1];
-
-            if (value == null) {
-                ret.putString(key, null);
-            } else if (value instanceof Integer) {
-                ret.putInt(key, (Integer) value);
-            } else if (value instanceof String) {
-                ret.putString(key, (String) value);
-            } else if (value instanceof Bundle) {
-                ret.putBundle(key, (Bundle) value);
-            } else {
-                fail("Type not supported yet: " + value.getClass().getName());
-            }
-        }
-        return ret;
-    }
-
-    public static PersistableBundle makePersistableBundle(Object... keysAndValues) {
-        assertTrue((keysAndValues.length % 2) == 0);
-
-        if (keysAndValues.length == 0) {
-            return null;
-        }
-        final PersistableBundle ret = new PersistableBundle();
-
-        for (int i = keysAndValues.length - 2; i >= 0; i -= 2) {
-            final String key = keysAndValues[i].toString();
-            final Object value = keysAndValues[i + 1];
-
-            if (value == null) {
-                ret.putString(key, null);
-            } else if (value instanceof Integer) {
-                ret.putInt(key, (Integer) value);
-            } else if (value instanceof String) {
-                ret.putString(key, (String) value);
-            } else if (value instanceof PersistableBundle) {
-                ret.putPersistableBundle(key, (PersistableBundle) value);
-            } else {
-                fail("Type not supported yet: " + value.getClass().getName());
-            }
-        }
-        return ret;
-    }
-
-    public static <T> List<T> list(T... array) {
-        return Arrays.asList(array);
-    }
-
-    public static <T> Set<T> hashSet(Set<T> in) {
-        return new LinkedHashSet<>(in);
-    }
-
-    public static <T> Set<T> set(T... values) {
-        return set(v -> v, values);
-    }
-
-    public static <T, V> Set<T> set(Function<V, T> converter, V... values) {
-        return set(converter, Arrays.asList(values));
-    }
-
-    public static <T, V> Set<T> set(Function<V, T> converter, List<V> values) {
-        final LinkedHashSet<T> ret = new LinkedHashSet<>();
-        for (V v : values) {
-            ret.add(converter.apply(v));
-        }
-        return ret;
-    }
-
-    public static void resetAll(Collection<?> mocks) {
-        for (Object o : mocks) {
-            reset(o);
-        }
-    }
-
-    public static <T extends Collection<?>> T assertEmpty(T collection) {
-        if (collection == null) {
-            return collection; // okay.
-        }
-        assertEquals(0, collection.size());
-        return collection;
-    }
-
-    public static List<ShortcutInfo> filter(List<ShortcutInfo> list, Predicate<ShortcutInfo> p) {
-        final ArrayList<ShortcutInfo> ret = new ArrayList<>(list);
-        ret.removeIf(si -> !p.test(si));
-        return ret;
-    }
-
-    public static List<ShortcutInfo> filterByActivity(List<ShortcutInfo> list,
-            ComponentName activity) {
-        return filter(list, si ->
-                (si.getActivity().equals(activity)
-                        && (si.isDeclaredInManifest() || si.isDynamic())));
-    }
-
-    public static List<ShortcutInfo> changedSince(List<ShortcutInfo> list, long time) {
-        return filter(list, si -> si.getLastChangedTimestamp() >= time);
-    }
-
-    @FunctionalInterface
-    public interface ExceptionRunnable {
-        void run() throws Exception;
-    }
-
-    public static void assertExpectException(Class<? extends Throwable> expectedExceptionType,
-            String expectedExceptionMessageRegex, ExceptionRunnable r) {
-        assertExpectException("", expectedExceptionType, expectedExceptionMessageRegex, r);
-    }
-
-    public static void assertCannotUpdateImmutable(Runnable r) {
-        assertExpectException(
-                IllegalArgumentException.class, "may not be manipulated via APIs", r::run);
-    }
-
-    public static void assertDynamicShortcutCountExceeded(Runnable r) {
-        assertExpectException(IllegalArgumentException.class,
-                "Max number of dynamic shortcuts exceeded", r::run);
-    }
-
-    public static void assertExpectException(String message,
-            Class<? extends Throwable> expectedExceptionType,
-            String expectedExceptionMessageRegex, ExceptionRunnable r) {
-        try {
-            r.run();
-        } catch (Throwable e) {
-            Assert.assertTrue(
-                    "Expected exception type was " + expectedExceptionType.getName()
-                            + " but caught " + e + " (message=" + message + ")",
-                    expectedExceptionType.isAssignableFrom(e.getClass()));
-            if (expectedExceptionMessageRegex != null) {
-                MoreAsserts.assertContainsRegex(expectedExceptionMessageRegex, e.getMessage());
-            }
-            return; // Pass
-        }
-        Assert.fail("Expected exception type " + expectedExceptionType.getName()
-                + " was not thrown");
-    }
-
-    public static List<ShortcutInfo> assertShortcutIds(List<ShortcutInfo> actualShortcuts,
-            String... expectedIds) {
-        final SortedSet<String> expected = new TreeSet<>(list(expectedIds));
-        final SortedSet<String> actual = new TreeSet<>();
-        for (ShortcutInfo s : actualShortcuts) {
-            actual.add(s.getId());
-        }
-
-        // Compare the sets.
-        assertEquals(expected, actual);
-        return actualShortcuts;
-    }
-
-    public static List<ShortcutInfo> assertShortcutIdsOrdered(List<ShortcutInfo> actualShortcuts,
-            String... expectedIds) {
-        final ArrayList<String> expected = new ArrayList<>(list(expectedIds));
-        final ArrayList<String> actual = new ArrayList<>();
-        for (ShortcutInfo s : actualShortcuts) {
-            actual.add(s.getId());
-        }
-        assertEquals(expected, actual);
-        return actualShortcuts;
-    }
-
-    public static List<ShortcutInfo> assertAllHaveIntents(
-            List<ShortcutInfo> actualShortcuts) {
-        for (ShortcutInfo s : actualShortcuts) {
-            assertNotNull("ID " + s.getId(), s.getIntent());
-        }
-        return actualShortcuts;
-    }
-
-    public static List<ShortcutInfo> assertAllNotHaveIntents(
-            List<ShortcutInfo> actualShortcuts) {
-        for (ShortcutInfo s : actualShortcuts) {
-            assertNull("ID " + s.getId(), s.getIntent());
-        }
-        return actualShortcuts;
-    }
-
-    public static List<ShortcutInfo> assertAllHaveTitle(
-            List<ShortcutInfo> actualShortcuts) {
-        for (ShortcutInfo s : actualShortcuts) {
-            assertNotNull("ID " + s.getId(), s.getShortLabel());
-        }
-        return actualShortcuts;
-    }
-
-    public static List<ShortcutInfo> assertAllNotHaveTitle(
-            List<ShortcutInfo> actualShortcuts) {
-        for (ShortcutInfo s : actualShortcuts) {
-            assertNull("ID " + s.getId(), s.getShortLabel());
-        }
-        return actualShortcuts;
-    }
-
-    public static List<ShortcutInfo> assertAllKeyFieldsOnly(
-            List<ShortcutInfo> actualShortcuts) {
-        for (ShortcutInfo s : actualShortcuts) {
-            assertTrue("ID " + s.getId(), s.hasKeyFieldsOnly());
-        }
-        return actualShortcuts;
-    }
-
-    public static List<ShortcutInfo> assertAllNotKeyFieldsOnly(
-            List<ShortcutInfo> actualShortcuts) {
-        for (ShortcutInfo s : actualShortcuts) {
-            assertFalse("ID " + s.getId(), s.hasKeyFieldsOnly());
-        }
-        return actualShortcuts;
-    }
-
-    public static List<ShortcutInfo> assertAllDynamic(List<ShortcutInfo> actualShortcuts) {
-        for (ShortcutInfo s : actualShortcuts) {
-            assertTrue("ID " + s.getId(), s.isDynamic());
-        }
-        return actualShortcuts;
-    }
-
-    public static List<ShortcutInfo> assertAllPinned(List<ShortcutInfo> actualShortcuts) {
-        for (ShortcutInfo s : actualShortcuts) {
-            assertTrue("ID " + s.getId(), s.isPinned());
-        }
-        return actualShortcuts;
-    }
-
-    public static List<ShortcutInfo> assertAllDynamicOrPinned(
-            List<ShortcutInfo> actualShortcuts) {
-        for (ShortcutInfo s : actualShortcuts) {
-            assertTrue("ID " + s.getId(), s.isDynamic() || s.isPinned());
-        }
-        return actualShortcuts;
-    }
-
-    public static List<ShortcutInfo> assertAllManifest(
-            List<ShortcutInfo> actualShortcuts) {
-        for (ShortcutInfo s : actualShortcuts) {
-            assertTrue("ID " + s.getId(), s.isDeclaredInManifest());
-        }
-        return actualShortcuts;
-    }
-
-    public static List<ShortcutInfo> assertAllNotManifest(
-            List<ShortcutInfo> actualShortcuts) {
-        for (ShortcutInfo s : actualShortcuts) {
-            assertFalse("ID " + s.getId(), s.isDeclaredInManifest());
-        }
-        return actualShortcuts;
-    }
-
-    public static List<ShortcutInfo> assertAllDisabled(
-            List<ShortcutInfo> actualShortcuts) {
-        for (ShortcutInfo s : actualShortcuts) {
-            assertTrue("ID " + s.getId(), !s.isEnabled());
-        }
-        return actualShortcuts;
-    }
-
-    public static List<ShortcutInfo> assertAllEnabled(
-            List<ShortcutInfo> actualShortcuts) {
-        for (ShortcutInfo s : actualShortcuts) {
-            assertTrue("ID " + s.getId(), s.isEnabled());
-        }
-        return actualShortcuts;
-    }
-
-    public static List<ShortcutInfo> assertAllImmutable(
-            List<ShortcutInfo> actualShortcuts) {
-        for (ShortcutInfo s : actualShortcuts) {
-            assertTrue("ID " + s.getId(), s.isImmutable());
-        }
-        return actualShortcuts;
-    }
-
-    public static void assertDynamicOnly(ShortcutInfo si) {
-        assertTrue(si.isDynamic());
-        assertFalse(si.isPinned());
-    }
-
-    public static void assertPinnedOnly(ShortcutInfo si) {
-        assertFalse(si.isDynamic());
-        assertFalse(si.isDeclaredInManifest());
-        assertTrue(si.isPinned());
-    }
-
-    public static void assertDynamicAndPinned(ShortcutInfo si) {
-        assertTrue(si.isDynamic());
-        assertTrue(si.isPinned());
-    }
-
-    public static void assertBitmapSize(int expectedWidth, int expectedHeight, Bitmap bitmap) {
-        assertEquals("width", expectedWidth, bitmap.getWidth());
-        assertEquals("height", expectedHeight, bitmap.getHeight());
-    }
-
-    public static <T> void assertAllUnique(Collection<T> list) {
-        final Set<Object> set = new LinkedHashSet<>();
-        for (T item : list) {
-            if (set.contains(item)) {
-                fail("Duplicate item found: " + item + " (in the list: " + list + ")");
-            }
-            set.add(item);
-        }
-    }
-
-    public static ShortcutInfo findShortcut(List<ShortcutInfo> list, String id) {
-        for (ShortcutInfo si : list) {
-            if (si.getId().equals(id)) {
-                return si;
-            }
-        }
-        fail("Shortcut " + id + " not found in the list");
-        return null;
-    }
-
-    public static Bitmap pfdToBitmap(ParcelFileDescriptor pfd) {
-        assertNotNull(pfd);
-        try {
-            try {
-                return BitmapFactory.decodeFileDescriptor(pfd.getFileDescriptor());
-            } finally {
-                pfd.close();
-            }
-        } catch (IOException e) {
-            throw new RuntimeException(e);
-        }
-    }
-
-    public static void assertBundleEmpty(BaseBundle b) {
-        assertTrue(b == null || b.size() == 0);
-    }
-
-    public static void assertCallbackNotReceived(LauncherApps.Callback mock) {
-        verify(mock, times(0)).onShortcutsChanged(anyString(), anyList(),
-                any(UserHandle.class));
-    }
-
-    public static void assertCallbackReceived(LauncherApps.Callback mock,
-            UserHandle user, String packageName, String... ids) {
-        verify(mock).onShortcutsChanged(eq(packageName), checkShortcutIds(ids),
-                eq(user));
-    }
-
-    public static boolean checkAssertSuccess(Runnable r) {
-        try {
-            r.run();
-            return true;
-        } catch (AssertionError e) {
-            return false;
-        }
-    }
-
-    public static <T> T checkArgument(Predicate<T> checker, String description,
-            List<T> matchedCaptor) {
-        final Matcher<T> m = new BaseMatcher<T>() {
-            @Override
-            public boolean matches(Object item) {
-                if (item == null) {
-                    return false;
-                }
-                final T value = (T) item;
-                if (!checker.test(value)) {
-                    return false;
-                }
-
-                if (matchedCaptor != null) {
-                    matchedCaptor.add(value);
-                }
-                return true;
-            }
-
-            @Override
-            public void describeTo(Description d) {
-                d.appendText(description);
-            }
-        };
-        return Mockito.argThat(m);
-    }
-
-    public static List<ShortcutInfo> checkShortcutIds(String... ids) {
-        return checkArgument((List<ShortcutInfo> list) -> {
-            final Set<String> actualSet = set(si -> si.getId(), list);
-            return actualSet.equals(set(ids));
-
-        }, "Shortcut IDs=[" + Arrays.toString(ids) + "]", null);
-    }
-
-    public static ShortcutInfo parceled(ShortcutInfo si) {
-        Parcel p = Parcel.obtain();
-        p.writeParcelable(si, 0);
-        p.setDataPosition(0);
-        ShortcutInfo si2 = p.readParcelable(ShortcutManagerTestUtils.class.getClassLoader());
-        p.recycle();
-        return si2;
-    }
-
-    public static List<ShortcutInfo> cloneShortcutList(List<ShortcutInfo> list) {
-        if (list == null) {
-            return null;
-        }
-        final List<ShortcutInfo> ret = new ArrayList<>(list.size());
-        for (ShortcutInfo si : list) {
-            ret.add(parceled(si));
-        }
-
-        return ret;
-    }
-
-    private static final Comparator<ShortcutInfo> sRankComparator =
-            (ShortcutInfo a, ShortcutInfo b) -> Integer.compare(a.getRank(), b.getRank());
-
-    public static List<ShortcutInfo> sortedByRank(List<ShortcutInfo> shortcuts) {
-        final ArrayList<ShortcutInfo> ret = new ArrayList<>(shortcuts);
-        Collections.sort(ret, sRankComparator);
-        return ret;
-    }
-
-    public static void waitUntil(String message, BooleanSupplier condition) {
-        waitUntil(message, condition, STANDARD_TIMEOUT_SEC);
-    }
-
-    public static void waitUntil(String message, BooleanSupplier condition, int timeoutSeconds) {
-        final long timeout = System.currentTimeMillis() + (timeoutSeconds * 1000L);
-        while (System.currentTimeMillis() < timeout) {
-            if (condition.getAsBoolean()) {
-                return;
-            }
-            try {
-                Thread.sleep(100);
-            } catch (InterruptedException e) {
-                throw new RuntimeException(e);
-            }
-        }
-        fail("Timed out for: " + message);
-    }
-
-    public static ShortcutListAsserter assertWith(List<ShortcutInfo> list) {
-        return new ShortcutListAsserter(list);
-    }
-
-    /**
-     * New style assertion that allows chained calls.
-     */
-    public static class ShortcutListAsserter {
-        private final ShortcutListAsserter mOriginal;
-        private final List<ShortcutInfo> mList;
-
-        ShortcutListAsserter(List<ShortcutInfo> list) {
-            this(null, list);
-        }
-
-        private ShortcutListAsserter(ShortcutListAsserter original, List<ShortcutInfo> list) {
-            mOriginal = (original == null) ? this : original;
-            mList = (list == null) ? new ArrayList<>(0) : new ArrayList<>(list);
-        }
-
-        public ShortcutListAsserter revertToOriginalList() {
-            return mOriginal;
-        }
-
-        public ShortcutListAsserter selectDynamic() {
-            return new ShortcutListAsserter(this,
-                    filter(mList, ShortcutInfo::isDynamic));
-        }
-
-        public ShortcutListAsserter selectManifest() {
-            return new ShortcutListAsserter(this,
-                    filter(mList, ShortcutInfo::isDeclaredInManifest));
-        }
-
-        public ShortcutListAsserter selectPinned() {
-            return new ShortcutListAsserter(this,
-                    filter(mList, ShortcutInfo::isPinned));
-        }
-
-        public ShortcutListAsserter selectByActivity(ComponentName activity) {
-            return new ShortcutListAsserter(this,
-                    ShortcutManagerTestUtils.filterByActivity(mList, activity));
-        }
-
-        public ShortcutListAsserter selectByChangedSince(long time) {
-            return new ShortcutListAsserter(this,
-                    ShortcutManagerTestUtils.changedSince(mList, time));
-        }
-
-        public ShortcutListAsserter selectByIds(String... ids) {
-            final Set<String> idSet = set(ids);
-            final ArrayList<ShortcutInfo> selected = new ArrayList<>();
-            for (ShortcutInfo si : mList) {
-                if (idSet.contains(si.getId())) {
-                    selected.add(si);
-                    idSet.remove(si.getId());
-                }
-            }
-            if (idSet.size() > 0) {
-                fail("Shortcuts not found for IDs=" + idSet);
-            }
-
-            return new ShortcutListAsserter(this, selected);
-        }
-
-        public ShortcutListAsserter toSortByRank() {
-            return new ShortcutListAsserter(this,
-                    ShortcutManagerTestUtils.sortedByRank(mList));
-        }
-
-        public ShortcutListAsserter call(Consumer<List<ShortcutInfo>> c) {
-            c.accept(mList);
-            return this;
-        }
-
-        public ShortcutListAsserter haveIds(String... expectedIds) {
-            assertShortcutIds(mList, expectedIds);
-            return this;
-        }
-
-        public ShortcutListAsserter haveIdsOrdered(String... expectedIds) {
-            assertShortcutIdsOrdered(mList, expectedIds);
-            return this;
-        }
-
-        private ShortcutListAsserter haveSequentialRanks() {
-            for (int i = 0; i < mList.size(); i++) {
-                final ShortcutInfo si = mList.get(i);
-                assertEquals("Rank not sequential: id=" + si.getId(), i, si.getRank());
-            }
-            return this;
-        }
-
-        public ShortcutListAsserter haveRanksInOrder(String... expectedIds) {
-            toSortByRank()
-                    .haveSequentialRanks()
-                    .haveIdsOrdered(expectedIds);
-            return this;
-        }
-
-        public ShortcutListAsserter isEmpty() {
-            assertEquals(0, mList.size());
-            return this;
-        }
-
-        public ShortcutListAsserter areAllDynamic() {
-            forAllShortcuts(s -> assertTrue("id=" + s.getId(), s.isDynamic()));
-            return this;
-        }
-
-        public ShortcutListAsserter areAllNotDynamic() {
-            forAllShortcuts(s -> assertFalse("id=" + s.getId(), s.isDynamic()));
-            return this;
-        }
-
-        public ShortcutListAsserter areAllPinned() {
-            forAllShortcuts(s -> assertTrue("id=" + s.getId(), s.isPinned()));
-            return this;
-        }
-
-        public ShortcutListAsserter areAllNotPinned() {
-            forAllShortcuts(s -> assertFalse("id=" + s.getId(), s.isPinned()));
-            return this;
-        }
-
-        public ShortcutListAsserter areAllManifest() {
-            forAllShortcuts(s -> assertTrue("id=" + s.getId(), s.isDeclaredInManifest()));
-            return this;
-        }
-
-        public ShortcutListAsserter areAllNotManifest() {
-            forAllShortcuts(s -> assertFalse("id=" + s.getId(), s.isDeclaredInManifest()));
-            return this;
-        }
-
-        public ShortcutListAsserter areAllImmutable() {
-            forAllShortcuts(s -> assertTrue("id=" + s.getId(), s.isImmutable()));
-            return this;
-        }
-
-        public ShortcutListAsserter areAllMutable() {
-            forAllShortcuts(s -> assertFalse("id=" + s.getId(), s.isImmutable()));
-            return this;
-        }
-
-        public ShortcutListAsserter areAllEnabled() {
-            forAllShortcuts(s -> assertTrue("id=" + s.getId(), s.isEnabled()));
-            return this;
-        }
-
-        public ShortcutListAsserter areAllDisabled() {
-            forAllShortcuts(s -> assertFalse("id=" + s.getId(), s.isEnabled()));
-            return this;
-        }
-
-        public ShortcutListAsserter areAllWithKeyFieldsOnly() {
-            forAllShortcuts(s -> assertTrue("id=" + s.getId(), s.hasKeyFieldsOnly()));
-            return this;
-        }
-
-        public ShortcutListAsserter areAllNotWithKeyFieldsOnly() {
-            forAllShortcuts(s -> assertFalse("id=" + s.getId(), s.hasKeyFieldsOnly()));
-            return this;
-        }
-
-        public ShortcutListAsserter areAllWithActivity(ComponentName activity) {
-            forAllShortcuts(s -> assertTrue("id=" + s.getId(), s.getActivity().equals(activity)));
-            return this;
-        }
-
-        public ShortcutListAsserter forAllShortcuts(Consumer<ShortcutInfo> sa) {
-            boolean found = false;
-            for (int i = 0; i < mList.size(); i++) {
-                final ShortcutInfo si = mList.get(i);
-                found = true;
-                sa.accept(si);
-            }
-            assertTrue("No shortcuts found.", found);
-            return this;
-        }
-
-        public ShortcutListAsserter forShortcut(Predicate<ShortcutInfo> p,
-                Consumer<ShortcutInfo> sa) {
-            boolean found = false;
-            for (int i = 0; i < mList.size(); i++) {
-                final ShortcutInfo si = mList.get(i);
-                if (p.test(si)) {
-                    found = true;
-                    try {
-                        sa.accept(si);
-                    } catch (Throwable e) {
-                        throw new AssertionError("Assertion failed for shortcut " + si.getId(), e);
-                    }
-                }
-            }
-            assertTrue("Shortcut with the given condition not found.", found);
-            return this;
-        }
-
-        public ShortcutListAsserter forShortcutWithId(String id, Consumer<ShortcutInfo> sa) {
-            forShortcut(si -> si.getId().equals(id), sa);
-
-            return this;
-        }
-    }
-
-    public static void assertBundlesEqual(BaseBundle b1, BaseBundle b2) {
-        if (b1 == null && b2 == null) {
-            return; // pass
-        }
-        assertNotNull("b1 is null but b2 is not", b1);
-        assertNotNull("b2 is null but b1 is not", b2);
-
-        // HashSet makes the error message readable.
-        assertEquals(set(b1.keySet()), set(b2.keySet()));
-
-        for (String key : b1.keySet()) {
-            final Object v1 = b1.get(key);
-            final Object v2 = b2.get(key);
-            if (v1 == null) {
-                if (v2 == null) {
-                    return;
-                }
-            }
-            if (v1.equals(v2)) {
-                return;
-            }
-
-            assertTrue("Only either value is null: key=" + key
-                    + " b1=" + b1 + " b2=" + b2, v1 != null && v2 != null);
-            assertEquals("Class mismatch: key=" + key, v1.getClass(), v2.getClass());
-
-            if (v1 instanceof BaseBundle) {
-                assertBundlesEqual((BaseBundle) v1, (BaseBundle) v2);
-
-            } else if (v1 instanceof boolean[]) {
-                assertTrue(Arrays.equals((boolean[]) v1, (boolean[]) v2));
-
-            } else if (v1 instanceof int[]) {
-                MoreAsserts.assertEquals((int[]) v1, (int[]) v2);
-
-            } else if (v1 instanceof double[]) {
-                MoreAsserts.assertEquals((double[]) v1, (double[]) v2);
-
-            } else if (v1 instanceof String[]) {
-                MoreAsserts.assertEquals((String[]) v1, (String[]) v2);
-
-            } else if (v1 instanceof Double) {
-                if (((Double) v1).isNaN()) {
-                    assertTrue(((Double) v2).isNaN());
-                } else {
-                    assertEquals(v1, v2);
-                }
-
-            } else {
-                assertEquals(v1, v2);
-            }
-        }
-    }
-
-    public static void waitOnMainThread() throws InterruptedException {
-        final CountDownLatch latch = new CountDownLatch(1);
-
-        new Handler(Looper.getMainLooper()).post(() -> latch.countDown());
-
-        latch.await();
-    }
-
-    public static class LauncherCallbackAsserter {
-        private final LauncherApps.Callback mCallback = mock(LauncherApps.Callback.class);
-
-        private Callback getMockCallback() {
-            return mCallback;
-        }
-
-        public LauncherCallbackAsserter assertNoCallbackCalled() {
-            verify(mCallback, times(0)).onShortcutsChanged(
-                    anyString(),
-                    any(List.class),
-                    any(UserHandle.class));
-            return this;
-        }
-
-        public LauncherCallbackAsserter assertNoCallbackCalledForPackage(
-                String publisherPackageName) {
-            verify(mCallback, times(0)).onShortcutsChanged(
-                    eq(publisherPackageName),
-                    any(List.class),
-                    any(UserHandle.class));
-            return this;
-        }
-
-        public LauncherCallbackAsserter assertNoCallbackCalledForPackageAndUser(
-                String publisherPackageName, UserHandle publisherUserHandle) {
-            verify(mCallback, times(0)).onShortcutsChanged(
-                    eq(publisherPackageName),
-                    any(List.class),
-                    eq(publisherUserHandle));
-            return this;
-        }
-
-        public ShortcutListAsserter assertCallbackCalledForPackageAndUser(
-                String publisherPackageName, UserHandle publisherUserHandle) {
-            final ArgumentCaptor<List> shortcuts = ArgumentCaptor.forClass(List.class);
-            verify(mCallback, times(1)).onShortcutsChanged(
-                    eq(publisherPackageName),
-                    shortcuts.capture(),
-                    eq(publisherUserHandle));
-            return new ShortcutListAsserter(shortcuts.getValue());
-        }
-    }
-
-    public static LauncherCallbackAsserter assertForLauncherCallback(
-            LauncherApps launcherApps, Runnable body) throws InterruptedException {
-        final LauncherCallbackAsserter asserter = new LauncherCallbackAsserter();
-        launcherApps.registerCallback(asserter.getMockCallback(),
-                new Handler(Looper.getMainLooper()));
-
-        body.run();
-
-        waitOnMainThread();
-
-        // TODO unregister doesn't work well during unit tests.  Figure out and fix it.
-        // launcherApps.unregisterCallback(asserter.getMockCallback());
-
-        return asserter;
-    }
-
-    public static void retryUntil(BooleanSupplier checker, String message) {
-        retryUntil(checker, message, 30);
-    }
-
-    public static void retryUntil(BooleanSupplier checker, String message, long timeoutSeconds) {
-        final long timeOut = System.currentTimeMillis() + timeoutSeconds * 1000;
-        while (!checker.getAsBoolean()) {
-            if (System.currentTimeMillis() > timeOut) {
-                break;
-            }
-            try {
-                Thread.sleep(200);
-            } catch (InterruptedException ignore) {
-            }
-        }
-        assertTrue(message, checker.getAsBoolean());
-    }
-}
diff --git a/telephony/java/com/android/internal/telephony/DcParamObject.java b/telephony/java/com/android/internal/telephony/DcParamObject.java
index 139939cbd0c..fc6b6106113 100644
--- a/telephony/java/com/android/internal/telephony/DcParamObject.java
+++ b/telephony/java/com/android/internal/telephony/DcParamObject.java
@@ -36,7 +36,7 @@ public class DcParamObject implements Parcelable {
     }
 
     public void writeToParcel(Parcel dest, int flags) {
-        dest.writeLong(mSubId);
+        dest.writeInt(mSubId);
     }
 
     private void readFromParcel(Parcel in) {
diff --git a/wifi/java/android/net/wifi/RttManager.java b/wifi/java/android/net/wifi/RttManager.java
index 590ff1b1bfa..8c96774eaea 100644
--- a/wifi/java/android/net/wifi/RttManager.java
+++ b/wifi/java/android/net/wifi/RttManager.java
@@ -766,8 +766,8 @@ public class RttManager {
                     }
                     dest.writeByte(result.LCR.id);
                     if (result.LCR.id != (byte) 0xFF) {
-                        dest.writeInt((byte) result.LCR.data.length);
-                        dest.writeByte(result.LCR.id);
+                        dest.writeByte((byte) result.LCR.data.length);
+                        dest.writeByteArray(result.LCR.data);
                     }
                     dest.writeByte(result.secure ? (byte) 1 : 0);
                 }
